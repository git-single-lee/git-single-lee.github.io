{"meta":{"title":"Coolqi`s Blog","subtitle":"Every day is always sleepy.","description":"“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”","author":"Coolqi.Li","url":"https://coolqi.top"},"pages":[{"title":"关于","date":"2017-04-18T16:00:00.000Z","updated":"2019-04-18T08:14:11.000Z","comments":true,"path":"about/index.html","permalink":"https://coolqi.top/about/index.html","excerpt":"","text":"关于博客 写博客的目的很简单，总结自己的所学，记录自己的成长！ 关于我 李帅奇，Android 开发工程师，我的 Email：lsq1968872434@gmail.com 写作计划 Java 设计模式 算法 数据结构Android Framework 源码分析第三放开源库Linux… 座右铭 生命不息，折腾不止。"},{"title":"分类","date":"2017-04-18T16:00:00.000Z","updated":"2017-05-01T17:58:10.000Z","comments":true,"path":"categories/index.html","permalink":"https://coolqi.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-04-18T16:00:00.000Z","updated":"2017-05-01T17:59:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://coolqi.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"EventBus 第四篇 - 发送消息","slug":"Eventbus-4-postMessage","date":"2019-09-13T12:46:25.000Z","updated":"2019-09-20T14:09:19.158Z","comments":true,"path":"2019/09/13/Eventbus-4-postMessage/","link":"","permalink":"https://coolqi.top/2019/09/13/Eventbus-4-postMessage/","excerpt":"","text":"本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 3.1.0 版本。 这是 EventBus 开源库的地址，大家可以直接访问https://github.com/greenrobot/EventBus 本篇文章是 EventBus 的第四篇，主要分析发送消息的流程； 1 回顾我们回顾下 eventbus 的使用： 发送普通的消息 1EventBus.getDefault().post(messageEvent); 发送 sticky 消息 1EventBus.getDefault().postSticky(messageEvent) 这里我们来分析下 post 的流程，也是最后一篇了； 2 EventBus2.1 post发送普通消息： 123456789101112131415161718192021222324252627public void post(Object event) &#123; //【--&gt;3.1】获取当前线程的 PostingThreadState 实例； PostingThreadState postingState = currentPostingThreadState.get(); //【2】获取每个线程的事件队列 queue； List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); //【3】如果当前的状态不是正在 posting； if (!postingState.isPosting) &#123; //【4】判断当前是否是主线程； postingState.isMainThread = isMainThread(); //【5】将 posting 状态设置为 true； postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; //【4】事件队列不为 Empty，所以要分发事件； while (!eventQueue.isEmpty()) &#123; //【--&gt;2.1.1】分发单个消息； postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 这段逻辑不是很复杂！！ isMainThread 方法很简单，就不多说了。。。 2.1.1 postSingleEvent发送单个事件： 1234567891011121314151617181920212223242526272829private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; //【1】获取事件的 class 实例； Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; //【2】如果允许继承的话，那就要针对事件类型做处理，因为可能有继承的关系； if (eventInheritance) &#123; //【--&gt;2.1.1.1】查询所有的事件类型； List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //【--&gt;2.1.2】开始根据每一种事件类型去分发事件（多态）； subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; //【--&gt;2.1.2】开始根据传入的事件类型去分发事件（无需继承）； subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //【3】处理没有订阅者的情况； if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; EventBus 中有一个 eventTypesCache 的 hash： 1private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = new HashMap&lt;&gt;(); key 是事件的 class，而 value 是一个 list，用于保存 class 和其 superClass，以及其他的所有接口； 因为如果允许事件继承的话，那么根据多态的概念，必须要收集所有的父类和接口； 2.1.1.1 lookupAllEventTypes查询所有的事件类型： 1234567891011121314151617181920private static List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123; synchronized (eventTypesCache) &#123; //【1】从 eventTypesCache 中获取事件 class 对应的事件类型列表； List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass); if (eventTypes == null) &#123; eventTypes = new ArrayList&lt;&gt;(); Class&lt;?&gt; clazz = eventClass; while (clazz != null) &#123; eventTypes.add(clazz); //【--&gt;2.1.1.2】添加接口，也就是获取 class 的所有接口； addInterfaces(eventTypes, clazz.getInterfaces());、 //【2】获取其父类，继续遍历； clazz = clazz.getSuperclass(); &#125; //【3】最后放到 cache 目录中； eventTypesCache.put(eventClass, eventTypes); &#125; return eventTypes; &#125;&#125; 这部分的代码，主要逻辑如下： 将 eventClass 加入到 eventTypesCache 的 eventTypes list 中； 向上遍历，对于每一个 super class，都会将其加入到 eventTypesCache 的 eventTypes list 中； 对于每个 class，将其直接实现和间接实现的所有接口，都添加到 eventTypesCache 的 eventTypes list 中； 2.1.1.2 addInterfaces添加接口集合，就是事件类实现的所有接口： 12345678910static void addInterfaces(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces) &#123; //【1】遍历所有的接口，将其收集到 eventTypes 中； for (Class&lt;?&gt; interfaceClass : interfaces) &#123; if (!eventTypes.contains(interfaceClass)) &#123; eventTypes.add(interfaceClass); //【--&gt;】处理的接口的接口； addInterfaces(eventTypes, interfaceClass.getInterfaces()); &#125; &#125;&#125; 逻辑很简单！ 2.1.2 postSingleEventForEventType12345678910111213141516171819202122232425262728293031private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //【1】首先去查询该事件是否已经有订阅关系了，这个关系在 register 的时候会确定； subscriptions = subscriptionsByEventType.get(eventClass); &#125; //【2】存在订阅关系的话，那就 post 消息； if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; //【2.1】处理每一个订阅关系； for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; //【--&gt;2.2.1】分发事件； postToSubscription(subscription, event, postingState.isMainThread); //【2.2】判断是否取消事件分发； aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; // 如果要取消分发，那么会跳出循环； break; &#125; &#125; return true; &#125; return false;&#125; 方法很简单； 2.2.1 postToSubscription - 线程模式处理分发事件，根据订阅方法的线程模式启动不同的 poster； 123456789101112131415161718192021222324252627282930313233private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: //【1】POSTING，就在事件分发的线程分发订阅； //【--&gt;2.2.2】分发订阅； invokeSubscriber(subscription, event); break; case MAIN: //【2】MAIN，在主线程分发订阅，这里会判断是否已经在 main 线程， // 如果是的话，那就直接分发订阅，否则就通过 mainThreadPoster 分发； if (isMainThread) &#123; invokeSubscriber(subscription, event); //【--&gt;2.2.2】分发订阅； &#125; else &#123; mainThreadPoster.enqueue(subscription, event); //【--&gt;4.1.2】加入队列； &#125; break; case BACKGROUND: //【3】BACKGROUND，通过子线程分发订阅，如果当前是在 main 线程， // 那就通过 backgroundPoster 新起一个线程分发，如果当前是在自线程，那就当前线程分发； if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); //【--&gt;4.2.2】加入队列； &#125; else &#123; invokeSubscriber(subscription, event); //【--&gt;2.2.2】分发订阅； &#125; break; case ASYNC: //【4】ASYNC，异步分发订阅，通过 asyncPoster 每次都新起一个线程分发； asyncPoster.enqueue(subscription, event); //【--&gt;4.3.2】加入队列； break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; 这里我们看到了四种不同的线程模式，每种模式有着不同的处理！ 同时也看到了一个重要的数据结构：Poster 123private final Poster mainThreadPoster; // 主线程 poster，指向一个 HandlerPoster 实例；private final BackgroundPoster backgroundPoster; // 后台线程 posterprivate final AsyncPoster asyncPoster; // 异步 poster 对于 mainThreadPoster，他是在 AndroidHandlerMainThreadSupport 中创建的： 1234@Overridepublic Poster createPoster(EventBus eventBus) &#123; return new HandlerPoster(eventBus, looper, 10);&#125; 不多说了！ 2.2.2 invokeSubscriber分发订阅，也就是调用订阅者的方法处理订阅事件： 12345678910void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; //【1】method.invoke 反射调用； subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(\"Unexpected exception\", e); &#125;&#125; 方法很简单，不多说了； 2.2 postSticky发送粘性消息，这可以看到，该方法会将 event 保存到 stickyEvents 表中： 12345678public void postSticky(Object event) &#123; synchronized (stickyEvents) &#123; //【1】保存到 stickyEvents 中； stickyEvents.put(event.getClass(), event); &#125; //【--&gt;2.1】发送该消息； post(event);&#125; 在前面 register 的时候，我们有分析过在 register 时会立刻处理 Sticky 事件的分发； 这里就不再多说了； 3 PostingThreadState这个类用于保存 thread post 的状态，在 EventBus 中有个 ThreadLocal 成员变量： 1234567private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; //【--&gt;3.1】创建 PostingThreadState 对象； return new PostingThreadState(); &#125;&#125;; 用于保存每一个线程的 post 状态！！ 3.1 成员变量12345678final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;(); // 事件队列； boolean isPosting; // 线程是否正在 post 消息； boolean isMainThread; // post 的线程是否是主线程； Subscription subscription; // 订阅关系； Object event; // 正在 post 的事件，会从 eventQueue 按照顺序来分发； boolean canceled; // 是否被取消了；&#125; 4 Posterposter 用于订阅事件的最终分发，所有的 Poster 都实现了下面的接口： 123456789101112131415/** * Posts events. * * @author William Ferguson */interface Poster &#123; /** * Enqueue an event to be posted for a particular subscription. * * @param subscription Subscription which will receive the event. * @param event Event that will be posted to subscribers. */ void enqueue(Subscription subscription, Object event);&#125; 我们接着分析： 4.1 HandlerPoster处理 main thread 的事件分发： 4.1.1 成员变量12345public class HandlerPoster extends Handler implements Poster &#123; private final PendingPostQueue queue; // 正在分发的 post 队列； private final int maxMillisInsideHandleMessage; private final EventBus eventBus; private boolean handlerActive; // 是否处于激活状态； 参数 maxMillisInsideHandleMessage 表示处理消息的函数的执行事件，单位是毫秒，传入的是 10； 123456---&gt; [AndroidHandlerMainThreadSupport.java]@Overridepublic Poster createPoster(EventBus eventBus) &#123; return new HandlerPoster(eventBus, looper, 10);&#125; 在 AndroidHandlerMainThreadSupport 创建了一个 HandlerPoster，他会作为 EventBus 单例的成员变量； 4.1.2 enqueue添加 post 到队列 中： 123456789101112131415public void enqueue(Subscription subscription, Object event) &#123; //【--&gt;6.2】创建一个 PendingPost； PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; //【--&gt;7.2】入队列： queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; //【3】发送消息； if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; &#125; &#125;&#125; HandlerPoster 本质上是一个 handler！ 4.1.3 run1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); //【1】一个 while 循环，处理 PendingPostQueue 中所有的 post 操作； while (true) &#123; //【--&gt;7.3】post 出队列； PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; //【--&gt;7.3】第一次为 null，post 出队列； pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; //【--&gt;2.2.2】执行方法； eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; //【2】判断了函数的执行时间，如果大于 10 毫秒，那么说明主线程比较卡顿， // 这里会再次发送消息，然后立刻退出循环，这是防止 while 循环堵塞主线程； if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; //【3】设置为 true，handlerActive 会被设置为 rescheduled // 因为上面已经再次发送了消息。 rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125;&#125; 可以看到，主线程的分发策略是： 尽可能一次性处理完成 PendingPostQueue 中的所有消息； 如果某个消息的处理时间超过 10 毫秒，说明主线程很卡，那么就会退出 while 循环； 4.2 BackgroundPoster处理 background thread 的事件分发： 4.2.1 成员变量1234final class BackgroundPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; // 消息队列； private final EventBus eventBus; private volatile boolean executorRunning; // 线程池是否在运行； 可以看到 BackgroundPoster 是一个 Runnable； 4.2.2 enqueue添加消息到 poster 中： 12345678910111213public void enqueue(Subscription subscription, Object event) &#123; //【--&gt;6.2】创建一个 PendingPost； PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; //【--&gt;7.2】入队列： queue.enqueue(pendingPost); if (!executorRunning) &#123; // executorRunning 设置为 true； executorRunning = true; //【--&gt;4.2.3】执行 BackgroundPoster; eventBus.getExecutorService().execute(this); &#125; &#125;&#125; 这个地方加了锁，这是因为 post 方法可以在多线程调用； 4.2.3 run12345678910111213141516171819202122232425262728@Overridepublic void run() &#123; try &#123; try &#123; while (true) &#123; //【1】post 出队列，这里有个超时处理： PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // 这里加锁了； //【2】如果为 null，那就再次检查，如果依然为 null // 那就退出 run 执行，executorRunning 设置为 false； pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; //【--&gt;2.2.2】执行方法； eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + \" was interruppted\", e); &#125; &#125; finally &#123; executorRunning = false; &#125;&#125; 可以看到，这个线程因为 while (true) 一直处于 runnable/running 的状态； 4.3 AsyncPoster处理 async thread 的事件分发： 4.3.1 成员变量123class AsyncPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; // 队列； private final EventBus eventBus; 4.3.2 enqueue添加消息到 poster 中： 1234567public void enqueue(Subscription subscription, Object event) &#123; //【--&gt;6.2】创建一个 PendingPost； PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); //【--&gt;7.2】入队列： queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this);&#125; 这个人地方竟然没有加锁，奇怪啊～ 4.3.3 run12345678910@Overridepublic void run() &#123; //【--&gt;7.3】post 出队列； PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException(\"No pending post available\"); &#125; //【--&gt;2.2.2】执行方法； eventBus.invokeSubscriber(pendingPost);&#125; 6 PendingPost表示一个正在分发的 post。 6.1 成员变量123456final class PendingPost &#123; // 缓存 post，用于复用； private final static List&lt;PendingPost&gt; pendingPostPool = new ArrayList&lt;PendingPost&gt;(); Object event; // 要分发的事件； Subscription subscription; // 订阅关系； PendingPost next; // 下一个要分发的 post，用户构成链表结构；！ 6.2 obtainPendingPost获取一个 PendingPost： 123456789101112131415static PendingPost obtainPendingPost(Subscription subscription, Object event) &#123; synchronized (pendingPostPool) &#123; int size = pendingPostPool.size(); //【1】优先从 pendingPostPool 中获取； if (size &gt; 0) &#123; PendingPost pendingPost = pendingPostPool.remove(size - 1); pendingPost.event = event; pendingPost.subscription = subscription; pendingPost.next = null; return pendingPost; &#125; &#125; //【2】没有的话，再创建新的； return new PendingPost(event, subscription);&#125; 这里有加锁的！ 6.3 releasePendingPost消息 post 完成后，会缓存 post： 1234567891011static void releasePendingPost(PendingPost pendingPost) &#123; pendingPost.event = null; pendingPost.subscription = null; pendingPost.next = null; synchronized (pendingPostPool) &#123; //【1】缓存已经 post 的消息的 PendingPost！！！ if (pendingPostPool.size() &lt; 10000) &#123; pendingPostPool.add(pendingPost); &#125; &#125;&#125; 可以看到：pendingPostPool 不会超过 10000 个； 7 PendingPostQueue这是一个由链表构成的 正在分发的 post 的队列！ 7.1 成员变量123final class PendingPostQueue &#123; private PendingPost head; // 队列头； private PendingPost tail; // 队列尾； 内部有队列头和队列尾两个属性； 这个方法的 enqueue 和 poll 是加锁的～ 7.2 enqueue将 PendingPost 放入到队列中，默认是加入到队尾，该方法是加锁了： 12345678910111213141516synchronized void enqueue(PendingPost pendingPost) &#123; if (pendingPost == null) &#123; throw new NullPointerException(\"null cannot be enqueued\"); &#125; //【1】入队列； if (tail != null) &#123; tail.next = pendingPost; tail = pendingPost; &#125; else if (head == null) &#123; head = tail = pendingPost; &#125; else &#123; throw new IllegalStateException(\"Head present, but no tail\"); &#125; //【2】提醒其他阻塞的线程； notifyAll();&#125; 7.3 pollPendingPost 出队列： 12345678910111213141516171819synchronized PendingPost poll() &#123; //【1】从 head 出队列，更改指针； PendingPost pendingPost = head; if (head != null) &#123; head = head.next; if (head == null) &#123; tail = null; &#125; &#125; return pendingPost;&#125;synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException &#123; if (head == null) &#123; //【2】这个方法会在队列为 null 的时候，等待一会儿； wait(maxMillisToWait); &#125; return poll();&#125; 8 总结到这里，EventBus 就整完了，驾鹤西去呦～～","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"EventBus","slug":"开源库源码分析/EventBus","permalink":"https://coolqi.top/categories/开源库源码分析/EventBus/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"https://coolqi.top/tags/EventBus/"}]},{"title":"EventBus 第三篇 - 初始化、注册和取消注册","slug":"Eventbus-3-getDefaultAndRegister","date":"2019-09-10T12:46:25.000Z","updated":"2019-09-16T14:13:10.000Z","comments":true,"path":"2019/09/10/Eventbus-3-getDefaultAndRegister/","link":"","permalink":"https://coolqi.top/2019/09/10/Eventbus-3-getDefaultAndRegister/","excerpt":"","text":"本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 3.1.0 版本。 这是 EventBus 开源库的地址，大家可以直接访问https://github.com/greenrobot/EventBus 本篇文章是 EventBus 的第三篇，主要分析 初始化，注册和取消注册； Eventbus 翻译过来就是事件总线，用于简化组件和组件，线程和线程之间的消息通信，可以看成是 Handler + Thread 的替代品。 1 回顾我们在使用的过程中，需要先进行注册： 1EventBus.getDefault().register(this); 当我们的组件在销毁以后，就要执行取消注册： 1EventBus.getDefault().unregister(this); 本篇文章，主要分析 register 和 unregister 的流程！ 2 EventBusEventBus 这个类是总的入口，我们可以通过 getDefault 返回默认配置的 EventBus，也可以通过 EventBusBuilder 去自定义配置： EventBus 使用了单例模式！ 2.1 成员属性我们先去看看 EventBus 的成员属性，当然我们后面也会详细分析： 核心的变量： 123456789101112131415161718192021222324252627// 保存了private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = new HashMap&lt;&gt;();// 保存了 [订阅事件 class 实例 --&gt; 该事件的订阅关系的 list] 的映射关系；private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;// 保存了 [订阅者实例 --&gt; 订阅事件 class 的 list] 的映射关系；private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;// 保存了 [粘性订阅事件 class 实例 --&gt; 粘性订阅事件实例] 的映射关系，只要是已经发送过的 sticky event 都会被加入这里；private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;// 用于保存每个 post 线程的状态；private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;;//【--&gt;4】保存主线程的支持类，对 Looper 的封装；@Nullableprivate final MainThreadSupport mainThreadSupport; //【--&gt;4】用于分发消息；@Nullableprivate final Poster mainThreadPoster; // 用于主线程的消息分发处理；private final BackgroundPoster backgroundPoster; // 用于后台线程的消息分发处理；private final AsyncPoster asyncPoster; // 用于异步线程的消息分发处理；//【--&gt;5】用于查找订阅方法；private final SubscriberMethodFinder subscriberMethodFinder; 其他的变量： 12345678910111213static volatile EventBus defaultInstance; //【1】EventBus 的单例对象；private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); //【--&gt;3.1】默认配置的 EventBusBuilderprivate final ExecutorService executorService; // 线程池，用于分发异步和后台的消息private final boolean throwSubscriberException; // 这些变量请参考 EventBusBuidler，这里不再多说！private final boolean logSubscriberExceptions;private final boolean logNoSubscriberMessages;private final boolean sendSubscriberExceptionEvent;private final boolean sendNoSubscriberEvent;private final boolean eventInheritance;private final int indexCount; // subscriberInfoIndex 实例的个数； 这里我简单的解释下： mainThreadPoster，backgroundPoster，asyncPoster 用于不同类型消息的分发，它们都是实现了 Post 接口，后面我们分析的时候再看！ currentPostingThreadState 是一个 ThreadLocal 变量，每个 post 线程都会有一个 PostingThreadState 属性，表示 post 的状态！ SubscriberMethodFinder 用于查找订阅方法； 2.2 创建 EventBus 实例EventBus 提供了多种创建方式，既可以通过单例模式创建一个统一的 EventBus 对象，也可以创建多个 EventBus 实例，每个实例都是一个单独的作用域！ 2.2.1 getDefault单例模式方法，创建默认的 EventBus： 1234567891011public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; //【--&gt;2.2.2】构造器； defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 2.2.2 new EventBus非单例模式方法，两个构造器，默认构造器会传入一个默认的 DEFAULT_BUILDER，另一个需要传入指定的 EventBusBuilder 实例； 但是，我们只能通过无参数的构造器创建非单例的 EventBus 实例！ 12345678910111213141516171819202122232425262728293031323334353637public class EventBus &#123; ... ... ... public EventBus() &#123; //【1】默认的构造器是通过默认的 builder 对象处理的；【--&gt;2.1】默认的 buidler 实例； this(DEFAULT_BUILDER); &#125; //【2】通过建造者模式来初始化，注意这个构造器是 protected 的，我们无法访问！ EventBus(EventBusBuilder builder) &#123; //【--&gt;3.2.3】通过 EventBusBuilder 初始化 log 系统； logger = builder.getLogger(); subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); //【--&gt;3.2.1】通过 EventBusBuilder 初始化 mainThread 相关变量； mainThreadSupport = builder.getMainThreadSupport(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); //【--&gt;3.1】通过 EventBusBuilder 初始化 EventBus 内部的变量： indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); //【--&gt;5.2】创建 SubscriberMethodFinder 对象； logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; ... ... ... &#125; 通过建造者模式来初始化部分变量，同时也会对其他变量做默认的初始化； 2.2.3 通过 EventBusBuilder 创建EventBusBuilder 也提供了两个方法，通过 build 模式创建 EventBus 实例！ 2.2.3.1 installDefaultEventBus单例模式方法，创建默认的 EventBus，但是如果已经创建了 EventBus 的单例，那就不能调用这个方法： 1234567891011public EventBus installDefaultEventBus() &#123; synchronized (EventBus.class) &#123; if (EventBus.defaultInstance != null) &#123; throw new EventBusException(\"Default instance already exists.\" + \" It may be only set once before it's used the first time to ensure consistent behavior.\"); &#125; //【--&gt;2.2.3.2】通过 build 方法创建单例！ EventBus.defaultInstance = build(); return EventBus.defaultInstance; &#125;&#125; 2.2.3.2 build这个方法可以用与创建非单例的 EventBus 实例： 1234public EventBus build() &#123; //【--&gt;2.2.2】调用一参数构造器； return new EventBus(this);&#125; 2.3 register - 注册我们来看 register 的过程： 123456789101112public void register(Object subscriber) &#123; //【1】获取订阅者的 class 对象； Class&lt;?&gt; subscriberClass = subscriber.getClass(); //【--&gt;5.3】查询订阅者的方法； List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; //【--&gt;2.3.1】建立订阅关系； subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 整体流程简单，不多说了； 注意：这里的 subscriberClass 是调用 register 方法所在的类； 2.3.1 subscribe创建订阅关系： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //【1】获取事件类型 eventType Class&lt;?&gt; eventType = subscriberMethod.eventType; //【--&gt;7.1】创建订阅关系； Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //【2】获取该 eventType 对应的订阅关系的 list； CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); // 初始化操作； &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); &#125; &#125; //【3】调整优先级顺序，订阅关系的 list 是以 priority 从小到大排序的； // 将订阅关系加入到 subscriptionsByEventType 中； int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //【4】将订阅者实例和要订阅的 eventType 的 class 实例保存到 subscribedEvents 中； List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); // 初始化； &#125; subscribedEvents.add(eventType); //【5】方法订阅的事件是 sticky 的，特殊处理；； if (subscriberMethod.sticky) &#123; //【5.1】如果允许事件继承，默认是为 true 的，可以去看 EventBusBuilder； if (eventInheritance) &#123; //【5.2】获取已经存在的 sticky 事件； Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); //【5.3】因为可能一个父类有多个子类，所以这里要处理所有的 sticky event。 if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); //【--&gt;2.3.2】分发 sticky Event checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; //【5.4】如果不允许事件继承，那就只能找对应类型的 sticky event。 Object stickyEvent = stickyEvents.get(eventType); //【--&gt;2.3.2】分发 sticky Event checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 流程： 将订阅关系保存到对应的缓存中； 处理 sticky 事件的分发； 这里的 eventInheritance 是啥意思呢，其实就是事件继承关系： 比如 MessageEvent2 继承了 MessageEvent，那么如果订阅方法的参数是 MessageEvent，而粘性事件是 MessageEvent2，那么我们依然可以分发该消息； 2.3.2 checkPostStickyEventToSubscription123456private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123; if (stickyEvent != null) &#123; //【--&gt;2.3.3】分发 event； postToSubscription(newSubscription, stickyEvent, isMainThread()); &#125;&#125; // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)–&gt; Strange corner case, which we don’t take care of here. 2.3.3 postToSubscription对于 sticky event 这个和粘性广播的道理是一样，如果它之前就已经分发过，那么他会被存储在系统里，下一个订阅者一旦注册，那就能够收到： 12345678910111213141516171819202122232425262728293031323334private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; 可以看到，这里开始事件的 post 了！ event post 这里我们不关注，后面会分析； 2.4 unregister - 反注册我们来看看反注册的过程： 123456789101112public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; //【--&gt;2.4.1】解除订阅； unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass()); &#125;&#125; 2.4.1 unsubscribeByEventType这个方法很简单，就是将订阅关系移除掉； 1234567891011121314151617private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; //【1】从 subscriptionsByEventType 返回 eventType 的所有订阅关系； List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; //【2】处理当前订阅者的订阅关系，设置为 no active，同时从集合中移除； Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 不多说了。 3 EventBusBuilder建造者模式，用于自定义 EventBus 的配置，并创建 EventBus 实例： 3.1 成员变量我们来看下成员变量： 12345678910111213141516171819202122public class EventBusBuilder &#123; // 内置的默认线程池 private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); boolean logSubscriberExceptions = true; // 是否记录订阅者的异常信息；默认为 true； boolean logNoSubscriberMessages = true; // boolean sendSubscriberExceptionEvent = true; // 是否发送订阅异常的事件；默认为 true； boolean sendNoSubscriberEvent = true; // 是否发送没有订阅者的消息；默认为 true； boolean throwSubscriberException; // 是否抛出订阅异常，用于 debug；默认为 false； boolean eventInheritance = true; // 是否开启事件继承机制，默认为 true； boolean ignoreGeneratedIndex; // 是否强制使用反射，即使开启了 Apt 特性；默认为 false； boolean strictMethodVerification; // 是否强制方法校验；默认为 false； ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE; // 线程池，用于分发异步和后台的消息；默认为 DEFAULT_EXECUTOR_SERVICE List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses; // 用于保存哪些跳过方法校验的 class List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes; // 用于保存 SubscriberInfoIndex 实例，也就是 APT 技术生成的动态 java 类； Logger logger; // log 系统； MainThreadSupport mainThreadSupport; // 用于提供对主线程的支持，指向 AndroidHandlerMainThreadSupport 实例； EventBusBuilder() &#123; &#125; 如果我们使用默认的 EventBusBuilder 来初始化 EventBus 的话，那么 EventBusBuilder 的方法会返回属性的默认值： 这里我简单的说下： 阿道夫 安抚 党法 3.2 方法前面我们顺便看了下通过 EventBusBuilder 创建 EventBus 的相关方法，这里就不再看了，我们来看下 EventBusBuilder 其中的部分方法： 3.2.1 getMainThreadSupport获取主线程的支持对象！ 12345678910111213MainThreadSupport getMainThreadSupport() &#123; if (mainThreadSupport != null) &#123; return mainThreadSupport; &#125; else if (AndroidLogger.isAndroidLogAvailable()) &#123; //【--&gt;3.2.1.1】获取主线程的 looper 对象； Object looperOrNull = getAndroidMainLooperOrNull(); return looperOrNull == null ? null : //【--&gt;4】创建 AndroidHandlerMainThreadSupport 实例对象； new MainThreadSupport.AndroidHandlerMainThreadSupport((Looper) looperOrNull); &#125; else &#123; return null; &#125;&#125; 3.2.1.1 getAndroidMainLooperOrNull获取主线程的 looper 对象； 1234567Object getAndroidMainLooperOrNull() &#123; try &#123; return Looper.getMainLooper(); &#125; catch (RuntimeException e) &#123; return null; &#125;&#125; 不多说了。 3.2.2 addIndex改方法用于将通过 EventBus 的 annotation preprocessor 生成的 SubscriberInfoIndex 子类实例，加入到 EventBusBuilder.subscriberInfoIndexes 中！ 1234567public EventBusBuilder addIndex(SubscriberInfoIndex index) &#123; if (subscriberInfoIndexes == null) &#123; subscriberInfoIndexes = new ArrayList&lt;&gt;(); &#125; subscriberInfoIndexes.add(index); return this;&#125; 不多说了。 3.2.3 getLogger获取 log 系统： 12345678910Logger getLogger() &#123; if (logger != null) &#123; return logger; &#125; else &#123; // also check main looper to see if we have \"good\" Android classes (not Stubs etc.) return AndroidLogger.isAndroidLogAvailable() &amp;&amp; getAndroidMainLooperOrNull() != null ? new AndroidLogger(\"EventBus\") : new Logger.SystemOutLogger(); &#125;&#125; 4 MainThreadSupport是一个接口，AndroidHandlerMainThreadSupport 内部类实现了该接口，作为主线程的支持类，是对 looper 对象的封装； 12345678910111213141516public interface MainThreadSupport &#123; boolean isMainThread(); Poster createPoster(EventBus eventBus); class AndroidHandlerMainThreadSupport implements MainThreadSupport &#123; //【1】主线程的 looper 对象； private final Looper looper; public AndroidHandlerMainThreadSupport(Looper looper) &#123; this.looper = looper; &#125; ... ... ... &#125;&#125; 这里我们先不看 AndroidHandlerMainThreadSupport 的其他方法，后面会分析。 暂时只需要知道，AndroidHandlerMainThreadSupport 的 createPoster 方法会创建一个 HandlerPoster 实例，他是 Handler 的子类，同时实现了 Poster 接口！ 看到这里，其实能猜到，HandlerPoster 会持有主线程的 Looper 对象，像主线程发送消息！！ 5 SubscriberMethodFinder该类用于查找订阅者的方法： 5.1 成员变量我们来看一些核心的成员变量： 123456789101112131415private static final int BRIDGE = 0x40;private static final int SYNTHETIC = 0x1000;// 方法校验位。private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;// 方法缓存，key 为订阅者的 class 实例，value 为订阅方法的 list；private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;(); // 以下三个变量的值来自 EventBusBuilder，意思我已经解释过了；private List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;private final boolean strictMethodVerification;private final boolean ignoreGeneratedIndex;// 用于保存 FindState 对象，每一个 FindState 用于记录查询订阅方法的结果和状态；private static final int POOL_SIZE = 4;private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE]; 这里可以看到，subscriberInfoIndexes 是要手动设置到 EventBusBuilder 中； 5.2 new SubscriberMethodFinder 参数 List subscriberInfoIndexes：表示 SubscriberInfoIndex 集合，就是通过 APT 技术生成的，存储了订阅方法的对象； 参数 boolean strictMethodVerification：是否强制方法校验，默认为 false； 参数 boolean ignoreGeneratedIndex：是否强制使用反射，即使开启了 APT 特性；默认为 false； 以上参数值均来自于 EventBusBuilder 中的默认值/自定义值； 123456SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, boolean strictMethodVerification, boolean ignoreGeneratedIndex) &#123; this.subscriberInfoIndexes = subscriberInfoIndexes; this.strictMethodVerification = strictMethodVerification; this.ignoreGeneratedIndex = ignoreGeneratedIndex;&#125; 5.3 findSubscriberMethods查询订阅者拥有的订阅方法： 1234567891011121314151617181920212223List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //【1】默认从方法 cache 中查询； List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //【2】如果从方法 cache中查询不到，那就判断是否不使用 GeneratedIndex； if (ignoreGeneratedIndex) &#123; //【--&gt;5.3.1】不使用的话，就通过反射的方式访问方法； subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //【--&gt;5.3.2】使用的话，就通过 GeneratedIndex 获取方法； subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(\"Subscriber \" + subscriberClass + \" and its super classes have no public methods with the @Subscribe annotation\"); &#125; else &#123; //【3】加入到方法 cache 中去； METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; ignoreGeneratedIndex 默认是 false 的； 核心代码在 findUsingReflection 和 findUsingInfo 中！ 5.3.1 findUsingReflection - 反射获取我们来看下通过反射是如何获取的： 1234567891011121314private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //【--&gt;5.4】返回一个 FindState 对象，用于记录查询的结果和状态； FindState findState = prepareFindState(); //【--&gt;6.2】初始化 FindState； findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //【--&gt;5.5】通过发射的方式收集注解方法； findUsingReflectionInSingleClass(findState); //【--&gt;6.3】处理其 superClass； findState.moveToSuperclass(); &#125; //【--&gt;5.6】返回所有的订阅方法； return getMethodsAndRelease(findState);&#125; 这里的 subscriberClass 是调用 register 方法所在的类，所以找父类肯定是向上搜索； 对于每一个调用了 register 的 class，都会创建一个 FindState 对象，保存相关信息； 5.3.2 findUsingInfo - APT 获取开启了 APT 预处理技术的话，那就通过动态生成的类获取，这个过程比反射更快； 12345678910111213141516171819202122232425262728private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; //【--&gt;5.4】返回一个 FindState 对象，用于记录查询的结果和状态； FindState findState = prepareFindState(); //【--&gt;6.2】初始化 FindState； findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //【--&gt;5.3.2.1】返回订阅者对应的 SubscriberInfo 实例，保存到 findState.subscriberInfo 中； findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; //【1】返回 SubscriberInfo 的所有订阅方法 SubscriberMethod[]； SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; //【--&gt;6.4】对方法做检查，和反射调用一个吊样； if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; //【2】检查没啥问题，就加入到 findState.subscriberMethods 中； findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //【--&gt;5.5】如果订阅者没有对应的 SubscriberInfo 实例，通过发射的方式收集注解方法； findUsingReflectionInSingleClass(findState); &#125; //【--&gt;6.3】处理其 superClass； findState.moveToSuperclass(); &#125; //【--&gt;5.6】返回所有的订阅方法； return getMethodsAndRelease(findState);&#125; 可以看到，这里会优先获取通过 APT 技术生成的类，如果没有对应的 SubscriberInfo，那就仍然通过反射来获取方法 Method； 这里的 subscriberClass 是调用 register 方法所在的类，所以找父类肯定是向上搜索； 5.3.2.1 getSubscriberInfo返回订阅者对应的 SubscriberInfo 实例，前面我们知道 findState.subscriberInfo 在初始化的时候是 null 的： 123456789101112131415161718192021private SubscriberInfo getSubscriberInfo(FindState findState) &#123; //【1】这里是针对于继承关系的，因为是先处理子类，再处理父类，所以先处理的子类的话，findState.subscriberInfo 肯定不是 null // 那么就要通过 subscriberInfo.getSuperSubscriberInfo() 获取父类的 SubscriberInfo。 if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); //【2】额外还要做一次 class 判断，因为 while 循环会调整 clazz； if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; //【2】通过 subscriberInfoIndexes 来查找，getSubscriberInfo 方法是动态类的内置方法，通过 class 实例获取 SubscriberInfo； if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 这里我们知道，通过前面的分析，每一个订阅者都是一个 SubscriberInfo 实例！ 5.4 prepareFindState主要是为每个 find 操作，创建一个 FindState 对象； 12345678910111213private FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; //【--&gt;6】返回了一个 FindState 实例； return new FindState();&#125; 默认情况下，FIND_STATE_POOL 是空的，所以会创建一个新的 FindState 实例； 5.5 findUsingReflectionInSingleClass通过反射的方式获取注册方法，通过 SubscriberMethod 实例封装，保存到 findState.subscriberMethods 中： 参数为 FindState 实例，这里获取方法的是通过 findState.clazz，这个要注意； 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; //【0】这个方法比 getMethods 快，特别是当订阅者是像活动这样的方法很多的类的时候； methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // 可能会抛出 java.lang.NoClassDefFoundError, see [https://github.com/greenrobot/EventBus/issues/149] // 这里会使用 getMethods() 方法获取，注意，会跳过父类； methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); //【1】这里是对 method 方法访问域做校验，必须是 public，不能是 abstract 和 static 的； if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; //【1.1】获取方法对应的注解 Subscribe，只处理被该注解修饰的方法; Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //【1.2】获取方法对应的参数； Class&lt;?&gt; eventType = parameterTypes[0]; //【--&gt;6.4】检查要添加方法的信息，没问题的话，就创建方法对应的 SubscriberMethod，添加到 findState.subscriberMethods； if (findState.checkAdd(method, eventType)) &#123; //【1.3】获取订阅的分发线程信息； ThreadMode threadMode = subscribeAnnotation.threadMode(); //【1.4】创建方法对应的 SubscriberMethod，添加到 findState.subscriberMethods； // SubscriberMethod 参数：订阅方法 method，订阅事件的 class 实例 eventType，线程模式 threadMode，优先级，粘性； findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; //【2】如果开启方法校验，那么被 @Subscribe 修饰的方法只能一个参数； String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(\"@Subscribe method \" + methodName + \"must have exactly 1 parameter but has \" + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(methodName + \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"); &#125; &#125;&#125; strictMethodVerification 表示是否强制校验方法的访问修饰符； 5.6 getMethodsAndRelease返回收集到的方法： 123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; //【1】通过 FindState 获取查询到的方法； List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); //【--&gt;6.5】clear 掉缓存； findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; // 将这个对象缓存下来，防止频繁的创建 FindState 对象； break; &#125; &#125; &#125; return subscriberMethods;&#125; 6 FindStateFindState 是 SubscriberMethodFinder 的内部类，用于保存查询的结果和状态信息（包括子类和父类）： 6.1 成员变量123456789101112131415static class FindState &#123; // 保存订阅者的方法 SubscriberMethod； final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(); // 保存订阅事件 class 实例 和 [订阅方法 Method/所属 FindState] 的映射关系； final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;(); // 保存了 methodKey 和 method 所属的订阅类的 class 实例； final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); // 用于生成 subscriberClassByMethodKey 中的 methodKey final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; // 订阅者 class 实例，也就是调用 register 方法的类； Class&lt;?&gt; clazz; // 初始化时，取值和 subscriberClass 一样，但是在处理继承关系时，会转为 superClass boolean skipSuperClasses; // 是否 skip 父类，初始化为 false； SubscriberInfo subscriberInfo; // 订阅者信息，开启了 APT 才有，否则为 null； subscriberClassByMethodKey：如果存在继承关系，同时方法有覆盖，那么以子类为准； 6.2 initForSubscriber初始化操作； 123456void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; //【1】初始化：subscriberClass == clazz this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null;&#125; 6.3 moveToSuperclass跳转到 superClass，处理父类： 1234567891011121314void moveToSuperclass() &#123; //【1】如果要跳过 superClass，那么 clazz 为 null； if (skipSuperClasses) &#123; clazz = null; &#125; else &#123; //【2】获取其 superClass； clazz = clazz.getSuperclass(); String clazzName = clazz.getName(); //【3】跳过系统的类； if (clazzName.startsWith(\"java.\") || clazzName.startsWith(\"javax.\") || clazzName.startsWith(\"android.\")) &#123; clazz = null; &#125; &#125;&#125; 不多说了； 6.4 checkAdd检查要添加方法的信息： 12345678910111213141516171819202122232425boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; //【1】这里会将订阅事件 class 实例 --&gt; 订阅方法 Method 放入 anyMethodByEventType 中； // 同时会返回以之前已经存在的 value； Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; //【2】如果是第一次添加，那么 check 成功，直接返回 true； return true; &#125; else &#123; //【3】如果之前添加过 eventType，说明可能一个类有多个处理该 eventType 的函数； // 也有可能是有继承关系，此时处理的是父类的方法，子类覆盖了父类的同名方法； if (existing instanceof Method) &#123; //【--&gt;6.4.1】检查已经添加的方法 existing 的方法签名，只有第二次处理同一个 eventType 才会进入这里 // 此时该方法是会返回 true 的，因为第一次添加的 method 还没有做签名校验； if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; //【4】这里很奇怪，直接将之前的 Method 替换成了 FindState 实例； // 如果有多个方法都处理同一个 eventType 的话，显然 value 就不是 Method 的实例了； anyMethodByEventType.put(eventType, this); &#125; //【--&gt;6.4.1】检查新添加的方法 method 的方法签名； return checkAddWithMethodSignature(method, eventType); &#125;&#125; 可以看到，作者其实在注释里面也有说明：有两级的检查： 第一级：检查时间类型； 第二级：检查方法签名； 可能有多个处理该 eventType 的函数： 只有第一次添加会进入 if (existing instanceof Method) { 分支； 第二次就会将 anyMethodByEventType 中的 value 从 Method 变为 FindState，那么就不会进入 if (existing instanceof Method) { 分支了； 无论一类多方法，还是继承一方法，都是上面的流程； （但是看作者的注释：貌似没有考虑一个订阅者有多个监听相同事件类型的方法。） 如果该 checkAdd 方法返回的是 false，那么 @Subscribe 修饰的方法就不会被收集！！！ 6.4.1 checkAddWithMethodSignature检查方法签名： 12345678910111213141516171819202122private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append('&gt;').append(eventType.getName()); //【1】生成 methodKey：methodName&gt;eventTypeName String methodKey = methodKeyBuilder.toString(); //【2】获取方法所在的类 class 实例； Class&lt;?&gt; methodClass = method.getDeclaringClass(); //【3】将 methodKey 和 methodClass 的映射关系放入 subscriberClassByMethodKey 中，同时返回旧的 value； Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); //【4】这里针对 old class 实例和 new class 做了比较； // 如果是第一次 add ，或者有 old class 实例，同时 old class 是 new class 的 super class // 那么就用 new class 替换旧的值； if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); // 恢复旧的值； return false; &#125;&#125; 这里实际上是方法的签名：方法名&gt;参数 对于同一个类，如果有多个函数处理同一个 eventType，显然方法签名是不一样的，那么这个 checkAddWithMethodSignature 返回的是 true； 对于继承关系，对于子类和父类有相同的方法签名的情况，以子类为准，也就是说父类的同名同参方法是不会被收集的 checkAddWithMethodSignature 返回的是 false；； 6.5 recycle回收内部的变量，就是 clear 操作： 12345678910void recycle() &#123; subscriberMethods.clear(); anyMethodByEventType.clear(); subscriberClassByMethodKey.clear(); methodKeyBuilder.setLength(0); subscriberClass = null; clazz = null; skipSuperClasses = false; subscriberInfo = null;&#125; 就不多说了，啊哈哈哈哈哈～～ 7 Subscription表示一种订阅关系； 7.1 成员变量我们来看下成员属性： 123final class Subscription &#123; final Object subscriber; // 订阅者； final SubscriberMethod subscriberMethod; // 订阅方法； 7.2 new Subscription创建订阅关系： 12345Subscription(Object subscriber, SubscriberMethod subscriberMethod) &#123; this.subscriber = subscriber; // 订阅者； this.subscriberMethod = subscriberMethod; // 订阅方法； active = true;&#125; 8 总结我们分析了 EventBus 的创建，注册和反注册，整个初始化和注册的过程主要分为下面的基本： 通过 EventBusBuilder 创建 EventBus； EventBus 收集当前类以及其父类所有的订阅方法； 根据事件类型和每一个订阅方法，创建订阅关系； 遗留了如下的几个问题： post 操作的执行流程； 不同线程模式的消息是如何分发和处理的；","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"EventBus","slug":"开源库源码分析/EventBus","permalink":"https://coolqi.top/categories/开源库源码分析/EventBus/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"https://coolqi.top/tags/EventBus/"}]},{"title":"EventBus 第二篇 - Subscribe 注解处理","slug":"Eventbus-2-SubscribeProcessor","date":"2019-08-27T12:46:25.000Z","updated":"2019-09-16T14:13:07.000Z","comments":true,"path":"2019/08/27/Eventbus-2-SubscribeProcessor/","link":"","permalink":"https://coolqi.top/2019/08/27/Eventbus-2-SubscribeProcessor/","excerpt":"","text":"本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 3.1.0 版本。 这是 EventBus 开源库的地址，大家可以直接访问https://github.com/greenrobot/EventBus 本篇文章是 EventBus 的第二篇，主要分析 Subscribe 注解的处理； Eventbus 翻译过来就是事件总线，用于简化组件和组件，线程和线程之间的消息通信，可以捆成是 Handler + Thread 的替代品。 1 回顾我们在使用的过程中，需要设置接收消息的方法： 1234@Subscribe(threadMode = ThreadMode.MAIN)public void onEventMainThread(Object object) &#123; ... ... ...&#125; 注解 Subscribe 可以说是 EventBus 的核心了，我们知道，3.x 版本之前，EventBus 使用的是运行时注解，其实就是 Java 的反射机制，但是这带来了性能的损耗！ 因此，从 3.x 开始，Eventbus 引入了编译时注解处理的特性，核心类就是 EventBusAnnotationProcessor！ 我们来看看注解的定义： 12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface Subscribe &#123; ThreadMode threadMode() default ThreadMode.POSTING; // 线程模型：默认 POSTING boolean sticky() default false; // 默认非粘性； int priority() default 0; // 优先级为 0；&#125; 可以看到，Subscribe 用于修饰方法，并且可以保留到运行时，这是因为默认情况下，EventBus 是通过运行时注解，反射加载方法的，除非开启编译时注解处理机制； 2 EventBusAnnotationProcessor - Subscribe 处理浏览 EventBus 的源码目录，我们能看到处理 Subscribe 注解的是 EventBusAnnotationProcessor 类，依然是编译时注解，动态生成代码： 123@SupportedAnnotationTypes(\"org.greenrobot.eventbus.Subscribe\")@SupportedOptions(value = &#123;\"eventBusIndex\", \"verbose\"&#125;)public class EventBusAnnotationProcessor extends AbstractProcessor &#123; 可以看到，它支持的只有一个注解：Subscribe 同时他支持两个配置属性： eventBusIndex：是否开启编译时注解处理，这个特性是 3.x 版本新增的，也就是将运行时的处理放到了编译时注解处理，动态生成 java 代码，用于提升框架的性能； verbose：用于控制 log，调试使用； 这两个属性是在 gradle 中配置的； 1234567891011121314android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [eventBusIndex:'com.monster.android.wild.MyEventBusIndex', verbose : \"true\"] &#125; &#125; &#125;&#125;dependencies &#123; api 'org.greenrobot:eventbus:3.1.0' annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1'&#125; 我们在下面的分析中就能看到，注解处理器对于这几个参数的处理： 2.1 成员变量EventBusAnnotationProcessor 内部如下的变量和常量： 12public static final String OPTION_EVENT_BUS_INDEX = \"eventBusIndex\";public static final String OPTION_VERBOSE = \"verbose\"; 上面的变量用于获取 gradle 的环境变量； 12345678// 保存订阅者（类）和其订阅方法（注解修饰的方法）的映射关系；private final ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass = new ListMap&lt;&gt;(); // 保存需要跳过的订阅者private final Set&lt;TypeElement&gt; classesToSkip = new HashSet&lt;&gt;();private boolean writerRoundDone;private int round;private boolean verbose; 2.2 process依然是核心方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; Messager messager = processingEnv.getMessager(); try &#123; //【1】获取 eventBusIndex 编译属性，并判断是否有设置这个，没有的话就不处理； String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX); if (index == null) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"No option \" + OPTION_EVENT_BUS_INDEX + \" passed to annotation processor\"); return false; &#125; //【2】判断是否要输出 log； verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE)); //【3】获取动态创建的 java 类的类名； int lastPeriod = index.lastIndexOf('.'); String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null; round++; if (verbose) &#123; messager.printMessage(Diagnostic.Kind.NOTE, \"Processing round \" + round + \", new annotations: \" + !annotations.isEmpty() + \", processingOver: \" + env.processingOver()); &#125; if (env.processingOver()) &#123; if (!annotations.isEmpty()) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"Unexpected processing state: annotations still available after processing over\"); return false; &#125; &#125; if (annotations.isEmpty()) &#123; return false; &#125; if (writerRoundDone) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"Unexpected processing state: annotations still available after writing.\"); &#125; //【--&gt;2.2.1】收集注解 Subscribe 修饰的元素； collectSubscribers(annotations, env, messager); //【--&gt;2.2.2】检查某些注解是否要忽略； checkForSubscribersToSkip(messager, indexPackage); if (!methodsByClass.isEmpty()) &#123; //【--&gt;2.2.3】如果收集到了被注解修饰的方法，那么就动态创建 java 类； createInfoIndexFile(index); &#125; else &#123; messager.printMessage(Diagnostic.Kind.WARNING, \"No @Subscribe annotations found\"); &#125; writerRoundDone = true; &#125; catch (RuntimeException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.ERROR, \"Unexpected error in EventBusAnnotationProcessor: \" + e); &#125; return true;&#125; 整个流程很简单，不多 say； 2.2.1 collectSubscribers - 收集收集注解 Subscribe 修饰的元素； 123456789101112131415161718private void collectSubscribers(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager) &#123; for (TypeElement annotation : annotations) &#123; Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation); // 获得 Subscribe 修饰的所有元素； for (Element element : elements) &#123; if (element instanceof ExecutableElement) &#123; ExecutableElement method = (ExecutableElement) element; //【--&gt;2.2.1.1】检查注解修饰的方法是否满足条件； if (checkHasNoErrors(method, messager)) &#123; //【1】获得方法所属的类元素，加入到 methodsByClass 哈希表中； TypeElement classElement = (TypeElement) method.getEnclosingElement(); methodsByClass.putElement(classElement, method); &#125; &#125; else &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"@Subscribe is only valid for methods\", element); &#125; &#125; &#125;&#125; 2.2.1.1 checkHasNoErrors检查是否有错误： 12345678910111213141516171819private boolean checkHasNoErrors(ExecutableElement element, Messager messager) &#123; //【1】方法不能是 static 的； if (element.getModifiers().contains(Modifier.STATIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"Subscriber method must not be static\", element); return false; &#125; //【2】方法必须是 public 的； if (!element.getModifiers().contains(Modifier.PUBLIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"Subscriber method must be public\", element); return false; &#125; //【3】方法必须至少有一个 param； List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters(); if (parameters.size() != 1) &#123; messager.printMessage(Diagnostic.Kind.ERROR, \"Subscriber method must have exactly 1 parameter\", element); return false; &#125; return true;&#125; 不多说； 2.2.2 checkForSubscribersToSkip跳过一些订阅者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void checkForSubscribersToSkip(Messager messager, String myPackage) &#123; //【1】遍历收集到所有的订阅者； for (TypeElement skipCandidate : methodsByClass.keySet()) &#123; TypeElement subscriberClass = skipCandidate; while (subscriberClass != null) &#123; //【--&gt;2.2.2.1】判断下注解方法所属的类是否满足条件，如果不满足，加入到 classesToSkip 跳过； if (!isVisible(myPackage, subscriberClass)) &#123; //【2】将要跳过的 class 加入到 classesToSkip 集合中； boolean added = classesToSkip.add(skipCandidate); if (added) &#123; String msg; if (subscriberClass.equals(skipCandidate)) &#123; // 是当前类，还是父类呢？ msg = \"Falling back to reflection because class is not public\"; &#125; else &#123; msg = \"Falling back to reflection because \" + skipCandidate + \" has a non-public super class\"; &#125; messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass); &#125; break; &#125; //【3】处理类（包括父类）所有的注解方法： List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass); if (methods != null) &#123; //【3.1】遍历该类的注解方法，处理方法的参数； for (ExecutableElement method : methods) &#123; String skipReason = null; //【3.2】获取注解方法的第一个参数（意味着第一个参数必须是消息对象） VariableElement param = method.getParameters().get(0); //【--&gt;2.2.2.2】获取被注解方法的参数类型； TypeMirror typeMirror = getParamTypeMirror(param, messager); //【3.3】如果参数的类型不是类/接口，那么就跳过该类； if (!(typeMirror instanceof DeclaredType) || !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) &#123; skipReason = \"event type cannot be processed\"; &#125; //【3.4】如果上面满足条件，那就判断下参数是否可以访问； if (skipReason == null) &#123; TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement(); //【--&gt;2.2.2.1】判断下注解方法所属的类是否满足条件，如果不满足，加入到 classesToSkip 跳过； if (!isVisible(myPackage, eventTypeElement)) &#123; skipReason = \"event type is not public\"; &#125; &#125; if (skipReason != null) &#123; //【3.2】将要跳过的 class 加入到 classesToSkip 集合中； boolean added = classesToSkip.add(skipCandidate); if (added) &#123; String msg = \"Falling back to reflection because \" + skipReason; if (!subscriberClass.equals(skipCandidate)) &#123; msg += \" (found in super class for \" + skipCandidate + \")\"; &#125; messager.printMessage(Diagnostic.Kind.NOTE, msg, param); &#125; break; &#125; &#125; &#125; //【--&gt;2.2.2.3】获取其父类对应的元素，然后 while 循环继续处理其 super class； subscriberClass = getSuperclass(subscriberClass); &#125; &#125;&#125; 可以看到，默认我们获得的是注解方法所在的当前类，但是 while 循环还会继续处理其父类； 先处理子类，再处理父类； 被注解的方法的第一个参数必须是要处理的消息； 消息类型必须是类/接口的实现； 2.2.2.1 isVisible用来判断注解方法所属的类是否满足条件： 1234567891011121314151617181920212223private boolean isVisible(String myPackage, TypeElement typeElement) &#123; Set&lt;Modifier&gt; modifiers = typeElement.getModifiers(); boolean visible; //【1】该类必须是 public 的； if (modifiers.contains(Modifier.PUBLIC)) &#123; visible = true; //【2】该类不能是 private/protected 的； &#125; else if (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) &#123; visible = false; &#125; else &#123; //【3】默认访问权限； //【--&gt;2.2.2.1.1】获得注解方法所属类的包元素名（包名）； String subscriberPackage = getPackageElement(typeElement).getQualifiedName().toString(); if (myPackage == null) &#123; visible = subscriberPackage.length() == 0; &#125; else &#123; // 正常情况进入这里： //【3】就是说注解方法所说的类必须和 eventBusIndex 指定的要动态生成的 java 类属于同一个包下； visible = myPackage.equals(subscriberPackage); &#125; &#125; return visible;&#125; 参数 myPackage 是我们 eventBusIndex 指定的要动态生成的 java 类的 class Name； 参数 TypeElement typeElement 则是注解方法所在的类元素； 可以看到，注解方法所属的类必须要满足一下的条件： 如果是 public，那就是可见的 visible 为 true； 如果是 private/protected，那就是不可见的； 如果是 default，那么 必须和 eventBusIndex 指定的要动态生成的 java 类属于同一个包下； 2.2.2.1.1 getPackageElement获得注解方法所属类的包元素： 12345678private PackageElement getPackageElement(TypeElement subscriberClass) &#123; Element candidate = subscriberClass.getEnclosingElement(); //【1】这里的 while 不断循环处理，直到 candidate 是一个包元素； while (!(candidate instanceof PackageElement)) &#123; candidate = candidate.getEnclosingElement(); &#125; return (PackageElement) candidate;&#125; 这里用到了 TypeElement. getenclosingelement() 的方法： 返回封装此元素（非严格意义上）的最里层元素。 如果此元素的声明在词法上直接封装在另一个元素的声明中，则返回那个封装元素。如果此元素是顶层类型，则返回它的包。如果此元素是一个包，则返回 null。如果此元素是一个类型参数，则返回 null。 2.2.2.2 getParamTypeMirror获取注解方法的参数的类型： 1234567891011121314151617private TypeMirror getParamTypeMirror(VariableElement param, Messager messager) &#123; //【1】获取参数的类型； TypeMirror typeMirror = param.asType(); // Check for generic type if (typeMirror instanceof TypeVariable) &#123; //【1.1】判断参数类型是否有上边界，如果有的话，那就使用上边界为参数类型； TypeMirror upperBound = ((TypeVariable) typeMirror).getUpperBound(); if (upperBound instanceof DeclaredType) &#123; // 上边界是类或接口类型； if (messager != null) &#123; messager.printMessage(Diagnostic.Kind.NOTE, \"Using upper bound type \" + upperBound + \" for generic parameter\", param); &#125; typeMirror = upperBound; // 就将上边界类型作为参数类型： &#125; &#125; return typeMirror;&#125; 这里我们用到了这个方法 TypeVariable.getUpperBound() 返回：此类型变量的上边界 如果此类型变量被声明为没有明确上边界，则结果为 java.lang.object。如果此类型变量被声明为有多个上边界，则结果是一个交集类型（建模为 declaredtype）。通过检查结果的超类型，可以发现个别边界。 这个是什么意思呢？举个简单的栗子，下面是我们的消息类： 12class Message&lt;T&gt; extends BaseMessage &#123;&#125; // 返回上边界 BaseMessage，为了使用多态；class Message&lt;T&gt; &#123;&#125; // 返回 Message 对应的类型； 这样解释就简单了吧！ 2.2.2.3 getSuperclass获取当前类的父类元素： 12345678910111213141516private TypeElement getSuperclass(TypeElement type) &#123; //【1】如果当前元素类型是类或者接口，才会获取父类； if (type.getSuperclass().getKind() == TypeKind.DECLARED) &#123; //【1.1】获取其直接父类； TypeElement superclass = (TypeElement) processingEnv.getTypeUtils().asElement(type.getSuperclass()); String name = superclass.getQualifiedName().toString(); if (name.startsWith(\"java.\") || name.startsWith(\"javax.\") || name.startsWith(\"android.\")) &#123; //【1.1.1】过滤掉 java/javax/android 系统类； return null; &#125; else &#123; return superclass; &#125; &#125; else &#123; return null; &#125;&#125; TypeKind 是枚举，保存了 Java 定义的所有的类型数据！ 2.2.3 createInfoIndexFile动态生成 java 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void createInfoIndexFile(String index) &#123; BufferedWriter writer = null; try &#123; //【1】创建 JavaFileObject 对象，用于生成 java 类； JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index); //【2】生成 java 包名（eventBusIndex 最后一个 . 前面的字符串）和 java 类名（eventBusIndex 最后一个 . 后面的字符串）； int period = index.lastIndexOf('.'); String myPackage = period &gt; 0 ? index.substring(0, period) : null; String clazz = index.substring(period + 1); writer = new BufferedWriter(sourceFile.openWriter()); if (myPackage != null) &#123; writer.write(\"package \" + myPackage + \";\\n\\n\"); // 动态 java 类的包名； &#125; writer.write(\"import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\\n\"); writer.write(\"import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\\n\"); writer.write(\"import org.greenrobot.eventbus.meta.SubscriberInfo;\\n\"); writer.write(\"import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\\n\\n\"); writer.write(\"import org.greenrobot.eventbus.ThreadMode;\\n\\n\"); writer.write(\"import java.util.HashMap;\\n\"); writer.write(\"import java.util.Map;\\n\\n\"); writer.write(\"/** This class is generated by EventBus, do not edit. */\\n\"); writer.write(\"public class \" + clazz + \" implements SubscriberInfoIndex &#123;\\n\"); // 动态 java 类的类名 writer.write(\" private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\\n\\n\"); writer.write(\" static &#123;\\n\"); writer.write(\" SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\\n\\n\"); //【--&gt;2.2.3.1】写入注解生成的信息； writeIndexLines(writer, myPackage); writer.write(\" &#125;\\n\\n\"); writer.write(\" private static void putIndex(SubscriberInfo info) &#123;\\n\"); // 写入内部的 putIndex 方法； writer.write(\" SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\\n\"); writer.write(\" &#125;\\n\\n\"); writer.write(\" @Override\\n\"); writer.write(\" public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\\n\"); // 写入的 getSubscriberInfo 方法； writer.write(\" SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\\n\"); writer.write(\" if (info != null) &#123;\\n\"); writer.write(\" return info;\\n\"); writer.write(\" &#125; else &#123;\\n\"); writer.write(\" return null;\\n\"); writer.write(\" &#125;\\n\"); writer.write(\" &#125;\\n\"); writer.write(\"&#125;\\n\"); &#125; catch (IOException e) &#123; throw new RuntimeException(\"Could not write source for \" + index, e); &#125; finally &#123; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; //Silent &#125; &#125; &#125;&#125; 这里的代码有些 low，竟然是硬编码写进去的； 生成了的代码会涉及到如下的类： 12345import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;import org.greenrobot.eventbus.meta.SubscriberMethodInfo;import org.greenrobot.eventbus.meta.SubscriberInfo;import org.greenrobot.eventbus.meta.SubscriberInfoIndex;import org.greenrobot.eventbus.ThreadMode; 可以看到，这几个类定义在 eventbus 模块里，简单的说下： SimpleSubscriberInfo：表示一个订阅者，就是 Subscribe 注解所在的类； SubscriberMethodInfo：表示一个订阅方法，就是 Subscribe 注解的方法； SubscriberInfo：接口，SimpleSubscriberInfo 继承了 AbstractSubscriberInfo，而 AbstractSubscriberInfo 实现了 SubscriberInfo 接口，适配器模式； SubscriberInfoIndex：接口，我们动态生成的 Java 类，实现了该接口； ThreadMode：枚举类型，表示线程类型； 这里我们不多关注； 2.2.3.1 writeIndexLines这里就是将 methodsByClass 中收集到的信息写入到动态 java 类中； 1234567891011121314151617181920212223private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOException &#123; //【1】遍历 methodsByClass 哈希表，跳过 classesToSkip 中的元素； for (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123; if (classesToSkip.contains(subscriberTypeElement)) &#123; continue; &#125; //【--&gt;2.2.3.1.1】获得注解方法所在的类名； String subscriberClass = getClassString(subscriberTypeElement, myPackage); //【--&gt;2.2.2.1】判断下动态 java 类所在的包是否可以访问注解所在类，可以的话，才写入！ if (isVisible(myPackage, subscriberTypeElement)) &#123; writeLine(writer, 2, \"putIndex(new SimpleSubscriberInfo(\" + subscriberClass + \".class,\", \"true,\", \"new SubscriberMethodInfo[] &#123;\"); // 这个我就不分析了，一行一行的写入呗； //【2】获取注解的方法； List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement); //【--&gt;2.2.3.1.2】将方法信息写入到 java 类中； writeCreateSubscriberMethods(writer, methods, \"new SubscriberMethodInfo\", myPackage); writer.write(\" &#125;));\\n\\n\"); &#125; else &#123; writer.write(\" // Subscriber not visible to index: \" + subscriberClass + \"\\n\"); &#125; &#125;&#125; 第二个参数表示的是否检查父类：shouldCheckSuperclass，传入的是 true； 2.2.3.1.1 getClassString获取类名； 1234567891011121314151617private String getClassString(TypeElement typeElement, String myPackage) &#123; //【--&gt;2.2.2.1.1】获取注解所在的类的包元素； PackageElement packageElement = getPackageElement(typeElement); //【1】获取所在包名； String packageString = packageElement.getQualifiedName().toString(); //【2】获取类的全限定名； String className = typeElement.getQualifiedName().toString(); if (packageString != null &amp;&amp; !packageString.isEmpty()) &#123; if (packageString.equals(myPackage)) &#123; //【3】如果注解所在的类和动态生成的 java 类的包名一样；就截掉全限定名的包名部分（因为在同一个包嘛） className = cutPackage(myPackage, className); &#125; else if (packageString.equals(\"java.lang\")) &#123; className = typeElement.getSimpleName().toString(); &#125; &#125; return className;&#125; 这里调用内部的 cutPackage 去截取类名！ 代码简单，就 String 的基本操作。。。 2.2.3.1.2 writeCreateSubscriberMethods将方法信息写入到 java 类中，参数 String callPrefix 的值：”new SubscriberMethodInfo” 12345678910111213141516171819202122232425262728293031323334353637383940414243private void writeCreateSubscriberMethods(BufferedWriter writer, List&lt;ExecutableElement&gt; methods, String callPrefix, String myPackage) throws IOException &#123; //【1】遍历方法 list； for (ExecutableElement method : methods) &#123; List&lt;? extends VariableElement&gt; parameters = method.getParameters(); TypeMirror paramType = getParamTypeMirror(parameters.get(0), null); //【--&gt;2.2.2.2】注解方法的参数的类型; TypeElement paramElement = (TypeElement) processingEnv.getTypeUtils().asElement(paramType); //【1.1】获取方法名； String methodName = method.getSimpleName().toString(); //【--&gt;2.2.3.1.2】获取方法参数（事件）的类名； String eventClass = getClassString(paramElement, myPackage) + \".class\"; //【1.3】获取 Subscribe 注解对象； Subscribe subscribe = method.getAnnotation(Subscribe.class); List&lt;String&gt; parts = new ArrayList&lt;&gt;(); parts.add(callPrefix + \"(\\\"\" + methodName + \"\\\",\"); //【1.4】第一个参数：methodName； String lineEnd = \"),\"; //【1.5】处理注解的 priority、sticky、threadMode 属性； if (subscribe.priority() == 0 &amp;&amp; !subscribe.sticky()) &#123; // 如果优先级为 0（默认）并且不是 sticky 事件，那么会进入 if； // 如果是默认类型的线程池，只要写入事件的类名； // 不是默认线程，那么还要写入线程枚举类型； if (subscribe.threadMode() == ThreadMode.POSTING) &#123; parts.add(eventClass + lineEnd); &#125; else &#123; parts.add(eventClass + \",\"); parts.add(\"ThreadMode.\" + subscribe.threadMode().name() + lineEnd); // 处理线程类型； &#125; &#125; else &#123; // 如果指定了优先级，或者是粘性事件，这里会写入事件的类名，线程枚举类型，优先级，粘性状态； parts.add(eventClass + \",\"); parts.add(\"ThreadMode.\" + subscribe.threadMode().name() + \",\"); parts.add(subscribe.priority() + \",\"); parts.add(subscribe.sticky() + lineEnd); &#125; writeLine(writer, 3, parts.toArray(new String[parts.size()])); if (verbose) &#123; processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, \"Indexed @Subscribe at \" + method.getEnclosingElement().getSimpleName() + \".\" + methodName + \"(\" + paramElement.getSimpleName() + \")\"); &#125; &#125;&#125; 这个过程是处理注解方法和注解参数的过程； 3 动态 Java 类实例我们可以看下动态生成的 Java 类实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.coolqi.top;import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;import org.greenrobot.eventbus.meta.SubscriberMethodInfo;import org.greenrobot.eventbus.meta.SubscriberInfo;import org.greenrobot.eventbus.meta.SubscriberInfoIndex;import org.greenrobot.eventbus.ThreadMode;import java.util.HashMap;import java.util.Map;/** This class is generated by EventBus, do not edit. */public class moduleAppIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(com.coolqi.ui.EditPicActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo(\"onEventMainThread\", com.coolqi.common.beans.MessageEvent.class), new SubscriberMethodInfo(\"onEventMainThread2\", com.coolqi.common.beans.MessageEvent.class, ThreadMode.ASYNC, 1, true), &#125;)); putIndex(new SimpleSubscriberInfo(com.coolqi.ui.ChangeDateActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo(\"onEventMainThread\", com.coolqi.common.beans.MessageEvent.class), &#125;)); putIndex(new SimpleSubscriberInfo(com.coolqi.ui.normal.ExhibitionWebFragment.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo(\"onShowMessageChatNumberEvent\", com.gensee.kzkt_res.bean.MessageChatNumber.class), new SubscriberMethodInfo(\"onEventMainThread\", com.coolqi.common.beans.MessageEvent.class), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125; 下面我们简单的看下涉及到的类和接口，这些类都位于 eventbus 模块中！ 后面再分析的时候，我们就不再过多关注这些类了！ 3.1 SubscriberInfoIndex接口，动态生成的类实现该接口： 1234public interface SubscriberInfoIndex &#123; //【1】用于获取订阅信息； SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass);&#125; 3.2 SubscriberInfo接口，订阅者类实现该接口： 123456789public interface SubscriberInfo &#123; Class&lt;?&gt; getSubscriberClass(); // 获取订阅者对应的类； SubscriberMethod[] getSubscriberMethods(); // 获取订阅方法； SubscriberInfo getSuperSubscriberInfo(); // 获取父类订阅者； boolean shouldCheckSuperclass(); // 是否检查父类，动态生成时，传入的是 true；&#125; 3.3 AbstractSubscriberInfo抽象类，实现了 SubscriberInfo 接口，并实现了其部分接口，适配器模式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class AbstractSubscriberInfo implements SubscriberInfo &#123; private final Class subscriberClass; private final Class&lt;? extends SubscriberInfo&gt; superSubscriberInfoClass; private final boolean shouldCheckSuperclass; protected AbstractSubscriberInfo(Class subscriberClass, Class&lt;? extends SubscriberInfo&gt; superSubscriberInfoClass, boolean shouldCheckSuperclass) &#123; this.subscriberClass = subscriberClass; // 订阅者类； this.superSubscriberInfoClass = superSubscriberInfoClass; // 订阅者的父类订阅者，processor 动态生成时传入的是 null； this.shouldCheckSuperclass = shouldCheckSuperclass; // 是否检查父类，processor 动态生成时传入的是 true； &#125; @Override public Class getSubscriberClass() &#123; return subscriberClass; &#125; @Override public SubscriberInfo getSuperSubscriberInfo() &#123; if(superSubscriberInfoClass == null) &#123; return null; &#125; try &#123; return superSubscriberInfoClass.newInstance(); // 返回父类订阅者的实例； &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public boolean shouldCheckSuperclass() &#123; return shouldCheckSuperclass; &#125; // 下面是创建订阅方法； protected SubscriberMethod createSubscriberMethod(String methodName, Class&lt;?&gt; eventType) &#123; return createSubscriberMethod(methodName, eventType, ThreadMode.POSTING, 0, false); &#125; protected SubscriberMethod createSubscriberMethod(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode) &#123; return createSubscriberMethod(methodName, eventType, threadMode, 0, false); &#125; protected SubscriberMethod createSubscriberMethod(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky) &#123; try &#123; // 显然这里是通过反射的方式来创建！ Method method = subscriberClass.getDeclaredMethod(methodName, eventType); return new SubscriberMethod(method, eventType, threadMode, priority, sticky); &#125; catch (NoSuchMethodException e) &#123; throw new EventBusException(\"Could not find subscriber method in \" + subscriberClass + \". Maybe a missing ProGuard rule?\", e); &#125; &#125;&#125; 3.4 SimpleSubscriberInfo订阅类，继承了 AbstractSubscriberInfo 类，适配器模式： 12345678910111213141516171819202122public class SimpleSubscriberInfo extends AbstractSubscriberInfo &#123; private final SubscriberMethodInfo[] methodInfos; // 保存的是订阅方法； public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass, SubscriberMethodInfo[] methodInfos) &#123; super(subscriberClass, null, shouldCheckSuperclass); //【--&gt;3.3】抽象类的方法； this.methodInfos = methodInfos; &#125; @Override public synchronized SubscriberMethod[] getSubscriberMethods() &#123; // 返回所有的订阅方法； int length = methodInfos.length; SubscriberMethod[] methods = new SubscriberMethod[length]; for (int i = 0; i &lt; length; i++) &#123; SubscriberMethodInfo info = methodInfos[i]; //【--&gt;3.3】注意并不是直接返回，而是返回了一份拷贝，防止修改； methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode, info.priority, info.sticky); &#125; return methods; &#125;&#125; 不多说了！ 4 总结本篇文章，分析了 eventbus 的注解是如何处理的，生成了哪些类，类的关系如何（适配器模式）； 下篇文章，分析 register 的过程；","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"EventBus","slug":"开源库源码分析/EventBus","permalink":"https://coolqi.top/categories/开源库源码分析/EventBus/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"https://coolqi.top/tags/EventBus/"}]},{"title":"EventBus 第一篇 - 基本使用","slug":"Eventbus-1-baseUsages","date":"2019-08-19T12:46:25.000Z","updated":"2019-08-27T14:28:00.642Z","comments":true,"path":"2019/08/19/Eventbus-1-baseUsages/","link":"","permalink":"https://coolqi.top/2019/08/19/Eventbus-1-baseUsages/","excerpt":"","text":"本系列文章主要分析 EventBus 框架的架构和原理，基于最新的 3.1.0 版本。 这是 EventBus 开源库的地址，大家可以直接访问https://github.com/greenrobot/EventBus 本篇文章是 EventBus 的第一篇，主要总结下基本的使用； Eventbus 翻译过来就是事件总线，用于简化组件和组件，线程和线程之间的消息通信，可以捆成是 Handler + Thread 的替代品。 1 引入Eventbus 的引入没有 ARouter 那么复杂，他的核心 api 和 AnnotationProcessor 是在同一个 jar 中： 1compile 'org.greenrobot:eventbus:3.0.0' 以上就是引入的方式，很简单； 2 基本使用Eventbus 的使用还是很简单的。 首先，我们要在组件生命周期的开始 register、生命周期的结束 unregister： 123EventBus.getDefault().register(this);EventBus.getDefault().unregister(this); 我们之后将组件 register 到 EventBus 中，该组件才能监听到事件； 当然，当组件生命周期结束后，需要 unregister！ 接着，我们要定义接收 Event 的方法； 123@Subscribepublic void onEventMainThread(MessageEvent event) &#123;&#125; 在 EventBus 中，处理 event 的方法需要被注解 @Subscribe 修饰，这是因为 EventBus 的机制，提供了一个 EventBusAnnotationProcessor，他负责自动处理 @Subscribe 修饰的方法，动态生成管理集合。 在事件分发的时候，会自动调用我们的方法； 对于注解 @Subscribe，我们可以设置其属性： 1@Subscribe(threadMode = ThreadMode.MAIN, sticky = true, priority = 2) 1、threadMode 用于指定线程模型（默认为 POSTING ），EventBus 提供了四种线程模型，下面会简单介绍； 2、sticky 表示方法是否开启粘性事件； 3、priority 表示多个订阅者收到事件的优先级顺序； 最后，我们要发送消息 消息这里分为普通消息和粘性消息，和 broadcast 很类似哦： 123EventBus.getDefault().postSticky(..)EventBus.getDefault().post(...) 对于普通消息和粘性消息的处理，后面再分析。 方法很简答，就不多说了～～ 3 线程模型EventBus 提供了四种线程模型，定义在 ThreadMode.java 中： POSTING 这是默认的线程模型，发布事件和接收事件在同一个线程进行，不要做耗时操作，因为可能是在 UI 线程，导致 ANR； MAIN 接收事件在 UI 线程中进行；不要做耗时操作，会导致 ANR； BACKGROUND 如果发送事件是在 UI 线程，那么接收事件会在一个新的子线程； 如果发送事件是在子线程，那么接收事件和发送事件会在同一个子线程； 不能处理 UI 相关操作！ ASYNC 接收事件始终会在一个新的子线程中，不能处理 UI 相关操作！ 这里简单分析了下线程模型，我们后面在分析源码的时候，再来分析每种线程模型的处理方式； 4 整体架构初识可以看到这种订阅和接收的关系，很类似于 Rxjava 的模式，其实就是观察者模式，这里直接引用 EventBus 官方的一张图来说明下： 5 总结本篇文章就到这里了，下一篇会从 @Subscribe 注解的处理入手，看下 EventBus 是如何处理该注解的；","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"EventBus","slug":"开源库源码分析/EventBus","permalink":"https://coolqi.top/categories/开源库源码分析/EventBus/"}],"tags":[{"name":"EventBus","slug":"EventBus","permalink":"https://coolqi.top/tags/EventBus/"}]},{"title":"JsBridge 第四篇 - H5 调用 Native 代码","slug":"JsBridge4-H5-->NativeCodes","date":"2019-05-23T12:46:25.000Z","updated":"2019-07-07T00:42:28.696Z","comments":true,"path":"2019/05/23/JsBridge4-H5-->NativeCodes/","link":"","permalink":"https://coolqi.top/2019/05/23/JsBridge4-H5-->NativeCodes/","excerpt":"","text":"本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头； 1 调用接口在 js 中，我们通过如下方式，使用 jsBridge 框架来和 Native 通信： 123456789101112131415161718var data = &#123;id: 1, content: \"这是一个图片 &lt;img src=\\\"a.png\\\"/&gt; test\\r\\nhahaha\"&#125;;//【1】通过 js 通信协议 send 方法；window.WebViewJavascriptBridge.send( data , function(responseData) &#123; document.getElementById(\"show\").innerHTML = \"repsonseData from java, data = \" + responseData &#125;);//【2】通过 js 通信协议 callHandler 方法；window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': '中文测试'&#125; , function(responseData) &#123; document.getElementById(\"show\").innerHTML = \"send get responseData from java, data = \" + responseData &#125;); send 方法；用客户端默认的 handler 处理； callHandler 方法：用指定的 handler 处理； 下面我们来分析下 callHandler 和 send 方法！ 2 WebViewJavascriptBridge接下来进入了 js 通信协议文件中： 2.1 send用客户端默认的 handler 处理 123456function send(data, responseCallback) &#123; //【--&gt;*2.3】调用 _doSend 方法； _doSend(&#123; data: data &#125;, responseCallback);&#125; 2.2 callHandler用指定的 handler 处理 1234567function callHandler(handlerName, data, responseCallback) &#123; //【--&gt;*2.3】调用 _doSend 方法； _doSend(&#123; handlerName: handlerName, data: data &#125;, responseCallback);&#125; 2.3 _doSend最后都调用了 _doSend 的方法： 123456789101112131415//sendMessage add message, 触发native处理 sendMessagefunction _doSend(message, responseCallback) &#123; if (responseCallback) &#123; //【1】创建了一个 calbackId，并将 id 和 callback 的映射关系保存到 responseCallbacks 中； // 将 callbackId 保存到 message 中！ var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; //【2】将消息保存到 sendMessageQueue 中，创建动态 url，通知 native； sendMessageQueue.push(message); //【3】yy://__QUEUE_MESSAGE__，最终会触发如下方法 //【--&gt;*3.1】BridgeWebView.flushMessageQueue messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; 这里在前面分析过了，和前面的类似。 messagingIframe.src 最终会触发如下方法调用链： 1BridgeWebViewClient.shouldOverrideUrlLoading ---&gt; BridgeWebView.flushMessageQueue 2.4 _fetchQueue从 sendMessageQueue 队列中获取 message，发送给 native：1234567891011function _fetchQueue() &#123; //【1】这里是统一处理要发给 native 的所有消息，将队列转为 string var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //【2】这里又再在页面生成 url，和之前的区别是包含数据，然后再次通过 shouldOverrideUrlLoading 方法拦截， // 捕获 url 中的数据； if (messageQueueString !== '[]') &#123; //【--&gt;*3.3】这一次，生成的 url 将真正带有回调数据； bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125;&#125; 这里生成了一个新的 url： yy://://return/_fetchQueue/[{“responseId”:”xxxxxxx”,”responseData”:”xxxxxxxxxx”}] messagingIframe.src 最终会触发如下方法调用链： 1BridgeWebViewClient.shouldOverrideUrlLoading ---&gt; BridgeWebView.handlerReturnData 2.5 _handleMessageFromNativejs 代码中会处理 native 发送的 message json： 12345678910function _handleMessageFromNative(messageJSON) &#123; console.log(messageJSON); //【1】如果 receiveMessageQueue 不为 null，那么会讲她加入到 // receiveMessageQueue 队列中，它是用来保存 native 发送的消息的； if (receiveMessageQueue) &#123; receiveMessageQueue.push(messageJSON); &#125; //【--&gt;*2.6】分发来自 native 的消息； _dispatchMessageFromNative(messageJSON);&#125; 在第二篇 js 协议中有讲过： 当在动态注入 js 脚本时，会执行 init 方法，那里会将 receiveMessageQueue 置为 null，同时处理已经包含的 native 消息； 所以这里就直接 _dispatchMessageFromNative 了； 2.6 _dispatchMessageFromNativejs 处理 native 层的回调消息： 1234567891011121314151617function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; var message = JSON.parse(messageJSON); var responseCallback; //【1】这里 js 处理消息回调，不多说了！ if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; ... ... ...// 这里是处理 java 回调的，之前分析过； &#125; &#125;);&#125; 3 BridgeWebView3.1 flushMessageQueuenative 读取 js 的命令： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void flushMessageQueue() &#123; //【1】必须在主线程（loadUrl） if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; //【---&gt;*3.2】执行 js 脚本 loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; //【*3.1.1】这个回调是用来分发 url 对应的数据给相应的回调！ @Override public void onCallBack(String data) &#123; //【1】用于存储所有的消息； List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; //【2】遍历处理下每一个 Message。 Message m = list.get(i); String responseId = m.getResponseId(); //【3】如果 Message.responseId 不为 null，说明这是 js 反馈给 native 的回调数据。 // 此时 responseId 表示 native 回调函数的 id！ if (!TextUtils.isEmpty(responseId)) &#123; ... ... ... ...// 这里前面有分析过； &#125; else &#123; //【4】这里是我们要关注的地方： // 这种情况是属于 js 主动向 Handler 发送消息的时候，callbackId 显然是 js 的回调函数 id； CallBackFunction responseFunction = null; final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; //【4.1】有 js 回调的情况，进入这里； responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; //【4.1.1】可以看到，这里创建了一个 Message，作为给 js 的回调信息； Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); //【--&gt;*3.4】将消息加入 list，等待处理； queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; //【4.2】无 js 回调的情况，进入这里； responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; //【4.3】js 指定了 native 处理数据的 handler！ BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; //【4.4】处理 js 的 message，并发送回调信息给 js。 if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125;&#125; 这里可以看大了，给 js 反馈回调的时候： 123Message responseMsg = new Message();responseMsg.setResponseId(callbackId);responseMsg.setResponseData(data); js 传入的 callbackId 被设置到了 responseId 上了； 3.2 loadUrl参数 jsUrl 是 javascript:WebViewJavascriptBridge._fetchQueue(); 123456public void loadUrl(String jsUrl, CallBackFunction returnCallback) &#123; //【--&gt;*2.4】执行 jsUrl 命令； this.loadUrl(jsUrl); //【2】同时将 CallBackFunction 放入到 responseCallbacks 中； responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);&#125; 这里有分析过，对 js 命令做了处理，生成了 key： javascript:WebViewJavascriptBridge._fetchQueue(); –&gt; _fetchQueue 用于保存回调； 3.3 handlerReturnData123456789101112131415void handlerReturnData(String url) &#123; //【--&gt;3*7.2】再次解析 url，获得回调的 key：functionName String functionName = BridgeUtil.getFunctionFromReturnUrl(url); //【1】functionName 就是 _fetchQueue，这里我们获得了【*3.3】注册的 callback CallBackFunction f = responseCallbacks.get(functionName); //【--&gt;3*7.2】获得 js 的回调返回数据； String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; //【--&gt;*3.1.1】执行回调，处理数据！ f.onCallBack(data); //【2】删除该 _fetchQueue 对应的回调（我觉得可以不删除的） responseCallbacks.remove(functionName); return; &#125;&#125; 触发前面的 _fetchQueue 对应的回调； 3.4 queueMessage加入 message list： 12345678private void queueMessage(Message m) &#123; if (startupMessage != null) &#123; startupMessage.add(m); &#125; else &#123; //【--&gt;*3.5】分发 message 给 js； dispatchMessage(m); &#125;&#125; 3.5 dispatchMessagenative 给 js 发送消息的关键点，参数 message 是一个消息对象！ 123456789101112131415161718void dispatchMessage(Message m) &#123; //【1】将 message 转为 json String messageJson = m.toJson(); //【2】为 message json 字符串转义特殊字符； messageJson = messageJson.replaceAll(\"(\\\\\\\\)([^utrn])\", \"\\\\\\\\\\\\\\\\$1$2\"); messageJson = messageJson.replaceAll(\"(?&lt;=[^\\\\\\\\])(\\\")\", \"\\\\\\\\\\\"\"); messageJson = messageJson.replaceAll(\"(?&lt;=[^\\\\\\\\])(\\')\", \"\\\\\\\\\\'\"); messageJson = messageJson.replaceAll(\"%7B\", URLEncoder.encode(\"%7B\")); messageJson = messageJson.replaceAll(\"%7D\", URLEncoder.encode(\"%7D\")); messageJson = messageJson.replaceAll(\"%22\", URLEncoder.encode(\"%22\")); //【3】创建要执行的 js 代码，用于和 H5 通信； String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson); //【4】必须要找主线程才会将数据传递出去 --- 划重点 if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; 【--&gt;*2.5】执行 js 代码； this.loadUrl(javascriptCommand); &#125;&#125; BridgeUtil 是一个工具类，里面主要是一些通信协议码，以及一些工具方法，native 和 H5 通信的时候，本质上是执行 js 代码： final static String JS_HANDLE_MESSAGE_FROM_JAVA =“javascript:WebViewJavascriptBridge._handleMessageFromNative(‘%s’);”; 可以看到，执行的 js 代码如下： javascript:WebViewJavascriptBridge._handleMessageFromNative(JsonString of Message); 我相信大家知道，这个方法将进入通信协议 js 文件了！","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"JsBridge","slug":"开源库源码分析/JsBridge","permalink":"https://coolqi.top/categories/开源库源码分析/JsBridge/"}],"tags":[{"name":"JsBridge","slug":"JsBridge","permalink":"https://coolqi.top/tags/JsBridge/"}]},{"title":"JsBridge 第三篇 - Native 调用 H5 代码","slug":"JsBridge3-Native-->H5Codes","date":"2019-05-23T12:46:25.000Z","updated":"2019-07-05T21:48:34.437Z","comments":true,"path":"2019/05/23/JsBridge3-Native-->H5Codes/","link":"","permalink":"https://coolqi.top/2019/05/23/JsBridge3-Native-->H5Codes/","excerpt":"","text":"本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头； 1 调用接口在 android 中，我们通过如下方式，使用 jsBridge 框架来和 H5 通信： 123456789101112131415//【1】封装 Java 层的 bean 数据；User user = new User();Location location = new Location();location.address = \"SDU\";user.location = location;user.name = \"大头鬼\";//【2】发送数据，并注册回调函数 CallBackFunction：webView.callHandler(\"functionInJs\", new Gson().toJson(user), new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; &#125;&#125;);//【3】这个是不需要回调的，直接发送数据给 H5；webView.send(\"hello\"); 这里涉及到 2 个交互接口： webView.callHandler：有回调； webView.send：没有回调； 下面我会来分析下这两个方法的调用链，这会涉及到 jsBridge 中其他的类： 12345678|____Message.java|____WebViewJavascriptBridge.java|____DefaultHandler.java|____BridgeWebView.java|____BridgeWebViewClient.java|____CallBackFunction.java|____BridgeHandler.java|____BridgeUtil.java 在分析交互流程的时候，我们会详细分析每个类的内部逻辑！ 2 BridgeWebView我们从 BridgeWebView 开始，先看看内部的一些重要成员变量：12345678//【1】native 的回调函数 map，key 是 id，value 是具体的回调对象；Map&lt;String, CallBackFunction&gt; responseCallbacks = new HashMap&lt;String, CallBackFunction&gt;();//【2】native 处理 js 消息的 handler map，key 是 handler name，value 是具体的 handlerMap&lt;String, BridgeHandler&gt; messageHandlers = new HashMap&lt;String, BridgeHandler&gt;();//【3】默认的 handler，默认是它处理 js 的消息；BridgeHandler defaultHandler = new DefaultHandler();//【4】native 发送给 js 的 message 列表；private List&lt;Message&gt; startupMessage = new ArrayList&lt;Message&gt;(); 不多说了。 2.1 callHandler我们先分析有回调的接口的交互流程： 123456//【1】发送数据，并注册回调函数 CallBackFunction：webView.callHandler(\"functionInJs\", new Gson().toJson(user), new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; &#125;&#125;); callHandler 方法指定了 js 使用哪个 Handler 处理 native 的消息！ 这里指定了 js 用于处理的 handler name 是 “functionInJs”！ 1234public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123; //【*2.2】调用另外一个方法： doSend(handlerName, data, callBack);&#125; 我们去看看 doSend 方法： 2.2 doSend继续分析 doSend 方法： 1234567891011121314151617181920private void doSend(String handlerName, String data, CallBackFunction responseCallback) &#123; //【1】创建一个消息； Message m = new Message(); if (!TextUtils.isEmpty(data)) &#123; //【2】设置 data 数据； m.setData(data); &#125; //【3】如果需要回调，那么会创建回调 id（String） if (responseCallback != null) &#123; String callbackStr = String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis())); responseCallbacks.put(callbackStr, responseCallback); m.setCallbackId(callbackStr); &#125; //【4】如果指定了 handler，那么设置 handlerName； if (!TextUtils.isEmpty(handlerName)) &#123; m.setHandlerName(handlerName); &#125; //【*2.3】将消息送入队列； queueMessage(m);&#125; 这里我们看到，会创建一个 Message 对象，封装要发给 js 的消息； 同时注意到，native 的回调并没有传递给 js，而是保存在了内部的一个 responseCallbacks 哈希表中； 实际传递给 js 的是 callbackId； 123Message.data // native 发送的数据Message.callbackId // native 回调函数的 idMessage.handlerName // js 处理数据的 handlerName； 最后就是把 message 放入到 message list； 2.3 queueMessage将 message 放入到 message list； 123456789private void queueMessage(Message m) &#123; if (startupMessage != null) &#123; //【1】将消息加入到 message list 中； startupMessage.add(m); &#125; else &#123; //【*2.4】特殊情况，直接发送 message！ dispatchMessage(m); &#125;&#125; 可以看到，这里默认是会将 message 添加到 startupMessage 消息列表中，然后 webview 会处理 message list！ 那么在哪里会处理呢？ 前面我们分析过，在网页加载好后，会出发 BridgeWebViewClient.onPageFinished 方法，就会启动 native 的消息处理循环！ 见 【3.1】 节； 2.4 dispatchMessagenative 给 js 发送消息的关键点，参数 message 是一个消息对象！ 123456789101112131415161718void dispatchMessage(Message m) &#123; //【*4.2】将 message 转为 json String messageJson = m.toJson(); //【1】为 message json 字符串转义特殊字符； messageJson = messageJson.replaceAll(\"(\\\\\\\\)([^utrn])\", \"\\\\\\\\\\\\\\\\$1$2\"); messageJson = messageJson.replaceAll(\"(?&lt;=[^\\\\\\\\])(\\\")\", \"\\\\\\\\\\\"\"); messageJson = messageJson.replaceAll(\"(?&lt;=[^\\\\\\\\])(\\')\", \"\\\\\\\\\\'\"); messageJson = messageJson.replaceAll(\"%7B\", URLEncoder.encode(\"%7B\")); messageJson = messageJson.replaceAll(\"%7D\", URLEncoder.encode(\"%7D\")); messageJson = messageJson.replaceAll(\"%22\", URLEncoder.encode(\"%22\")); //【2】创建要执行的 js 代码，用于和 H5 通信； String javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson); //【3】必须要找主线程才会将数据传递出去 --- 划重点 if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; 【*5.1】执行 js 代码； this.loadUrl(javascriptCommand); &#125;&#125; BridgeUtil 是一个工具类，里面主要是一些通信协议码，以及一些工具方法，native 和 H5 通信的时候，本质上是执行 js 代码： 1final static String JS_HANDLE_MESSAGE_FROM_JAVA = \"javascript:WebViewJavascriptBridge._handleMessageFromNative('%s');\"; 可以看到，执行的 js 代码如下： 1javascript:WebViewJavascriptBridge._handleMessageFromNative(JsonString of Message); 我相信大家知道，这个方法将进入通信协议 js 文件了！ 2.5 handlerReturnData拦截 url 并处理信息 12345678910void handlerReturnData(String url) &#123; String functionName = BridgeUtil.getFunctionFromReturnUrl(url); CallBackFunction f = responseCallbacks.get(functionName); String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; f.onCallBack(data); responseCallbacks.remove(functionName); return; &#125;&#125; 3 BridgeWebViewClientWebViewClient 是用于处理各种事件的回调。 3.1 onPageFinished当 H5 页面加载完成后，会 WebViewClient 方法会处罚； 12345678910111213141516171819202122@Overridepublic void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); //【1】动态注入 js 协议脚本，这个我们之前有讲过； if (BridgeWebView.toLoadJs != null) &#123; BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs); &#125; //【*2.5】这里会遍历 BridgeWebView.startupMessage 分发 native 消息； if (webView.getStartupMessage() != null) &#123; for (Message m : webView.getStartupMessage()) &#123; //【*2.5】分发 native 消息； webView.dispatchMessage(m); &#125; //【*2.3】注意：这里将 BridgeWebView.startupMessage 设置为 null 了 // 那么下次就不用将消息加入 list 了，而是直接 dispatch 了！ webView.setStartupMessage(null); &#125; //【2】调用其他函数处理 url！ onCustomPageFinishd(view,url);&#125; 看起来最终调用了 webView.dispatchMessage 方法！ 3.2 shouldOverrideUrlLoading我们来看看： 123456789101112131415161718192021222324@Overridepublic boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; //【1】获得动态创建的 url url = URLDecoder.decode(url, \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; //【*3.2.2】此时是返回数据，url 携带数据； if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; //【*3.5】native 解析 js 返回的数据； webView.handlerReturnData(url); return true; //【*3.2.1】此时是提醒 native，js 有数据返回； &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; //【*3.3】native 再次和 js 通信，获取数据； webView.flushMessageQueue(); return true; &#125; ... ... ...&#125; BridgeUtil 定义了如下的 url 前缀规则：12345final static String YY_OVERRIDE_SCHEMA = \"yy://\";//【1】表示 js 有数据返回，提醒 native 去读取数据；final static String YY_RETURN_DATA = YY_OVERRIDE_SCHEMA + \"return/\";//【2】该 url 会携带 js 返回的数据；final static String YY_FETCH_QUEUE = YY_RETURN_DATA + \"_fetchQueue/\"; 3.3 flushMessageQueue核心方法，从 js 的队列里获取要发送给 native 的 message： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778void flushMessageQueue() &#123; //【1】必须在主线程（loadUrl） if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123; //【---&gt;*3.4】执行 js 脚本 loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, new CallBackFunction() &#123; //【*3.3.1】这个回调是用来分发 url 对应的数据给相应的回调！ @Override public void onCallBack(String data) &#123; //【1】用于存储所有的消息； List&lt;Message&gt; list = null; try &#123; list = Message.toArrayList(data); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; if (list == null || list.size() == 0) &#123; return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; //【2】遍历处理下每一个 Message。 Message m = list.get(i); String responseId = m.getResponseId(); //【3】如果 Message.responseId 不为 null，说明这是 js 反馈给 native 的回调数据。此时 responseId 表示 native 回调函数的 id！ if (!TextUtils.isEmpty(responseId)) &#123; //【3.1】获得 native 在 callHandler 是设定的回调函数！ CallBackFunction function = responseCallbacks.get(responseId); //【3.2】获得回调数据； String responseData = m.getResponseData(); //【--&gt;*2.1】native 处理数据，这里又回到了 callHandler 哪里！ function.onCallBack(responseData); //【3.3】移除 native 注册的回调函数！ responseCallbacks.remove(responseId); &#125; else &#123; //【4】这种情况是属于，js 主动向 Handler 发送消息的时候，callbackId 显然是 js 的回调函数 id； CallBackFunction responseFunction = null; final String callbackId = m.getCallbackId(); if (!TextUtils.isEmpty(callbackId)) &#123; //【4.1】有 js 回调的情况，进入这里； responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; //【4.1.1】可以看到，这里创建了一个 Message，作为给 js 的回调信息； Message responseMsg = new Message(); responseMsg.setResponseId(callbackId); responseMsg.setResponseData(data); //【--&gt;*2.4】将消息加入 list，等待处理； queueMessage(responseMsg); &#125; &#125;; &#125; else &#123; //【4.2】无 js 回调的情况，进入这里； responseFunction = new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; // do nothing &#125; &#125;; &#125; //【4.3】js 指定了 native 处理数据的 handler！ BridgeHandler handler; if (!TextUtils.isEmpty(m.getHandlerName())) &#123; handler = messageHandlers.get(m.getHandlerName()); &#125; else &#123; handler = defaultHandler; &#125; //【4.4】处理 js 的message，并发送回调信息给 js。 if (handler != null)&#123; handler.handler(m.getData(), responseFunction); &#125; &#125; &#125; &#125; &#125;); &#125;&#125; 下面部分的代码（【4】)），是和 H5 调用 Native 代码相关的，我们不过多关注！ BridgeUtil 定义了指定 js 协议的 _fetchQueue 方法的命令：1final static String JS_FETCH_QUEUE_FROM_JAVA = \"javascript:WebViewJavascriptBridge._fetchQueue();\"; 下面去看一下 loadUrl： 3.4 loadUrl参数 jsUrl 是 javascript:WebViewJavascriptBridge._fetchQueue(); 123456public void loadUrl(String jsUrl, CallBackFunction returnCallback) &#123; //【*5.4】执行 jsUrl 命令； this.loadUrl(jsUrl); //【2】同时将 CallBackFunction 放入到 responseCallbacks 中； responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);&#125; 这里调用了【*7.1】BridgeUtil.parseFunctionName 对 jsUrl 做了处理，以结果作为 key！ 处理入下： javascript:WebViewJavascriptBridge._fetchQueue(); –&gt; _fetchQueue 这样是有好处了，因为 returnCallback 根据协议是可以复用的，所以这里也保存在了 responseCallbacks 中！！ responseCallbacks 之前我们有分析过！此时 responseCallbacks 放入了 2 个 native 的回调！ 3.5 handlerReturnData改方法用于处理 js 返回给 native 的回调数据： 123456789101112131415void handlerReturnData(String url) &#123; //【*7.2】再次解析 url，获得回调的 key：functionName String functionName = BridgeUtil.getFunctionFromReturnUrl(url); //【1】functionName 就是 _fetchQueue，这里我们获得了【*3.3】注册的 callback CallBackFunction f = responseCallbacks.get(functionName); //【*7.3」获得 js 的回调返回数据； String data = BridgeUtil.getDataFromReturnUrl(url); if (f != null) &#123; //【*3.3.1】执行回调，处理数据！ f.onCallBack(data); //【2】删除该 _fetchQueue 对应的回调（我觉得可以不删除的） responseCallbacks.remove(functionName); return; &#125;&#125; 这里调用了【*7.2】BridgeUtil.getFunctionFromReturnUrl 对 url 再次做了处理，前面在 【3.3】 flushMessageQueue，我们将另一个解析回调以 _fetchQueue 为 key，保存到了 responseCallbacks 中，这里是触发他的时候了！ 4 Message该对象用于封装 native 和 js 交互的信息： 4.1 属性我们来看看他的基本属性： 123456789101112131415 // native --&gt; js: native 回调的 id，用于处理 js 的返回信息； // js --&gt; native: js 回调的 id，用于处理 native 的返回信息；private String callbackId; // js --&gt; native: native 回调的 id，用于处理 js 的返回信息；private String responseId;// js --&gt; native: js 发送给 native 的信息：json，string；private String responseData; // js 的回调信息，json string；// native --&gt; js: native 发送给 js 的信息：json，string；private String data; // native --&gt; js: 处理 native 信息的 js handler name；private String handlerName; 不多说了！ 4.2 toJson将 Message 转为 json string！ 12345678910111213141516171819202122public String toJson() &#123; JSONObject jsonObject= new JSONObject(); try &#123; jsonObject.put(CALLBACK_ID_STR, getCallbackId()); // callbackId jsonObject.put(DATA_STR, getData()); // data jsonObject.put(HANDLER_NAME_STR, getHandlerName()); // handlerName String data = getResponseData(); //【3】这个地方我有些疑问，不知道作者为啥这样写 // 值永远会被第三个覆盖掉； if (TextUtils.isEmpty(data)) &#123; jsonObject.put(RESPONSE_DATA_STR, data); &#125; else &#123; jsonObject.put(RESPONSE_DATA_STR, new JSONTokener(data).nextValue()); &#125; jsonObject.put(RESPONSE_DATA_STR, getResponseData()); // responseData jsonObject.put(RESPONSE_ID_STR, getResponseId()); // responseId return jsonObject.toString(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return null;&#125; 具体的参数我就不说了，很简单！ 5 WebViewJavascriptBridge最后进入了通信协议 js 脚本： 5.1 _handleMessageFromNativejs 代码中会处理 native 发送的 message json： 12345678910function _handleMessageFromNative(messageJSON) &#123; console.log(messageJSON); //【1】如果 receiveMessageQueue 不为 null，那么会讲她加入到 // receiveMessageQueue 队列中，它是用来保存 native 发送的消息的； if (receiveMessageQueue) &#123; receiveMessageQueue.push(messageJSON); &#125; //【*5.2】分发来自 native 的消息； _dispatchMessageFromNative(messageJSON);&#125; 在第二篇 js 协议中有讲过： 当在动态注入 js 脚本时，会执行 init 方法，那里会将 receiveMessageQueue 置为 null，同时处理已经包含的 native 消息； 所以这里就直接 _dispatchMessageFromNative 了； 5.2 _dispatchMessageFromNativejs 处理 native 层的消息： 12345678910111213141516171819202122232425262728293031323334353637383940function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; //【1】获得 message json 对象； var message = JSON.parse(messageJSON); var responseCallback; if (message.responseId) &#123; ... ... ...// 这个地方是 js 回调的地方，我们先不看； &#125; else &#123; //【2】很显然，此时会进入这里，因为我们设置了 callbackId！ if (message.callbackId) &#123; //【3】获得 callbackId！ var callbackResponseId = message.callbackId; //【*5.2.1】创建 js 回调函数，当回调触发后，会执行 doSend 方法！ responseCallback = function(responseData) &#123; //【*5.3】将结果以回调形式发送给 native！ _doSend(&#123; //【4】注意这里，Message.callbackId 的值赋给了 Message.responseId // Message.responseData 用于保存回调数据； responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; //【5】选择合适的 handler 去处理 native message。 // 没有指定 handler，就用默认的！ var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; try &#123; //【*6.1】handler 其实就是一个函数，这个在通信协议 js 有分析过！ handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", message, exception); &#125; &#125; &#125; &#125;);&#125; 最后会选择合适的 handler，将 native message 和 js 回调函数交给 handler 处理！ 5.3 _doSend将结果以回调形式发送给 native！ 12345678910111213141516171819function _doSend(message, responseCallback) &#123; //【1】responseCallback 不为 null，说明 native 需要回调通知，这里将 responseCallback // 保存到 responseCallbacks 的意义是：可以建立双向通信！ if (responseCallback) &#123; //【2】为该 responseCallback 创建 id，并将 id：responseCallback 的映射关系 // 保存到 responseCallbacks 数组中！ var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; //【3】将 id 保存到 message.callbackId 中；！ // 因为此时 message 用于保存 js 发给 native 的数据，所以 message.callbackId 保存了 js 的回调函数， // 这样 native 就可以和 js 双向通信了！ message.callbackId = callbackId; &#125; //【4】将消息保存到 sendMessageQueue 中，然后创建 url， //【*3.2】这样 BridgeWebViewClient.shouldOverrideUrlLoading 就能拦截这个 url 了； sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; responseCallback 实际上是 js 处理 native 消息的回调函数，这里给 responseCallback 也分配了一个 id，并保存到 responseCallbacks 中！ 目的很明显，是为了建立双向通信！ 到这里 Message 中的数据发生了变化：123Message.responseId // native 的回调函数 idMessage.callbackId // js 的回调函数 idMessage.responseData // js 发送的回调数据； 这里创建了一个 url： 1yy://__QUEUE_MESSAGE__/ 这个方法会导致 BridgeWebViewClient.shouldOverrideUrlLoading 触发！ 5.4 _fetchQueue从 sendMessageQueue 队列中获取 message，发送给 native： 1234567891011function _fetchQueue() &#123; //【1】这里是统一处理要发给 native 的所有消息，将队列转为 string var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //【2】这里又再在页面生成 url，和之前的区别是包含数据，然后再次通过 shouldOverrideUrlLoading 方法拦截， // 捕获 url 中的数据； if (messageQueueString !== '[]') &#123; //【*3.2.2】这一次，生成的 url 将真正带有回调数据； bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125;&#125; 这里生成了一个新的 url： 1yy://://return/_fetchQueue/[&#123;\"responseId\":\"xxxxxxx\",\"responseData\":\"xxxxxxxxxx\"&#125;] 再次回到了 shouldOverrideUrlLoading： 6 H5 页面初始化 js 脚本在 jsBridge 框架中，当 js 协议脚本被动态注入到 H5 中时，会触发 H5 页面中的初始化 js 脚本，该脚本会初始化 js 的 handler： 6.1 connectWebViewJavascriptBridge可以看到，H5 页面注册的 js handler 的名字就是 “functionInJs” 这个和前面 callHandler 相符合了！ 12345678910111213connectWebViewJavascriptBridge(function(bridge) &#123; ... ... ... //【1】后面的 function 就是我们的 handler。 bridge.registerHandler(\"functionInJs\", function(data, responseCallback) &#123; document.getElementById(\"show\").innerHTML = (\"data from Java: = \" + data); if (responseCallback) &#123; var responseData = \"Javascript Says Right back aka!\"; //【*5.2.1】js 处理完 message 后，回调 responseCallback 接口！ // 其实就是【*5.2】创建的回调，会触发 _doSend 方法！ responseCallback(responseData); &#125; &#125;);&#125;) 这个在前面的 js 通信协议中有分析过，不多说了！ 7 BridgeUtil工具类，包含一些解析方法和协议头常量： 7.1 parseFunctionName从 url 中解析 funtion name： 12345// url 的一个例子：javascript:WebViewJavascriptBridge._fetchQueue();public static String parseFunctionName(String jsUrl)&#123; //【1】返回_fetchQueue return jsUrl.replace(\"javascript:WebViewJavascriptBridge.\", \"\").replaceAll(\"\\\\(.*\\\\);\", \"\");&#125; 该方法是在 js 创建 url，通知 native 有回调消息后调用的！ 7.2 getFunctionFromReturnUrl从 url 中解析 funtion name： 12345678910111213// 下面是 url 的一个例子；// url = yy://return/_fetchQueue/[&#123;\"responseId\":\"xxxxx\",\"responseData\":\"xxxxx\"&#125;]public static String getFunctionFromReturnUrl(String url) &#123; //【1】去掉 \"yy://return/\"; String temp = url.replace(YY_RETURN_DATA, EMPTY_STR); //【2】去掉 \"/[&#123;\"responseId\":\"xxxxx\",\"responseData\":\"xxxxx\"&#125;]\" String[] functionAndData = temp.split(SPLIT_MARK); if(functionAndData.length &gt;= 1)&#123; //【3】我们得到了 key，也就是 functionName； return functionAndData[0]; &#125; return null;&#125; 该方法是在 native 获取到 js 消息后调用的！ 7.3 getDataFromReturnUrl1234567891011121314151617181920212223// 下面是 url 的一个例子；// url = yy://return/_fetchQueue/[&#123;\"responseId\":\"JAVA_CB_2_3957\",\"responseData\":\"xxxxx\"&#125;]public static String getDataFromReturnUrl(String url) &#123; if(url.startsWith(YY_FETCH_QUEUE)) &#123; //【1】返回了 [&#123;\"responseId\":\"JAVA_CB_2_3957\",\"responseData\":\"xxxxx\"&#125;] return url.replace(YY_FETCH_QUEUE, EMPTY_STR); &#125; // temp = _fetchQueue/[&#123;\"responseId\":\"JAVA_CB_2_3957\",\"responseData\":\"Javascript Says Right back aka!\"&#125;] //【2】对另外一种情况的处理 String temp = url.replace(YY_RETURN_DATA, EMPTY_STR); String[] functionAndData = temp.split(SPLIT_MARK); if(functionAndData.length &gt;= 2) &#123; StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt; functionAndData.length; i++) &#123; sb.append(functionAndData[i]); &#125; //【3】返回结果是一样的！ return sb.toString(); &#125; return null;&#125; 该方法是在 native 获取到 js 消息后调用的，并且在【7.2】调用以后才调用！","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"JsBridge","slug":"开源库源码分析/JsBridge","permalink":"https://coolqi.top/categories/开源库源码分析/JsBridge/"}],"tags":[{"name":"JsBridge","slug":"JsBridge","permalink":"https://coolqi.top/tags/JsBridge/"}]},{"title":"JsBridge 第二篇 - js 通信协议分析","slug":"JsBridge2-jsCommunicationProtocol","date":"2019-05-21T12:46:25.000Z","updated":"2019-07-03T22:46:15.585Z","comments":true,"path":"2019/05/21/JsBridge2-jsCommunicationProtocol/","link":"","permalink":"https://coolqi.top/2019/05/21/JsBridge2-jsCommunicationProtocol/","excerpt":"","text":"本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头； 1 初步分析下面分析下 jsBridge 框架的通信协议，他是实际上是一个 js 文件，位于 assets 目录下： 1WebViewJavascriptBridge.js 这个 js 文件作为协议，决定了 H5 和 Native 代码通信方式和通信数据！ 这里就有一个问题了，他是如何被加载并生效的呢，有两种方式： 第一种方式：通过 H5 直接加载； 第二种方式：通过动态注入的方式： 1BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs); 我们的 jsBridge 框架也是用的第二种方式，具体的逻辑我们后面再分析； 2 协议代码分析下面我们分析下 js 协议代码的逻辑： 1234567(function() &#123; //【1】判断变量 WebViewJavascriptBridge 是否初始化过了； if (window.WebViewJavascriptBridge) &#123; return; &#125; ... ... ...&#125;)(); 这里来看的话，其实他是一个 js function，当我们将 js 动态注入到 H5 中时，这么这个 function 就会执行； 2.1 内部关键变量js 文件中定义了一些关键的变量： 123456789101112131415161718192021222324var messagingIframe; // 这两个变量用与 android 获取 js 的数据；var bizMessagingIframe;var sendMessageQueue = []; // 发送的消息队列，H5 传递给 Nativevar receiveMessageQueue = []; // 接受的消息队列，Native 传递给 H5var messageHandlers = &#123;&#125;; // js 处理 native 消息的 handler 数组！var CUSTOM_PROTOCOL_SCHEME = 'yy'; // 消息的 scheme，类似与 file，content；var QUEUE_HAS_MESSAGE = '__QUEUE_MESSAGE__/';var responseCallbacks = &#123;&#125;; // js 端的回调数组；var uniqueId = 1;... ... ...// 这个很重要，window.WebViewJavascriptBridge 是 H5 和 Native 通信的// 关键点！var WebViewJavascriptBridge = window.WebViewJavascriptBridge = &#123; init: init, send: send, registerHandler: registerHandler, callHandler: callHandler, _fetchQueue: _fetchQueue, _handleMessageFromNative: _handleMessageFromNative&#125;; 上面最关键的一个对象就是 WebViewJavascriptBridge，H5 和 Native 都会通过它。 这个 window.WebViewJavascriptBridge 内部包含了一些函数对象，这些 function 都定义在 js 内部！ 2.2 动态注入初始化这里是很关键的地方： 12345678910var doc = document;//【1】创建消息队列，一个是 index，一个是消息体；_createQueueReadyIframe(doc);_createQueueReadyIframe4biz(doc);//【2】创建一个 event，类型为 'WebViewJavascriptBridgeReady'// 然后分发 event；var readyEvent = doc.createEvent('Events');readyEvent.initEvent('WebViewJavascriptBridgeReady');readyEvent.bridge = WebViewJavascriptBridge;doc.dispatchEvent(readyEvent); //【*2.2.1】关键点！！ 在动态注入的时候，会执行初始化的操作： 创建了一个 event； 初始化 event，事件类型为 ‘WebViewJavascriptBridgeReady’； readyEvent.bridge 设置为我们上面创建的 ‘WebViewJavascriptBridgeReady’ 对象； doc.dispatchEvent 分发 event； 这个 event 是在哪里做响应的呢？ 是在 H5 里面，这个 H5 在加载时候，会执行内部 js 脚本，并通过 document.addEventListener 方法设置该 event 的监听器； 2.2.1 H5 加载启动 event 监听H5 的页面里面，是有下面的一段 js 脚本，在 webview.loadUrl 后会直接加载该 js： 12345678910111213141516171819202122232425&lt;script&gt;... ... ...function connectWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; //【2】如果 window.WebViewJavascriptBridge 已经存在 // 直接执行函数闭包； callback(WebViewJavascriptBridge) &#125; else &#123; //【3】否则我们就注册一个 EventListener，监听 WebViewJavascriptBridgeReady 事件； document.addEventListener( 'WebViewJavascriptBridgeReady' , function() &#123; // 事件出发后，执行函数闭包； callback(WebViewJavascriptBridge) &#125;, false ); &#125;&#125;//【1】执行 connectWebViewJavascriptBridge 方法，传入了一个 js 闭包;connectWebViewJavascriptBridge(function(bridge) &#123; //【*2.2.2】下一步初始化！ ... ... ... ...&#125;)&lt;/script&gt; 默认情况下，window.WebViewJavascriptBridge 不存在，那么会注册一个 EventListener！ 等待 event 触发后，执行 callback！ 2.2.2 event 出发点后下一步初始化callback 实际上就是闭包，参数 bridge 就是 js 协议中创建的 var WebViewJavascriptBridge： 12345678910111213141516171819202122232425//【*2.3.1】执行 WebViewJavascriptBridge 对象的 init 方法，// 传入一个函数闭包！bridge.init(function(message, responseCallback) &#123; console.log('JS got a message', message); var data = &#123; 'Javascript Responds': '测试中文!' &#125;; if (responseCallback) &#123; console.log('JS responding with', data); //【1】函数闭包出发后，会回调 responseCallback responseCallback(data); &#125;&#125;);//【*2.3.1】执行 WebViewJavascriptBridge 对象的 registerHandler 方法，// 传入一个函数闭包！bridge.registerHandler(\"functionInJs\", function(data, responseCallback) &#123; document.getElementById(\"show\").innerHTML = (\"data from Java: = \" + data); if (responseCallback) &#123; var responseData = \"Javascript Says Right back aka!\"; //【2】函数闭包出发后，会回调 responseCallback，通知 native； responseCallback(responseData); &#125;&#125;); 关于 init 和 registerHandler 我们会在下面分析： 2.3 核心函数下面来分析下关键的协议函数： 2.3.1 initinit 方法用于设置 js 处理 native 消息的默认 handler： 同时也会分发已经被添加到 receiveMessageQueue 接受队列中的 native 的消息： 123456789101112131415function init(messageHandler) &#123; if (WebViewJavascriptBridge._messageHandler) &#123; throw new Error('WebViewJavascriptBridge.init called twice'); &#125; //【1】设置 js 用于处理 native 消息的 handler // 实际上就是【*2.2.2】中的函数闭包； WebViewJavascriptBridge._messageHandler = messageHandler; //【2】分发已经被添加到 receiveMessageQueue 接受队列中的 native 的消息 var receivedMessages = receiveMessageQueue; receiveMessageQueue = null; for (var i = 0; i &lt; receivedMessages.length; i++) &#123; //【*2.3.3】分发来自 native 的消息； _dispatchMessageFromNative(receivedMessages[i]); &#125;&#125; 参数 messageHandler 就是【*2.2.2】中的函数闭包； 2.3.2 registerHandler注册特定的消息处理 handler： 1234function registerHandler(handlerName, handler) &#123; //【1】实际上就是向数组中放值； messageHandlers[handlerName] = handler;&#125; messageHandlers 之前有说过，是 js 处理 native 消息的 handler 数组！ index 是 handler 的名称，根据前面代码，名称是 “functionInJs”； value 是一个函数闭包； 2.3.3 _dispatchMessageFromNative这个方法是 js 层调用的，分发来自 native 的消息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function _dispatchMessageFromNative(messageJSON) &#123; setTimeout(function() &#123; //【2】JSON 字符串转化 JSON 对象 message； var message = JSON.parse(messageJSON); var responseCallback; //【2】这里我们知道 native 发送消息完成，接下来 js 会处理消息，并将结果 // 通过 callback 传递给 native 层； if (message.responseId) &#123; //【2.1】如果 native 指定了消息的 responseId，这种情况对应的情况是： // js 发送消息给 native，此时 native 发送回调消息给 js； // 那么我们就要在 responseCallback 数组中找到对应的 responseCallback responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; //【2.2】然后执行 js 的 callback； responseCallback(message.responseData); //【2.3】删掉该 callback delete responseCallbacks[message.responseId]; &#125; else &#123; //【2.4】没有指定 responseId，但是指定了 callbackId，这种情况对应的是： // native 发送消息给 js，此时 js 发送回调消息给 native； if (message.callbackId) &#123; //【2.4.1】获得 callbackId，并创建一个 responseCallback // 实际上就是一个函数闭包，该闭包会执行 _doSend 方法！ var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; //【*2.3.4】发送回调给 native，但是此时是不触发的，出发的点在下面； _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; //【2.5】找到处理 native 消息的 handler，如果没有指定 handlerName // 那么就是 init 方法注册的默认 handler；否则就是特定的 handler // 其实就是前面 \"functionInJs\" 对应的 handler； var handler = WebViewJavascriptBridge._messageHandler; if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; //【2.6】这个 handler 其实就是一个函数闭包，见【*2.2.2】，最后会回调 // responseCallback 接口，就是上面的 function； try &#123; handler(message.data, responseCallback); &#125; catch (exception) &#123; if (typeof console != 'undefined') &#123; console.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", message, exception); &#125; &#125; &#125; &#125;);&#125; 到这里看起来，似乎很清晰呢； 2.3.4 _doSend这个方法是 js 层调用，用于发送消息给 native 端： 1234567891011121314function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; //【1】计算回调 id； var callbackId = 'cb_' + (uniqueId++) + '_' + new Date().getTime(); //【2】以 index 为回调 id，value 为具体的回调接口的形式，保存到 responseCallbacks 数组重； responseCallbacks[callbackId] = responseCallback; //【3】message.callbackId 为计算出的回调 id； message.callbackId = callbackId; &#125; //【4】将该 message 加入到 sendMessageQueue 队列中，要发送给 native； sendMessageQueue.push(message); //【6】这个地方会通过 messagingIframe.src 生成一个 Url，这会被 Webview.shouldOverrideUrlLoading 拦截到； messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; 这里要注意第二个参数 responseCallback： 如果 responseCallback 不为 null，说明本次消息需要回调通知； 如果 responseCallback 为 null，说明不需要回调通知； 该方法创建了一个动态的 url，这会被 Webview.shouldOverrideUrlLoading 拦截到，这是该库 android 获得 js 数据的方式； 但是这里并不是真正获取数据的地方，该 url 会触发一次 Webview.shouldOverrideUrlLoading； 然后 android 又会调用 js 的 _fetchQueue 方法，这时，又会生成一个 url，这个 url 才会保存了要传递给 android 的消息； 具体可以看 2.3.8 的 _fetchQueue 方法； 2.3.5 callHandler这个方法是 js 层调用的，通过这个接口来调用 native 方法： handlerName：js 处理消息的 handler 名称，这个 handler 是 native 层注册到 js 的； data：native 层传递的数据； responseCallback：接受回调的接口，native 层处理完数据会回调； 12345678function callHandler(handlerName, data, responseCallback) &#123; //【*2.3.4】调用 _doSend 方法发送消息给 js，注意这里第二个参数 // 不为 null，因为 js 短需要收到回调； _doSend(&#123; handlerName: handlerName, data: data &#125;, responseCallback);&#125; 这里第二个参数不为 null，因为 js 短需要收到回调； 该方法设置 handlerName，所以 native 会使用指定 handlerName 的 handler 去处理； 2.3.6 send这个方法也是 js 层调用的，通过这个接口来调用 native 方法： 123456// 发送function send(data, responseCallback) &#123; _doSend(&#123; data: data &#125;, responseCallback);&#125; 这里我们看到，他并没有设置 handlerName，所以 native 会使用默认的 handler 去处理； 2.3.7 _handleMessageFromNative这个方法是 native 层调用的，以 json string 的形式发送数据给 js： 123456789function _handleMessageFromNative(messageJSON) &#123; console.log(messageJSON); //【1】如果 receiveMessageQueue 不为 null，那就直接添加到 receiveMessageQueue 队列中去； if (receiveMessageQueue) &#123; receiveMessageQueue.push(messageJSON); &#125; //【*2.3.3】处理 native 传递的数据； _dispatchMessageFromNative(messageJSON);&#125; 这里很简单，就不多说了； 2.3.8 _fetchQueue这个方法是 native 层调用的，用于获取 sendMessageQueue 队列中的消息： 123456789function _fetchQueue() &#123; //【1】这里是统一处理要发给 native 的所有消息，将队列转为 string var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; //【2】这里又再在页面生成 url，和之前的区别是包含数据，然后通过 shouldOverrideUrlLoading 方法拦截，捕获 url 中的数据； if (messageQueueString !== '[]') &#123; bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://return/_fetchQueue/' + encodeURIComponent(messageQueueString); &#125;&#125; 逻辑很简单，不多说了，关于 H5 和 Native 通信的流程，后续再分析！ 3 总结关于 js 通信协议的相关分析到这里就结束了。 这里我自己也有点疑惑，对于 android 获取 js 数据的方式，该库并没有使用 @JavascriptInterface 注解，通过如下方式实现： 1WebView.addJavascriptInterface(new WebData(), \"webdata\"); 通过查阅相关资料，可能有如下的原因： 安全隐患：这是因为同源规则 (SOP) 不适用与该方法，加上第三方 JavaScript 库或来自一个陌生域名的 iframe 可能在 Java 层访问这些被暴露的方法。因此，攻击者可通过一个 XSS 漏洞执行原生代码或者注入病毒代码到应用程序中。 兼容性：JavaScript 层中暴露的 Java 对象的所有公有方法在 Android 版本低于 JerryBean MRI(API Level 17) 以下时可访问。而在 Google API 17 （4.２）以上，暴露的函数必须通过 @JavaScriptInterface 注释来防止方法的暴露","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"JsBridge","slug":"开源库源码分析/JsBridge","permalink":"https://coolqi.top/categories/开源库源码分析/JsBridge/"}],"tags":[{"name":"JsBridge","slug":"JsBridge","permalink":"https://coolqi.top/tags/JsBridge/"}]},{"title":"JsBridge 第一篇 - 框架整体结构和基本使用","slug":"JsBridge1-frameworkStructureAndBaseUsages","date":"2019-05-20T12:46:25.000Z","updated":"2019-07-03T22:41:04.612Z","comments":true,"path":"2019/05/20/JsBridge1-frameworkStructureAndBaseUsages/","link":"","permalink":"https://coolqi.top/2019/05/20/JsBridge1-frameworkStructureAndBaseUsages/","excerpt":"","text":"本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头； 1 工程结构我们先来看看 lib 的主要文件结构： 1234567891011121314151617|____src| |____main| | |____java| | | |____com| | | | |____github| | | | | |____lzyzsd| | | | | | |____jsbridge| | | | | | | |____Message.java| | | | | | | |____WebViewJavascriptBridge.java| | | | | | | |____DefaultHandler.java| | | | | | | |____BridgeWebView.java| | | | | | | |____BridgeWebViewClient.java| | | | | | | |____CallBackFunction.java| | | | | | | |____BridgeHandler.java| | | | | | | |____BridgeUtil.java| | |____assets| | | |____WebViewJavascriptBridge.js 可以看到，核心的代码在 asserts 和 jsbridge 目录下。 js 文件是是通信的协议，H5 会出发 js 脚本中的语句，然后把通信的数据传递给 WebView； jsbridge 目录下的 .java 文件则是和 Native 层的逻辑相关； 这里先不详细分析每个文件的具体逻辑，我们后面分析交互流程的时候会讲； 2 基本使用具体的使用主要分为如下几个部分，我会将 Demo 中的一些重点代码块，用注视标注出来： 2.1 初始化 BridgeWebView：12345678910webView = (BridgeWebView) findViewById(R.id.webView);button = (Button) findViewById(R.id.button);button.setOnClickListener(this);//【1】设置默认的消息处理回调；webView.setDefaultHandler(new DefaultHandler());//【2】设置 WebChromeClient 对象，无关不分析；webView.setWebChromeClient(new WebChromeClient() &#123; ... ... ...&#125;); 当然，这里的 WebChromeClient 其实没有太大的用处，而真正有用的是其内部的：WebViewClient 对象，这个我们后面单独去分析 BridgeWebView 的时候，就知道 WebViewClient 的具体逻辑了； 2.2 注册回调 Handler 到 webview 中：12345678910//【1】加载 H5 页面；webView.loadUrl(\"file:///android_asset/demo.html\");//【2】注册了一个 BridgeHandler 回调对象，用于处理 js 的消息并回调通知；webView.registerHandler(\"submitFromWeb\", new BridgeHandler() &#123; @Override public void handler(String data, CallBackFunction function) &#123; Log.i(TAG, \"handler = submitFromWeb, data from web = \" + data); function.onCallBack(\"submitFromWeb exe, response data 中文 from Java\"); &#125;&#125;); BridgeHandler 是一个接口，面向接口编程，前面的 DefaultHandler 实现了这个接口！ 可以看到 BridgeHandler 是用于处理 H5 发送给 Native 的消息的； 而 CallBackFunction 则是用于回调结果给 H5； 2.3 Native 向 H5 发送消息，并接受回调123456789101112131415//【1】封装 Java 层的 bean 数据；User user = new User();Location location = new Location();location.address = \"SDU\";user.location = location;user.name = \"大头鬼\";//【2】发送数据，并注册回调函数 CallBackFunction：webView.callHandler(\"functionInJs\", new Gson().toJson(user), new CallBackFunction() &#123; @Override public void onCallBack(String data) &#123; &#125;&#125;);//【3】这个是不需要回调的，直接发送数据给 H5；webView.send(\"hello\"); 可以看到，上面给出了有回调和没有回调的两种通信方式； 具体的调用逻辑，我们后面再分析！ 2.4 H5 向 Native 发送消息，并接受回调这个地方就比较复杂了，我们要从 H5 中看起； H5 触发 js 的函数，指定具体的 handler 处理： 12345678910111213function testClick1() &#123; var str1 = document.getElementById(\"text1\").value; var str2 = document.getElementById(\"text2\").value; //【1】调用本地方法，特定 handler 处理！ window.WebViewJavascriptBridge.callHandler( 'submitFromWeb' , &#123;'param': '中文测试'&#125; , function(responseData) &#123; document.getElementById(\"show\").innerHTML = \"send get responseData from java, data = \" + responseData &#125; );&#125; 这里看到了 ‘submitFromWeb’，这和前面的 registerHandler 相呼应了！ H5 触发 js 的函数，默认 handler 处理： 12345678910111213function testClick() &#123; var str1 = document.getElementById(\"text1\").value; var str2 = document.getElementById(\"text2\").value; //【1】调用本地方法，默认 handler 处理！ var data = &#123;id: 1, content: \"这是一个图片 &lt;img src=\\\"a.png\\\"/&gt; test\\r\\nhahaha\"&#125;; window.WebViewJavascriptBridge.send( data , function(responseData) &#123; document.getElementById(\"show\").innerHTML = \"repsonseData from java, data = \" + responseData &#125; );&#125; 这和前面的 DefaultHandler 相呼应了！","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"JsBridge","slug":"开源库源码分析/JsBridge","permalink":"https://coolqi.top/categories/开源库源码分析/JsBridge/"}],"tags":[{"name":"JsBridge","slug":"JsBridge","permalink":"https://coolqi.top/tags/JsBridge/"}]},{"title":"ARouter 第七篇 - 路由跳转/数据传递 (arouter-api)","slug":"ARouter7-navigationWithData-arouter-api","date":"2019-05-09T12:46:25.000Z","updated":"2019-08-13T15:35:26.563Z","comments":true,"path":"2019/05/09/ARouter7-navigationWithData-arouter-api/","link":"","permalink":"https://coolqi.top/2019/05/09/ARouter7-navigationWithData-arouter-api/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的架构和原理。 这是阿里 ARouter 开源库的地址，大家可以直接访问https://github.com/alibaba/ARouter 本篇博文主要分析 arouter-api 模块的路由跳转的过程，以及变量/数据的传递，这篇文章将是本系列的最后一篇（后续会抽时间写其他的）！ 在阅读过程中，涉及到方法跳转的时候，注释上有 --&gt;的标志，这样的好处是，以类为单位，一次性分析其所有的方法： 1 路由跳转我们来看看 1.1 跳转方式ARouter 支持两种方式来跳转： path 跳转 123ARouter.getInstance().build(\"/home/main\") // 指定 path .navigation();ARouter.getInstance().build(\"/home/main\", \"ap\").navigation(); // 显示指定分组 uri 跳转 12Uri uri;ARouter.getInstance().build(uri).navigation(); // 指定 uri 我们可以设置跳转请求码和跳转回调 这种调用方式相当于原生的 startActivityForResult： 1ARouter.getInstance().build(\"/home/main\", \"ap\").navigation(this, 5); 同时我们也可以指定跳转回调：NavigationCallback 1234567891011121314151617ARouter.getInstance().build(\"/test/activity\").navigation(this, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; &#125; @Override public void onLost(Postcard postcard) &#123; &#125; @Override public void onArrival(Postcard postcard) &#123; &#125; @Override public void onInterrupt(Postcard postcard) &#123; &#125;&#125;); 处理跳转的结果； 我们也可以设置跳过所有的拦截器 我们知道 actiivty 的跳转是收到拦截器的限制的，但是 PostCard 提供了接口，能够跳过所有的拦截器： 12// 使用绿色通道(跳过所有的拦截器)ARouter.getInstance().build(\"/home/main\").greenChannel().navigation(); 这里的 greenChannel 方法我们前面有分析过，不多说了！ 1.1.1 Uri 跳转的特殊性这里要单独讲下 uri 跳转的特殊性，ARouter 通过新建一个没有 UI 的界面作为跳板来统一处理，scheme 是 arouter 的跳转请求！ 需要新建一个 activity 来接收 uri，没有 ui 界面，这是关键点！ 12345678910public class SchameFilterActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); ARouter.getInstance().build(uri).navigation(); finish(); &#125;&#125; AndroidManifest.xml 中要指定该 activity 监听的 schame 事件是：arouter://m.aliyun.com 1234567891011121314151617181920212223&lt;activity android:name=\".activity.SchameFilterActivity\"&gt; &lt;!-- Schame --&gt; &lt;intent-filter&gt; &lt;data android:host=\"m.aliyun.com\" android:scheme=\"arouter\"/&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;!-- 让浏览器可以打这个 Actvity，当然要符合 host 和 scheme --&gt; &lt;/intent-filter&gt; &lt;!-- App Links --&gt; &lt;intent-filter android:autoVerify=\"true\"&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;!-- 让浏览器可以打这个 Actvity，当然要符合 host 和 scheme --&gt; &lt;data android:host=\"m.aliyun.com\" android:scheme=\"http\"/&gt; &lt;data android:host=\"m.aliyun.com\" android:scheme=\"https\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 相当于这个 activity 作为外界的统一入口，H5 或者 native 通过 intent 匹配，将数据传递给这个 activity，然后这个 activity 解析数据，将 uri 叫给 ARouter 最终实现跳转！ 详细分析：Uri 的组成为：scheme://host:port/path?query，我们通过中转 activity 匹配 scheme://host:port 部分，截获 Uri，然后通过 getPath 就可以回去到 Path，这个 Path 需要和 @Route 的 path 匹配，这样就可以实现跳转了！ 可以看出这个过程就是 intent 的匹配！ 1.2 数据传递以上的两种跳转方式，都可以传递数据，我们来看下数据传递的方式： 直接传递 Bundle 12345Bundle params = new Bundle();ARouter.getInstance() .build(\"/home/main\") .with(params) .navigation(); 注意：这个方法会覆盖掉 PostCast 内部默认创建的 Bundle； 指定启动 Flag 1234ARouter.getInstance() .build(\"/home/main\") .withFlags(); .navigation(); 支持传递各种基本类型数据、对象、数组、List、可序列化数据： 123456789101112ARouter.getInstance() .build(\"/home/main\").withAction(..) .withBoolean(String key, boolean value) .withBundle(String key, Bundle value) .withByte(String key, byte value) .withCharSequenceArrayList(String key, ArrayList&lt;CharSequence&gt; value) .withParcelable(String key, Parcelable value) .withSerializable(String key, Serializable value) .withStringArrayList(String key, ArrayList&lt;String&gt; value) .withObject(@Nullable String key, @Nullable Object value) ... ... ... // 接口太多了，省略下，其实这些接口对应的是 Bundle 中的方法！ .navigation(); 这些数据都会被加入到 PostCard 内部的默认创建的 Bundle 中，其实这些方法对应的就是 Bundle 中的方法！ 支持设置转场动画 12345678910111213// 转场动画(常规方式)ARouter.getInstance() .build(\"/test/activity2\") .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this);// 转场动画(API16+)ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);ARouter.getInstance() .build(\"/test/activity2\") .withOptionsCompat(compat) .navigation(); 1.2.1 对象传递的特殊对于自定义的对象，不能确保它可序列化，所以这里通过 SerializationService 将其转为了 jsonstring： 12345public Postcard withObject(@Nullable String key, @Nullable Object value) &#123; serializationService = ARouter.getInstance().navigation(SerializationService.class); mBundle.putString(key, serializationService.object2Json(value)); return this;&#125; 2 跳转流程下面，我们重点分析路由跳转的流程，和数据传递的流程，忽略掉一些之前已经见过的流程！ 1ARouter.getInstance().build(...); --&gt; _ARouter.getInstance().build(...); 无论是 path 跳转，还是 uri 跳转，ARouter 都会调用 _ARouter 的方法！ 2.1 _ARouter.build无论是 build(path)，还是 build(uri)，最终创建的 PostCard 都是一样的！ 1234567891011121314151617181920212223protected Postcard build(String path) &#123; if (TextUtils.isEmpty(path)) &#123; throw new HandlerException(Consts.TAG + \"Parameter is invalid!\"); &#125; else &#123; PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) &#123; path = pService.forString(path); &#125; return build(path, extractGroup(path)); // 通过 path 创建！ &#125;&#125;protected Postcard build(Uri uri) &#123; if (null == uri || TextUtils.isEmpty(uri.toString())) &#123; throw new HandlerException(Consts.TAG + \"Parameter invalid!\"); &#125; else &#123; PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) &#123; uri = pService.forUri(uri); &#125; return new Postcard(uri.getPath(), extractGroup(uri.getPath()), uri, null); // 通过 uri 创建！ &#125;&#125; 2.2 Postcard2.2.1 new Postcard创建一个新的 Postcard： 12345678910public Postcard(String path, String group) &#123; this(path, group, null, null);&#125;public Postcard(String path, String group, Uri uri, Bundle bundle) &#123; setPath(path); setGroup(group); setUri(uri); this.mBundle = (null == bundle ? new Bundle() : bundle);&#125; 可以看到，通过 Uri 创建的话，会多设置一个 Uri 的属性； 2.2.2 navigation最核心的就后面的两个方法，支持传入 requestCode 和 NavigationCallback 实例： 12345678910111213141516171819public Object navigation() &#123; return navigation(null);&#125;public Object navigation(Context context) &#123; return navigation(context, null);&#125;public void navigation(Activity mContext, int requestCode) &#123; navigation(mContext, requestCode, null);&#125;public Object navigation(Context context, NavigationCallback callback) &#123; return ARouter.getInstance().navigation(context, this, -1, callback);&#125;public void navigation(Activity mContext, int requestCode, NavigationCallback callback) &#123; ARouter.getInstance().navigation(mContext, this, requestCode, callback);&#125; 对于 ARouter.getInstance().navigation，我们知道最后会调用 _ARouter.getInstance().navigation 1ARouter.getInstance().navigation(...) --&gt; _ARouter.getInstance().navigation(...); 2.3 _ARouter.navigation这里我们可以看到回调的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; //【1】这里的获取方式是一样的； PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class); if (null != pretreatmentService &amp;&amp; !pretreatmentService.onPretreatment(context, postcard)) &#123; return null; &#125; try &#123; //【--&gt;2.3.1】完善跳转信息； LogisticsCenter.completion(postcard); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); if (debuggable()) &#123; runInMainThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mContext, \"There's no route matched!\\n\" + \" Path = [\" + postcard.getPath() + \"]\\n\" + \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; if (null != callback) &#123; //【--&gt;2.4.2】完善跳转信息失败后会调用，通过 NavigationCallback 通知； callback.onLost(postcard); &#125; else &#123; //【2】这里的获取方式是一样的； DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class); if (null != degradeService) &#123; degradeService.onLost(context, postcard); &#125; &#125; return null; &#125; if (null != callback) &#123; //【--&gt;2.4.1】完善跳转信息成功后会调用，通过 NavigationCallback 通知； callback.onFound(postcard); &#125; //【3】对于 Service/Fragment 是会跳过拦截器的，对于 activity 默认是不会跳过的，当然了可动态设置； if (!postcard.isGreenChannel()) &#123; interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; //【--&gt;2.3.2】最终的处理； _navigation(context, postcard, requestCode, callback); &#125; @Override public void onInterrupt(Throwable exception) &#123; if (null != callback) &#123; //【--&gt;2.4.4】拦截器对跳转进行了拦截后会调用，通过 NavigationCallback 通知； callback.onInterrupt(postcard); &#125; logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage()); &#125; &#125;); &#125; else &#123; //【--&gt;2.3.2】最终的处理； return _navigation(context, postcard, requestCode, callback); &#125; return null;&#125; 2.3.1 LogisticsCenter.completion完善登陆信息，这里前面有说过： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public synchronized static void completion(Postcard postcard) &#123; if (null == postcard) &#123; throw new NoRouteFoundException(TAG + \"No postcard!\"); &#125; //【1】从 Warehouse.routes 中获取 path 对应的 RouteMeta 缓存数据； RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); //【2】如果找不到，那么就从 compiler 生成的数据中查找！ if (null == routeMeta) &#123; //【2.1】从 Warehouse.routes 中获取 group 对应的 group 类文件； Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup()); if (null == groupMeta) &#123; //【2.1.1】找不到抛出异常； throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\"); &#125; else &#123; try &#123; if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath())); &#125; //【2.1.2】创建 groupMeta 对应的实例； IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance(); //【2.1.3】调用其 loadInto 将 group 对应的信息加入到缓存 Warehouse.routes 中！ iGroupInstance.loadInto(Warehouse.routes); //【2.1.4】然后从 Warehouse.groupsIndex 删除这个组对应的信息； Warehouse.groupsIndex.remove(postcard.getGroup()); if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath())); &#125; &#125; catch (Exception e) &#123; throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\"); &#125; //【--&gt;2.3.1】重新加载； completion(postcard); &#125; &#125; else &#123; //【--&gt;2.3.1.1】这里是通过 RouteMeta 来设置 Postcard 对象，我们先不看； postcard.setDestination(routeMeta.getDestination()); postcard.setType(routeMeta.getType()); postcard.setPriority(routeMeta.getPriority()); postcard.setExtra(routeMeta.getExtra()); Uri rawUri = postcard.getUri(); if (null != rawUri) &#123; Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri); Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); if (MapUtils.isNotEmpty(paramsType)) &#123; for (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123; setValue(postcard, params.getValue(), params.getKey(), resultMap.get(params.getKey())); &#125; postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]&#123;&#125;)); &#125; postcard.withString(ARouter.RAW_URI, rawUri.toString()); &#125; //【4】这里是关键点，判断类型，可以看到 activity 这里是不处理的，主要是 IProvider 类型； switch (routeMeta.getType()) &#123; case PROVIDER: //【4.1】我们要获取的 Serivce，类型就是 PROVIDER，routeMeta.getDestination 返回的是要访问的目标类：service.class; Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); //【4.2】然后优先从 Warehouse.providers 缓存中获取； IProvider instance = Warehouse.providers.get(providerMeta); if (null == instance) &#123; IProvider provider; try &#123; //【4.3】创建 providerMeta 对应的实例，就是 Service 实例； provider = providerMeta.getConstructor().newInstance(); //【4.3.1】执行 init 方法； provider.init(mContext); //【4.3.2】然后将加入到 Warehouse.providers 中去； Warehouse.providers.put(providerMeta, provider); instance = provider; &#125; catch (Exception e) &#123; throw new HandlerException(\"Init provider failed! \" + e.getMessage()); &#125; &#125; //【5】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类； postcard.setProvider(instance); postcard.greenChannel(); //【6】跳过所有的拦截器！ break; case FRAGMENT: postcard.greenChannel(); // 跳过所有的拦截器！ default: break; &#125; &#125;&#125; 这里是 2.3.1.1 数据传递 - important这里我们要重点看下 PostCard 中的数据是如何处理的： 1234567891011121314151617181920212223242526postcard.setDestination(routeMeta.getDestination());postcard.setType(routeMeta.getType()); postcard.setPriority(routeMeta.getPriority());postcard.setExtra(routeMeta.getExtra());//【1】注意这里是处理 uri 的数据Uri rawUri = postcard.getUri();if (null != rawUri) &#123; //【--&gt;2.3.1.2】获得 uri 的数据； Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri); //【2】RouteMeta 的 paramsType 保存了被 @AutoWired 注解的参数和类型的枚举序号的映射关系； Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); if (MapUtils.isNotEmpty(paramsType)) &#123; for (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123; //【--&gt;2.3.1.3】将传递的数据设置到 Postcard 中，调用 Postcard.withXXX 方法； setValue(postcard, params.getValue(), // 变量类型的枚举序号； params.getKey(), // 变量名/注解name值 resultMap.get(params.getKey())); // uri 写到的变量的值； &#125; //【3】将被 @AutoWired 注解的变量的变量名/注解name值以 String[] 形式保存到 PostCard.Bundle 中； postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]&#123;&#125;)); &#125; //【4】将 uri 保存到 PostCard.Bundle 中， postcard.withString(ARouter.RAW_URI, rawUri.toString());&#125; 上面的两个常量的如下： 12public static final String RAW_URI = \"NTeRQWvye18AkPd6G\";public static final String AUTO_INJECT = \"wmHzgD4lOj5o4241\"; 2.3.1.2 TextUtils.splitQueryParameters将 uri 后缀保存的 key-value 的键值对转为 Map&lt;String, String&gt;： 12345678910111213141516171819202122232425262728293031public static Map&lt;String, String&gt; splitQueryParameters(Uri rawUri) &#123; String query = rawUri.getEncodedQuery(); if (query == null) &#123; return Collections.emptyMap(); &#125; Map&lt;String, String&gt; paramMap = new LinkedHashMap&lt;&gt;(); int start = 0; do &#123; int next = query.indexOf('&amp;', start); int end = (next == -1) ? query.length() : next; int separator = query.indexOf('=', start); if (separator &gt; end || separator == -1) &#123; separator = end; &#125; String name = query.substring(start, separator); if (!android.text.TextUtils.isEmpty(name)) &#123; String value = (separator == end ? \"\" : query.substring(separator + 1, end)); paramMap.put(Uri.decode(name), Uri.decode(value)); &#125; // Move start to end of name. start = end + 1; &#125; while (start &lt; query.length()); return Collections.unmodifiableMap(paramMap);&#125; 2.3.1.3 LogisticsCenter.setValue将传递的数据设置进入 Postcard 中！ 123456789101112131415161718192021222324252627282930313233343536373839private static void setValue(Postcard postcard, Integer typeDef, String key, String value) &#123; if (TextUtils.isEmpty(key) || TextUtils.isEmpty(value)) &#123; return; &#125; try &#123; if (null != typeDef) &#123; //【1】根据类型的枚举序号，匹配对应的 withXXX 方法，将值设置到内部的 Bundle 中！ if (typeDef == TypeKind.BOOLEAN.ordinal()) &#123; postcard.withBoolean(key, Boolean.parseBoolean(value)); &#125; else if (typeDef == TypeKind.BYTE.ordinal()) &#123; postcard.withByte(key, Byte.valueOf(value)); &#125; else if (typeDef == TypeKind.SHORT.ordinal()) &#123; postcard.withShort(key, Short.valueOf(value)); &#125; else if (typeDef == TypeKind.INT.ordinal()) &#123; postcard.withInt(key, Integer.valueOf(value)); &#125; else if (typeDef == TypeKind.LONG.ordinal()) &#123; postcard.withLong(key, Long.valueOf(value)); &#125; else if (typeDef == TypeKind.FLOAT.ordinal()) &#123; postcard.withFloat(key, Float.valueOf(value)); &#125; else if (typeDef == TypeKind.DOUBLE.ordinal()) &#123; postcard.withDouble(key, Double.valueOf(value)); &#125; else if (typeDef == TypeKind.STRING.ordinal()) &#123; postcard.withString(key, value); &#125; else if (typeDef == TypeKind.PARCELABLE.ordinal()) &#123; // TODO : How to description parcelable value with string? &#125; else if (typeDef == TypeKind.OBJECT.ordinal()) &#123; postcard.withString(key, value); &#125; else &#123; // Compatible compiler sdk 1.0.3, in that version, the string type = 18 postcard.withString(key, value); &#125; &#125; else &#123; postcard.withString(key, value); &#125; &#125; catch (Throwable ex) &#123; logger.warning(Consts.TAG, \"LogisticsCenter setValue failed! \" + ex.getMessage()); &#125;&#125; 方法很简单，不多说了！ 2.3.2 _ARouter._navigation可以看到，启动过的过程就是将 Postcard 中的数据设置到 intent 中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; final Context currentContext = null == context ? mContext : context; //【1】根据跳转类型处理不同的目标； switch (postcard.getType()) &#123; case ACTIVITY: //【1.1】创建 activity； final Intent intent = new Intent(currentContext, postcard.getDestination()); intent.putExtras(postcard.getExtras()); //【1.2】设置目标启动的 flags int flags = postcard.getFlags(); if (-1 != flags) &#123; intent.setFlags(flags); &#125; else if (!(currentContext instanceof Activity)) &#123; // Non activity, need less one flag. intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; //【1.3】设置 action！ String action = postcard.getAction(); if (!TextUtils.isEmpty(action)) &#123; intent.setAction(action); &#125; //【--&gt;2.3.2.1】执行启动； runInMainThread(new Runnable() &#123; @Override public void run() &#123; startActivity(requestCode, currentContext, intent, postcard, callback); &#125; &#125;); break; case PROVIDER: return postcard.getProvider(); // 这个是针对 Provider 的； case BOARDCAST: case CONTENT_PROVIDER: case FRAGMENT: //【1.4】针对于 brocastreceiver，contenprovider，fragment，会拿到其实例！ Class fragmentMeta = postcard.getDestination(); try &#123; Object instance = fragmentMeta.getConstructor().newInstance(); //【1.4.1】针对于 fragment，还会设置 Arguments； if (instance instanceof Fragment) &#123; ((Fragment) instance).setArguments(postcard.getExtras()); &#125; else if (instance instanceof android.support.v4.app.Fragment) &#123; ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras()); &#125; return instance; &#125; catch (Exception ex) &#123; logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace())); &#125; case METHOD: // 其他情况没有； case SERVICE: default: return null; &#125; return null;&#125; 针对于 brocastreceiver，contenprovider，fragment，会拿到其实例，针对于 fragment，还会设置 Arguments！ 2.3.2.1 _ARouter.startActivity这就是最后启动过程了，其实很简单： 123456789101112131415161718192021private void startActivity(int requestCode, Context currentContext, Intent intent, Postcard postcard, NavigationCallback callback) &#123; //【1】这里根据 requestCode 有不同的调用方式； if (requestCode &gt;= 0) &#123; // Need start for result if (currentContext instanceof Activity) &#123; ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle()); &#125; else &#123; logger.warning(Consts.TAG, \"Must use [navigation(activity, ...)] to support [startActivityForResult]\"); &#125; &#125; else &#123; ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle()); &#125; if ((-1 != postcard.getEnterAnim() &amp;&amp; -1 != postcard.getExitAnim()) &amp;&amp; currentContext instanceof Activity) &#123; // Old version. ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim()); &#125; if (null != callback) &#123; //【--&gt;2.4.3】启动完成，回调 NavigationCallback callback.onArrival(postcard); &#125;&#125; 不多说了！ 这里的 postcard.getOptionsBundle() 会返回一个 Bundle 是用来保存额外的启动参数，比如动画等等； 1234 private Bundle optionsCompat; public Bundle getOptionsBundle() &#123; return optionsCompat; &#125; 2.4 跳转回调我们看看 NavigationCallback 的相关接口： 12345678910111213public interface NavigationCallback &#123; //【--&gt;2.4.1】完善跳转信息成功后会调用； void onFound(Postcard postcard); //【--&gt;2.4.2】完善跳转信息失败后会调用； void onLost(Postcard postcard); //【--&gt;2.4.3】跳转成功后会回调； void onArrival(Postcard postcard); //【--&gt;2.4.4】拦截器对跳转进行了拦截后会调用； void onInterrupt(Postcard postcard);&#125; 3 总结到这里 ARouter 分析就暂告一段落了；","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"ARouter 第六篇 - 自动注入 (arouter-api)","slug":"ARouter6-autoInjectWithAutoWired-arouter-api","date":"2019-04-30T12:46:25.000Z","updated":"2019-08-13T15:35:34.960Z","comments":true,"path":"2019/04/30/ARouter6-autoInjectWithAutoWired-arouter-api/","link":"","permalink":"https://coolqi.top/2019/04/30/ARouter6-autoInjectWithAutoWired-arouter-api/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的架构和原理。 这是阿里 ARouter 开源库的地址，大家可以直接访问https://github.com/alibaba/ARouter 本篇博文主要分析 arouter-api 模块的自动注入原理！ 在阅读过程中，涉及到方法跳转的时候，注释上有 --&gt;的标志，这样的好处是，以类为单位，一次性分析其所有的方法： 1 自动注入我们在跳转的过程中，可能会传递一些数据，在原生的机制里面，我们是通过 Intent 来传递数据的： 12Intent intent = getIntent();intent.getXXXX(); 但是这需要我们手动的获取传递的值，ARouter 提供了一种更方便的方法：自动注入 12345678910@AutowiredString key1;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test1); ARouter.getInstance().inject(this);&#125; 想要实现自动注入，对于变量要通过 @Autowired 注解，同时要使用 ARouter.getInstance().inject(this) 方法关联变量； 其实自动注入依然是通过 intent 来传递值的 2 注解处理 - Autowired我们来回顾下对于 @Autowired 的处理。 12345@AutoService(Processor.class)@SupportedAnnotationTypes(&#123;ANNOTATION_TYPE_AUTOWIRED&#125;)public class AutowiredProcessor extends BaseProcessor &#123; ... ... ...&#125; @Autowired 注解是由 AutowiredProcessor 解析并处理，这里我们不再关注注解的处理了，ok？ 直接来看生成的类！ 2.1 动态生成类这里我们以 activity 为例子，下面我们一次性把所有可以自动注入的变量类型都加进来； 2.1.1 被注解的类 TestInjectActivity，用于接受 intent 传递的值； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Route(path = \"/test/TestInjectActivity\")public class TestInjectActivity extends Activity &#123; @Autowired(name = \"str1\") String str; // string @Autowired(name = \"bool1\") boolean bool; // boolean @Autowired(name = \"shortNum1\") short shortNum; // short @Autowired int intNum; // int @Autowired int[] intNumArray; //int[] @Autowired long longNum; // long @Autowired(name = \"charStr1\") char charStr; // char @Autowired(name = \"floatNum1\") float floatNum; // float @Autowired float[] floatNumArray; // float[] @Autowired(name = \"doubleNum\") double doubleNum; // double @Autowired(name = \"mapStr\") Map&lt;String, String&gt; mapStr; // map @Autowired List&lt;TestOne&gt; objList; @Autowired TestOne testOne; @Autowired() TestOneParcelable testOneParcelable; // Parcelable @Autowired() TestTwoParcelable TestTwoParcelable; // Serializable @Autowired(name = \"/test/TestHelloInterface\") HelloInterface helloInterface; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); // 自动注入； &#125; static class TestOneParcelable implements Parcelable &#123; // 实现了 Parcelable public String one; public static final Parcelable.Creator&lt;TestOneParcelable&gt; CREATOR = new Parcelable.Creator&lt;TestOneParcelable&gt;() &#123; @Override public TestOneParcelable createFromParcel(Parcel source) &#123; return null; &#125; @Override public TestOneParcelable[] newArray(int size) &#123; return new TestOneParcelable[0]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(one); &#125; &#125; class TestTwoParcelable implements Serializable &#123; // 实现了 Serializable public String one; &#125; class TestOne &#123; // 自定义的类 public String one; &#125; interface HelloInterface extends IProvider &#123; // 用于暴漏服务的接口 void sayHello(); &#125;&#125; 上面是一个 TestInjectActivity 定义了一些需要自动赋值的成员！ TestSerializationService：用于序列化自定义的类对象； 12345678910111213141516171819202122@Route(path = \"/test/TestSerializationService\")public class TestSerializationService implements SerializationService &#123; // 用于序列化自定义对象； @Override public &lt;T&gt; T json2Object(String input, Class&lt;T&gt; clazz) &#123; return null; &#125; @Override public String object2Json(Object instance) &#123; return null; &#125; @Override public &lt;T&gt; T parseObject(String input, Type clazz) &#123; return null; &#125; @Override public void init(Context context) &#123; &#125;&#125; TestHelloInterface：暴漏的服务，具体的实现。 1234567891011@Route(path = \"/Test/TestHelloInterface\")public class TestHelloInterface implements TestInjectActivity.HelloInterface &#123; // 用于实现具体的服务； @Override public void init(Context context) &#123; &#125; @Override public void sayHello() &#123; &#125;&#125; 上面是简单的例子！ 2.1.2 动态生成类我们去看看动态生成的类，动态生成的类所在的包名和自动注入的类的包名是一样的； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class TestInjectActivity$$ARouter$$Autowired implements ISyringe &#123; private SerializationService serializationService; @Override public void inject(Object target) &#123; //【1】获取序列化服务； serializationService = ARouter.getInstance().navigation(SerializationService.class); //【2】获取目标 activity TestInjectActivity substitute = (TestInjectActivity)target; //【3】通过 getIntent 来处理传递的数据； substitute.str = substitute.getIntent().getStringExtra(\"str1\"); substitute.bool = substitute.getIntent().getBooleanExtra(\"bool1\", substitute.bool); substitute.shortNum = substitute.getIntent().getShortExtra(\"shortNum1\", substitute.shortNum); substitute.intNum = substitute.getIntent().getIntExtra(\"intNum\", substitute.intNum); if (null != serializationService) &#123; substitute.intNumArray = serializationService.parseObject(substitute.getIntent().getStringExtra(\"intNumArray\"), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;int[]&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(\"ARouter::\", \"You want automatic inject the field 'intNumArray' in class 'TestInjectActivity' \" + \", then you should implement 'SerializationService' to support object auto inject!\"); &#125; substitute.longNum = substitute.getIntent().getLongExtra(\"longNum\", substitute.longNum); substitute.charStr = substitute.getIntent().getCharExtra(\"charStr1\", substitute.charStr); substitute.floatNum = substitute.getIntent().getFloatExtra(\"floatNum1\", substitute.floatNum); if (null != serializationService) &#123; substitute.floatNumArray = serializationService.parseObject(substitute.getIntent().getStringExtra(\"floatNumArray\"), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;float[]&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(\"ARouter::\", \"You want automatic inject the field 'floatNumArray' in class 'TestInjectActivity' \" + \", then you should implement 'SerializationService' to support object auto inject!\"); &#125; substitute.doubleNum = substitute.getIntent().getDoubleExtra(\"doubleNum\", substitute.doubleNum); if (null != serializationService) &#123; substitute.mapStr = serializationService.parseObject(substitute.getIntent().getStringExtra(\"mapStr\"), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;Map&lt;String, String&gt;&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(\"ARouter::\", \"You want automatic inject the field 'mapStr' in class 'TestInjectActivity' \" + \", then you should implement 'SerializationService' to support object auto inject!\"); &#125; if (null != serializationService) &#123; substitute.objList = serializationService.parseObject(substitute.getIntent().getStringExtra(\"objList\"), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;List&lt;TestInjectActivity.TestOne&gt;&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(\"ARouter::\", \"You want automatic inject the field 'objList' in class 'TestInjectActivity' \" + \", then you should implement 'SerializationService' to support object auto inject!\"); &#125; if (null != serializationService) &#123; substitute.testOne = serializationService.parseObject(substitute.getIntent().getStringExtra(\"testOne\"), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;TestInjectActivity.TestOne&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(\"ARouter::\", \"You want automatic inject the field 'testOne' in class 'TestInjectActivity' \" + \", then you should implement 'SerializationService' to support object auto inject!\"); &#125; substitute.testOneParcelable = substitute.getIntent().getParcelableExtra(\"testOneParcelable\"); if (null != serializationService) &#123; substitute.TestTwoParcelable = serializationService.parseObject(substitute.getIntent().getStringExtra(\"TestTwoParcelable\"), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;TestInjectActivity.TestTwoParcelable&gt;()&#123;&#125;.getType()); &#125; else &#123; Log.e(\"ARouter::\", \"You want automatic inject the field 'TestTwoParcelable' in class 'TestInjectActivity' \" + \", then you should implement 'SerializationService' to support object auto inject!\"); &#125; substitute.helloInterface = (TestInjectActivity.HelloInterface)ARouter.getInstance().build(\"/test/TestHelloInterface\").navigation();; &#125; 其实这个和之前分析注解解析的时候的模版类是一一对应的。 可以看到： 基本类型，直接通过 intent 的相关方法来处理； 数组，list，map，自定义类对象，都是通过序列化服务 serializationService 来处理的，也就是说要先将其转为 jsonString，然后保存到 intent 中； 这里我们就不看 AutoWired 的注解解析了，大家可以直接看前面的文章； 3 inject - 自动注入下面我们来分析下自动注入的流程： 1ARouter.getInstance().inject(this); // 自动注入； 这个是核心的方法！ 3.1 ARouter.inject1234public void inject(Object thiz) &#123; //【--&gt;3.2】进入 _ARouter _ARouter.inject(thiz);&#125; 3.2 _ARouter.inject12345678static void inject(Object thiz) &#123; //【1】返回 AutowiredServiceImpl 服务 AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build(\"/arouter/service/autowired\").navigation()); if (null != autowiredService) &#123; //【--&gt;3.3.1】通过 AutowiredServiceImpl 自动注入 autowiredService.autowire(thiz); &#125;&#125; “/arouter/service/autowired” 对应的 service 是 AutowiredServiceImpl，他是 ARouter 系统 Service，实现了 AutowiredService 接口！ 它和 InterceptorServiceImpl 的作用很类似，获取方式这里就不再分析了！ 3.3 AutowiredServiceImpl我们来看看 AutowiredServiceImpl 的属性： 1234@Route(path = \"/arouter/service/autowired\")public class AutowiredServiceImpl implements AutowiredService &#123; private LruCache&lt;String, ISyringe&gt; classCache; private List&lt;String&gt; blackList; 内部有一个 LruCache 缓存对象：key 是自动注入的类的全限定名（activity/fragment），value 是 activityName$$ARouter$$Autowired 的实例； 黑名单 blackList 用于保存哪些无法自动注入的类，value 是 自动注入的类的全限定名（activity/fragment； 3.3.1 autowire我们来看看他是如何处理的； 12345678910111213141516171819202122@Overridepublic void autowire(Object instance) &#123; //【1】获取自动注入的类的全限定名； String className = instance.getClass().getName(); try &#123; if (!blackList.contains(className)) &#123; //【2】判断是否已经添加到了 classCache 缓存中了； ISyringe autowiredHelper = classCache.get(className); if (null == autowiredHelper) &#123; //【3】没有的话就通过反射创建 ISyringe 的实例，其实就是我们解析 AutoWired 的时候生成的：TestInjectActivity$$ARouter$$Autowired // 这里会创建其实例； autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); &#125; //【4】调用其 inject 方法！ autowiredHelper.inject(instance); //【5】将其加入到缓存中； classCache.put(className, autowiredHelper); &#125; &#125; catch (Exception ex) &#123; blackList.add(className); // This instance need not autowired. &#125;&#125; SUFFIX_AUTOWIRED 定义在 Consts 中，值为：$$ARouter$$Autowired!! 这里只是用 TestInjectActivity$$ARouter$$Autowire举个例子，实际上这个类的类名、包名和具体的业务相关； 后面的逻辑就不多说了，大家去看 inject 方法，一幕了然！ 4 SerializationService我们来看看如何序列化： 12345678910111213141516171819202122@Route(path = \"/yourservicegroupname/json\")public class JsonServiceImpl implements SerializationService &#123; @Override public void init(Context context) &#123; &#125; @Override public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123; return JSON.parseObject(text, clazz); &#125; @Override public String object2Json(Object instance) &#123; return JSON.toJSONString(instance); &#125; @Override public &lt;T&gt; T parseObject(String input, Type clazz) &#123; // TestInjectActivity$$ARouter$$Autowired 使用的是这个方法； return JSON.parseObject(input, clazz); &#125;&#125; 我们需要自己实现一个 SerializationService，前面的动态生成类，使用了 parseObject 方法，将 jsonString 转为了 Object！ 5 总结本篇文章我们分析了 inject 的方法流程，但是我们遗留的下面的问题： ARouter 自动注入的值是如何传递的； 我们会在路由跳转中分析；","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"ARouter 第五篇 - 服务和拦截器 (arouter-api)","slug":"ARouter5-ServiceAndIntecerptor-arouter-api","date":"2019-04-25T12:46:25.000Z","updated":"2019-08-09T13:23:53.716Z","comments":true,"path":"2019/04/25/ARouter5-ServiceAndIntecerptor-arouter-api/","link":"","permalink":"https://coolqi.top/2019/04/25/ARouter5-ServiceAndIntecerptor-arouter-api/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的架构和原理。 这是阿里 ARouter 开源库的地址，大家可以直接访问 https://github.com/alibaba/ARouter 本篇博文主要分析 arouter-api 模块，该模块涉及到 ARouter 一些核心逻辑：初始化，跳转，拦截，服务等，下面的几篇文章就要从这几个方向来分析； 在阅读过程中，涉及到方法跳转的时候，注释上有 --&gt;的标志，这样的好处是，以类为单位，一次性分析其所有的方法！ 1 开篇这篇文章分析下 ARouter 的 Service 和 Interceptor，二者有如下的区别： 1.1 实现接口不同 Service 直接或者间接的实现了 IProvider 接口： 123public interface IProvider &#123; void init(Context context);&#125; Interceptor 直接或者间接的实现了 IInterceptor 接口： 123public interface IInterceptor extends IProvider &#123; void process(Postcard postcard, InterceptorCallback callback);&#125; 1.2 注解不同 Service 使用 @Route 注解处理： 123@Route(path = \"/yourservicegroupname/single\")public class SingleService implements IProvider &#123;&#125; Interceptor 使用 @Interceptor 注解处理： 123@Interceptor(priority = 7)public class Test1Interceptor implements IInterceptor &#123;&#125; 1.3 逻辑处理不同 拦截器会在 ARouter 初始化 init 的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。- 这个下面可以看到，内部有一个同步锁来控制； 服务没有该限制，某一服务可能在 App 整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作； 1 服务 Service1.1 服务统一接口ARouter 已经帮我们提供了一些 Service 统一接口，对于对内对外提供特定的功能模版： 1234567-rwxr-xr-x 1 lishuaiqi820 235765416 468 May 8 20:46 AutowiredService.java-rwxr-xr-x 1 lishuaiqi820 235765416 424 May 8 20:46 ClassLoaderService.java-rwxr-xr-x 1 lishuaiqi820 235765416 590 May 8 20:46 DegradeService.java-rwxr-xr-x 1 lishuaiqi820 235765416 575 May 8 20:46 InterceptorService.java-rwxr-xr-x 1 lishuaiqi820 235765416 555 May 8 20:46 PathReplaceService.java-rwxr-xr-x 1 lishuaiqi820 235765416 656 May 8 20:46 PretreatmentService.java-rwxr-xr-x 1 lishuaiqi820 235765416 974 May 8 20:46 SerializationService.java AutowiredService：用于处理 Autowired 注解的变量的 Service，ARouter 内置了一个 AutowiredServiceImpl 实现了 AutowiredService，我们在分析 inject 的时候，再讲； ClassLoaderService：针对于 installrun 的 Service； DegradeService：用于在跳转不成功的情况下，做降级处理； InterceptorService：用于处理 Interceptor 的 Service，ARouter 内置了一个 InterceptorServiceImpl 实现了 InterceptorService，用于初始化所有的 Interceptor 和处理拦截，我们下面分析； PathReplaceService：用于对路由的 path 做预处理； PretreatmentService；用于在跳转之前做预处理操作； SerializationService：用于序列化 Object 对象，和 Autowired 注解配合使用，我们在分析 inject 的时候，再讲； 1.2 获取服务ARouter 是通过路由跳转的方式获取服务的，我们来回顾 init 的流程： 获取拦截器处理服务： 1PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); 获取拦截器处理服务： 1interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation(); 之前在分析 init 的过程中，我们又遇到好几个获取 Service 的地方，上面是举了其中几个栗子！ 获取序列化服务： 1serializationService = ARouter.getInstance().navigation(SerializationService.class); 上面的代码是在处理 @Autowired 注解的时候，也就是 arouter complier 编译的时候处理的，用于传递自定义的对象； 1.3 获取流程分析通过上面可以知道，获取一个 Service 的方法有两种： 123ARouter.getInstance().navigation(xxxx.class);ARouter.getInstance().build(path).navigation(); 下面我们会分析下这两种方式的流程！ 有些代码在前面的路由处理过程中分析了，这里不会再重复分析。 1.3.1 navigation(className.class)第一种方式是传入 Service 的父类，我们回顾下调用链： 123456ARouter.getInstance().navigation(service.class); _ARouter.getInstance().navigation(service); Postcard postcard = LogisticsCenter.buildProvider(service.getName()); Postcard postcard = Warehouse.providersIndex.get(serviceName); LogisticsCenter.completion(postcard); _ARouter.getInstance()._navigation(...); 上面这部分的调用过程实际上，我们在路由初始化的时候见到过！ 这里我们只看核心的逻辑，省略掉一些奇葩的 1.3.1.1 _ARouter.navigation我回顾下 _ARouter.navigation 方法； 12345678910111213141516171819202122232425protected &lt;T&gt; T navigation(Class&lt;? extends T&gt; service) &#123; try &#123; //【--&gt;1.3.1.2】通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例 // service.getName() 返回的是全限定名； Postcard postcard = LogisticsCenter.buildProvider(service.getName()); //【1】如果是 null，说明使用的是旧版本的 compiler sdk，早期的 compiler 不使用全限定名区获取服务； if (null == postcard) &#123; //【--&gt;1.3.1.2】通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例 postcard = LogisticsCenter.buildProvider(service.getSimpleName()); &#125; if (null == postcard) &#123; return null; &#125; //【--&gt;1.3.1.3】完成跳转！ LogisticsCenter.completion(postcard); //【2】获取 Serivce； return (T) postcard.getProvider(); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); return null; &#125;&#125; 这里的核心处理： LogisticsCenter.buildProvider LogisticsCenter.completion 1.3.1.2 LogisticsCenter.buildProvider1234567891011public static Postcard buildProvider(String serviceName) &#123; //【1】我们知道 service 实现了 IProvider 实例，所以保存在了 Warehouse.providersIndex 中！ RouteMeta meta = Warehouse.providersIndex.get(serviceName); if (null == meta) &#123; return null; &#125; else &#123; //【2】创建路由跳转信息； return new Postcard(meta.getPath(), meta.getGroup()); &#125;&#125; 这里的 Warehouse.providersIndex 保存的是如下的数据： 12providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, MySerializationService.class, \"/coolqiService/MySerializationService\", \"coolqiService\", null, -1, -2147483648)); 1.3.1.3 LogisticsCenter.completion1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public synchronized static void completion(Postcard postcard) &#123; if (null == postcard) &#123; throw new NoRouteFoundException(TAG + \"No postcard!\"); &#125; //【1】从 Warehouse.routes 中获取 path 对应的 RouteMeta 缓存数据； RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); //【2】如果找不到，那么就从 compiler 生成的数据中查找！ if (null == routeMeta) &#123; //【2.1】从 Warehouse.routes 中获取 group 对应的 group 类文件； Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup()); if (null == groupMeta) &#123; // 【2.1.1】找不到抛出异常； throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\"); &#125; else &#123; try &#123; if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath())); &#125; //【2.1.2】创建 groupMeta 对应的实例； IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance(); //【2.1.3】调用其 loadInto 将 group 对应的信息加入到缓存 Warehouse.routes 中！ iGroupInstance.loadInto(Warehouse.routes); //【2.1.4】然后从 Warehouse.groupsIndex 删除这个组对应的信息； Warehouse.groupsIndex.remove(postcard.getGroup()); if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath())); &#125; &#125; catch (Exception e) &#123; throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\"); &#125; //【--&gt;1.3.1.3】重新加载； completion(postcard); &#125; &#125; else &#123; //【3】这里是通过 RouteMeta 来设置 Postcard 对象，我们先不看； postcard.setDestination(routeMeta.getDestination()); postcard.setType(routeMeta.getType()); postcard.setPriority(routeMeta.getPriority()); postcard.setExtra(routeMeta.getExtra()); Uri rawUri = postcard.getUri(); if (null != rawUri) &#123; Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri); Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); if (MapUtils.isNotEmpty(paramsType)) &#123; for (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123; setValue(postcard, params.getValue(), params.getKey(), resultMap.get(params.getKey())); &#125; postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]&#123;&#125;)); &#125; postcard.withString(ARouter.RAW_URI, rawUri.toString()); &#125; //【4】这里是关键点，判断类型，可以看到 activity 这里是不处理的！； switch (routeMeta.getType()) &#123; case PROVIDER: //【4.1】我们要获取的 Serivce，类型就是 PROVIDER，routeMeta.getDestination 返回的是要访问的目标类：service.class; Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); //【4.2】然后优先从 Warehouse.providers 缓存中获取； IProvider instance = Warehouse.providers.get(providerMeta); if (null == instance) &#123; IProvider provider; try &#123; //【4.3】创建 providerMeta 对应的实例，就是 Service 实例； provider = providerMeta.getConstructor().newInstance(); //【4.3.1】执行 init 方法； provider.init(mContext); //【4.3.2】然后将加入到 Warehouse.providers 中去； Warehouse.providers.put(providerMeta, provider); instance = provider; &#125; catch (Exception e) &#123; throw new HandlerException(\"Init provider failed! \" + e.getMessage()); &#125; &#125; //【5】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类； postcard.setProvider(instance); postcard.greenChannel(); //【6】跳过所有的拦截器！ break; case FRAGMENT: postcard.greenChannel(); // 跳过所有的拦截器！ default: break; &#125; &#125;&#125; 这里有所谓的 “按组加载” 可以看到，最后获取了 Service，并调用了其 init 方法； 最后将获得的 Service 保存到了 Postcard 中； 1.3.2 build(path).navigation()第二种方式是通过 path 来查找 Service，我们回顾下调用链： 1234567ARouter.getInstance().build(path).navigation() Postcard postcard = _ARouter.getInstance().build(path) Object object = Postcard.navigation(); Object object = ARouter.getInstance().navigation(context, this, -1, callback) Object object = _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback) LogisticsCenter.completion(postcard); Object object = _ARouter.getInstance()._navigation(...); 上面这部分的调用过程实际上，我们在路由初始化的时候见到过！ 这里我们只看核心的逻辑，省略掉一些非核心的代码； 1.3.2.1 _ARouter.navigation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; //【1】这里的获取方式是一样的； PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class); if (null != pretreatmentService &amp;&amp; !pretreatmentService.onPretreatment(context, postcard)) &#123; return null; &#125; try &#123; //【--&gt;1.3.1.3】完善跳转信息！ LogisticsCenter.completion(postcard); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); if (debuggable()) &#123; runInMainThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mContext, \"There's no route matched!\\n\" + \" Path = [\" + postcard.getPath() + \"]\\n\" + \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; if (null != callback) &#123; callback.onLost(postcard); &#125; else &#123; //【2】这里的获取方式是一样的； DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class); if (null != degradeService) &#123; degradeService.onLost(context, postcard); &#125; &#125; return null; &#125; if (null != callback) &#123; callback.onFound(postcard); &#125; //【3】对于 Service 是会跳过拦截器的； if (!postcard.isGreenChannel()) &#123; interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; //【--&gt;1.3.2.2】最终的处理； _navigation(context, postcard, requestCode, callback); &#125; @Override public void onInterrupt(Throwable exception) &#123; if (null != callback) &#123; callback.onInterrupt(postcard); &#125; logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage()); &#125; &#125;); &#125; else &#123; //【--&gt;1.3.2.2】最终的处理； return _navigation(context, postcard, requestCode, callback); &#125; return null;&#125; 1.3.2.4 _ARouter._navigation最终处理： 12345678910111213141516171819202122private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; final Context currentContext = null == context ? mContext : context; switch (postcard.getType()) &#123; case ACTIVITY: ... ... ... break; case PROVIDER: //【1】返回了 iprovider 实例，就是我们的 Service 对象； return postcard.getProvider(); case BOARDCAST: case CONTENT_PROVIDER: case FRAGMENT: ... ... ... case METHOD: case SERVICE: default: return null; &#125; return null;&#125; 就这样，我们获得了 Service 对象！ 1.4 内置服务我们来看看内置服务接口！ 对与 AutowiredService，InterceptorService，SerializationService 我们后面会分析，这里就不重点分析了，累！ 1.4.1 DegradeService降级服务，当跳转失败后，可以在这里做处理： 1234public interface DegradeService extends IProvider &#123; void onLost(Context context, Postcard postcard);&#125; 1.4.2 PathReplaceService路径 path 替换服务，我们可以在启动跳转之前，对 path 进行拦截，替换新的 path： 1234public interface PathReplaceService extends IProvider &#123; String forString(String path); Uri forUri(Uri uri);&#125; 可以针对 path 和 uri 两种方式！ 1.4.3 PretreatmentService跳转预处理服务，我们可以在启动跳转之前，针对跳转路由数据做预处理： 1234public interface PathReplaceService extends IProvider &#123; String forString(String path); Uri forUri(Uri uri);&#125; 可以针对 path 和 uri 两种方式！ 2 拦截器 Interceptor2.1 InterceptorServiceImpl - 统一管理拦截器在 ARouter 框架里面，有一个 InterceptorServiceImpl 服务，用于统一管理 Interceptor： 123static void afterInit() &#123; interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();&#125; 这里我们就不多说了，这个是获取拦截器管理服务的方式，流程上面分析了； 2.2 初始化 InterceptorInterceptor 的初始化由 InterceptorServiceImpl 完成， 核心的逻辑在 LogisticsCenter.completion 中！ 2.2.1 LogisticsCenter.completion这里我们省略掉无关的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public synchronized static void completion(Postcard postcard) &#123; if (null == postcard) &#123; throw new NoRouteFoundException(TAG + \"No postcard!\"); &#125; RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); if (null == routeMeta) &#123; ... ... ... &#125; else &#123; ... ... ... //【1】这里是关键点，判断类型，可以看到 activity 这里是不处理的！； switch (routeMeta.getType()) &#123; case PROVIDER: //【2.1】我们要获取的 InterceptorServiceImpl，类型就是 PROVIDER，routeMeta.getDestination 返回的是要访问的目标类：InterceptorServiceImpl.class; Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); //【1.2】然后优先从 Warehouse.providers 缓存中获取； IProvider instance = Warehouse.providers.get(providerMeta); if (null == instance) &#123; IProvider provider; try &#123; //【1.2.1】创建 providerMeta 对应的实例，就是 InterceptorServiceImpl； provider = providerMeta.getConstructor().newInstance(); //【---&gt;2.2.2】执行 init 方法； provider.init(mContext); //【1.2.2】然后将加入到 Warehouse.providers 中去； Warehouse.providers.put(providerMeta, provider); instance = provider; &#125; catch (Exception e) &#123; throw new HandlerException(\"Init provider failed! \" + e.getMessage()); &#125; &#125; //【1.2.3】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类； postcard.setProvider(instance); postcard.greenChannel(); //【1.2.4】跳过所有的拦截器！ break; case FRAGMENT: postcard.greenChannel(); // 跳过所有的拦截器！ default: break; &#125; &#125;&#125; 回顾： 我们知道在路由初始化的过程中，afterInit 会获得 InterceptorServiceImpl 方法并执行其 init 的初始化操作！ 2.2.2 InterceptorServiceImpl.init在 InterceptorServiceImpl 的 init 方法中，会获取所有的 Interceptor，并对其做初始化操作； 123456789101112131415161718192021222324252627282930313233@Overridepublic void init(final Context context) &#123; //【1】这里是在由线程池管理的子线程中执行 init 操作； LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123; //【1】从 Warehouse.interceptorsIndex 获取所有注解生成的拦截器； for (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123; Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue(); try &#123; //【2】创建 interceptors 实例，并执行 init 初始化； IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance(); iInterceptor.init(context); //【3】将其加入到缓存 Warehouse.interceptors Warehouse.interceptors.add(iInterceptor); &#125; catch (Exception ex) &#123; throw new HandlerException(TAG + \"ARouter init interceptor error! name = [\" + interceptorClass.getName() + \"], reason = [\" + ex.getMessage() + \"]\"); &#125; &#125; interceptorHasInit = true; //【4】init 状态设置为 true； logger.info(TAG, \"ARouter interceptors init over.\"); synchronized (interceptorInitLock) &#123; //【5】当 init 操作完成后 notifyAll 通知等待 init 的线程； interceptorInitLock.notifyAll(); &#125; &#125; &#125; &#125;);&#125; 这里是在由线程池管理的字现场中执行 init 操作！ 注意，这里有一个同步锁，如果在路由的时候，发现 interceptorHasInit 为 false，那么会调用 interceptorInitLock.wait 进入阻塞状态，等待初始化完成，被 notifyAll 唤醒！ 2.3 拦截操作我们来看看拦截操作是如何做的，核心代码在 _ARouter.navigation 中： 2.3.1 _ARouter.navigation我们只关注核心的逻辑： 1234567891011121314151617181920212223242526272829303132protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; ... ... ... if (null != callback) &#123; callback.onFound(postcard); &#125; //【1】如果跳转不能避开所有的拦截器，那么就要在这里处理，我们知道 Fragment 和 IProvider 的子类是会避开拦截器的！ if (!postcard.isGreenChannel()) &#123; //【--&gt;2.3.2】这一部分设计拦截器功能，我们在跳转那一篇再分析； interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123; //【--&gt;2.3.1.1】处理拦截结果； @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; @Override public void onInterrupt(Throwable exception) &#123; if (null != callback) &#123; callback.onInterrupt(postcard); &#125; logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage()); &#125; &#125;); &#125; else &#123; //【--&gt;3.2.7】最终的处理； return _navigation(context, postcard, requestCode, callback); &#125; return null;&#125; 我们看到，这里传入了一个拦截结果回调： 2.3.1.1 InterceptorCallback位于 callback 包下： 1234public interface InterceptorCallback &#123; void onContinue(Postcard postcard); void onInterrupt(Throwable exception);&#125; 2.3.2 InterceptorServiceImpl.doInterceptions当我们路由跳转时，如果指定了 Interceptor，那么就要执行拦截操作： 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void doInterceptions(final Postcard postcard, final InterceptorCallback callback) &#123; if (null != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; 0) &#123; //【--&gt;2.3.2.1】判断下 init 操作是否完成； checkInterceptorsInitStatus(); if (!interceptorHasInit) &#123; callback.onInterrupt(new HandlerException(\"Interceptors initialization takes too much time.\")); return; &#125; //【1】这里是在由线程池管理的子线程中执行 init 操作； LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; //【2】创建了一个 CountDownLatch 对象，这个对象以 Warehouse.interceptors 的 size 为计数基准； // 没处理一个 inteceptor，计数减一，知道计数为 0，才会释放持有的锁！； CancelableCountDownLatch interceptorCounter = new CancelableCountDownLatch(Warehouse.interceptors.size()); try &#123; //【--&gt;2.3.2.2】执行拦截操作！ _excute(0, interceptorCounter, postcard); //【3】调用 await，子线程进入等待中； interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS); //【4】拦截器处理完成（CountDownLatch 计数归 0），或者 await 超时退出； if (interceptorCounter.getCount() &gt; 0) &#123; // Cancel the navigation this time, if it hasn't return anythings. callback.onInterrupt(new HandlerException(\"The interceptor processing timed out.\")); &#125; else if (null != postcard.getTag()) &#123; // Maybe some exception in the tag. callback.onInterrupt(new HandlerException(postcard.getTag().toString())); &#125; else &#123; callback.onContinue(postcard); &#125; &#125; catch (Exception e) &#123; callback.onInterrupt(e); &#125; &#125; &#125;); &#125; else &#123; callback.onContinue(postcard); &#125;&#125; 这里其实可以看出，拦截器使用了责任链模式！ 这里有一个新的类型：CancelableCountDownLatch，其实就是一个 CountDownLatch，代码很简单，不多说了！ 2.3.2.1 checkInterceptorsInitStatus判断是否初始化完成： 12345678910111213private static void checkInterceptorsInitStatus() &#123; synchronized (interceptorInitLock) &#123; //【1】主要是判断 interceptorHasInit 是否为 true！ while (!interceptorHasInit) &#123; try &#123; //【1】进入等待状态，超时时间是 10s！ interceptorInitLock.wait(10 * 1000); &#125; catch (InterruptedException e) &#123; throw new HandlerException(TAG + \"Interceptor init cost too much time error! reason = [\" + e.getMessage() + \"]\"); &#125; &#125; &#125;&#125; interceptorInitLock 是 InterceptorServiceImpl 内部的一个锁对象； 2.3.2.2 _excuteindex 的值为 0，开始执行拦截： 1234567891011121314151617181920212223242526272829 private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) &#123; if (index &lt; Warehouse.interceptors.size()) &#123; //【1】获得 index 对应的拦截器； IInterceptor iInterceptor = Warehouse.interceptors.get(index); //【2】执行拦截器的 process 方法，同时传入一个回调：【--&gt;2.3.1.1】InterceptorCallback iInterceptor.process(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; //【2.1】不拦截，CountDownLatch 计数减去 1； counter.countDown(); //【--&gt;2.3.2.2】继续调用 _excute 方法，index 加一，下一个拦截器； _excute(index + 1, counter, postcard); // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know. &#125; @Override public void onInterrupt(Throwable exception) &#123; //【2.2】拦截，CountDownLatch 计数归 0； postcard.setTag(null == exception ? new HandlerException(\"No message.\") : exception.getMessage()); // save the exception message for backup. counter.cancel(); // Be attention, maybe the thread in callback has been changed, // then the catch block(L207) will be invalid. // The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!// if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123; // You shouldn't throw the exception if the thread is main thread.// throw new HandlerException(exception.getMessage());// &#125; &#125; &#125;); &#125; &#125; 整个过程很简单，不多说了。 3 线程池刚刚我们有看到，拦截器的初始化和拦截都是在子线程中做的，ARouter 通过内部的一个线程池来管理： 12DefaultPoolExecutor.java // 线程池DefaultThreadFactory.java // 线程工厂 3.1 线程池初始化123456789final class _ARouter &#123; static ILogger logger = new DefaultLogger(Consts.TAG); private volatile static boolean monitorMode = false; private volatile static boolean debuggable = false; private volatile static boolean autoInject = false; private volatile static _ARouter instance = null; private volatile static boolean hasInit = false; //【1】DefaultPoolExecutor 是 _ARouter 的静态变量； private volatile static ThreadPoolExecutor executor = DefaultPoolExecutor.getInstance(); 然后再初始化 LogisticsCenter 的时候传递给了 LogisticsCenter； 3.2 DefaultPoolExecutor我们来看下线程池的构造，这里要重点看看线程池的核心参数： 3.2.1 getInstance单例模式： 1234567891011121314151617public static DefaultPoolExecutor getInstance() &#123; if (null == instance) &#123; synchronized (DefaultPoolExecutor.class) &#123; if (null == instance) &#123; //【--&gt;3.2.2】创建线程池； instance = new DefaultPoolExecutor( INIT_THREAD_COUNT, MAX_THREAD_COUNT, SURPLUS_THREAD_LIFE, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(64), new DefaultThreadFactory()); &#125; &#125; &#125; return instance;&#125; 3.2.2 new DefaultPoolExecutor我们来研究下 DefaultPoolExecutor 的一些核心参数： 123456789private DefaultPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, new RejectedExecutionHandler() &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; ARouter.logger.error(Consts.TAG, \"Task rejected, too many task!\"); &#125; &#125;); &#125; 这里涉及到了 DefaultPoolExecutor 内部的常量： 1234private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); // Java 虚拟机的可用的处理器数量；private static final int INIT_THREAD_COUNT = CPU_COUNT + 1; // 核心线程数private static final int MAX_THREAD_COUNT = INIT_THREAD_COUNT; // 最大线程数；private static final long SURPLUS_THREAD_LIFE = 30L; // 空闲线程在 可以看到，线程池的参数如下： corePoolSize：核心线程数是可用的处理器数量 + 1； maximumPoolSize：最大线程数是可用的处理器数量； keepAliveTime：空闲线程存活时间：30s； workQueue：阻塞队列是 ArrayBlockingQueue，数组实现的阻塞队列，有界 64； threadFactory：线程工厂类，自定义的 DefaultThreadFactory 类； RejectedExecutionHandler：线程池在无法处理添加的 runnnable 时的处理机制，这里是自定义了一个 RejectedExecutionHandler，只是打印了一个 Log； 3.3 DefaultThreadFactoryARouter 内部自定义的线程工厂类，DefaultThreadFactory 需要实现 ThreadFactory 接口； 1234567public DefaultThreadFactory() &#123; //【1】这里通过 SecurityManager 来设置 thread 的 group； SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"ARouter task pool No.\" + poolNumber.getAndIncrement() + \", thread No.\";&#125; 我们来看看 newThread 方法： 123456789101112131415161718192021public Thread newThread(@NonNull Runnable runnable) &#123; String threadName = namePrefix + threadNumber.getAndIncrement(); ARouter.logger.info(Consts.TAG, \"Thread production, name is [\" + threadName + \"]\"); //【1】创建线程，一个线程对应一个 runnable； Thread thread = new Thread(group, runnable, threadName, 0); if (thread.isDaemon()) &#123; //【2】设为非后台线程 thread.setDaemon(false); &#125; if (thread.getPriority() != Thread.NORM_PRIORITY) &#123; // 【2】优先级为 normal thread.setPriority(Thread.NORM_PRIORITY); &#125; //【3】捕获多线程处理中的异常 thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread thread, Throwable ex) &#123; ARouter.logger.info(Consts.TAG, \"Running task appeared exception! Thread [\" + thread.getName() + \"], because [\" + ex.getMessage() + \"]\"); &#125; &#125;); return thread;&#125; 不多说了！ 4 总结本篇文章分析了 ARouter 的服务和拦截器的相关机制 拦截器的初始化和拦截操作都是在子线程中处理的，拦截器使用了责任链模式； 子线程通过线程池管理，采用了单例模式； 拦截器是使用了责任链模式，通过它使用 CountDownLatch 来实现了路由等待的操作； 但是遗留了几个问题： AutowiredService 和 AutowiredServiceImpl 是如何工作的； ClassLoaderService 是如何工作的； 我们下次再说～～～","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"ARouter 第四篇 - 路由初始化 (arouter-api)","slug":"ARouter4-arouterInitCreate-arouter-api","date":"2019-04-23T12:46:25.000Z","updated":"2019-08-09T13:24:46.859Z","comments":true,"path":"2019/04/23/ARouter4-arouterInitCreate-arouter-api/","link":"","permalink":"https://coolqi.top/2019/04/23/ARouter4-arouterInitCreate-arouter-api/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的架构和原理。 这是阿里 ARouter 开源库的地址，大家可以直接访问 https://github.com/alibaba/ARouter 本篇博文主要分析 arouter-api 模块，该模块涉及到 ARouter 一些核心逻辑：初始化，跳转，拦截，服务等，下面的几篇文章就要从这几个方向来分析； 绘图工具：PlantXML 在阅读过程中，涉及到方法跳转的时候，注释上有 --&gt;的标志，这样的好处是，以类为单位，一次性分析其所有的方法： 1 模块结构我们先来看看模块结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455└── com └── alibaba └── android └── arouter ├── base │ └── UniqueKeyTreeMap.java ├── core │ ├── AutowiredLifecycleCallback.java │ ├── AutowiredServiceImpl.java │ ├── InstrumentationHook.java │ ├── InterceptorServiceImpl.java │ ├── LogisticsCenter.java │ └── Warehouse.java ├── exception │ ├── HandlerException.java │ ├── InitException.java │ └── NoRouteFoundException.java ├── facade │ ├── Postcard.java │ ├── callback │ │ ├── InterceptorCallback.java │ │ ├── NavCallback.java │ │ └── NavigationCallback.java │ ├── service │ │ ├── AutowiredService.java │ │ ├── ClassLoaderService.java │ │ ├── DegradeService.java │ │ ├── InterceptorService.java │ │ ├── PathReplaceService.java │ │ ├── PretreatmentService.java │ │ └── SerializationService.java │ └── template │ ├── IInterceptor.java │ ├── IInterceptorGroup.java │ ├── ILogger.java │ ├── IPolicy.java │ ├── IProvider.java │ ├── IProviderGroup.java │ ├── IRouteGroup.java │ ├── IRouteRoot.java │ └── ISyringe.java ├── launcher │ ├── ARouter.java │ └── _ARouter.java ├── thread │ ├── CancelableCountDownLatch.java │ ├── DefaultPoolExecutor.java │ └── DefaultThreadFactory.java └── utils ├── ClassUtils.java ├── Consts.java ├── DefaultLogger.java ├── MapUtils.java ├── PackageUtils.java └── TextUtils.java 可以看到，有如下的 package： base：数据缓存类，内部提供了一个 treeMap 实现，用于存储 intercepter； core：核心类，ARouter的核心功能都在这里实现； exception：异常相关，主要是定义了内部的一些异常； facade：通过外观模式对外提供统一的接口，下面有三个子包： callback：提供回调接口，以及默认的回调处理； service：ARouter 内部已经实现的一些 Service，对外提供拦截等功能； template：包含模版，提供了大量的模版接口，可以通过实现接口，配合注解，实现自定义的功能； launcher：ARouter 的入口； thread：线程操作类； utils：提供多个工具类 2 初始化方法我们在使用时，必须要做初始化： 123456//这两行必须写在 init 之前，否则这些配置在 init 过程中将无效； //【1】打印日志；ARouter.openLog();//【2】开启调试模式（如果在 InstantRun 模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险）；ARouter.openDebug();ARouter.init(mApplication); // 尽可能早，推荐在 Application 中初始化； 接下来，我们来看看 init 的过程： 3 Launcher 包3.1 ARouterARouter 是整个库的入口！ 3.1.1 成员变量1234567// Key of raw uripublic static final String RAW_URI = \"NTeRQWvye18AkPd6G\";public static final String AUTO_INJECT = \"wmHzgD4lOj5o4241\";private volatile static ARouter instance = null;private volatile static boolean hasInit = false;public static ILogger logger; 3.1.2 init我们来看看 init 初始化的方法： 1234567891011121314public static void init(Application application) &#123; if (!hasInit) &#123; logger = _ARouter.logger; _ARouter.logger.info(Consts.TAG, \"ARouter init start.\"); //【--&gt;3.2.2】执行初始化； hasInit = _ARouter.init(application); if (hasInit) &#123; //【--&gt;3.2.3】执行初始化后面的操作； _ARouter.afterInit(); &#125; _ARouter.logger.info(Consts.TAG, \"ARouter init over.\"); &#125;&#125; 3.1.3 getInstance获得 ARouter 的实例（单例模式）： 123456789101112131415public static ARouter getInstance() &#123; if (!hasInit) &#123; throw new InitException(\"ARouter::Init::Invoke init(context) first!\"); &#125; else &#123; if (instance == null) &#123; synchronized (ARouter.class) &#123; if (instance == null) &#123; //【1】ARouter 的构造器方法体是空的； instance = new ARouter(); &#125; &#125; &#125; return instance; &#125;&#125; 这里使用了单例模式创建：ARouter ！ 3.1.4 buildafterInit 方法中传入了 “/arouter/service/interceptor” 参数，创建跳转信息！ 123456public Postcard build(String path) &#123; // Route.path //【--&gt;3.2.4】返回 _ARouter 的实例 //【--&gt;3.2.5】创建跳转信息； return _ARouter.getInstance().build(path);&#125;... ... ...// 先不关注其他的方法； ARouter 提供了下面的多个方法用于创建跳转信息： Postcard build(String path): 指定 Route.path，跳转/初始化都会使用到该方法； Postcard build(String path, String group)：指定 Route.path, Route.group，跳转时使用； Postcard build(Uri url)：指定 uri，uri 需要在说明书中设置； 这里我们先关注 init 过程中调用的！ 可以看到，最后调用的是 _ARouter 的方法，注意这个方法返回的是： Postcard：继承了 RouteMeta，用于封装跳转信息； 3.1.5 navigation执行跳转： 123456789public &lt;T&gt; T navigation(Class&lt;? extends T&gt; service) &#123; //【--&gt;3.2.6】通过跳转，返回服务对象； return _ARouter.getInstance().navigation(service);&#125;public Object navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback) &#123; //【--&gt;3.2.6】执行跳转，这也是真正的跳转接口； return _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);&#125; ARouter 提供了 2 个跳转接口： navigation(Class&lt;? extends T&gt; service): 用于获取泛型指定的 Service，实际上并不是跳转接口； navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback)：这个才是真正的跳转接口！ 这篇博文先不讲 navigation，我们分析初始化 init 的过程： interceptorService = (InterceptorService) ARouter.getInstance().build(&quot;/arouter/service/interceptor&quot;).navigation(); 在执行 afterInit 的时候，会通过 navigation 方法返回 InterceptorServiceIpml 实例，这个方法我们跟踪了代码，调的是第二个 navigation 方法； PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); 而在获得 InterceptorService 实例的时候，会先调用 build 方法，获得 PathReplaceService 实例，这里就是第一个 navigation 方法，但是这里我们不分析它； 实际上 PathReplaceService 和 InterceptorServiceImpl 的获取方式是一样的！ 3.2 _ARouter3.2.1 成员变量下面是 _ARouter 的成员属性： 1234567891011static ILogger logger = new DefaultLogger(Consts.TAG); // Log 系统，位于 utils 包；private volatile static boolean monitorMode = false;private volatile static boolean debuggable = false;private volatile static boolean autoInject = false;private volatile static _ARouter instance = null;private volatile static boolean hasInit = false;private volatile static ThreadPoolExecutor executor = DefaultPoolExecutor.getInstance(); // 线程池对象，由 DefaultPoolExecutor 创建；private static Handler mHandler;private static Context mContext;private static InterceptorService interceptorService; // 用于执行所有的 Interceptor； 3.2.2 init12345678910protected static synchronized boolean init(Application application) &#123; mContext = application; //【--&gt;4.1.2】初始化 LogisticsCenter LogisticsCenter.init(mContext, executor); logger.info(Consts.TAG, \"ARouter init success!\"); hasInit = true; // 判断是否 init； mHandler = new Handler(Looper.getMainLooper()); // 主线程的 handler return true;&#125; 在初始化 LogisticsCenter 的时候，传入了一个线程池！ 3.2.3 afterInit 在 ARouter 执行完成初始化之后，会触发 interceptor 的 init 操作： 123456static void afterInit() &#123; //【--&gt;3.1.3】获取 ARouter 的实例； //【--&gt;3.1.4】build 跳转信息，返回一个 PostCard 实例； //【--&gt;6.1.3】执行 PostCard 的 nativagation 方法，获得系统服务 InterceptorServiceImpl 实例； interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();&#125; 可以看到，获取 InterceptorServiceImpl 实例，是通过 PostCard.navigation 方法的！ build 的参数传入的是 “/arouter/service/interceptor”，这里我们要获取一个 InterceptorServiceImpl 实例 ！ 3.2.4 getInstance123456789101112131415protected static _ARouter getInstance() &#123; if (!hasInit) &#123; throw new InitException(\"ARouterCore::Init::Invoke init(context) first!\"); &#125; else &#123; if (instance == null) &#123; synchronized (_ARouter.class) &#123; if (instance == null) &#123; //【1】_ARouter 的构造器是空的，就不再分析了； instance = new _ARouter(); &#125; &#125; &#125; return instance; &#125;&#125; 通过单例模式创建 _ARouter 对象； 3.2.5 buildARouter.build 的方法，最后会掉到 _ARouter 中来； 12345678910111213141516171819202122232425262728293031protected Postcard build(String path) &#123; // Route.path； if (TextUtils.isEmpty(path)) &#123; throw new HandlerException(Consts.TAG + \"Parameter is invalid!\"); &#125; else &#123; //【--&gt;3.1.5】创建 PathReplaceService，用于在跳转前，拦截 path，并对 path 做处理！ PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) &#123; //【---&gt;6.3.1】通过 PathReplaceService 对 path 做预处理！ path = pService.forString(path); &#125; //【2】调用第三个方法： return build(path, extractGroup(path)); &#125;&#125;... ... ...// 先不看其他的 build 方法！protected Postcard build(String path, String group) &#123; // Route,path, Route.group； if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123; throw new HandlerException(Consts.TAG + \"Parameter is invalid!\"); &#125; else &#123; //【--&gt;3.1.5】创建 PathReplaceService，用于在跳转前，拦截 uri，并对 uri 做处理！ PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) &#123; //【---&gt;6.3.1】通过 PathReplaceService 对 path 做预处理！ path = pService.forString(path); &#125; //【--&gt;5.1】返回跳转信息； //【--&gt;6.1.1】创建跳转实例 Postcard； return new Postcard(path, group); &#125;&#125; 同样，也是有三个重载函数： Postcard build(String path): 指定 Route.path，跳转/初始化都会使用到该方法，这个方法会调用第二个； Postcard build(String path, String group)：指定 Route.path, Route.group，跳转时使用； Postcard build(Uri url)：指定 uri，uri 需要在说明书中设置； 这里我们先关注 init 过程中调用的！ （注意：这里有一个 PathReplaceService，用于在跳转前，拦截 path，并对 path 做处理，这个 Service 和路由跳转有关系，初始化这里我们先不过多分析！） 3.2.5.1 extractGroup这个方法的作用是对 path 做修正，看 path 是否正确，同时根据 path 生成 group： 1234567891011121314151617181920private String extractGroup(String path) &#123; //【1】校验 path 是否正确 if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) &#123; throw new HandlerException(Consts.TAG + \"Extract the default group failed, the path must be start with\" + \"'/' and contain more than 2 '/'!\"); &#125; try &#123; //【3】根据 path 生成 group； String defaultGroup = path.substring(1, path.indexOf(\"/\", 1)); if (TextUtils.isEmpty(defaultGroup)) &#123; throw new HandlerException(Consts.TAG + \"Extract the default group failed! There's nothing between 2 '/'!\"); &#125; else &#123; return defaultGroup; &#125; &#125; catch (Exception e) &#123; logger.warning(Consts.TAG, \"Failed to extract default group! \" + e.getMessage()); return null; &#125;&#125; 3.2.6 navigation最后会进入 _ARouter 的 navigation 方法中，我们看到，该方法的逻辑还是很多的，注意，这里我们传入的 callback 是 null 的！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; //【*important】这里又和 PathReplaceService 一样的，又是通过跳转的方式获取 PretreatmentService 服务，对 Postcard 做预处理； // 这个同样的，我们先不看； PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class); if (null != pretreatmentService &amp;&amp; !pretreatmentService.onPretreatment(context, postcard)) &#123; return null; &#125; try &#123; //【--&gt;4.1.2】完善跳转信息！ LogisticsCenter.completion(postcard); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); if (debuggable()) &#123; runInMainThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mContext, \"There's no route matched!\\n\" + \" Path = [\" + postcard.getPath() + \"]\\n\" + \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; if (null != callback) &#123; ///【1】当完善失败，则通过 callback.onLost 提示用户！ callback.onLost(postcard); &#125; else &#123; //【*important】如果没有指定 callback，显然通过降级服务处理！ // 这里又和 PathReplaceService 一样的，又是通过跳转的方式获取 DegradeService 服务，对 Postcard 做预处理； // 这个同样的，我们先不看； DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class); if (null != degradeService) &#123; degradeService.onLost(context, postcard); &#125; &#125; return null; &#125; if (null != callback) &#123; //【2】回调 onFound 方法，表示跳转信息有效； callback.onFound(postcard); &#125; //【--&gt;6.1】如果跳转不能避开所有的拦截器，那么就要在这里处理，我们知道 Fragment 和 IProvider 的子类是会避开拦截器的！ if (!postcard.isGreenChannel()) &#123; //【*important】这一部分设计拦截器功能，我们在跳转那一篇再分析； interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; @Override public void onInterrupt(Throwable exception) &#123; if (null != callback) &#123; callback.onInterrupt(postcard); &#125; logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage()); &#125; &#125;); &#125; else &#123; //【--&gt;3.2.7】最终的处理； return _navigation(context, postcard, requestCode, callback); &#125; return null;&#125; _ARouter 也提供了 2 个跳转接口： navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback)：这个才是真正的跳转接口！ 同样的，我们也只看 init的过程，也就是获取 InterceptorServiceImpl 实例的过程，这个过程调用的是上面的四参方法； &lt;T&gt; T navigation(Class&lt;? extends T&gt; service): 用于获取泛型指定的 Service！ 1234567891011121314151617181920212223protected &lt;T&gt; T navigation(Class&lt;? extends T&gt; service) &#123; try &#123; //【--&gt;4.1.3】通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例 // service.getName() 返回的是全限定名； Postcard postcard = LogisticsCenter.buildProvider(service.getName()); //【1】如果是 null，说明使用的是旧版本的 compiler sdk，早期的 compiler 不使用全限定名区获取服务； if (null == postcard) &#123; //【--&gt;4.1.3】通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例 postcard = LogisticsCenter.buildProvider(service.getSimpleName()); &#125; if (null == postcard) &#123; return null; &#125; //【--&gt;4.1.4】完成跳转！ LogisticsCenter.completion(postcard); return (T) postcard.getProvider(); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); return null; &#125;&#125; 实际上并不是跳转接口，PathReplaceService，PretreatmentService，DegradeService 都是通过这个方法获取！ 我们后面统一进行分析！ 3.2.7 _navigation最后会调用 _navigation 返回我们的 InterceptorServiceImpl 实例，我们知道 InterceptorServiceImpl 是 PROVIDER 类型的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; final Context currentContext = null == context ? mContext : context; switch (postcard.getType()) &#123; case ACTIVITY: // Build intent final Intent intent = new Intent(currentContext, postcard.getDestination()); intent.putExtras(postcard.getExtras()); // Set flags. int flags = postcard.getFlags(); if (-1 != flags) &#123; intent.setFlags(flags); &#125; else if (!(currentContext instanceof Activity)) &#123; // Non activity, need less one flag. intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; // Set Actions String action = postcard.getAction(); if (!TextUtils.isEmpty(action)) &#123; intent.setAction(action); &#125; // Navigation in main looper. runInMainThread(new Runnable() &#123; @Override public void run() &#123; startActivity(requestCode, currentContext, intent, postcard, callback); &#125; &#125;); break; case PROVIDER: //【over】返回了 iprovider 实例，就是我们的 InterceptorServiceImpl 对象； return postcard.getProvider(); case BOARDCAST: case CONTENT_PROVIDER: case FRAGMENT: Class fragmentMeta = postcard.getDestination(); try &#123; Object instance = fragmentMeta.getConstructor().newInstance(); if (instance instanceof Fragment) &#123; ((Fragment) instance).setArguments(postcard.getExtras()); &#125; else if (instance instanceof android.support.v4.app.Fragment) &#123; ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras()); &#125; return instance; &#125; catch (Exception ex) &#123; logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace())); &#125; case METHOD: case SERVICE: default: return null; &#125; return null;&#125; 这里涉及到其他类型的处理，我们在路由跳转的时候再分析； 4 core 包4.1 LogisticsCenter - 核心一号种子4.1.1 成员变量 123private static Context mContext;static ThreadPoolExecutor executor; // 线程池；private static boolean registerByPlugin; // 是否通过插件自动注册； 4.1.2 init执行 init 操作； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException &#123; mContext = context; executor = tpe; try &#123; long startInit = System.currentTimeMillis(); //【--&gt;5.1.1】是否使用 arouter-auto-register 插件来加载路由表； loadRouterMap(); if (registerByPlugin) &#123; logger.info(TAG, \"Load router map by arouter-auto-register plugin.\"); &#125; else &#123; // 默认情况下是进入这里： Set&lt;String&gt; routerMap; //【1】如果开启了 debug 模式或者说 Apk 发生了更新，那么 ARouter 会重建路由表； //【--&gt;9.2.2】isNewVersion 判断 apk 是否是新的安装； if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123; logger.info(TAG, \"Run with debug mode or new install, rebuild router map.\"); //【--&gt;9.1.2】这里更新路由表，通过包名 com.alibaba.android.arouter.routes，扫描包下面包含的所有的类的 ClassName // 这个包是在 arouter complier 阶段生成的，里面包含解析注解生成的 java 类； routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE); if (!routerMap.isEmpty()) &#123; //【1.1】当我们能够扫描到路由信息后，会将这个信息保存到本地 sp 中； context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply(); &#125; PackageUtils.updateVersion(context); //【--&gt;9.2.3】保存版本号； &#125; else &#123; logger.info(TAG, \"Load router map from cache.\"); //【2】其他情况，是默认从本地缓存中读取路由表的！ routerMap = new HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet&lt;String&gt;())); &#125; logger.info(TAG, \"Find router map finished, map size = \" + routerMap.size() + \", cost \" + (System.currentTimeMillis() - startInit) + \" ms.\"); startInit = System.currentTimeMillis(); //【2】处理路由表的信息，在前面，我们将 aouter-compiler 在编译时期生成的 class 都加载到了 routerMap 中了； for (String className : routerMap) &#123; if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123; //【2.1】判断前缀：com.alibaba.android.arouter.routes.ARouter&amp;&amp;Root，符合前缀的都是 IRouteRoot 的子类 // 调用其 loadInto --&gt; Warehouse.groupsIndex； ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex); &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123; //【2.2】判断前缀：com.alibaba.android.arouter.routes.ARouter&amp;&amp;Interceptors，符合前缀的都是 IInterceptorGroup 的子类 // 调用其 loadInto --&gt; Warehouse.interceptorsIndex； ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex); &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123; //【2.3】判断前缀：com.alibaba.android.arouter.routes.ARouter&amp;&amp;Providers，符合前缀的都是 IProviderGroup 的子类 // 调用其 loadInto --&gt; Warehouse.providersIndex； ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex); &#125; &#125; &#125; logger.info(TAG, \"Load root element finished, cost \" + (System.currentTimeMillis() - startInit) + \" ms.\"); if (Warehouse.groupsIndex.size() == 0) &#123; logger.error(TAG, \"No mapping files were found, check your configuration please!\"); &#125; if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], “ + ”InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(),“ + Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size())); &#125; &#125; catch (Exception e) &#123; throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\"); &#125;&#125; 我们看到，ARouter 会将路由表存储在本地缓存 sp 中，在版本号发生变化的时候会处理，上面的这些常量定义在 Consts 中。 我们还记得 arouter compiler 在动态生成代码的时候，会创建 IRouteRoot，IInterceptorGroup，IProviderGroup 的子类，我们通过 Route，intercepor 注解的元素都会被封装成 RouteMeta 实例，通过 loadInto 方法，加入到 Warehouse 对应的集合中！ 下面我们通过之前动态代码来分析： 如果前缀是 ARouter$$Root, 那么会触发 ARouter$$Root$$moduleName.loadInto方法： 12345678public class ARouter$$Root$$app implements IRouteRoot &#123; @Override public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put(\"coolqiActivity\", ARouter$$Group$$coolqiActivity.class); routes.put(\"coolqiProvider\", ARouter$$Group$$coolqiProvider.class); routes.put(\"coolqiService\", ARouter$$Group$$coolqiService.class); &#125;&#125; 这部分数据会加载到：Warehouse.groupsIndex，这样，我们就可以通过它按组加载了； 如果前缀是 ARouter$$Interceptors, 那么会触发 ARouter$$Interceptors$$moduleName.loadInto方法： 123456public class ARouter$$Interceptors$$app implements IInterceptorGroup &#123; @Override public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(8, TestInterceptor.class); &#125;&#125; 这部分数据会加载到：Warehouse.interceptorsIndex 如果前缀是 ARouter$$Providers, 那么会触发 ARouter$$Providers$$moduleName.loadInto方法： 123456789public class ARouter$$Providers$$app implements IProviderGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123; providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, MySerializationService.class, \"/coolqiService/MySerializationService\", \"coolqiService\", null, -1, -2147483648)); providers.put(\"com.pa.sales2.test.MyIProvider\", RouteMeta.build(RouteType.PROVIDER, MyIProvider.class, \"/coolqiProvider/MyIProvider\", \"coolqiProvider\", null, -1, -2147483648)); &#125;&#125; 这部分数据会加载到：Warehouse.providersIndex 4.2.1.1 loadRouterMap这个方法用于判断是否通过 arouter-auto-register 插件自动注册路由； 1234567private static void loadRouterMap() &#123; registerByPlugin = false; //auto generate register code by gradle plugin: arouter-auto-register // looks like below: // registerRouteRoot(new ARouter..Root..modulejava()); // registerRouteRoot(new ARouter..Root..modulekotlin());&#125; 可以看到，如果使用了 arouter-auto-register 插件，那么会自动执行 registerRouteRoot 相关代码； 这里我们先不看和 arouter-auto-register 相关的代码： 这个方法默认是将 registerByPlugin 设置为 false； 4.1.3 buildProvider通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例： 1234567891011public static Postcard buildProvider(String serviceName) &#123; //【--&gt;4.2.1】我们知道 service 实现了 IProvider 实例，所以保存在了 Warehouse.providersIndex 中！ RouteMeta meta = Warehouse.providersIndex.get(serviceName); if (null == meta) &#123; return null; &#125; else &#123; //【--&gt;6.1.2】创建路由跳转信息； return new Postcard(meta.getPath(), meta.getGroup()); &#125;&#125; 4.1.4 completion完善跳转信息，completion 会通过 Warehouse 的数据，填充 Postcard！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public synchronized static void completion(Postcard postcard) &#123; if (null == postcard) &#123; throw new NoRouteFoundException(TAG + \"No postcard!\"); &#125; //【--&gt;4.2.1】从 Warehouse.routes 中获取 path 对应的 RouteMeta 缓存数据； RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); //【1】如果找不到，那么就从 compiler 生成的数据中查找！ if (null == routeMeta) &#123; //【--&gt;4.2.1】从 Warehouse.routes 中获取 group 对应的 group 类文件； Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup()); if (null == groupMeta) &#123; // 【1.1】找不到抛出异常； throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\"); &#125; else &#123; try &#123; if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath())); &#125; //【1.2】创建 groupMeta 对应的实例； IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance(); //【--&gt;4.2.1】调用其 loadInto 将 group 对应的信息加入到缓存 Warehouse.routes 中！ iGroupInstance.loadInto(Warehouse.routes); //【--&gt;4.2.1】然后从 Warehouse.groupsIndex 删除这个组对应的信息； Warehouse.groupsIndex.remove(postcard.getGroup()); if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath())); &#125; &#125; catch (Exception e) &#123; throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\"); &#125; //【--&gt;4.2.2】重新加载； completion(postcard); &#125; &#125; else &#123; //【2】这里是通过 RouteMeta 来设置 Postcard 对象； postcard.setDestination(routeMeta.getDestination()); postcard.setType(routeMeta.getType()); postcard.setPriority(routeMeta.getPriority()); postcard.setExtra(routeMeta.getExtra()); //【3】如果指定了 uri 就要从 uri 中设置传递的数据了，显然，这里我们并没有设置 Uri； // 我们也没有传递数据，只是为了获取 InterceptorServiceImpl 实例，我们先不看！ Uri rawUri = postcard.getUri(); if (null != rawUri) &#123; Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri); Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); if (MapUtils.isNotEmpty(paramsType)) &#123; for (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123; setValue(postcard, params.getValue(), params.getKey(), resultMap.get(params.getKey())); &#125; // 这里和 AutoInject 有关系，我们先不看！ postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]&#123;&#125;)); &#125; postcard.withString(ARouter.RAW_URI, rawUri.toString()); &#125; //【4】这里是关键点，判断类型，可以看到 activity 这里是不处理的！； switch (routeMeta.getType()) &#123; case PROVIDER: //【4.1】我们要获取的 InterceptorServiceImpl，类型就是 PROVIDER； // routeMeta.getDestination 返回的是要访问的目标类：InterceptorServiceImpl.class; Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); //【--&gt;4.2.1】然后优先从 Warehouse.providers 缓存中获取； IProvider instance = Warehouse.providers.get(providerMeta); if (null == instance) &#123; IProvider provider; try &#123; //【--&gt;4.3】创建 providerMeta 对应的实例，就是 InterceptorServiceImpl； provider = providerMeta.getConstructor().newInstance(); //【--&gt;4.3.1】执行 init 方法； provider.init(mContext); //【--&gt;4.2.1】然后将加入到 Warehouse.providers 中去； Warehouse.providers.put(providerMeta, provider); instance = provider; &#125; catch (Exception e) &#123; throw new HandlerException(\"Init provider failed! \" + e.getMessage()); &#125; &#125; //【--&gt;6.1.1】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类； postcard.setProvider(instance); postcard.greenChannel(); //【--&gt;6.1.1】跳过所有的拦截器！ break; case FRAGMENT: postcard.greenChannel(); // 跳过所有的拦截器！ default: break; &#125; &#125;&#125; 缓存处理： Warehouse.groupsIndex —&gt; Warehouse.routes 这里优先从 Warehouse.groupsIndex 中读取，Warehouse.groupsIndex 中保存的是类似下面的数据； 123routes.put(\"coolqiActivity\", ARouter$$Group$$coolqiActivity.class);routes.put(\"coolqiProvider\", ARouter$$Group$$coolqiProvider.class);routes.put(\"coolqiService\", ARouter$$Group$$coolqiService.class); 这里会从 Warehouse.groupsIndex 中，获取 group 对应的类，并创建实例，比如 ARouter$$Group$$coolqiService： 12345678public class ARouter$$Group$$coolqiService implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put(\"/coolqiService/MySerializationService\", RouteMeta.build(RouteType.PROVIDER, MySerializationService.class, \"/coolqiservice/myserializationservice\", \"coolqiservice\", null, -1, -2147483648)); &#125;&#125; 然后，调用其 loadInto 方法，就会将数据加入到 Warehouse.routes 中； Warehouse.providers 上面涉及到了数据处理，我们先不看，后面再分析； 4.2 WareHouse - 核心二号种子WareHouse 是 ARouter 的数据仓库，存储跳转的信息！ 4.2.1 成员变量1234567891011121314//【1】保存动态生成的 ARouter$$Root$$moduleName.loadInto 方法加载的数据；// 相当于，我们把 compiler 编译生成的数据保存到了这里；static Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = new HashMap&lt;&gt;();static Map&lt;String, RouteMeta&gt; routes = new HashMap&lt;&gt;(); // 上面数据的缓存；//【2】保存动态生成的 ARouter$$Providers$$moduleName.loadInto 方法加载的数据；// 相当于，我们把 compiler 编译生成的数据保存到了这里；static Map&lt;String, RouteMeta&gt; providersIndex = new HashMap&lt;&gt;();static Map&lt;Class, IProvider&gt; providers = new HashMap&lt;&gt;(); // 上面数据的缓存，key：类名，value：实例；//【3】保存动态生成的 ARouter$$Interceptors$$moduleName.loadInto 方法加载的数据；【--&gt;5.1】对于 interceptor，是通过 UniqueKeyTreeMap 来存放的！// 相当于，我们把 compiler 编译生成的数据保存到了这里；static Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = new UniqueKeyTreeMap&lt;&gt;(\"More than one interceptors use same priority [%s]\");static List&lt;IInterceptor&gt; interceptors = new ArrayList&lt;&gt;(); // 上面数据的缓存 每次都会从 compiler 数据中获取数据保存到缓存数据中，然后删除 compiler 数据； 4.2.2 clear清除内部数据： 12345678static void clear() &#123; routes.clear(); groupsIndex.clear(); providers.clear(); providersIndex.clear(); interceptors.clear(); interceptorsIndex.clear();&#125; WareHouse 只有一个 clear 方法，用来清除数据； 4.3 InterceptorServiceImplInterceptorServiceImpl 他是 ARouter 内部实现的系统服务，是通过：@Route(path = &quot;/arouter/service/interceptor&quot;) 注解处理的，它的作用是用于处理拦截器 123456@Route(path = \"/arouter/service/interceptor\")public class InterceptorServiceImpl implements InterceptorService &#123; private static boolean interceptorHasInit; private static final Object interceptorInitLock = new Object(); &#125; 4.3.1 init初始化所有的 Interceptor： 1234567891011121314151617181920212223242526272829303132@Overridepublic void init(final Context context) &#123; LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123; //【--&gt;4.2.1】从 Warehouse.interceptorsIndex 获取所有注解生成的拦截器； for (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123; Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue(); try &#123; //【1】创建 interceptors 实例，并执行 init 初始化； IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance(); iInterceptor.init(context); //【--&gt;4.2.1】将其加入到缓存 Warehouse.interceptors Warehouse.interceptors.add(iInterceptor); &#125; catch (Exception ex) &#123; throw new HandlerException(TAG + \"ARouter init interceptor error! name = [\" + interceptorClass.getName() + \"], reason = [\" + ex.getMessage() + \"]\"); &#125; &#125; interceptorHasInit = true; logger.info(TAG, \"ARouter interceptors init over.\"); synchronized (interceptorInitLock) &#123; interceptorInitLock.notifyAll(); &#125; &#125; &#125; &#125;);&#125; 这里又涉及到缓存：Warehouse.interceptorsIndex —&gt;Warehouse.interceptors; 5 base 包5.1 UniqueKeyTreeMap123456789101112131415161718public class UniqueKeyTreeMap&lt;K, V&gt; extends TreeMap&lt;K, V&gt; &#123; private String tipText; public UniqueKeyTreeMap(String exceptionText) &#123; super(); tipText = exceptionText; &#125; @Override public V put(K key, V value) &#123; if (containsKey(key)) &#123; throw new RuntimeException(String.format(tipText, key)); &#125; else &#123; return super.put(key, value); &#125; &#125;&#125; 不多说了！ 6 facade 包6.1 PostCardPostCard 继承了 RouteMeta，用于保存跳转的信息； 6.1.1 成员变量123456789101112private Uri uri; // uriprivate Object tag; // A tag prepare for some thing wrong.private Bundle mBundle; // 数据 bundle；private int flags = -1; // 跳转的 flags，用于 activity；private int timeout = 300; // Navigation timeout, TimeUnit.Secondprivate IProvider provider; // 如果跳转的目标实例是 IProvider 的子类，那么该值不为 null；private boolean greenChannel; // 是否跳过所有的拦截器；private SerializationService serializationService;private Bundle optionsCompat; // 和动画相关的属性；private int enterAnim = -1;private int exitAnim = -1; 6.1.2 new Postcard创建了一个 Postcard 实例！ 1234567891011121314public Postcard() &#123; this(null, null);&#125;public Postcard(String path, String group) &#123; this(path, group, null, null);&#125;//【1】最终会调用这个方法；public Postcard(String path, String group, Uri uri, Bundle bundle) &#123; setPath(path); // 设置 path setGroup(group); // 设置 group setUri(uri); // 设置 uri this.mBundle = (null == bundle ? new Bundle() : bundle);&#125; 不多说了！ 在初始化过程中，我们传入的 path：”/arouter/service/interceptor” 6.1.3 navigation在初始化过程中，执行 navigation 方法，获取系统拦截器：InterceptorServiceImpl 123456789101112public Object navigation() &#123; return navigation(null);&#125;public Object navigation(Context context) &#123; return navigation(context, null);&#125;public Object navigation(Context context, NavigationCallback callback) &#123; //【--&gt;3.1.5】调用了 ARouter 的 navigation 方法！ return ARouter.getInstance().navigation(context, this, -1, callback);&#125; 这里涉及到了 NavigationCallback callback 的概念：跳转回调！ 9 Utils 包9.1 ClassUtils9.1.1 成员变量12345678910private static final String EXTRACTED_NAME_EXT = \".classes\"; // 文件后缀private static final String EXTRACTED_SUFFIX = \".zip\";private static final String SECONDARY_FOLDER_NAME = \"code_cache\" + File.separator + \"secondary-dexes\"; // 文件路径 /code_cache/secondary-dexes；private static final String PREFS_FILE = \"multidex.version\"; // 记录 mutilDex 信息的 sp name；private static final String KEY_DEX_NUMBER = \"dex.number\"; // sp key 值，记录 dex 的数量；private static final int VM_WITH_MULTIDEX_VERSION_MAJOR = 2; // VM 相关，用于判断 vm 是否支持 multiDex；private static final int VM_WITH_MULTIDEX_VERSION_MINOR = 1; 9.1.2 getFileNameByPackageName通过指定包名，扫描 Apk 下面包含的所有类的 ClassName: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static Set&lt;String&gt; getFileNameByPackageName(Context context, final String packageName) throws PackageManager.NameNotFoundException, IOException, InterruptedException &#123; final Set&lt;String&gt; classNames = new HashSet&lt;&gt;(); //【--&gt;9.1.3】获取 apk 源代码（dex）的路径； List&lt;String&gt; paths = getSourcePaths(context); final CountDownLatch parserCtl = new CountDownLatch(paths.size()); for (final String path : paths) &#123; DefaultPoolExecutor.getInstance().execute(new Runnable() &#123; @Override public void run() &#123; DexFile dexfile = null; try &#123; //【2】根据文件后缀的不同，会执行不通的操作，如果后缀是 .zip，那么回调用 DexFile.loadDex 方法； if (path.endsWith(EXTRACTED_SUFFIX)) &#123; dexfile = DexFile.loadDex(path, path + \".tmp\", 0); &#125; else &#123; dexfile = new DexFile(path); &#125; //【3】遍历 dex 文件，找到该 apk 的所有 class，并返回其 class name； Enumeration&lt;String&gt; dexEntries = dexfile.entries(); while (dexEntries.hasMoreElements()) &#123; String className = dexEntries.nextElement(); if (className.startsWith(packageName)) &#123; classNames.add(className); &#125; &#125; &#125; catch (Throwable ignore) &#123; Log.e(\"ARouter\", \"Scan map file in dex files made error.\", ignore); &#125; finally &#123; if (null != dexfile) &#123; try &#123; dexfile.close(); &#125; catch (Throwable ignore) &#123; &#125; &#125; parserCtl.countDown(); &#125; &#125; &#125;); &#125; parserCtl.await(); Log.d(Consts.TAG, \"Filter \" + classNames.size() + \" classes by packageName &lt;\" + packageName + \"&gt;\"); return classNames;&#125; 9.1.3 getSourcePaths获取源代码路径： 1234567891011121314151617181920212223242526272829303132333435public static List&lt;String&gt; getSourcePaths(Context context) throws PackageManager.NameNotFoundException, IOException &#123; ApplicationInfo applicationInfo = context.getPackageManager().getApplicationInfo(context.getPackageName(), 0); File sourceApk = new File(applicationInfo.sourceDir); List&lt;String&gt; sourcePaths = new ArrayList&lt;&gt;(); sourcePaths.add(applicationInfo.sourceDir);//【1】添加默认的 apk 源路径； //【1】文件前缀：name.classes String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT; //【--&gt;9.1.3.1】判断 vm 是否支持 multiDex，如何已经支持了 muitiDex，那就不去 Secondary Folder 加载 Classesx.zip if (!isVMMultidexCapable()) &#123; //【2】不支持 multiDex，那就要去加载 Classesx.zip； int totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, 1); //【--&gt;9.1.3.2】获取 dex 的数量； File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME); // 获取存放其他 dex 的目录； //【3】收集 Secondary Folder 目录下的 dex 的路径； for (int secondaryNumber = 2; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123; //【3.1】每个 dex file 的文件名都是：name.classes.zip，添加到 sourcePaths 列表中； String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX; File extractedFile = new File(dexDir, fileName); if (extractedFile.isFile()) &#123; sourcePaths.add(extractedFile.getAbsolutePath()); //we ignore the verify zip part &#125; else &#123; throw new IOException(\"Missing extracted secondary dex file '\" + extractedFile.getPath() + \"'\"); &#125; &#125; &#125; if (ARouter.debuggable()) &#123; // Search instant run support only debuggable sourcePaths.addAll(tryLoadInstantRunDexFile(applicationInfo)); &#125; //【4】返回收集的列表 return sourcePaths;&#125; 过程还是比较简单的； 9.1.3.1 isVMMultidexCapable判断 vm 是否支持 multiDex： 12345678910111213141516171819202122232425262728293031323334private static boolean isVMMultidexCapable() &#123; boolean isMultidexCapable = false; String vmName = null; try &#123; if (isYunOS()) &#123; //【1】YunOS 需要特殊判断 vmName = \"'YunOS'\"; isMultidexCapable = Integer.valueOf(System.getProperty(\"ro.build.version.sdk\")) &gt;= 21; &#125; else &#123; //【2】非 YunOS 原生 Android vmName = \"'Android'\"; String versionString = System.getProperty(\"java.vm.version\"); if (versionString != null) &#123; //【3】判断 java.vm.version 属性的 major 和 minor 的范围； Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString); if (matcher.matches()) &#123; try &#123; int major = Integer.parseInt(matcher.group(1)); int minor = Integer.parseInt(matcher.group(2)); isMultidexCapable = (major &gt; VM_WITH_MULTIDEX_VERSION_MAJOR) || ((major == VM_WITH_MULTIDEX_VERSION_MAJOR) &amp;&amp; (minor &gt;= VM_WITH_MULTIDEX_VERSION_MINOR)); &#125; catch (NumberFormatException ignore) &#123; // let isMultidexCapable be false &#125; &#125; &#125; &#125; &#125; catch (Exception ignore) &#123; &#125; Log.i(Consts.TAG, \"VM with name \" + vmName + (isMultidexCapable ? \" has multidex support\" : \" does not have multidex support\")); return isMultidexCapable; &#125; 不多说了 ； 9.1.3.2 getMultiDexPreferences获取记录 multi dex 信息 sp，ARouter 将 dex 的数量保存到内部 sp 中，name： “multidex.version”： 1234private static SharedPreferences getMultiDexPreferences(Context context) &#123; return context.getSharedPreferences(PREFS_FILE, Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB ? Context.MODE_PRIVATE : Context.MODE_PRIVATE | Context.MODE_MULTI_PROCESS); &#125; 9.2 PackageUtils9.2.1 成员变量12private static String NEW_VERSION_NAME;private static int NEW_VERSION_CODE; 用来缓存 apk 的版本号和版本名； 9.2.2 isNewVersion判断 apk 是否是新的版本，包括第一次安装/更新安装； 1234567891011121314151617181920212223public static boolean isNewVersion(Context context) &#123; //【1】获得 apk 的信息； PackageInfo packageInfo = getPackageInfo(context); if (null != packageInfo) &#123; //【2】获取 apk 的版本名和版本号； String versionName = packageInfo.versionName; int versionCode = packageInfo.versionCode; SharedPreferences sp = context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE); //【3】如何和本地缓存的不一样，那就说明是新版本； if (!versionName.equals(sp.getString(LAST_VERSION_NAME, null)) || versionCode != sp.getInt(LAST_VERSION_CODE, -1)) &#123; //【3.1】将新的 versionCode 和 VersionName 缓存下来； NEW_VERSION_NAME = versionName; NEW_VERSION_CODE = versionCode; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125;&#125; 9.2.3 updateVersion更新本地缓存： 1234567public static void updateVersion(Context context) &#123; if (!android.text.TextUtils.isEmpty(NEW_VERSION_NAME) &amp;&amp; NEW_VERSION_CODE != 0) &#123; SharedPreferences sp = context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE); //【1】写入到本地 sp 中； sp.edit().putString(LAST_VERSION_NAME, NEW_VERSION_NAME).putInt(LAST_VERSION_CODE, NEW_VERSION_CODE).apply(); &#125;&#125; 这里的 LAST_VERSION_NAME，LAST_VERSION_CODE 均定义在 Consts 中； 9.x Consts常量类，保存了 arouter-api 中的常量关键字； 1234567891011121314151617public final class Consts &#123; public static final String SDK_NAME = \"ARouter\"; // 这几个常量在 complier 中有见过，用于生成注解处理后的类的类名和包名； public static final String TAG = SDK_NAME + \"::\"; public static final String SEPARATOR = \"$$\"; public static final String SUFFIX_ROOT = \"Root\"; public static final String SUFFIX_INTERCEPTORS = \"Interceptors\"; public static final String SUFFIX_PROVIDERS = \"Providers\"; public static final String SUFFIX_AUTOWIRED = SEPARATOR + SDK_NAME + SEPARATOR + \"Autowired\"; public static final String DOT = \".\"; public static final String ROUTE_ROOT_PAKCAGE = \"com.alibaba.android.arouter.routes\"; public static final String AROUTER_SP_CACHE_KEY = \"SP_AROUTER_CACHE\"; // 本地缓存 sp 的 name public static final String AROUTER_SP_KEY_MAP = \"ROUTER_MAP\"; public static final String LAST_VERSION_NAME = \"LAST_VERSION_NAME\"; // 用于保存 apk 的版本号 public static final String LAST_VERSION_CODE = \"LAST_VERSION_CODE\";&#125; 10 总结我们分析路由初始化的整个过程，设计的 pkg 也很多，但是细心的观察，我们其实已经分析了一些路由跳转的逻辑，哈哈哈。 当然，还有下面的问题遗漏了： PathReplaceService，PretreatmentService，DegradeService：是如何获取的，作用又是什么呢？ facade.service 下的这些 Service 都是如何工作的呢？ core目录下的 AutowiredServiceImpl 和 InterceptorServiceImpl，又是如何工作的呢？ ARouter 如何处理跳转回调的呢？ 这些问题，我会在下篇：路由跳转中分析；","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"ARouter 第三篇 - 注解解析 (arouter-compiler)","slug":"ARouter3-arouter-compiler","date":"2019-04-19T12:46:25.000Z","updated":"2019-08-09T13:24:57.132Z","comments":true,"path":"2019/04/19/ARouter3-arouter-compiler/","link":"","permalink":"https://coolqi.top/2019/04/19/ARouter3-arouter-compiler/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的架构和原理。 这是阿里 ARouter 开源库的地址，大家可以直接访问https://github.com/alibaba/ARouter 本篇博文主要分析 arouter-compiler 模块； 1 模块结构下面我们来看看 arouter-compiler 的模块结构： 12345678910111213141516|____com| |____alibaba| | |____android| | | |____arouter| | | | |____compiler| | | | | |____entity| | | | | | |____RouteDoc.java| | | | | |____processor| | | | | | |____BaseProcessor.java| | | | | | |____InterceptorProcessor.java| | | | | | |____AutowiredProcessor.java| | | | | | |____RouteProcessor.java| | | | | |____utils| | | | | | |____TypeUtils.java| | | | | | |____Consts.java| | | | | | |____Logger.java 可以看到，一共有三个 pacakge： entity：包含了实体数据类； processor：包含了所有的注解解释器类； utils：包含了一些工具类； 我们知道，在 Gradle 对 App 执行编译的时候，arouter-compiler 会对相关的注解进行解析，并动态生成所需的类； arouter-compiler 模块还依赖了两个三方库： 12implementation 'com.google.auto.service:auto-service:1.0-rc3'implementation 'com.squareup:javapoet:1.8.0' JavaPoet 是 square 推出的开源 java 代码生成框架，提供 Java Api 生成 .java 源文件； auto-service 是 google 提供的用于自动注册自定义注解处理器的三方库； 关于这两个库的源码，本系列文章不分析，后面单独分析； 2 源码分析我们分别分析下三个 package 目录下的 class 的作用！ 2.1 entity该 package 下面只包含一个实体数据类：RouteDoc。 2.1.1 RouteDocRouteDoc 用于描述路由跳转的信息，用于生成路由表： 123456789101112131415161718192021222324252627282930313233public class RouteDoc &#123; @JSONField(ordinal = 1) private String group; @JSONField(ordinal = 2) private String path; @JSONField(ordinal = 3) private String description; @JSONField(ordinal = 4) private String prototype; @JSONField(ordinal = 5) private String className; @JSONField(ordinal = 6) private String type; @JSONField(ordinal = 7) private int mark; @JSONField(ordinal = 8) private List&lt;Param&gt; params; ... ... ...// 省略掉 get/set 方法； public static class Param &#123; @JSONField(ordinal = 1) private String key; @JSONField(ordinal = 2) private String type; @JSONField(ordinal = 3) private String description; @JSONField(ordinal = 4) private boolean required; ... ... ...// 省略掉 get/set 方法； &#125;&#125; 当 processor 对注解进行解析的时候，它会把路由跳转相关的信息记录到 RouteDoc 中！ 后面我们分析 processor 的时候就可以看到了！ 2.2 processor - 注解解析该 package 下面包含 ARouter 的核心类：processors，根据前面的注解，一共有三个 processor，我们分别来分析！ 重点要关注他们是如何“解析注解，并动态生成代码的！ 2.2.1 BaseProcessorBaseProcessor 是其他三个 processor 的基类，定义了一些共有的属性和操作； 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class BaseProcessor extends AbstractProcessor &#123; Filer mFiler; Logger logger; Types types; Elements elementUtils; // 元素工具类对象； TypeUtils typeUtils; //【1】模块的名称 name； String moduleName = null; //【2】是否要生成 route doc； boolean generateDoc; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); mFiler = processingEnv.getFiler(); types = processingEnv.getTypeUtils(); elementUtils = processingEnv.getElementUtils(); //【*2.3.2】创建 TypeUtils 对象，用于对类型做处理； typeUtils = new TypeUtils(types, elementUtils); //【*2.3.1】创建 Logger 对象，用于打印过程信息； logger = new Logger(processingEnv.getMessager()); //【3】获取 Processor 当前所在 moudle 的 name，判断是否生成路由文档； // 常量第一在 Consts 中； Map&lt;String, String&gt; options = processingEnv.getOptions(); if (MapUtils.isNotEmpty(options)) &#123; moduleName = options.get(KEY_MODULE_NAME); generateDoc = VALUE_ENABLE.equals(options.get(KEY_GENERATE_DOC_NAME)); &#125; if (StringUtils.isNotEmpty(moduleName)) &#123; // 这部分是对 moduleName 进行检查； moduleName = moduleName.replaceAll(\"[^0-9a-zA-Z_]+\", \"\"); logger.info(\"The user has configuration the module name, it was [\" + moduleName + \"]\"); &#125; else &#123; logger.error(NO_MODULE_NAME_TIPS); throw new RuntimeException(\"ARouter::Compiler &gt;&gt;&gt; No module name, for more information, look at gradle log.\"); &#125; &#125; ... ... ... // getSupportedSourceVersion /getSupportedOptions&#125; 上面省略掉了一些非核心方法，我们不关注它们； 1234567891011android &#123; defaultConfig &#123; ... javaCompileOptions &#123; // 这里是核心配置点； annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: \"enable\"] &#125; &#125; &#125;&#125; 上面的 KEY_MODULE_NAME，KEY_GENERATE_DOC_NAME，对应的我们在 .gradle 中的配置，这些配置最终都会解析并保存到 ProcessingEnvironment 中； BaseProcessor 主要作用就是创建 TypeUtils 对象和 Logger 对象，然后获得当前所在 module 的 gradle 配置！ 2.2.2 RouteProcessor核心解释器，用于处理 @Route 注解： 12345@AutoService(Processor.class)@SupportedAnnotationTypes(&#123;ANNOTATION_TYPE_ROUTE, ANNOTATION_TYPE_AUTOWIRED&#125;)public class RouteProcessor extends BaseProcessor &#123; ... ... ...&#125; 我们从成员变量，初始化，注解处理三个方面来分析： 2.2.2.1 Field内部变量； 123456// key 是所属的组 group，value 是该组下的所有跳转信息 RouteMeta 对象；private Map&lt;String, Set&lt;RouteMeta&gt;&gt; groupMap = new HashMap&lt;&gt;();private Map&lt;String, String&gt; rootMap = new TreeMap&lt;&gt;(); // Map of root metas, used for generate class file in order.private TypeMirror iProvider = null; // .IProvider 的类型；private Writer docWriter; // 用于生成路由文档； 2.2.2.2 Init初始化 processor： 1234567891011121314151617181920@Overridepublic synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); if (generateDoc) &#123; try &#123; docWriter = mFiler.createResource( StandardLocation.SOURCE_OUTPUT, PACKAGE_OF_GENERATE_DOCS, \"arouter-map-of-\" + moduleName + \".json\" ).openWriter(); &#125; catch (IOException e) &#123; logger.error(\"Create doc writer failed, because \" + e.getMessage()); &#125; &#125; iProvider = elementUtils.getTypeElement(Consts.IPROVIDER).asType(); logger.info(\"&gt;&gt;&gt; RouteProcessor init. &lt;&lt;&lt;\");&#125; 2.2.2.3 Process - 处理 Route 注解核心逻辑：注意，这里的参数 Set&lt;? extends TypeElement&gt; annotations ，表示的是要处理的注解，根据前面的内容：Route 和 AutoWired ！ 123456789101112131415161718@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; if (CollectionUtils.isNotEmpty(annotations)) &#123; //【1】这里返回了 @Route 处理的元素； Set&lt;? extends Element&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class); try &#123; logger.info(\"&gt;&gt;&gt; Found routes, start... &lt;&lt;&lt;\"); //【*2.2.2.3.1】开始处理注解修饰的元素； this.parseRoutes(routeElements); &#125; catch (Exception e) &#123; logger.error(e); &#125; return true; &#125; return false;&#125; 我们看到，这里调用了 parseRoutes 方法： 2.2.2.3.1 parseRoutes核心的核心： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281private void parseRoutes(Set&lt;? extends Element&gt; routeElements) throws IOException &#123; if (CollectionUtils.isNotEmpty(routeElements)) &#123; logger.info(\"&gt;&gt;&gt; Found routes, size is \" + routeElements.size() + \" &lt;&lt;&lt;\"); rootMap.clear(); //【1】保存 activity，service，fragment 的元素类型； TypeMirror type_Activity = elementUtils.getTypeElement(ACTIVITY).asType(); TypeMirror type_Service = elementUtils.getTypeElement(SERVICE).asType(); TypeMirror fragmentTm = elementUtils.getTypeElement(FRAGMENT).asType(); TypeMirror fragmentTmV4 = elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType(); //【2】获得 .IProvider/.IProviderGroup 对应的 TypeElement 对象； TypeElement type_IRouteGroup = elementUtils.getTypeElement(IROUTE_GROUP); TypeElement type_IProviderGroup = elementUtils.getTypeElement(IPROVIDER_GROUP); //【3】获得 RouteMeta 和 RouteType 的类全限定名； ClassName routeMetaCn = ClassName.get(RouteMeta.class); ClassName routeTypeCn = ClassName.get(RouteType.class); //【4】准备动态生成 java 代码： //【4.1】生成方法参数类型： // Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(String.class), ParameterizedTypeName.get( ClassName.get(Class.class), WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup)) ) ); //【4.2】生成方法参数类型：Map&lt;String, RouteMeta&gt; ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(String.class), ClassName.get(RouteMeta.class) ); //【4.4】生成方法参数： // Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes // Map&lt;String, RouteMeta&gt; atlas // Map&lt;String, RouteMeta&gt; providers ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, \"routes\").build(); ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"atlas\").build(); ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"providers\").build(); //【4.5】生成方法签名： // @Override // public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(rootParamSpec); //【5】处理 @Route 注解修饰的元素 for (Element element : routeElements) &#123; TypeMirror tm = element.asType(); // 获得 Route 注解的元素的类型信息； Route route = element.getAnnotation(Route.class); // 获得 Route 注解对象； RouteMeta routeMeta; // 用于封装跳转信息； if (types.isSubtype(tm, type_Activity)) &#123; //【5.1】注解的元素是 activity 的子类； logger.info(\"&gt;&gt;&gt; Found activity route: \" + tm.toString() + \" &lt;&lt;&lt;\"); Map&lt;String, Integer&gt; paramsType = new HashMap&lt;&gt;(); // 保存 fieldName/Autowired.name --&gt; 类型枚举序号； Map&lt;String, Autowired&gt; injectConfig = new HashMap&lt;&gt;(); // 保存 fieldName/Autowired.name --&gt; Autowired 实例 for (Element field : element.getEnclosedElements()) &#123; //【5.1.1】返回该元素直接包含的子元素（成员属性），处理内部哪些被 @Autowired 注解的成员属性（避开 IProvider 子类）； if (field.getKind().isField() &amp;&amp; field.getAnnotation(Autowired.class) != null &amp;&amp; !types.isSubtype(field.asType(), iProvider)) &#123; // 必须是被 @Autowired 注解的属性，但是不能是 IProvider Autowired paramConfig = field.getAnnotation(Autowired.class); //【5.1.1.1】根据是否设置 Autowired.name 对属性进行 byName 或者 byType 处理； String injectName = StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name(); //【5.1.1.2】加入到集合； paramsType.put(injectName, typeUtils.typeExchange(field)); injectConfig.put(injectName, paramConfig); &#125; &#125; //【5.1.2】创建跳转对象； routeMeta = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType); routeMeta.setInjectConfig(injectConfig); &#125; else if (types.isSubtype(tm, iProvider)) &#123; //【5.2】注解的元素实现了 IProvider 接口，创建跳转对象 logger.info(\"&gt;&gt;&gt; Found provider route: \" + tm.toString() + \" &lt;&lt;&lt;\"); routeMeta = new RouteMeta(route, element, RouteType.PROVIDER, null); &#125; else if (types.isSubtype(tm, type_Service)) &#123; //【5.3】注解的元素是 service 的子类，创建跳转对象 logger.info(\"&gt;&gt;&gt; Found service route: \" + tm.toString() + \" &lt;&lt;&lt;\"); routeMeta = new RouteMeta(route, element, RouteType.parse(SERVICE), null); &#125; else if (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) //【5.4】注解的元素是 fragment 的子类，，创建跳转对象 logger.info(\"&gt;&gt;&gt; Found fragment route: \" + tm.toString() + \" &lt;&lt;&lt;\"); routeMeta = new RouteMeta(route, element, RouteType.parse(FRAGMENT), null); &#125; else &#123; throw new RuntimeException(\"ARouter::Compiler &gt;&gt;&gt; Found unsupported class type, type = [\" + types.toString() + \"].\"); &#125; //【*2.2.2.3.1.1】对跳转对象进行分类； categories(routeMeta); &#125; //【4.6】生成方法签名： // @Override // public void loadInto(Map&lt;String, RouteMeta&gt; providers) MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(providerParamSpec); Map&lt;String, List&lt;RouteDoc&gt;&gt; docSource = new HashMap&lt;&gt;(); // key：组名；value：每个组内的路由跳转文档； //【5】按照分组的方式，遍历 RouteMeta； for (Map.Entry&lt;String, Set&lt;RouteMeta&gt;&gt; entry : groupMap.entrySet()) &#123; String groupName = entry.getKey(); //【5.1】生成方法签名： // @Override // public void loadInto(Map&lt;String, RouteMeta&gt; atlas) MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(groupParamSpec); List&lt;RouteDoc&gt; routeDocList = new ArrayList&lt;&gt;(); // 用于保存路由跳转信息； //【5.2】获得属于该 group 下的所有 RouteMeta，并依次处理； Set&lt;RouteMeta&gt; groupData = entry.getValue(); for (RouteMeta routeMeta : groupData) &#123; //【*2.2.2.3.1.2】根据跳转信息，生成文档对象； RouteDoc routeDoc = extractDocInfo(routeMeta); ClassName className = ClassName.get((TypeElement) routeMeta.getRawType()); // 目标类的全限定名 switch (routeMeta.getType()) &#123; //【5.2.1】针对跳转类型为 PROVIDER 的情况，这里会将其父类的信息缓存下来； case PROVIDER: // 返回直接由此类实现或直接由此接口扩展的接口类型（目标类的负类） List&lt;? extends TypeMirror&gt; interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces(); for (TypeMirror tm : interfaces) &#123; routeDoc.addPrototype(tm.toString()); if (types.isSameType(tm, iProvider)) &#123; // 如果是 .IProvider 类型，说明目标类是直接实现的 .IProvider 接口； //【5.2.2】生成方法体： // providers.put(\"目标类的全限定名\", RouteMeta.build(RouteType.PROVIDER, 目标类的类名.class, // $&#123;routeMeta.getPath()&#125;, $&#123;routeMeta.getGroup()&#125;, null, $&#123;routeMeta.getPriority()&#125;, $&#123;routeMeta.getExtra()&#125;)); loadIntoMethodOfProviderBuilder.addStatement( \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\", (routeMeta.getRawType()).toString(), // routeMeta.getRawType() 返回的是 element; routeMetaCn, // RouteMeta routeTypeCn, // RouteType className, // 类名； routeMeta.getPath(), // Route 的 path 属性； routeMeta.getGroup()); // group 属性； &#125; else if (types.isSubtype(tm, iProvider)) &#123; // 如果是 .IProvider 的字类型，说明目标类是继承了一个实现 .IProvider 的类； //【5.2.3】生成方法体： // providers.put(\"直接父类的全限定名\", RouteMeta.build(RouteType.PROVIDER, 目标类的类名.class, // $&#123;routeMeta.getPath()&#125;, $&#123;routeMeta.getGroup()&#125;, null, $&#123;routeMeta.getPriority()&#125;, $&#123;routeMeta.getExtra()&#125;)); loadIntoMethodOfProviderBuilder.addStatement( \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\", tm.toString(), routeMetaCn, routeTypeCn, className, routeMeta.getPath(), routeMeta.getGroup()); &#125; &#125; break; default: break; &#125; //【5.3】用于继续生成 route doc, 和 Autowired 注解的参数 hashmap StringBuilder mapBodyBuilder = new StringBuilder(); Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); Map&lt;String, Autowired&gt; injectConfigs = routeMeta.getInjectConfig(); if (MapUtils.isNotEmpty(paramsType)) &#123; List&lt;RouteDoc.Param&gt; paramList = new ArrayList&lt;&gt;(); for (Map.Entry&lt;String, Integer&gt; types : paramsType.entrySet()) &#123; // 创建 Autowired 注解的参数 hashmap； mapBodyBuilder.append(\"put(\\\"\").append(types.getKey()).append(\"\\\", \").append(types.getValue()).append(\"); \"); RouteDoc.Param param = new RouteDoc.Param(); Autowired injectConfig = injectConfigs.get(types.getKey()); param.setKey(types.getKey()); param.setType(TypeKind.values()[types.getValue()].name().toLowerCase()); param.setDescription(injectConfig.desc()); param.setRequired(injectConfig.required()); paramList.add(param); &#125; // 将 @AutoWeird 修饰的变量信息保存到 routeDoc 中； routeDoc.setParams(paramList); &#125; String mapBody = mapBodyBuilder.toString(); //【5.4】生成方法体：： // atlas.put($&#123;path&#125;, RouteMeta.build(RouteType.XXXX, $&#123;className&#125;.class, // $&#123;path&#125;, $&#123;group&#125;, new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put($&#123;fieldName&#125;/$&#123;AutoWired.Name&#125;, $&#123;TypeKind&#125;);&#125;&#125;, $&#123;priority&#125;, $&#123;extra&#125;)); loadIntoMethodOfGroupBuilder.addStatement( \"atlas.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, \" + (StringUtils.isEmpty(mapBody) ? null : (\"new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;\" + mapBodyBuilder.toString() + \"&#125;&#125;\")) + \", \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\", routeMeta.getPath(), routeMetaCn, routeTypeCn, className, routeMeta.getPath().toLowerCase(), routeMeta.getGroup().toLowerCase()); routeDoc.setClassName(className.toString()); // 将 className 保存到 routeDoc 中； routeDocList.add(routeDoc); // 将这个路由表加入到 routeDocList 中； &#125; //【5.5】动态生成 java 文件： String groupFileName = NAME_OF_GROUP + groupName; JavaFile.builder(PACKAGE_OF_GENERATE_FILE, // 包名；com.alibaba.android.arouter.routes TypeSpec.classBuilder(groupFileName) // 类名 ARouter$$Group$$ + $&#123;groupName&#125; .addJavadoc(WARNING_TIPS) .addSuperinterface(ClassName.get(type_IRouteGroup)) // 实现 .IRouteGroup 接口； .addModifiers(PUBLIC) .addMethod(loadIntoMethodOfGroupBuilder.build()) .build() ).build().writeTo(mFiler); logger.info(\"&gt;&gt;&gt; Generated group: \" + groupName + \"&lt;&lt;&lt;\"); //【5.6】将 key：groupName ---&gt; value：ARouter$$Group$$ + $&#123;groupName&#125; 保存到 rootMap 表中； rootMap.put(groupName, groupFileName); docSource.put(groupName, routeDocList); // 将当前组的所有路由表保存到 docSource 中； &#125; if (MapUtils.isNotEmpty(rootMap)) &#123; //【6】生成方法体：： // routes.put(\"app\", ARouter$$Group$$$&#123;$groupName&#125;.class); for (Map.Entry&lt;String, String&gt; entry : rootMap.entrySet()) &#123; loadIntoMethodOfRootBuilder.addStatement(\"routes.put($S, $T.class)\", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue())); // 当然，这里是全限定名； &#125; &#125; //【7】如果 gradle 设置了生成路由表，那就将 docSource 以 json 的形式输出； if (generateDoc) &#123; docWriter.append(JSON.toJSONString(docSource, SerializerFeature.PrettyFormat)); docWriter.flush(); docWriter.close(); &#125; //【8】动态生成 java 文件： String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName; JavaFile.builder(PACKAGE_OF_GENERATE_FILE, // 包名；com.alibaba.android.arouter.routes TypeSpec.classBuilder(providerMapFileName) // 类名：ARouter$$Providers$$ + $&#123;moduleName&#125; .addJavadoc(WARNING_TIPS) .addSuperinterface(ClassName.get(type_IProviderGroup)) // 实现 .IProviderGroup 接口； .addModifiers(PUBLIC) .addMethod(loadIntoMethodOfProviderBuilder.build()) .build() ).build().writeTo(mFiler); logger.info(\"&gt;&gt;&gt; Generated provider map, name is \" + providerMapFileName + \" &lt;&lt;&lt;\"); //【9】动态生成 java 文件： String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName; JavaFile.builder(PACKAGE_OF_GENERATE_FILE, // 包名；com.alibaba.android.arouter.routes TypeSpec.classBuilder(rootFileName) // 包名；ARouter$$Root$$ + $&#123;moduleName&#125; .addJavadoc(WARNING_TIPS) .addSuperinterface(ClassName.get(elementUtils.getTypeElement(ITROUTE_ROOT))) // 实现 .IRouteRoot 接口； .addModifiers(PUBLIC) .addMethod(loadIntoMethodOfRootBuilder.build()) .build() ).build().writeTo(mFiler); logger.info(\"&gt;&gt;&gt; Generated root, name is \" + rootFileName + \" &lt;&lt;&lt;\"); &#125;&#125; 整个流程还是很简单清晰的，主要是代码生成过程用很多的占位符，为我们看源码产生了很多的阻碍； RouteProcessor 不仅会解析 @Route，还会解析 @AutoWired； 最终会生成三个 java 文件，具体的模版信息： 2.2.2.3.1.1 categories对跳转信息进行分类； 123456789101112131415161718192021222324252627282930private void categories(RouteMeta routeMete) &#123; //【*2.2.2.3.1.2】校验路由跳转信息！ if (routeVerify(routeMete)) &#123; logger.info(\"&gt;&gt;&gt; Start categories, group = \" + routeMete.getGroup() + \", path = \" + routeMete.getPath() + \" &lt;&lt;&lt;\"); //【1】将校验通过的跳转 RouteMeta 加入到 groupMap 中； Set&lt;RouteMeta&gt; routeMetas = groupMap.get(routeMete.getGroup()); if (CollectionUtils.isEmpty(routeMetas)) &#123; //【2】如果是第一次添加，需要创建一个 Set&lt;RouteMeta&gt;，内部元素以 path 排序； Set&lt;RouteMeta&gt; routeMetaSet = new TreeSet&lt;&gt;(new Comparator&lt;RouteMeta&gt;() &#123; @Override public int compare(RouteMeta r1, RouteMeta r2) &#123; try &#123; return r1.getPath().compareTo(r2.getPath()); &#125; catch (NullPointerException npe) &#123; logger.error(npe.getMessage()); return 0; &#125; &#125; &#125;); //【3】加入到集合中； routeMetaSet.add(routeMete); groupMap.put(routeMete.getGroup(), routeMetaSet); &#125; else &#123; //【4】已经创建了 set，直接加入； routeMetas.add(routeMete); &#125; &#125; else &#123; logger.warning(\"&gt;&gt;&gt; Route meta verify error, group is \" + routeMete.getGroup() + \" &lt;&lt;&lt;\"); &#125;&#125; end～ 2.2.2.3.1.2 routeVerify校验路由跳转信息； 123456789101112131415161718192021222324private boolean routeVerify(RouteMeta meta) &#123; String path = meta.getPath(); //【1】path 必须要指定，并且以 \"/\" 开头； if (StringUtils.isEmpty(path) || !path.startsWith(\"/\")) &#123; // The path must be start with '/' and not empty! return false; &#125; //【2】如果 Route 没有指定 group 属性，那么就以 path 的一级目录为 if (StringUtils.isEmpty(meta.getGroup())) &#123; // Use default group(the first word in path) try &#123; String defaultGroup = path.substring(1, path.indexOf(\"/\", 1)); if (StringUtils.isEmpty(defaultGroup)) &#123; return false; &#125; //【2.1】设置组 group meta.setGroup(defaultGroup); return true; &#125; catch (Exception e) &#123; logger.error(\"Failed to extract default group! \" + e.getMessage()); return false; &#125; &#125; return true;&#125; 不多说了～ 2.2.2.3.1.2 extractDocInfo创建路由信息对象： 1234567891011private RouteDoc extractDocInfo(RouteMeta routeMeta) &#123; //【1】根据 RouteMeta 创建 RouteDoc 实例； RouteDoc routeDoc = new RouteDoc(); routeDoc.setGroup(routeMeta.getGroup()); routeDoc.setPath(routeMeta.getPath()); routeDoc.setDescription(routeMeta.getName()); routeDoc.setType(routeMeta.getType().name().toLowerCase()); routeDoc.setMark(routeMeta.getExtra()); return routeDoc;&#125; 2.2.5.4 动态生成类2.2.5.4.1 模版信息我们来看看生成了哪几种模板类： ARouter$$Providers$$${moduleName}.java 这个模版类继承了 IProviderGroup，其实都可以猜到，用于添加属于同一组的 iprovider： 1234567891011121314151617181920package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.enums.RouteType;import com.alibaba.android.arouter.facade.model.RouteMeta;import com.alibaba.android.arouter.facade.template.IProviderGroup;import java.lang.Override;import java.lang.String;import java.util.Map;... ... ...public class ARouter$$Providers$$$&#123;moduleName&#125; implements IProviderGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123; providers.put(\"目标类的全限定名\", RouteMeta.build(RouteType.PROVIDER, 目标类的类名.class, $&#123;routeMeta.getPath()&#125;, $&#123;routeMeta.getGroup()&#125;, null, $&#123;routeMeta.getPriority()&#125;, $&#123;routeMeta.getExtra()&#125;)); providers.put(\"父类的全限定名\", RouteMeta.build(RouteType.PROVIDER, 目标类的类名.class, $&#123;routeMeta.getPath()&#125;, $&#123;routeMeta.getGroup()&#125;, null, $&#123;routeMeta.getPriority()&#125;, $&#123;routeMeta.getExtra()&#125;)); &#125;&#125; 不多说了～ ARouter$$Group$$${groupName}.java 这个模版类继承了 IRouteGroup，其实都可以猜到，用于添加属于同一组的所有被 @Route 注解的元素： 123456789101112131415161718package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.enums.RouteType;import com.alibaba.android.arouter.facade.model.RouteMeta;import com.alibaba.android.arouter.facade.template.IRouteGroup;import java.lang.Override;import java.lang.String;import java.util.Map;... ... ...public class ARouter$$Group$$$&#123;groupName&#125; implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put($&#123;path&#125;, RouteMeta.build(RouteType.XXXX, $&#123;className&#125;.class, $&#123;path&#125;, $&#123;group&#125;, new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put($&#123;fieldName&#125;/$&#123;AutoWired.Name&#125;, $&#123;TypeKind&#125;);&#125;&#125;, $&#123;priority&#125;, $&#123;extra&#125;)); atlas.put($&#123;path&#125;, RouteMeta.build(RouteType.XXXX, $&#123;className&#125;.class, $&#123;path&#125;, $&#123;group&#125;, null, $&#123;priority&#125;, $&#123;extra&#125;)); &#125;&#125; 不多说了～ ARouter$$Root$$${moduleName}.java 这个模版类继承了 IRouteRoot，最为 root，用于添加和管理 group 和对应的 ARouter$$Group$$${moduleName}.java 的映射关系； 123456789101112131415package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.template.IRouteGroup;import com.alibaba.android.arouter.facade.template.IRouteRoot;import java.lang.Class;import java.lang.Override;import java.lang.String;import java.util.Map;public class ARouter$$Root$$$&#123;moduleName&#125; implements IRouteRoot &#123; @Override public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put($&#123;groupName&#125;, ARouter$$Group$$$&#123;groupName&#125;.class); &#125;&#125; 我们可以通过 ARouter$$Root$$${groupName}.java 知道该 module 一共包含多少个 group。每个组中的的元素，可以通过 ARouter$$Group$$${moduleName}.java 这个文档添加； 2.2.5.4.2 举个栗子我写了个 Demo 可以让大家更直观的看到模版对应的实际代码： 2.2.5.4.2.1 实例代码下面是一个简单的 Demo： MyActivity.java MyActivity 的组是：coolqiActivity 1234567891011121314151617181920212223242526package com.lishuaiqi.test;import android.app.Activity;import android.os.Bundle;import android.support.annotation.Nullable;import com.alibaba.android.arouter.facade.annotation.Autowired;import com.alibaba.android.arouter.facade.annotation.Route;import com.alibaba.android.arouter.launcher.ARouter;/** * Created by lishuaiqi */@Route(path = \"/coolqiActivity/MyActivity\")public class MyActivity extends Activity &#123; @Autowired(name = \"isOneAuto\") public boolean isOne; @Autowired(name = \"isTwoAuto\") public int isTwo; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); &#125;&#125; MyIProvider.java MyIProvider 的组是：coolqiProvider 123456789101112131415package com.lishuaiqi.test;import android.content.Context;import com.alibaba.android.arouter.facade.annotation.Route;import com.alibaba.android.arouter.facade.template.IProvider;/** * Created by lishuaiqi */@Route(path = \"/coolqiProvider/MyIProvider\")public class MyProvider implements IProvider &#123; @Override public void init(Context context) &#123; &#125;&#125; MySerializationService.java MySerializationService 的组是：coolqiService 12345678910111213141516171819202122@Route(path = \"/coolqiService/MySerializationService\")public class MySerializationService implements SerializationService &#123; @Override public &lt;T&gt; T json2Object(String input, Class&lt;T&gt; clazz) &#123; return null; &#125; @Override public String object2Json(Object instance) &#123; return null; &#125; @Override public &lt;T&gt; T parseObject(String input, Type clazz) &#123; return null; &#125; @Override public void init(Context context) &#123; &#125;&#125; 我是新建了一个 Module，名字叫：Coolqi 2.2.5.4.2.2 动态代码动态的代码如下所示： ARouter$$Group$$coolqiActivity.java， ARouter$$Group$$coolqiProvider.java， ARouter$$Group$$coolqiService.java 123456789101112131415161718192021222324252627282930313233package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.enums.RouteType;import com.alibaba.android.arouter.facade.model.RouteMeta;import com.alibaba.android.arouter.facade.template.IRouteGroup;import com.lishuaiqi.test.MyActivity;import com.lishuaiqi.test.MyPathReplaceService;import com.lishuaiqi.test.MyProvider;import com.lishuaiqi.MainActivity;import java.lang.Override;import java.lang.String;import java.util.Map;public class ARouter$$Group$$coolqiActivity implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put(\"/coolqiActivity/MyActivity\", RouteMeta.build(RouteType.ACTIVITY, MyActivity.class, \"/coolqiactivity/myactivity\", \"coolqiactivity\", null, -1, -2147483648)); &#125;&#125;public class ARouter$$Group$$coolqiProvider implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put(\"/coolqiProvider/MyIProvider\", RouteMeta.build(RouteType.PROVIDER, MyIProvider.class, \"/coolqiprovider/myiprovider\", \"coolqiprovider\", null, -1, -2147483648)); &#125;&#125;public class ARouter$$Group$$coolqiService implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put(\"/coolqiService/MySerializationService\", RouteMeta.build(RouteType.PROVIDER, MySerializationService.class, \"/coolqiservice/myserializationservice\", \"coolqiservice\", null, -1, -2147483648)); &#125;&#125; 其他的就不说了，反正就是看代码！ ARouter$$Providers$$app.java 1234567891011121314151617181920package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.enums.RouteType;import com.alibaba.android.arouter.facade.model.RouteMeta;import com.alibaba.android.arouter.facade.template.IProviderGroup;import com.pa.sales2.test.MyIProvider;import com.pa.sales2.test.MySerializationService;import java.lang.Override;import java.lang.String;import java.util.Map;public class ARouter$$Providers$$Coolqi implements IProviderGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123; providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, MySerializationService.class, \"/coolqiService/MySerializationService\", \"coolqiService\", null, -1, -2147483648)); providers.put(\"com.pa.sales2.test.MyIProvider\", RouteMeta.build(RouteType.PROVIDER, MyIProvider.class, \"/coolqiProvider/MyIProvider\", \"coolqiProvider\", null, -1, -2147483648)); &#125;&#125; 其他的就不说了，反正就是看代码！ ARouter$$Root$$app.java 1234567891011121314151617package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.template.IRouteGroup;import com.alibaba.android.arouter.facade.template.IRouteRoot;import java.lang.Class;import java.lang.Override;import java.lang.String;import java.util.Map;public class ARouter$$Root$$Coolqi implements IRouteRoot &#123; @Override public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put(\"coolqiActivity\", ARouter$$Group$$coolqiActivity.class); routes.put(\"coolqiProvider\", ARouter$$Group$$coolqiProvider.class); routes.put(\"coolqiService\", ARouter$$Group$$coolqiService.class); &#125;&#125; 其他的就不说了，反正就是看代码！ 2.2.3 AutowiredProcessor核心解释器，用于处理 @Autowired 注解： 12345@AutoService(Processor.class)@SupportedAnnotationTypes(&#123;ANNOTATION_TYPE_AUTOWIRED&#125;)public class AutowiredProcessor extends BaseProcessor &#123; ... ... ...&#125; 我们从成员变量，初始化，注解处理三个方面来分析： 2.2.3.1 Field1234//【1】key 表示属性所属的类，value 是一个 list 列表，保存这个类被 Autowired 修饰的所有元素；private Map&lt;TypeElement, List&lt;Element&gt;&gt; parentAndChild = new HashMap&lt;&gt;(); private static final ClassName ARouterClass = ClassName.get(\"com.alibaba.android.arouter.launcher\", \"ARouter\");private static final ClassName AndroidLog = ClassName.get(\"android.util\", \"Log\"); 2.2.3.2 Initinit 方法很简单，没有太多代码： 12345@Overridepublic synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); logger.info(\"&gt;&gt;&gt; AutowiredProcessor init. &lt;&lt;&lt;\");&#125; 2.2.3.3 Process - 处理 Autowired 注解123456789101112131415161718@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; if (CollectionUtils.isNotEmpty(set)) &#123; try &#123; logger.info(\"&gt;&gt;&gt; Found autowired field, start... &lt;&lt;&lt;\"); //【*2.2.3.3.1】对变量进行归类，并找到其所属的类； categories(roundEnvironment.getElementsAnnotatedWith(Autowired.class)); //【*2.2.3.3.2】动态生成 java 类！ generateHelper(); &#125; catch (Exception e) &#123; logger.error(e); &#125; return true; &#125; return false;&#125; 2.2.3.3.1 categories对变量进行归类，并找到其所属的类； 123456789101112131415161718192021222324private void categories(Set&lt;? extends Element&gt; elements) throws IllegalAccessException &#123; if (CollectionUtils.isNotEmpty(elements)) &#123; //【1】遍历所有被 @AutoWired 注解的元素； for (Element element : elements) &#123; //【2】返回封装此元素（非严格意义上）的最里层元素，实际上就是其所属的类； TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); //【3】如果此成员属性是 private 的，那就抛出异常！ if (element.getModifiers().contains(Modifier.PRIVATE)) &#123; throw new IllegalAccessException(\"The inject fields CAN NOT BE 'private'!!! please check field [\" + element.getSimpleName() + \"] in class [\" + enclosingElement.getQualifiedName() + \"]\"); &#125; //【4】将成员属性 element 和所属类元素 enclosingElement 保存到 parentAndChild 中，分类完毕； if (parentAndChild.containsKey(enclosingElement 保存到 )) &#123; parentAndChild.get(enclosingElement).add(element); &#125; else &#123; List&lt;Element&gt; childs = new ArrayList&lt;&gt;(); childs.add(element); parentAndChild.put(enclosingElement, childs); &#125; &#125; logger.info(\"categories finished.\"); &#125;&#125; 可以看到，private 的元素不能用 Autowired 修饰； 2.2.3.3.2 generateHelper动态生成 java 类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157private void generateHelper() throws IOException, IllegalAccessException &#123; //【1】获得 .ISyringe/.SerializationService 接口在编译时期的状态信息； TypeElement type_ISyringe = elementUtils.getTypeElement(ISYRINGE); TypeElement type_JsonService = elementUtils.getTypeElement(JSON_SERVICE); //【2】返回类型信息：类/接口 TypeMirror iProvider = elementUtils.getTypeElement(Consts.IPROVIDER).asType(); TypeMirror activityTm = elementUtils.getTypeElement(Consts.ACTIVITY).asType(); TypeMirror fragmentTm = elementUtils.getTypeElement(Consts.FRAGMENT).asType(); TypeMirror fragmentTmV4 = elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType(); //【3】开始动态生成类： //【3.1】生成 inject 方法的参数：Object target ParameterSpec objectParamSpec = ParameterSpec.builder(TypeName.OBJECT, \"target\").build(); if (MapUtils.isNotEmpty(parentAndChild)) &#123; // 遍历 parentAndChild 集合； for (Map.Entry&lt;TypeElement, List&lt;Element&gt;&gt; entry : parentAndChild.entrySet()) &#123; //【3.2】生成 inject 方法签名； // @Override // public void inject(Object target) MethodSpec.Builder injectMethodBuilder = MethodSpec.methodBuilder(METHOD_INJECT) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(objectParamSpec); TypeElement parent = entry.getKey(); List&lt;Element&gt; childs = entry.getValue(); //【3.3】获得所属类的全限定名，包名； String qualifiedName = parent.getQualifiedName().toString(); String packageName = qualifiedName.substring(0, qualifiedName.lastIndexOf(\".\")); //【3.4】获得所属类的类名，拼接 \"$$ARouter$$Root$$Autowired\" 作为动态生成类的类名； String fileName = parent.getSimpleName() + NAME_OF_AUTOWIRED; logger.info(\"&gt;&gt;&gt; Start process \" + childs.size() + \" field in \" + parent.getSimpleName() + \" ... &lt;&lt;&lt;\"); //【3.5】创建生成 java 类 helper 对象：指定类名(fileName)，实现的接口(.ISyringe), 修饰符(public) TypeSpec.Builder helper = TypeSpec.classBuilder(fileName) .addJavadoc(WARNING_TIPS) .addSuperinterface(ClassName.get(type_ISyringe)) .addModifiers(PUBLIC); //【3.6】创建动态类的成员变量： // private com.alibaba.android.arouter.facade.service.SerializationService serializationService; FieldSpec jsonServiceField = FieldSpec.builder(TypeName.get(type_JsonService.asType()), \"serializationService\", Modifier.PRIVATE).build(); helper.addField(jsonServiceField); //【3.5】给 inject 增加方法体： // serializationService = com.alibaba.android.arouter.launcher.ARouter.getInstance() // .navigation(com.alibaba.android.arouter.facade.service.SerializationService.class); // parentClass substitute = (parentClass) target injectMethodBuilder.addStatement(\"serializationService = $T.getInstance().navigation($T.class)\", ARouterClass, ClassName.get(type_JsonService)); injectMethodBuilder.addStatement(\"$T substitute = ($T)target\", ClassName.get(parent), ClassName.get(parent)); //【3.6】继续给 inject 增加方法体：（处理成员变量） for (Element element : childs) &#123; Autowired fieldConfig = element.getAnnotation(Autowired.class); //【3.6.1】获取变量的名称； String fieldName = element.getSimpleName().toString(); //【3.6.2】如果实现了 .IProvider 接口，针对于是否设置了 name 属性，进行 byType/ byName 分类处理； if (types.isSubtype(element.asType(), iProvider)) &#123; // It's provider if (\"\".equals(fieldConfig.name())) &#123; //【3.6.2.1】如果 Autowired.name 为空，生成如下代码： // substitute.变量名 = com.alibaba.android.arouter.launcher.ARouter.getInstance() // .navigation(变量类型的全限定名.class); injectMethodBuilder.addStatement( \"substitute.\" + fieldName + \" = $T.getInstance().navigation($T.class)\", ARouterClass, ClassName.get(element.asType()) ); &#125; else &#123; //【3.6.2.2】如果 Autowired.name 不为空，生成如下代码： // substitute.变量名 = (变量类型的全限定名) com.alibaba.android.arouter.launcher.ARouter.getInstance() // .build(Autowired().name).navigation(); injectMethodBuilder.addStatement( \"substitute.\" + fieldName + \" = ($T)$T.getInstance().build($S).navigation()\", ClassName.get(element.asType()), ARouterClass, fieldConfig.name() ); &#125; //【3.6.2.3】判断 Autowired 的 required 是否为 true，如果为 true，那就要禁止 null 的情况！ // 其实就是判断 substitute.变量 如果 null，抛出异常； if (fieldConfig.required()) &#123; injectMethodBuilder.beginControlFlow(\"if (substitute.\" + fieldName + \" == null)\"); injectMethodBuilder.addStatement( \"throw new RuntimeException(\\\"The field '\" + fieldName + \"' is null, in class '\\\" + $T.class.getName() + \\\"!\\\")\", ClassName.get(parent)); injectMethodBuilder.endControlFlow(); &#125; &#125; else &#123; //【3.6.3】对于一般的可通过 intent 传递的变量，进入这里； String originalValue = \"substitute.\" + fieldName; // 用于拼接成员变量的生成方式：\"substitute.变量名 = substitute.\"； //【*2.2.3.3.2.1】对于实现了 serializable 接口的变量, 则是：\"substitute.变量名 = (变量类型的全限定名) substitute.\" String statement = \"substitute.\" + fieldName + \" = \" + buildCastCode(element) + \"substitute.\"; boolean isActivity = false; if (types.isSubtype(parent.asType(), activityTm)) &#123; //【3.6.4.1】如果是 activity，那么拼接代码：getIntent(). isActivity = true; statement += \"getIntent().\"; &#125; else if (types.isSubtype(parent.asType(), fragmentTm) || types.isSubtype(parent.asType(), fragmentTmV4)) &#123; //【3.6.4.2】如果是 fragment，那么拼接代码：getArguments(). statement += \"getArguments().\"; &#125; else &#123; throw new IllegalAccessException(\"The field [\" + fieldName + \"] need autowired from intent, \" + \"its parent must be activity or fragment!\"); &#125; //【*2.2.3.3.2.2】处理 getIntent()/getArguments() 的数据； // typeUtils.typeExchange(element) 返回的是成员属性的枚举序号！ statement = buildStatement(originalValue, statement, typeUtils.typeExchange(element), isActivity); if (statement.startsWith(\"serializationService.\")) &#123; //【3.6.5.1】处理 serializationService（自定义对象）的情况： injectMethodBuilder.beginControlFlow(\"if (null != serializationService)\"); //【3.6.5.2】生成方法体：\"substitute.fieldName = \" + statement; // $S 被替换为变量名/Autowired.name，$T 被替换为变量类型的全限定名； injectMethodBuilder.addStatement( \"substitute.\" + fieldName + \" = \" + statement, (StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name()), ClassName.get(element.asType()) ); injectMethodBuilder.nextControlFlow(\"else\"); injectMethodBuilder.addStatement( \"$T.e(\\\"\" + Consts.TAG + \"\\\", \\\"You want automatic inject the field '\" + fieldName + \"' in class '$T' , then you should implement 'SerializationService'\" + \" to support object auto inject!\\\")\", AndroidLog, ClassName.get(parent)); injectMethodBuilder.endControlFlow(); &#125; else &#123; //【3.6.5.3】处理其他的情况，如果 Autowired.name 不为 null，那么 $S 替换为变量名，否则为 Autowired.name // 将方法体写入 inject； injectMethodBuilder.addStatement(statement, StringUtils.isEmpty(fieldConfig.name()) ? fieldName : fieldConfig.name()); &#125; // Autowired 的 required 为 true，且不是 private 的，非空判断； if (fieldConfig.required() &amp;&amp; !element.asType().getKind().isPrimitive()) &#123; injectMethodBuilder.beginControlFlow(\"if (null == substitute.\" + fieldName + \")\"); injectMethodBuilder.addStatement( \"$T.e(\\\"\" + Consts.TAG + \"\\\", \\\"The field '\" + fieldName + \"' is null, in class '\\\" + $T.class.getName() + \\\"!\\\")\", AndroidLog, ClassName.get(parent)); injectMethodBuilder.endControlFlow(); // 闭合方法体； &#125; &#125; &#125; helper.addMethod(injectMethodBuilder.build()); // 将方法 builder 加入到类 builder 中； //【4】动态创建 java 文件； JavaFile.builder(packageName, helper.build()).build().writeTo(mFiler); logger.info(\"&gt;&gt;&gt; \" + parent.getSimpleName() + \" has been processed, \" + fileName + \" has been generated. &lt;&lt;&lt;\"); &#125; logger.info(\"&gt;&gt;&gt; Autowired processor stop. &lt;&lt;&lt;\"); &#125;&#125; 整个流程我们分析完成了，我们先不关注动态生成的类的作用，在后面分析 arouter-api 模块的时候，就会知道这些类的作用是什么了。 2.2.3.3.2.1 buildCastCode判断 element 的类型是否是 SERIALIZABLE 的，这里利用到了前面的枚举类 TypeKind 和工具类 typeUtils： 12345678private String buildCastCode(Element element) &#123; //【1】判断 element 的类型是否是 SERIALIZABLE 的！ if (typeUtils.typeExchange(element) == TypeKind.SERIALIZABLE.ordinal()) &#123; //【2】创建代码块：(变量类型的全限定名) return CodeBlock.builder().add(\"($T) \", ClassName.get(element.asType())).build().toString(); &#125; return \"\";&#125; 这个主要是针对于实现了 serializable 接口的变量，比如一些集合等等； 2.2.3.3.2.2 buildStatement处理 getIntent()/getArguments() 的数据： 参数 originalValue 表示变量: “substitute.fieldName“，用于返回默认值； 参数 type 是成员属性对应的枚举序号： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private String buildStatement(String originalValue, String statement, int type, boolean isActivity) &#123; switch (TypeKind.values()[type]) &#123; case BOOLEAN: //【1】如果是 boolean，那么 activty 拼接：getBooleanExtra($S, 变量)，fragment 拼接：getBoolean($S) statement += (isActivity ? (\"getBooleanExtra($S, \" + originalValue + \")\") : (\"getBoolean($S)\")); break; case BYTE: //【2】如果是 byte，那么 activty 拼接：getByteExtra($S, 变量)，fragment 拼接：getByte($S) statement += (isActivity ? (\"getByteExtra($S, \" + originalValue + \")\") : (\"getByte($S)\")); break; case SHORT: //【3】如果是 short，那么 activty 拼接：getShortExtra($S, 变量)，fragment 拼接：getShort($S) statement += (isActivity ? (\"getShortExtra($S, \" + originalValue + \")\") : (\"getShort($S)\")); break; case INT: //【4】如果是 int，那么 activty 拼接：getIntExtra($S, 变量)，fragment 拼接：getInt($S) statement += (isActivity ? (\"getIntExtra($S, \" + originalValue + \")\") : (\"getInt($S)\")); break; case LONG: //【5】如果是 long，那么 activty 拼接：getLongExtra($S, 变量)，fragment 拼接：getLong($S) statement += (isActivity ? (\"getLongExtra($S, \" + originalValue + \")\") : (\"getLong($S)\")); break; case CHAR: //【6】如果是 char，那么 activty 拼接：getCharExtra($S, 变量)，fragment 拼接：getChar($S) statement += (isActivity ? (\"getCharExtra($S, \" + originalValue + \")\") : (\"getChar($S)\")); break; case FLOAT: //【7】如果是 float，那么 activty 拼接：getFloatExtra($S, 变量)，fragment 拼接：getFloat($S) statement += (isActivity ? (\"getFloatExtra($S, \" + originalValue + \")\") : (\"getFloat($S)\")); break; case DOUBLE: //【8】如果是 double，那么 activty 拼接：getDoubleExtra($S, 变量)，fragment 拼接：getDouble($S) statement += (isActivity ? (\"getDoubleExtra($S, \" + originalValue + \")\") : (\"getDouble($S)\")); break; case STRING: //【9】如果是 string，那么 activty 拼接：getExtras() == null ? 变量 : substitute.getIntent().getExtras().getString($S, 变量) // fragment 拼接：getString($S) statement += (isActivity ? (\"getExtras() == null ? \" + originalValue + \" : substitute.getIntent().getExtras().getString($S, \" + originalValue + \")\") : (\"getString($S)\")); break; case SERIALIZABLE: //【10】如果是 serializable，那么 activty 拼接：getSerializableExtra($S) // fragment 拼接：getSerializable($S) statement += (isActivity ? (\"getSerializableExtra($S)\") : (\"getSerializable($S)\")); break; case PARCELABLE: //【11】如果是 parcelable，那么 activty 拼接：getParcelableExtra($S) // fragment 拼接：getParcelable($S) statement += (isActivity ? (\"getParcelableExtra($S)\") : (\"getParcelable($S)\")); break; case OBJECT: //【12】如果是 object，那么 activity 返回：serializationService.parseObject(substitute.getIntent().getStringExtra($S), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;$T&gt;()&#123;&#125;.getType()) // fragment 返回：serializationService.parseObject(substitute.getArguments().getString($S), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;$T&gt;()&#123;&#125;.getType()) statement = \"serializationService.parseObject(substitute.\" + (isActivity ? \"getIntent().\" : \"getArguments().\") + (isActivity ? \"getStringExtra($S)\" : \"getString($S)\") + \", new \" + TYPE_WRAPPER + \"&lt;$T&gt;()&#123;&#125;.getType())\"; break; &#125; return statement;&#125; 可以看到，buildStatement 会处理 getIntent()/getArguments() 的数据，在 statement 基础上拼接/修改： Activity - 生成的 statement 变量类型 动态生成的代码块 boolean substitute.变量 = substitute.getIntent().getBooleanExtra($S, 变量) byte substitute.变量 = substitute.getIntent().getByteExtra($S, 变量) short substitute.变量 = substitute.getIntent().getShortExtra($S, 变量) int substitute.变量 = substitute.getIntent().getIntExtra($S, 变量) long substitute.变量 = substitute.getIntent().getLongExtra($S, 变量) char substitute.变量 = substitute.getIntent().getCharExtra($S, 变量) float substitute.变量 = substitute.getIntent().getFloatExtra($S, 变量) double substitute.变量 = substitute.getIntent().getDoubleExtra($S, 变量) string substitute.变量 = substitute.getIntent().getExtras() == null ? 变量 : substitute.getIntent().getExtras().getString($S, 变量) serializable substitute.变量 = (变量类型的全限定名) substitute.getIntent().getSerializableExtra($S) parcelable substitute.变量 = substitute.getIntent().getParcelableExtra($S) object serializationService.parseObject(substitute.getIntent().getStringExtra($S), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;$T&gt;(){}.getType()) 这里的 $S, $T，依然是作为占位符，并没有被替换成实体的类型； Fragment - 生成的 statement 变量类型 动态生成的代码块 boolean substitute.变量 = substitute.getArguments().getBoolean($S) byte substitute.变量 = substitute.getArguments().getByte($S) short substitute.变量 = substitute.getArguments().getShort($S) int substitute.变量 = substitute.getArguments().getInt($S) long substitute.变量 = substitute.getArguments().getLong($S) char substitute.变量 = substitute.getArguments().getChar($S) float substitute.变量 = substitute.getArguments().getFloat($S) double substitute.变量 = substitute.getArguments().getDouble($S) string substitute.变量 = substitute.getArguments().getString($S) serializable substitute.变量 = (变量类型的全限定名) substitute.getArguments().getSerializable($S) parcelable substitute.变量 = substitute.getArguments().getParcelable($S) object serializationService.parseObject(substitute.getArguments().getString($S), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;$T&gt;(){}.getType()) 这里的 $S, $T，依然是作为占位符，并没有被替换成实体的类型； 返回的 statement 会继续被处理！ 2.2.3.4 动态生成类2.2.3.4.1 模版信息我们来看一下，解析 AutoWired 后动态生成的 java 类的模版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package 所属类所在的包;import com.alibaba.android.arouter.facade.template.ISyringe;import com.alibaba.android.arouter.facade.service.SerializationService;import com.alibaba.android.arouter.launcher.ARouter;import ... ... ...// 省略掉其他的导入信息（变量类型等等）class 所属类的类名$$ARouter$$Root$$Autowired implements ISyringe &#123; private SerializationService serializationService; @Override public void inject(Object target) &#123; serializationService = ARouter.getInstance().navigation(SerializationService.class); 所属类的全限定名 substitute = (所属类的全限定名) target; // 实现了 .IProvider 的成员变量； substitute.变量 = ARouter.getInstance().navigation(变量类型的全限定名.class); substitute.变量 = (变量类型) ARouter.getInstance().build(Autowired.name).navigation(); // Autowired 的 required 为 true 才有； if (substitute.变量 == null) &#123; throw new RuntimeException(...); &#125; // activity 的成员； substitute.变量 = substitute.getIntent().getBooleanExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getByteExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getShortExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getIntExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getCharExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getFloatExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getDoubleExtra(变量名/Autowired.name, substitute.变量); substitute.变量 = substitute.getIntent().getExtras() == null ? substitute.变量 : substitute.getIntent().getExtras().getString(变量名/Autowired.name, substitute.变量); substitute.变量 = (变量类型) substitute.getIntent().getSerializableExtra(变量名/Autowired.name); substitute.变量 = substitute.getIntent().getParcelableExtra(变量名/Autowired.name); substitute.变量 = serializationService.parseObject(substitute.getIntent().getStringExtra(变量名/Autowired.name), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;变量类型&gt;()&#123;&#125;.getType()); // fragment 的成员； substitute.变量 = substitute.getArguments().getBoolean(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getByte(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getShort(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getInt(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getLong(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getChar(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getFloat(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getDouble(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getString(变量名/Autowired.name); substitute.变量 = (变量类型) substitute.getArguments().getSerializable(变量名/Autowired.name); substitute.变量 = substitute.getArguments().getParcelable(变量名/Autowired.name); serializationService.parseObject(substitute.getArguments().getString(变量名/Autowired.name), new com.alibaba.android.arouter.facade.model.TypeWrapper&lt;变量类型&gt;()&#123;&#125;.getType()); &#125;&#125; 其实大家可以看的出来，inject 方法就是用来自动给成员变量赋值的； 2.2.3.4.2 举个栗子2.2.3.4.2.1 实例代码以 activity 为例子； 1234567891011121314151617181920212223242526package com.lishuaiqi.test;import android.app.Activity;import android.os.Bundle;import android.support.annotation.Nullable;import com.alibaba.android.arouter.facade.annotation.Autowired;import com.alibaba.android.arouter.facade.annotation.Route;import com.alibaba.android.arouter.launcher.ARouter;/** * Created by lishuaiqi */@Route(path = \"/app/MyActivity\")public class MyActivity extends Activity &#123; @Autowired(name = \"isOneAuto\") public boolean isOne; @Autowired(name = \"isTwoAuto\") public int isTwo; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); &#125;&#125; 2.2.3.4.2.2 动态代码如下是动态代码了，不多说了： 123456789101112131415161718192021package com.lishuaiqi.test;import com.alibaba.android.arouter.facade.service.SerializationService;import com.alibaba.android.arouter.facade.template.ISyringe;import com.alibaba.android.arouter.launcher.ARouter;import java.lang.Object;import java.lang.Override;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class MyActivity$$ARouter$$Autowired implements ISyringe &#123; private SerializationService serializationService; @Override public void inject(Object target) &#123; serializationService = ARouter.getInstance().navigation(SerializationService.class); MyActivity substitute = (MyActivity)target; substitute.isOne = substitute.getIntent().getBooleanExtra(\"isOneAuto\", substitute.isOne); substitute.isTwo = substitute.getIntent().getIntExtra(\"isTwoAuto\", substitute.isTwo); &#125;&#125; 2.2.4 InterceptorProcessor核心解释器，用于处理 @Interceptor 注解： 12345@AutoService(Processor.class)@SupportedAnnotationTypes(ANNOTATION_TYPE_INTECEPTOR)public class InterceptorProcessor extends BaseProcessor &#123; ... ... ...&#125; 我们从成员变量，初始化，注解处理三个方面来分析： 2.2.4.1 Field成员变量有两个： 1234//【1】用于保存 key: [priority 优先级] 和 value：[@Interceptor 修饰的元素 Element] 的映射关系，作为 cache； private Map&lt;Integer, Element&gt; interceptors = new TreeMap&lt;&gt;();//【2】用于保存 [com.alibaba.android.arouter.facade.template.IInterceptor] 的类型信息private TypeMirror iInterceptor = null; 2.2.4.2 Init初始化操作： 12345678@Overridepublic synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); //【1】Elements.getTypeElement 会返回 .IInterceptor 接口对应的 TypeElement // TypeElement.sType() 会返回 .IInterceptor 的类型信息：接口 iInterceptor = elementUtils.getTypeElement(Consts.IINTERCEPTOR).asType(); logger.info(\"&gt;&gt;&gt; InterceptorProcessor init. &lt;&lt;&lt;\");&#125; 这里的 Consts.IINTERCEPTOR 是 IInterceptor 接口的全限定名： com.alibaba.android.arouter.facade.template.IInterceptor 2.2.4.3 Process - 处理 Interceptor 注解12345678910111213141516@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; if (CollectionUtils.isNotEmpty(annotations)) &#123; //【1】获得 @Interceptor 修饰的元素，这里会返回多个 Element 组成的 set！！ Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Interceptor.class); try &#123; //【*2.2.4.3.1】解析元素： parseInterceptors(elements); &#125; catch (Exception e) &#123; logger.error(e); &#125; return true; &#125; return false;&#125; 核心逻辑在 parseInterceptors 中； 2.2.4.3.1 parseInterceptors我们来看下如何解析元素： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void parseInterceptors(Set&lt;? extends Element&gt; elements) throws IOException &#123; if (CollectionUtils.isNotEmpty(elements)) &#123; logger.info(\"&gt;&gt;&gt; Found interceptors, size is \" + elements.size() + \" &lt;&lt;&lt;\"); //【1】执行校验，并将元素缓存下来； for (Element element : elements) &#123; //【*2.2.4.3.1.1】执行校验； if (verify(element)) &#123; logger.info(\"A interceptor verify over, its \" + element.asType()); //【1.1】获得 Interceptor 对象的优先级，判断是否已经添加到 interceptors 哈希表中，已经添加，抛出异常； Interceptor interceptor = element.getAnnotation(Interceptor.class); Element lastInterceptor = interceptors.get(interceptor.priority()); if (null != lastInterceptor) &#123; // Added, throw exceptions throw new IllegalArgumentException( String.format(Locale.getDefault(), \"More than one interceptors use same\" + \"priority [%d], They are [%s] and [%s].\", interceptor.priority(), lastInterceptor.getSimpleName(), element.getSimpleName()) ); &#125; //【1.2】将 priority --&gt; element 关系缓存到 interceptors 中； interceptors.put(interceptor.priority(), element); &#125; else &#123; logger.error(\"A interceptor verify failed, its \" + element.asType()); &#125; &#125; //【2】返回 \".IInterceptor/.IInterceptorGroup\" 接口对应的 TypeElement，保存了接口在编译时期的状态信息； TypeElement type_ITollgate = elementUtils.getTypeElement(IINTERCEPTOR); TypeElement type_ITollgateGroup = elementUtils.getTypeElement(IINTERCEPTOR_GROUP); //【3】生成 loadInto 方法的参数类型：\"Map&lt;Integer, Class&lt;? extends ITollgate&gt;&gt;\"\" ParameterizedTypeName inputMapTypeOfTollgate = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(Integer.class), ParameterizedTypeName.get( ClassName.get(Class.class), WildcardTypeName.subtypeOf(ClassName.get(type_ITollgate)) ) ); //【4】生成 loadInto 方法的方法参数：“Map&lt;Integer, Class&lt;? extends ITollgate&gt;&gt; interceptors” ParameterSpec tollgateParamSpec = ParameterSpec.builder(inputMapTypeOfTollgate, \"interceptors\").build(); //【5】生成 loadInto 方法声明： // @Override // public void loadInto(Map&lt;Integer, Class&lt;? extends ITollgate&gt;&gt; interceptors)&#123;...&#125; MethodSpec.Builder loadIntoMethodOfTollgateBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(tollgateParamSpec); //【6】生成 loadInto 方法体: // @Override // public void loadInto(Map&lt;Integer, Class&lt;? extends ITollgate&gt;&gt; interceptors)&#123; // interceptors.put(priority, $T.class); // &#125; if (null != interceptors &amp;&amp; interceptors.size() &gt; 0) &#123; // for 循环中 interceptors 是 InterceptorProcessor 的成员变量哦！用来保存所有的 interceptor； // $T 最终会被替换为自定义的 interceptor 的类全限定名； for (Map.Entry&lt;Integer, Element&gt; entry : interceptors.entrySet()) &#123; loadIntoMethodOfTollgateBuilder.addStatement(\"interceptors.put(\" + entry.getKey() + \", $T.class)\", ClassName.get((TypeElement) entry.getValue())); &#125; &#125; //【7】生成最终的类文件，指定了包名，类名，修饰符，实现的接口等等； // 常量均定义在 Consts 中，具体的生成的类见下面…… JavaFile.builder(PACKAGE_OF_GENERATE_FILE, TypeSpec.classBuilder(NAME_OF_INTERCEPTOR + SEPARATOR + moduleName) .addModifiers(PUBLIC) .addJavadoc(WARNING_TIPS) .addMethod(loadIntoMethodOfTollgateBuilder.build()) .addSuperinterface(ClassName.get(type_ITollgateGroup)) .build() ).build().writeTo(mFiler); logger.info(\"&gt;&gt;&gt; Interceptor group write over. &lt;&lt;&lt;\"); &#125;&#125; 可以看到其是使用 javapoet 三方库来懂爱生成 .java 文件； 2.2.4.3.1.1 verify校验元素和注解的正确性： 1234567private boolean verify(Element element) &#123; //【1】获得注解对象； Interceptor interceptor = element.getAnnotation(Interceptor.class); //【2】元素 Element 必须被 Interceptor 注解修饰， // 并且其实现了 com.alibaba.android.arouter.facade.template.IInterceptor 接口； return null != interceptor &amp;&amp; ((TypeElement) element).getInterfaces().contains(iInterceptor);&#125; end～ 2.2.4.4 动态生成类2.2.4.4.1 模版信息最终生成的 java 文件名为： 1ARouter$$Interceptors$$&#123;moduleName&#125;.java 最终生成的模版类信息为： 12345678910111213141516package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.template.IInterceptor;import com.alibaba.android.arouter.facade.template.IInterceptorGroup;import java.lang.Class;import java.lang.Integer;import java.lang.Override;import java.util.Map;... ... ...public class ARouter$$Interceptors$$$&#123;moduleName&#125; implements IInterceptorGroup &#123; @Override public void loadInto(Map&lt;Integer, Class&lt;? extends ITollgate&gt;&gt; interceptors)&#123; interceptors.put($&#123;priority&#125;, $&#123;InterceptorName&#125;.class); &#125;&#125; 可以看到，对于 Interceptor，ARouter 也是采取分组管理的方式： 以 module 为组，组名为 ARouter$$Interceptors$${moduleName}； 2.2.4.4.2 举个栗子2.2.4.4.2.1 实例代码我们自定义了一个拦截器： 1234567891011121314151617181920212223package com.lishuaiqi.test;import android.content.Context;import com.alibaba.android.arouter.facade.Postcard;import com.alibaba.android.arouter.facade.annotation.Interceptor;import com.alibaba.android.arouter.facade.callback.InterceptorCallback;import com.alibaba.android.arouter.facade.template.IInterceptor;/** * Created by lishuaiqi */@Interceptor(priority = 8, name = \"测试用拦截器\")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; &#125; @Override public void init(Context context) &#123; &#125;&#125; 2.2.4.4.2.2 动态代码看看最终的代码： 123456789101112131415161718package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.template.IInterceptor;import com.alibaba.android.arouter.facade.template.IInterceptorGroup;import com.lishuaiqi.test.TestInterceptor;import java.lang.Class;import java.lang.Integer;import java.lang.Override;import java.util.Map;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Interceptors$$Coolqi implements IInterceptorGroup &#123; @Override public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(8, TestInterceptor.class); &#125;&#125; 2.3 utils该 package 下包含了一些工具类： 2.3.1 Logger用于打印 log 信息，调试使用； 123456789101112131415161718192021222324252627282930313233343536373839404142public class Logger &#123; private Messager msg; public Logger(Messager messager) &#123; msg = messager; &#125; public void info(CharSequence info) &#123; if (StringUtils.isNotEmpty(info)) &#123; msg.printMessage(Diagnostic.Kind.NOTE, Consts.PREFIX_OF_LOGGER + info); &#125; &#125; public void error(CharSequence error) &#123; if (StringUtils.isNotEmpty(error)) &#123; msg.printMessage(Diagnostic.Kind.ERROR, Consts.PREFIX_OF_LOGGER + \"An exception is encountered, [\" + error + \"]\"); &#125; &#125; public void error(Throwable error) &#123; if (null != error) &#123; msg.printMessage(Diagnostic.Kind.ERROR, Consts.PREFIX_OF_LOGGER + \"An exception is encountered, [\" + error.getMessage() + \"]\" + \"\\n\" + formatStackTrace(error.getStackTrace())); &#125; &#125; public void warning(CharSequence warning) &#123; if (StringUtils.isNotEmpty(warning)) &#123; msg.printMessage(Diagnostic.Kind.WARNING, Consts.PREFIX_OF_LOGGER + warning); &#125; &#125; private String formatStackTrace(StackTraceElement[] stackTrace) &#123; StringBuilder sb = new StringBuilder(); for (StackTraceElement element : stackTrace) &#123; sb.append(\" at \").append(element.toString()); sb.append(\"\\n\"); &#125; return sb.toString(); &#125; 方法都比较简单，就不多说了。 2.3.2 TypeUtils该类是一个类型工具类，主要用于获取元素的类型，并对类型做一个转换； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TypeUtils &#123; private Types types; private TypeMirror parcelableType; private TypeMirror serializableType; public TypeUtils(Types types, Elements elements) &#123; this.types = types; parcelableType = elements.getTypeElement(PARCELABLE).asType(); serializableType = elements.getTypeElement(SERIALIZABLE).asType(); &#125; //【1】可以看到，这个方法用于返回枚举常量的序数。这里的枚举常量是前面分析的 TypeKind.XXX public int typeExchange(Element element) &#123; TypeMirror typeMirror = element.asType(); //【1】对于 private，类型这里直接处理； if (typeMirror.getKind().isPrimitive()) &#123; return element.asType().getKind().ordinal(); &#125; //【2】对于 no private 的类型，返回变量的类型，通过 TypeKind 找到类型对应的序数（0，1，2...） switch (typeMirror.toString()) &#123; case BYTE: return TypeKind.BYTE.ordinal(); case SHORT: return TypeKind.SHORT.ordinal(); case INTEGER: return TypeKind.INT.ordinal(); case LONG: return TypeKind.LONG.ordinal(); case FLOAT: return TypeKind.FLOAT.ordinal(); case DOUBEL: return TypeKind.DOUBLE.ordinal(); case BOOLEAN: return TypeKind.BOOLEAN.ordinal(); case CHAR: return TypeKind.CHAR.ordinal(); case STRING: return TypeKind.STRING.ordinal(); default: //【3】处理 PARCELABLE，SERIALIZABLE 和 OBJECT 的情况； if (types.isSubtype(typeMirror, parcelableType)) &#123; // PARCELABLE return TypeKind.PARCELABLE.ordinal(); &#125; else if (types.isSubtype(typeMirror, serializableType)) &#123; // SERIALIZABLE return TypeKind.SERIALIZABLE.ordinal(); &#125; else &#123; return TypeKind.OBJECT.ordinal(); &#125; &#125; &#125; TypeKind 前面有分析过，其是一个枚举类！ 2.3.3 Consts用于保存一些核心的常量，下面来看看核心的常量。 2.3.3.1 Log 打印相关这些是和 log 打印相关的，比较简单： 1234567891011121314public static final String PROJECT = \"ARouter\"; // 这个常量其他常量也会用到；public static final String TAG = PROJECT + \"::\";static final String PREFIX_OF_LOGGER = PROJECT + \"::Compiler \";public static final String NO_MODULE_NAME_TIPS = \"These no module name, at 'build.gradle', like :\\n\" + \"android &#123;\\n\" + \" defaultConfig &#123;\\n\" + \" ...\\n\" + \" javaCompileOptions &#123;\\n\" + \" annotationProcessorOptions &#123;\\n\" + \" arguments = [AROUTER_MODULE_NAME: project.getName()]\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \"&#125;\\n\"; 不多说！ 2.3.3.2 Gradle 配置相关这些是和 gradle 配置相关的机制： 123public static final String KEY_MODULE_NAME = \"AROUTER_MODULE_NAME\";public static final String KEY_GENERATE_DOC_NAME = \"AROUTER_GENERATE_DOC\";public static final String VALUE_ENABLE = \"enable\"; 这个前面有说过，通过 gradle 配置； 2.3.3.3 系统核心类这些是和 Android 系统的一些核心类有关，也是 ARouter 能够注解处理的类： 12345public static final String ACTIVITY = \"android.app.Activity\";public static final String FRAGMENT = \"android.app.Fragment\";public static final String FRAGMENT_V4 = \"android.support.v4.app.Fragment\";public static final String SERVICE = \"android.app.Service\";public static final String PARCELABLE = \"android.os.Parcelable\"; 可以看到，都是系统类的全限定名； 2.3.3.4 注解类型这些是和 ARouter 的注解相关的常量： 1234private static final String FACADE_PACKAGE = \"com.alibaba.android.arouter.facade\"; // 这个常量其他常量也会用到；public static final String ANNOTATION_TYPE_INTECEPTOR = FACADE_PACKAGE + \".annotation.Interceptor\";public static final String ANNOTATION_TYPE_ROUTE = FACADE_PACKAGE + \".annotation.Route\";public static final String ANNOTATION_TYPE_AUTOWIRED = FACADE_PACKAGE + \".annotation.Autowired\"; 可以看到，都是注解的全限定名； 2.3.3.5 核心接口和类这些是和 ARouter 提供的一些核心接口： 1234567891011121314151617//【1】用于指定不同的 package 目录，属于 arouter-api 模块；private static final String FACADE_PACKAGE = \"com.alibaba.android.arouter.facade\";private static final String TEMPLATE_PACKAGE = \".template\";private static final String SERVICE_PACKAGE = \".service\";private static final String MODEL_PACKAGE = \".model\";//【2】下面是 arouter-api 模块的 template 包下的接口的全限定名；public static final String IPROVIDER = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".IProvider\";public static final String IPROVIDER_GROUP = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".IProviderGroup\";public static final String IINTERCEPTOR = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".IInterceptor\";public static final String IINTERCEPTOR_GROUP = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".IInterceptorGroup\";public static final String ITROUTE_ROOT = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".IRouteRoot\";public static final String IROUTE_GROUP = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".IRouteGroup\";public static final String ISYRINGE = FACADE_PACKAGE + TEMPLATE_PACKAGE + \".ISyringe\";//【3】下面是 arouter-api 模块的 service 包下的服务的全限定名；public static final String JSON_SERVICE = FACADE_PACKAGE + SERVICE_PACKAGE + \".SerializationService\";//【4】下面是 arouter-annotation 模块的 model 包下的服务的全限定名；public static final String TYPE_WRAPPER = FACADE_PACKAGE + MODEL_PACKAGE + \".TypeWrapper\"; 同样的，也是一些全限定名； ARouter 的拦截器需要实现 IInterceptor 接口，服务需要实现 IProvider 接口； 同时，由于 ARouter 是分组管理的，所以拦截器和服务又会属于不同的组：拦截器组需要实现 IInterceptorGroup 接口，服务组需要实现 IProviderGroup 组； 对于跳转来说，也会有分组，跳转组需要实现 IRouteGroup，而所有的跳转组属于一个 root：IRouteRoot 2.3.3.6 动态生成类下面 这些是和动态生成的类相关的： 动态生成类的类名； 123456789public static final String SEPARATOR = \"$$\";public static final String PROJECT = \"ARouter\";public static final String METHOD_LOAD_INTO = \"loadInto\";public static final String METHOD_INJECT = \"inject\";public static final String NAME_OF_ROOT = PROJECT + SEPARATOR + \"Root\"; // ARouter$$Rootpublic static final String NAME_OF_PROVIDER = PROJECT + SEPARATOR + \"Providers\"; // ARouter$$Providerspublic static final String NAME_OF_GROUP = PROJECT + SEPARATOR + \"Group\" + SEPARATOR; // ARouter$$Group$$public static final String NAME_OF_INTERCEPTOR = PROJECT + SEPARATOR + \"Interceptors\"; // ARouter$$Interceptorspublic static final String NAME_OF_AUTOWIRED = SEPARATOR + PROJECT + SEPARATOR + \"Autowired\"; //$$ARouter$$Root$$Autowired 动态生成类的类名是通过 “$$” 将关键字拼接起来！ 动态生成类的所属包名； 12public static final String PACKAGE_OF_GENERATE_FILE = \"com.alibaba.android.arouter.routes\";public static final String PACKAGE_OF_GENERATE_DOCS = \"com.alibaba.android.arouter.docs\"; ARouter 会通过 javapoet 来动态生成对应的类，我们在分析 processor 的过程中就会看到。 3 总结本篇文章分析了 arouter-compiler 模块的架构，arouter 内置的三种注解处理器，以及 arouter 注解的处理，动态类的生成。 好累～ 后续上流程图吧～～对于个人收获也是很大的～～至少会自定义注解～～至少会动态生成代码了～～","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"ARouter 第二篇 - 注解定义 (arouter-annotation)","slug":"ARouter2-arouter-annotations","date":"2019-04-17T12:46:25.000Z","updated":"2019-08-09T13:25:03.274Z","comments":true,"path":"2019/04/17/ARouter2-arouter-annotations/","link":"","permalink":"https://coolqi.top/2019/04/17/ARouter2-arouter-annotations/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的架构和原理。 这是阿里 ARouter 开源库的地址，大家可以直接访问https://github.com/alibaba/ARouter 本篇博文主要分析 arouter-annotation 模块； 1 模块结构下面我们来看看 arouter-annotation 的结构； 1234567891011121314151617src -&gt; main -&gt; java:|____com| |____alibaba| | |____android| | | |____arouter| | | | |____facade| | | | | |____enums| | | | | | |____RouteType.java| | | | | | |____TypeKind.java| | | | | |____annotation| | | | | | |____Interceptor.java| | | | | | |____Route.java| | | | | | |____Param.java| | | | | | |____Autowired.java| | | | | |____model| | | | | | |____TypeWrapper.java| | | | | | |____RouteMeta.java 一共有三个 package： enums：包含了一些枚举类： annotation：包含了一些注解； model：包含了一些跳转所需的数据； 2 源码分析2.1 enums这个 package 包含了一些枚举类： 2.1.1 RouteType枚举类，每一个成员都用于保存 id 和 className 的映射！ className 包括 android 的 Activity，Service，ContentProvider，Fragment，以及 ARouter 自己的 IProvider 类型！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public enum RouteType &#123; ACTIVITY(0, \"android.app.Activity\" ), SERVICE(1, \"android.app.Service\"), PROVIDER(2, \"com.alibaba.android.arouter.facade.template.IProvider\"), CONTENT_PROVIDER(-1, \"android.app.ContentProvider\"), BOARDCAST(-1, \"\"), METHOD(-1, \"\"), FRAGMENT(-1, \"android.app.Fragment\"), UNKNOWN(-1, \"Unknown route type\"); int id; String className; public int getId() &#123; return id; &#125; public RouteType setId(int id) &#123; this.id = id; return this; &#125; public String getClassName() &#123; return className; &#125; public RouteType setClassName(String className) &#123; this.className = className; return this; &#125; RouteType(int id, String className) &#123; this.id = id; this.className = className; &#125; public static RouteType parse(String name) &#123; for (RouteType routeType : RouteType.values()) &#123; if (routeType.getClassName().equals(name)) &#123; return routeType; &#125; &#125; return UNKNOWN; &#125;&#125; 代码很简单，不多说。 它的作用是，我们可以通过 RouteType 判断判断 @Route 修饰的是类是那种类型； 2.1.2 TypeKind枚举类，每一个枚举成员都用于表示一个类型，包括基本类型，可序列化类型，字符串，对象等等； 1234567891011121314151617public enum TypeKind &#123; // Base type BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE, // Other type STRING, SERIALIZABLE, PARCELABLE, OBJECT;&#125; 它的作用是在设置跳转数据的时候，通过 TypeKind 来判断数据的类型，然后调用 Postcard.withXXX 方法，设置不同的类型； 2.2 annotation这个 package 包含了一些注解类： 2.2.1 Route用于注解 RouteType 指定的那些 type： 1234567891011121314@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.CLASS)public @interface Route &#123; //【1】用于指定路由跳转的路径，至少包含两级目录； String path(); //【2】用于指定路由跳转的分组，组名必须要使用相同的名称； String group() default \"\"; //【3】路由跳转的名称，用于 javadoc； String name() default \"\"; //【4】用于指定额外的数据，一共 32 位，每一位都是一个开关； int extras() default Integer.MIN_VALUE; //【5】路由跳转的优先级，值越小，优先级越高； int priority() default -1;&#125; 不多说了。 2.2.1.1 简单使用 注解服务 1234@Route(path = \"/xxx/xxx\")public class PretreatmentServiceImpl implements PretreatmentService &#123; ... ... ...&#125; 注解 android 组件 1234@Route(path = &quot;/test/activity&quot;)public class Test1Activity extends Activity &#123; ... ... ...&#125; 2.2.2 Autowired用于修饰成员变量： 1234567891011121314@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.CLASS)public @interface Autowired &#123; //【1】变量（属性或服务）的名称 String name() default \"\"; //【2】是否必须不为 null，如果为 true，应用会 crash 当其为 null 的情况； // private 类型的变量不会检查是否为 null； boolean required() default false; //【2】属性的描述 String desc() default \"\";&#125; 2.2.2.1 简单使用 注解服务 1234@Route(path = \"/xxx/xxx\")public class PretreatmentServiceImpl implements PretreatmentService &#123; ... ... ...&#125; 注解 android 组件 1234@Route(path = &quot;/test/activity&quot;)public class Test1Activity extends Activity &#123; ... ... ...&#125; 2.2.3 Interceptor用于注解拦截器： 123456789@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.CLASS)public @interface Interceptor &#123; //【1】拦截器的优先级，ARouter 会根据优先级执行拦截器； int priority(); //【2】拦截器的名称，用于 javadoc； String name() default \"Default\";&#125; 2.2.3.1 简单使用 注解拦截器 1234@Interceptor(priority = 8, name = \"测试用拦截器\")public class TestInterceptor implements IInterceptor &#123; ... ... ...&#125; 2.2.4 Param（DEPRECATED）这个注解也是用来修饰成员变量的，但是不推荐使用了，请使用 Autowired！ 12345678910@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.CLASS)@Deprecatedpublic @interface Param &#123; //【1】属性的名称； String name() default \"\"; //【2】属性的描述 String desc() default \"No desc.\";&#125; 因为已经不在推荐使用，不多说了！ 2.3 model这个 package 下主要保存了一些数据类，这些类保存了跳转需要的数据，已经目前对象的类型： 2.3.1 RouteMeta用于保存路由跳转的数据： 123456789101112131415161718public class RouteMeta &#123; private RouteType type; //【1】路由的类型，枚举类实例； private Element rawType; //【2】@Route 注解修饰的元素； private Class&lt;?&gt; destination; //【3】路由跳转的目标类 private String path; //【4】路由跳转的路径 path private String group; //【5】路由跳转的组 group private int priority = -1; //【6】路由跳转的优先级，值越小，优先级越高； private int extra; //【7】路由跳转携带的额外数据，23 位开关； private Map&lt;String, Integer&gt; paramsType; //【8】(Autowired 注解的属性) 保存 fieldName/Autowired.name --&gt; 属性类型对应的枚举序号 private String name; //【9】路由跳转的名称； private Map&lt;String, Autowired&gt; injectConfig; //【10】(Autowired 注解的属性) 保存 fieldName/Autowired.name --&gt; 对应的 Autowired 实例 public RouteMeta() &#123; &#125; ... ... ... ...// 这里我们先省略内部方法，后续分析！ &#125; 其实可以看到，RouteMeta 内部的数据很多事 compiler 解析 Route、Autowired 注解获得的！ 2.3.2 TypeWrapper用于保存路由跳转的目标对象类型： 123456789101112131415161718public class TypeWrapper&lt;T&gt; &#123; //【1】用于保存泛型 T； protected final Type type; protected TypeWrapper() &#123; //【2】调用 getClass() 获得当前类的 class 对象； //【3】然后再调用 getGenericSuperclass() 获得带有泛型的父类； Type superClass = getClass().getGenericSuperclass(); //【4】将 superClass 强转为 ParameterizedType 类型； //【5】getActualTypeArguments() 返回表示此类型实际类型参数的 Type 对象的数组； //【6】[0] 就是这个数组中第一个了，简而言之就是获得超类的泛型参数的实际类型 type = ((ParameterizedType) superClass).getActualTypeArguments()[0]; &#125; public Type getType() &#123; return type; &#125;&#125; TypeWrapper 是一个泛型类，泛型 T 表示目标对象类型！ 后面我们再具体分析。 4 总结本篇文章分析了 ARouter 中的 arouter-annotation 模块，其内部定义了 ARouter 必须的注解类，数据类，已经枚举类。 下篇文章将分析 arouter-compiler 模块，探寻在 App 编译期间，Gradle 事如何使用 arouter-compiler 对注解进行解析，和动态生成中间类的！","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"ARouter 第一篇 - 基本使用","slug":"ARouter1-baseUsages","date":"2019-04-13T12:46:25.000Z","updated":"2019-08-01T13:32:27.796Z","comments":true,"path":"2019/04/13/ARouter1-baseUsages/","link":"","permalink":"https://coolqi.top/2019/04/13/ARouter1-baseUsages/","excerpt":"","text":"本系列文章主要分析 ARouter 框架的原理。 这篇文章 里面的一些内容来自： https://github.com/alibaba/ARouter/blob/master/README_CN.md 官网对其使用已经总结的很好了，本篇博文在其基础上整理了下～～ 1 简单介绍对于 ARouter 大家只要做过模块化开发，那么就一定有所了解，ARouter 是阿里巴巴开源的一款路由框架，用于解决模块化开发中的模块依赖。 2.1 主要模块官方提供了下面的四个插件模块： arouter-api：对外提供功能相关的 Api； arouter-compiler：用于解析注解，生成代码； arouter-register：用于 App 加固时的自动注册； arouter-idea-plugin：Idea 插件，用于关联路径和目标类； 2.2 功能介绍官方文档中讲到 ARouter 支持如下的功能： 支持直接解析标准 URL 进行跳转，并自动注入参数到目标页面中； 支持多模块工程使用； 支持添加多个拦截器，自定义拦截顺序； 支持依赖注入，可单独作为依赖注入框架使用； 支持 InstantRun； 支持 MultiDex； (Google 方案) 映射关系按组分类、多级管理，按需初始化； 支持用户指定全局降级与局部降级策略； 页面、拦截器、服务等组件均自动注册到框架； 支持多种方式配置转场动画； 支持获取 Fragment； 完全支持 Kotlin 以及混编； 支持第三方 App 加固；(使用 arouter-register 实现自动注册) 支持生成路由文档； 提供 IDE 插件便捷的关联路径和目标类； 当然，我们后面通过源码分析； 2 ARouter 使用（官网整理）以下内容来自对 https://github.com/alibaba/ARouter/edit/master/README_CN.md 的整理： 2.1 Gradle 配置12345678910111213141516android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName()] &#125; &#125; &#125;&#125;dependencies &#123; compile 'com.alibaba:arouter-api:x.x.x' annotationProcessor 'com.alibaba:arouter-compiler:x.x.x' ...&#125; 这里两个库均要使用最新版本，防止兼容问题发生； 2.2 基本使用2.2.1 添加注解1234@Route(path = \"/test/activity\")public class YourActivity extend Activity &#123; ...&#125; 2.2.2 初始化操作123456789//【1】这两行必须写在init之前，否则这些配置在init过程中将无效if (isDebug()) &#123; //【2】打印日志 ARouter.openLog(); //【3】开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！ // 线上版本需要关闭,否则有安全风险) ARouter.openDebug();&#125;ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化 2.2.3 路由跳转123456789//【1】应用内简单的跳转(通过URL跳转在'进阶用法'中)ARouter.getInstance().build(\"/test/activity\").navigation();//【3】跳转并携带参数ARouter.getInstance().build(\"/test/1\") .withLong(\"key1\", 666L) .withString(\"key3\", \"888\") .withObject(\"key4\", new Test(\"Jack\", \"Rose\")) .navigation(); 2.3 进阶使用2.3.1 通过 URL 跳转我们除了可以使用 @Route 方式指定 path 来跳转，我们还可以通过 url 跳转： 当通过 URL 跳转时，URL 中不能传递 Parcelable 类型数据，通过 ARouter api 才能传递 Parcelable 对象； 123456789101112// 新建一个 Activity 用于监听 Schame 事件, // 之后直接把 url 传递给 ARouter 即可；public class SchameFilterActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); ARouter.getInstance().build(uri).navigation(); finish(); &#125; &#125; 说明书 AndroidManifest.xml 中的配置： 12345678910111213&lt;activity android:name=\".activity.SchameFilterActivity\"&gt; &lt;!-- Schame --&gt; &lt;intent-filter&gt; &lt;data android:host=\"m.aliyun.com\" android:scheme=\"arouter\"/&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2.3.2 自动解析参数自动解析参数。 为每一个参数声明一个字段，并使用 @Autowired 标注，我们传递的值将会自动赋值给所属变量。 1234567891011121314151617181920212223242526272829303132@Route(path = \"/test/activity\")public class Test1Activity extends Activity &#123; @Autowired public String name; @Autowired int age; //【1】通过 name 来映射 URL 中的不同参数 @Autowired(name = \"girl\") boolean boy; //【2】支持解析自定义对象，URL中使用 json 传递 @Autowired TestObj obj; //【3】使用 withObject 传递 List 和 Map 的实现了 // Serializable 接口的实现类(ArrayList/HashMap) // 的时候，接收该对象的地方不能标注具体的实现类类型 // 应仅标注为 List 或 Map，否则会影响序列化中类型 // 的判断, 其他类似情况需要同样处理 @Autowired List&lt;TestObj&gt; list; @Autowired Map&lt;String, List&lt;TestObj&gt;&gt; map; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //【4】这里很关键，执行 ativity 的注入； ARouter.getInstance().inject(this); &#125;&#125; 如果需要传递自定义对象（比如上面的 TestObj），新建一个类，实现 SerializationService, 并使用 @Route 注解标注！ 这个类的作用是自定义对象的序列化方式： 1234567891011121314151617@Route(path = \"/yourservicegroupname/json\")public class JsonServiceImpl implements SerializationService &#123; @Override public void init(Context context) &#123; &#125; @Override public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123; return JSON.parseObject(text, clazz); &#125; @Override public String object2Json(Object instance) &#123; return JSON.toJSONString(instance); &#125;&#125; 这里使用的是 JSON 序列化。 2.3.3 跳转拦截器拦截器用于拦截跳转过程，面向切面编程，比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查！ 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行！ 12345678910111213141516@Interceptor(priority = 8, name = \"测试用拦截器\")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; ... // 处理完成，交还控制权 callback.onContinue(postcard); // 觉得有问题，中断路由流程，以上两种至少需要调用其中一种，否则不会继续路由 // callback.onInterrupt(new RuntimeException(\"我觉得有点异常\")); &#125; @Override public void init(Context context) &#123; //【1】拦截器的初始化，会在 sdk 初始化的时候调用该方法，仅会调用一次 &#125;&#125; 上面说的初始化，就是 ARouter.init 方法； 2.3.4 处理跳转结果navigation 方法支持传入一个 NavigationCallback 回调，处理跳转结果： 1234567891011ARouter.getInstance().build(\"/test/1\").navigation(this, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; ... &#125; @Override public void onLost(Postcard postcard) &#123; ... &#125;&#125;); 2.3.5 自定义全局降级策略自定义类，实现 DegradeService 接口，并加上一个 Path 内容任意的注解： 1234567891011@Route(path = \"/xxx/xxx\")public class DegradeServiceImpl implements DegradeService &#123; @Override public void onLost(Context context, Postcard postcard) &#123; // do something. &#125; @Override public void init(Context context) &#123; &#125;&#125; 2.3.6 为目标页面声明更多信息@Route 还有一个 extras 属性，用于设置一些额外的属性，他是一个 int 值，有 32 位，可以配置 32 个开关； 我们可以通过设置指定的开关位，然后在拦截器中可以拿到这个标记进行业务逻辑判断！ 1234@Route(path = \"/test/activity\", extras = Consts.XXXX)public class Test1Activity extends Activity &#123; ... ... ...&#125; 2.3.7 依赖注入解耦ARouter 通过定义统一的访问接口来实现解耦 module 依赖； 核心接口：IProvider！ 2.3.7.1 暴露服务1234567891011121314151617181920// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; //【1】module 间通信接口； String sayHello(String name);&#125;//【2】实现接口，也是我们实际要暴漏的服务；@Route(path = \"/yourservicegroupname/hello\", name = \"测试服务\")public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return \"hello, \" + name; &#125; @Override public void init(Context context) &#123; &#125;&#125; 暴漏的服务，需要通过 @Route 注解去修饰！ 2.3.7.2 访问服务当我们暴漏了服务后，需要 12345678910111213141516171819public class Test &#123; //【1】依赖注入的方式 @Autowired HelloService helloService; @Autowired(name = \"/yourservicegroupname/hello\") HelloService helloService2; //【2】依赖查找的方式 HelloService helloService3; HelloService helloService4; public Test() &#123; //【3】依赖注入的方式； ARouter.getInstance().inject(this); &#125; public void testService() &#123; ... ... ... &#125;&#125; 访问服务的方式有下面两种方式： 使用依赖注入的方式发现服务 这也是推荐的方式，通过注解标注字段, 即可使用，无需主动获取 Autowired 注解标注 name 之后，将会使用 byName 的方式注入对应的字段；不设置 name 属性，会默认使用byType 的方式发现服务(当同一接口有多个实现的时候，必须使用 byName 的方式发现服务) 12helloService.sayHello(\"Vergil\");helloService2.sayHello(\"Vergil\"); 使用依赖查找的方式发现服务 使用依赖查找的方式发现服务，主动去发现服务并使用，也有 byName 和 byType 两种方式： 1234helloService3 = ARouter.getInstance().navigation(HelloService.class);helloService4 = (HelloService) ARouter.getInstance().build(\"/yourservicegroupname/hello\").navigation();helloService3.sayHello(\"Vergil\");helloService4.sayHello(\"Vergil\"); 2.3.8 预处理服务预处理服务和拦截器的概念很类似： 12345678910111213// 实现 PretreatmentService 接口，并加上一个Path内容任意的注解即可@Route(path = \"/xxx/xxx\")public class PretreatmentServiceImpl implements PretreatmentService &#123; @Override public boolean onPretreatment(Context context, Postcard postcard) &#123; // 跳转前预处理，如果需要自行处理跳转，该方法返回 false 即可 &#125; @Override public void init(Context context) &#123; &#125;&#125; 3 源码结构我们来看下 ARouter 的源码结构，下面列出关键的目录： 12345678|-ARouter-master.iml |-README_CN.md |-arouter-api |-arouter-idea-plugin|-arouter-compiler|-arouter-annotation|-arouter-gradle-plugin|- ... ... ... 这里分别解释下每个 module 的作用： arouter-annotation： 定义了 ARouter 使用到的所有的注解； arouter-api： 对应 “arouter-api” 插件，对外提供功能相关的 Api； arouter-compiler： 对应 “arouter-compiler” 插件，用于解析注解，生成代码； arouter-gradle-plugin： 对应 “arouter-register” 插件，用于 App 加固时的自动注册； arouter-idea-plugin： 对应 “arouter-idea-plugin” 插件，用于关联路径和目标类； 3.1 Module 依赖关系下图我们来看看这几个 module 的依赖关系： 依赖关系还是很简单的，毕竟只有几个 module。 4 总结本篇博文整理了下 ARouter 官网的一些内容，总结了 ARouter 的基本使用和进阶使用，接下来，会通过分析每个 module 的源码，来进一步分析 ARouter 的原理！","categories":[{"name":"开源库源码分析","slug":"开源库源码分析","permalink":"https://coolqi.top/categories/开源库源码分析/"},{"name":"ARouter","slug":"开源库源码分析/ARouter","permalink":"https://coolqi.top/categories/开源库源码分析/ARouter/"}],"tags":[{"name":"ARouter","slug":"ARouter","permalink":"https://coolqi.top/tags/ARouter/"}]},{"title":"Permission第 6 篇 - permission info 的获取和更新","slug":"Permission6-getAndUpdatePermissionInfo","date":"2018-11-07T16:22:14.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/11/08/Permission6-getAndUpdatePermissionInfo/","link":"","permalink":"https://coolqi.top/2018/11/08/Permission6-getAndUpdatePermissionInfo/","excerpt":"","text":"[toc] 0 综述基于 Android 7.1.1，分析权限管理相关知识，本文权限信息的获取！ PackageManagerService 提供了很多个接口用于获取权限的信息！ 1 获取权限组相关的信息！PackageManagerService.mPermissionGroups 保存了从所有 Application 中解析到的权限组信息！ PackageManagerService 提供了如下的两个接口来获得权限组的信息！ 1.1 PackageManagerS.getAllPermissionGroups获得所有的权限组12345678910111213@Overridepublic @NonNull ParceledListSlice&lt;PermissionGroupInfo&gt; getAllPermissionGroups(int flags) &#123; synchronized (mPackages) &#123; final int N = mPermissionGroups.size(); ArrayList&lt;PermissionGroupInfo&gt; out = new ArrayList&lt;PermissionGroupInfo&gt;(N); for (PackageParser.PermissionGroup pg : mPermissionGroups.values()) &#123; //【*1.2.1】调用了 PackageParser.generatePermissionGroupInfo 方法 out.add(PackageParser.generatePermissionGroupInfo(pg, flags)); &#125; return new ParceledListSlice&lt;&gt;(out); &#125;&#125; 1.2 PackageManagerS.getPermissionGroupInfo获得指定的权限组信息 12345678@Overridepublic PermissionGroupInfo getPermissionGroupInfo(String name, int flags) &#123; synchronized (mPackages) &#123; //【*1.2.1】调用了 PackageParser.generatePermissionGroupInfo 方法 return PackageParser.generatePermissionGroupInfo( mPermissionGroups.get(name), flags); &#125;&#125; 1.2.1 PackageParser.generatePermissionGroupInfo该方法会新创建的 PermissionGroupInfo 对象，作为解析数据 PermissionGroup.PermissionGroupInfo 的拷贝！！ 12345678910111213public static final PermissionGroupInfo generatePermissionGroupInfo( PermissionGroup pg, int flags) &#123; if (pg == null) return null; // 如果 flags 没有设置 PackageManager.GET_META_DATA，直接返回 PermissionGroup.PermissionGroupInfo if ((flags &amp; PackageManager.GET_META_DATA) == 0) &#123; return pg.info; &#125; // 如果 flags 设置了 PackageManager.GET_META_DATA，我们会新建一个 PermissionGroupInfo 对象， // 将解析的数据拷贝进来！ PermissionGroupInfo pgi = new PermissionGroupInfo(pg.info); pgi.metaData = pg.metaData; return pgi;&#125; 2 获取权限相关的信息！mSettings.mPermissions 保存了系统和应用定义的所有的权限信息！ PackageManagerService 提供了如下的两个接口来获得权限组的信息！ 2.1 PackageParser.getPermissionInfo获得指定 name 的权限信息！ 1234567891011@Overridepublic PermissionInfo getPermissionInfo(String name, int flags) &#123; synchronized (mPackages) &#123; final BasePermission p = mSettings.mPermissions.get(name); if (p != null) &#123; //【2.2.1】调用了 PackageParser.generatePermissionInfo 方法 return generatePermissionInfo(p, flags); &#125; return null; &#125;&#125; 2.2 PackageParser.queryPermissionsByGroup获得同一个 group 中的所有权限信息！ 12345678910111213141516171819202122232425@Overridepublic @Nullable ParceledListSlice&lt;PermissionInfo&gt; queryPermissionsByGroup(String group, int flags) &#123; synchronized (mPackages) &#123; //【1】校验权限组是否存在！ if (group != null &amp;&amp; !mPermissionGroups.containsKey(group)) &#123; // This is thrown as NameNotFoundException return null; &#125; //【2.2.1】调用了 PackageParser.generatePermissionInfo 方法 ArrayList&lt;PermissionInfo&gt; out = new ArrayList&lt;PermissionInfo&gt;(10); for (BasePermission p : mSettings.mPermissions.values()) &#123; if (group == null) &#123; // 如果参数 group 为 null，只收集无 group 的权限！ if (p.perm == null || p.perm.info.group == null) &#123; out.add(generatePermissionInfo(p, flags)); &#125; &#125; else &#123; if (p.perm != null &amp;&amp; group.equals(p.perm.info.group)) &#123; out.add(PackageParser.generatePermissionInfo(p.perm, flags)); &#125; &#125; &#125; return new ParceledListSlice&lt;&gt;(out); &#125;&#125; 2.2.1 PackageParser.generatePermissionInfo该方法会新创建的 PermissionInfo 对象，拷贝 Permission 的数据！！ 12345678910public static final PermissionInfo generatePermissionInfo( Permission p, int flags) &#123; if (p == null) return null; if ((flags &amp; PackageManager.GET_META_DATA) == 0) &#123; return p.info; &#125; PermissionInfo pi = new PermissionInfo(p.info); pi.metaData = p.metaData; return pi;&#125; 如果不需要 GET_META_DATA，那就直接返回解析得到的 PermissionInfo 对象！ 3 获取权限标志位的信息！PackageManagerService 提供了如下接口来获得权限标志位组的信息！ PackageManagerService.mPackages 用于保存所有解析过的 Pacakge 信息！ mSettings.mPermissions 中保存了系统中所有的权限信息！ 3.1 PackageManagerService.getPermissionFlags123456789101112131415161718192021222324252627282930313233@Overridepublic int getPermissionFlags(String name, String packageName, int userId) &#123; if (!sUserManager.exists(userId)) &#123; return 0; &#125; enforceGrantRevokeRuntimePermissionPermissions(\"getPermissionFlags\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, false /* checkShell */, \"getPermissionFlags\"); synchronized (mPackages) &#123; //【1】如果 packageName 不存在，返回 0； final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; return 0; &#125; //【2】如果权限不存在，返回 0； final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; return 0; &#125; //【3】获得该 package 对应的 PackageSettings 或者 SharedUserSetting 对象！ SettingBase sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; return 0; &#125; //【4】获得权限的 flags PermissionsState permissionsState = sb.getPermissionsState(); return permissionsState.getPermissionFlags(name, userId); &#125;&#125; 方法很简单，不多说了！ 4 更新权限标志位的信息！PackageManagerService 提供了如下接口来更新权限标志位的信息！ 4.1 PackageManagerService.updatePermissionFlags该方法更新指定权限的 flags，flagMask 表示的是 flags 的位掩码，用来屏蔽某些位；flagValues 表示新的标志位值！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overridepublic void updatePermissionFlags(String name, String packageName, int flagMask, int flagValues, int userId) &#123; if (!sUserManager.exists(userId)) &#123; return; &#125; enforceGrantRevokeRuntimePermissionPermissions(\"updatePermissionFlags\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, true /* checkShell */, \"updatePermissionFlags\"); //【1】如果调用者不是 system uid，不能改变以下标志位，flagMask 和 flagValues 需去掉对应标志位： if (getCallingUid() != Process.SYSTEM_UID) &#123; flagMask &amp;= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED; flagValues &amp;= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED; flagMask &amp;= ~PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT; flagValues &amp;= ~PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT; flagValues &amp;= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED; &#125; synchronized (mPackages) &#123; //【2】如果该 package 不存在，抛出异常！ final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; //【3】如果权限 name 不存在，抛出异常！ final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; throw new IllegalArgumentException(\"Unknown permission: \" + name); &#125; //【4】如果该 package 没有安装记录，抛出异常！ SettingBase sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; //【5】获得该 package 的权限状态管理对象！ PermissionsState permissionsState = sb.getPermissionsState(); //【6】获得该应用程序的运行时权限状态信息，返回不为 null，说明其有运行时权限！ boolean hadState = permissionsState.getRuntimePermissionState(name, userId) != null; //【*4.1.1】更新该权限的标志位！ if (permissionsState.updatePermissionFlags(bp, userId, flagMask, flagValues)) &#123; // 安装时权限和运行时权限保存在不同的目录下，所以要更新不同的文件 if (permissionsState.getInstallPermissionState(name) != null) &#123; scheduleWriteSettingsLocked(); // 更新运行时权限！ &#125; else if (permissionsState.getRuntimePermissionState(name, userId) != null || hadState) &#123; // 更新安装时权限！ mSettings.writeRuntimePermissionsForUserLPr(userId, false); &#125; &#125; &#125;&#125; 先会更新 flags，更新成功后，会根据权限的类型去，去更新对应的持久化文件！ 4.1.1 PermissionsState.updatePermissionFlagsPermissionsState 用于管理 package 的权限状态! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public boolean updatePermissionFlags(BasePermission permission, int userId, int flagMask, int flagValues) &#123; enforceValidUserId(userId); //【1】如果 flagValues 和 flagMask 有一个不为 0，那就需要更新 flags！ final boolean mayChangeFlags = flagValues != 0 || flagMask != 0; if (mPermissions == null) &#123; if (!mayChangeFlags) &#123; return false; &#125; ensurePermissionData(permission); &#125; PermissionData permissionData = mPermissions.get(permission.name); if (permissionData == null) &#123; if (!mayChangeFlags) &#123; return false; &#125; permissionData = ensurePermissionData(permission); &#125; //【2】获得旧的 flags！ final int oldFlags = permissionData.getFlags(userId); //【*4.1.1.1】调用 PermissionData.updatePermissionFlags 更新权限的标志位： final boolean updated = permissionData.updateFlags(userId, flagMask, flagValues); //【3】如果 flags 发生了更新，比较下，更新后是否需要再次 review！ if (updated) &#123; final int newFlags = permissionData.getFlags(userId); // 获得新的 flags！ if ((oldFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) == 0 &amp;&amp; (newFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0) &#123; if (mPermissionReviewRequired == null) &#123; mPermissionReviewRequired = new SparseBooleanArray(); &#125; mPermissionReviewRequired.put(userId, true); &#125; else if ((oldFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0 &amp;&amp; (newFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) == 0) &#123; if (mPermissionReviewRequired != null) &#123; mPermissionReviewRequired.delete(userId); if (mPermissionReviewRequired.size() &lt;= 0) &#123; mPermissionReviewRequired = null; &#125; &#125; &#125; &#125; return updated;&#125; 整个方法很简单，无需多说，前面分析过了，这里就不多说了！！ 4.1.1.1 PermissionData.updateFlagsPermissionData 用于封装指定权限的状态信息！ 123456789101112131415161718192021222324252627282930313233public boolean updateFlags(int userId, int flagMask, int flagValues) &#123; if (isInstallPermission()) &#123; userId = UserHandle.USER_ALL; &#125; if (!isCompatibleUserId(userId)) &#123; return false; &#125; //【1】新的 newFlags 取 flagValues 和 flagMask 相同的位值！ // 就是说，新的 flags 要么是 0，要么只能取和 flagMask 相同的位值！ final int newFlags = flagValues &amp; flagMask; PermissionState userState = mUserStates.get(userId); if (userState != null) &#123; final int oldFlags = userState.mFlags; //【2】最新的权限 flags 设置如下： // 先取 oldFlags 和 ~flagMask 相同的位值，然后加上 newFlags！ userState.mFlags = (userState.mFlags &amp; ~flagMask) | newFlags; if (userState.isDefault()) &#123; mUserStates.remove(userId); &#125; return userState.mFlags != oldFlags; // 判断标志位是否变化！ &#125; else if (newFlags != 0) &#123; userState = new PermissionState(mPerm.name); userState.mFlags = newFlags; mUserStates.put(userId, userState); return true; &#125; return false;&#125; 这里首先，通过 flagValues &amp; flagMask 取其相同的位值为 newFlags！ 设置最新的 flags 的时候，先是 oldFlags &amp; ~flagMask 取 oldFlags 和 ～flagMask 相同的位值，然后加上 newFlags！ 4.2 PackageManagerService.updatePermissionFlagsForAllApps该方法更新指定所有权限的 flags！ 123456789101112131415161718192021222324252627282930313233343536373839@Overridepublic void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) &#123; if (!sUserManager.exists(userId)) &#123; return; &#125; enforceGrantRevokeRuntimePermissionPermissions(\"updatePermissionFlagsForAllApps\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, true /* checkShell */, \"updatePermissionFlagsForAllApps\"); //【1】如果不是 system uid，不能修改 system fixed flags，从 flagMask 和 flagValues 中去掉该标志位！ // 那么下面的调整中就不会涉及到 system fix 标志位！ if (getCallingUid() != Process.SYSTEM_UID) &#123; flagMask &amp;= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED; flagValues &amp;= ~PackageManager.FLAG_PERMISSION_SYSTEM_FIXED; &#125; synchronized (mPackages) &#123; boolean changed = false; final int packageCount = mPackages.size(); for (int pkgIndex = 0; pkgIndex &lt; packageCount; pkgIndex++) &#123; final PackageParser.Package pkg = mPackages.valueAt(pkgIndex); SettingBase sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; continue; &#125; PermissionsState permissionsState = sb.getPermissionsState(); //【*4.2.1】调用了 updatePermissionFlagsForAllPermissions 方法，更新 flags！ changed |= permissionsState.updatePermissionFlagsForAllPermissions( userId, flagMask, flagValues); &#125; if (changed) &#123; //【2】如果发生了改变，更新 rumtime-permissions.xml 文件！ mSettings.writeRuntimePermissionsForUserLPr(userId, false); &#125; &#125;&#125; 4.2.1 PermissionsState.updatePermissionFlagsForAllPermissions12345678910111213141516public boolean updatePermissionFlagsForAllPermissions( int userId, int flagMask, int flagValues) &#123; enforceValidUserId(userId); if (mPermissions == null) &#123; return false; &#125; boolean changed = false; final int permissionCount = mPermissions.size(); //【*4.1.1.1】更新 PermissionsState 管理的所有权限的 flags！ for (int i = 0; i &lt; permissionCount; i++) &#123; PermissionData permissionData = mPermissions.valueAt(i); changed |= permissionData.updateFlags(userId, flagMask, flagValues); &#125; return changed;&#125; 流程很简单，不多说了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Permission权限管理","slug":"AndroidFramework源码分析/Permission权限管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Permission权限管理/"}],"tags":[{"name":"Permission权限管理","slug":"Permission权限管理","permalink":"https://coolqi.top/tags/Permission权限管理/"}]},{"title":"PMS 第 12 篇 - 通过 adb 指令分析 enable/disable 过程","slug":"PMS12-enable_disableThroughAdb","date":"2018-09-16T16:00:00.000Z","updated":"2019-01-27T09:50:50.000Z","comments":true,"path":"2018/09/17/PMS12-enable_disableThroughAdb/","link":"","permalink":"https://coolqi.top/2018/09/17/PMS12-enable_disableThroughAdb/","excerpt":"","text":"[toc] 基于 Android7.1.1 分析 PackageManagerService 的架构设计！ 0 综述本文来分析下 pms enable 相关的操作： adb shell pm enable adb shell pm disable 同样的，我们从 Pm 中看起！ 1 Pm1.1 run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int run(String[] args) throws RemoteException &#123; boolean validCommand = false; if (args.length &lt; 1) &#123; return showUsage(); &#125; mAm = IAccountManager.Stub.asInterface(ServiceManager.getService(Context.ACCOUNT_SERVICE)); mUm = IUserManager.Stub.asInterface(ServiceManager.getService(Context.USER_SERVICE)); mPm = IPackageManager.Stub.asInterface(ServiceManager.getService(\"package\")); if (mPm == null) &#123; System.err.println(PM_NOT_RUNNING_ERR); return 1; &#125; mInstaller = mPm.getPackageInstaller(); mArgs = args; String op = args[0]; mNextArg = 1; ... ... ... if (\"enable\".equals(op)) &#123; //【*1.2】调用 runSetEnabledSetting 方法； return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED); &#125; if (\"disable\".equals(op)) &#123; //【*1.2】调用 runSetEnabledSetting 方法； return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED); &#125; if (\"disable-user\".equals(op)) &#123; //【*1.2】调用 runSetEnabledSetting 方法；** return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER); &#125; if (\"disable-until-used\".equals(op)) &#123; //【*1.2】调用 runSetEnabledSetting 方法； return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED); &#125; if (\"default-state\".equals(op)) &#123; //【*1.2】调用 runSetEnabledSetting 方法； return runSetEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DEFAULT); &#125; ... ... ...&#125; 我们可以看到，和 enable/disable 相关的 pm 指令有很多，但无疑最后调用的都是：runSetEnabledSetting，唯一的区别是参数 int state 不一样！ 我们知道，在 AndroidManifest.xml 中，我们可以给 application，activity 等四大组件设置如下的属性，来设置其是否可用： 1android:enabled=\"true|false\" 下面，我们来看下 state 的值： PackageManager.COMPONENT_ENABLED_STATE_ENABLED：组件或应用程序已被明确启用，无论其清单中指定了什么，适用于 setApplicationEnabledSetting 和 setComponentEnabledSetting； PackageManager.COMPONENT_ENABLED_STATE_DISABLED：组件或应用程序已被明确禁用，无论其清单中指定了什么，适用于 setApplicationEnabledSetting 和 setComponentEnabledSetting； PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER：应用程序已被明确禁用，无论其清单中指定了什么。因为这是由于用户的请求，所以如果需要，他们可以通过适当的系统 UI 重新启用它，只适用于 setApplicationEnabledSetting； PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED： PackageManager.COMPONENT_ENABLED_STATE_DEFAULT：组件或应用程序处于默认的 enable 状态，也就是我们在 AndroidManifest.xml 中设置的值！ 接下来，我们继续分析下流程： 1.2 runSetEnabledSetting1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private int runSetEnabledSetting(int state) &#123; int userId = UserHandle.USER_SYSTEM; String option = nextOption(); //【1】如果有指定 user，那么将 user id 保存到 userId 中； if (option != null &amp;&amp; option.equals(\"--user\")) &#123; String optionData = nextOptionData(); if (optionData == null || !isNumber(optionData)) &#123; System.err.println(\"Error: no USER_ID specified\"); return showUsage(); &#125; else &#123; userId = Integer.parseInt(optionData); &#125; &#125; //【2】获得传入的包名参数； String pkg = nextArg(); if (pkg == null) &#123; System.err.println(\"Error: no package or component specified\"); return showUsage(); &#125; //【2】尝试将其转为组件名； ComponentName cn = ComponentName.unflattenFromString(pkg); if (cn == null) &#123; try &#123; //【*2.1】如果传入的参数指定的是包名，调用 setApplicationEnabledSetting 方法！ mPm.setApplicationEnabledSetting(pkg, state, 0, userId, \"shell:\" + android.os.Process.myUid()); System.out.println(\"Package \" + pkg + \" new state: \" + enabledSettingToString( mPm.getApplicationEnabledSetting(pkg, userId))); return 0; &#125; catch (RemoteException e) &#123; System.err.println(e.toString()); System.err.println(PM_NOT_RUNNING_ERR); return 1; &#125; &#125; else &#123; try &#123; //【*2.2】如果传入的参数指定的是组件名，调用 setComponentEnabledSetting 方法； mPm.setComponentEnabledSetting(cn, state, 0, userId); System.out.println(\"Component \" + cn.toShortString() + \" new state: \" + enabledSettingToString( mPm.getComponentEnabledSetting(cn, userId))); return 0; &#125; catch (RemoteException e) &#123; System.err.println(e.toString()); System.err.println(PM_NOT_RUNNING_ERR); return 1; &#125; &#125;&#125; 下面会进入 PackageManagerService 中去！ 2 PackageManagerService2.1 setApplicationEnabledSetting12345678910@Overridepublic void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) &#123; if (!sUserManager.exists(userId)) return; if (callingPackage == null) &#123; callingPackage = Integer.toString(Binder.getCallingUid()); &#125; //【*2.3】设置 enable 状态 setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);&#125; 2.2 setComponentEnabledSetting12345678@Overridepublic void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return; //【*2.3】设置 enable 状态 setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);&#125; 2.3 setEnabledSetting - 核心入口可以看到，无论 application 环视 component，最后调用的都是该方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189private void setEnabledSetting(final String packageName, String className, int newState, final int flags, int userId, String callingPackage) &#123; //【1】首先是对 newState 的取值做检查！ if (!(newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED || newState == COMPONENT_ENABLED_STATE_DISABLED || newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED)) &#123; throw new IllegalArgumentException(\"Invalid new component state: \" + newState); &#125; PackageSetting pkgSetting; final int uid = Binder.getCallingUid(); final int permission; //【2】校验权限，如果是 system uid 默认是授予；如果是其他 uid 检查下是否有 CHANGE_COMPONENT_ENABLED_STATE // 的权限； if (uid == Process.SYSTEM_UID) &#123; permission = PackageManager.PERMISSION_GRANTED; &#125; else &#123; permission = mContext.checkCallingOrSelfPermission( android.Manifest.permission.CHANGE_COMPONENT_ENABLED_STATE); &#125; //【3】检查是否有跨 user 的权限； enforceCrossUserPermission(uid, userId, false /* requireFullPermission */, true /* checkShell */, \"set enabled\"); final boolean allowedByPermission = (permission == PackageManager.PERMISSION_GRANTED); boolean sendNow = false; boolean isApp = (className == null); String componentName = isApp ? packageName : className; int packageUid = -1; ArrayList&lt;String&gt; components; // writer synchronized (mPackages) &#123; //【4】获得上一次的安装信息； pkgSetting = mSettings.mPackages.get(packageName); if (pkgSetting == null) &#123; if (className == null) &#123; throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; throw new IllegalArgumentException( \"Unknown component: \" + packageName + \"/\" + className); &#125; &#125; //【5】对于可以执行 enable/disable 的应用做限制，如果 calling uid 和要被 enable/disable 的应用不是同一个 // ，那么，如果前面没有权限，不允许 enable/disable；如果该应用是受保护的，那么也不允许； if (!UserHandle.isSameApp(uid, pkgSetting.appId)) &#123; if (!allowedByPermission) &#123; throw new SecurityException( \"Permission Denial: attempt to change component state from pid=\" + Binder.getCallingPid() + \", uid=\" + uid + \", package uid=\" + pkgSetting.appId); &#125; if (mProtectedPackages.isPackageStateProtected(userId, packageName)) &#123; throw new SecurityException(\"Cannot disable a protected package: \" + packageName); &#125; &#125; //【6】进一步处理！ synchronized (mPackages) &#123; if (uid == Process.SHELL_UID) &#123; //【6.1】Shell 只能改变 application 的状态，在 ENABLED 和 DISABLED_USER 之间； // Shell 不能该 compnent 的状态； int oldState = pkgSetting.getEnabled(userId); if (className == null &amp;&amp; (oldState == COMPONENT_ENABLED_STATE_DISABLED_USER || oldState == COMPONENT_ENABLED_STATE_DEFAULT || oldState == COMPONENT_ENABLED_STATE_ENABLED) &amp;&amp; (newState == COMPONENT_ENABLED_STATE_DISABLED_USER || newState == COMPONENT_ENABLED_STATE_DEFAULT || newState == COMPONENT_ENABLED_STATE_ENABLED)) &#123; // ok &#125; else &#123; throw new SecurityException( \"Shell cannot change component state for \" + packageName + \"/\" + className + \" to \" + newState); &#125; &#125; //【6.2】开始设置 state 状态； if (className == null) &#123; //【6.2.1】设置的是 application/package 级别的 state； if (pkgSetting.getEnabled(userId) == newState) &#123; // 如果本次设置的状态和上一次的一样，不做任何处理 return; &#125; //【6.2.2】如果新的状态是 default 或者 enabled 那么我们不关注 callingPackage！ if (newState == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT || newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) &#123; callingPackage = null; &#125; //【*3.2】设置 state 状态； pkgSetting.setEnabled(newState, userId, callingPackage); // pkgSetting.pkg.mSetEnabled = newState; &#125; else &#123; //【6.2.3】设置的是 component 级别的 state，前提是 component 的 className 是有效的； PackageParser.Package pkg = pkgSetting.pkg; if (pkg == null || !pkg.hasComponentClassName(className)) &#123; if (pkg != null &amp;&amp; pkg.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; throw new IllegalArgumentException(\"Component class \" + className + \" does not exist in \" + packageName); &#125; else &#123; Slog.w(TAG, \"Failed setComponentEnabledSetting: component class \" + className + \" does not exist in \" + packageName); &#125; &#125; //【6.2.4】处理新的 state 状态； switch (newState) &#123; case COMPONENT_ENABLED_STATE_ENABLED: //【*3.3】enable 组件； if (!pkgSetting.enableComponentLPw(className, userId)) &#123; return; &#125; break; case COMPONENT_ENABLED_STATE_DISABLED: //【*3.4】disable 组件； if (!pkgSetting.disableComponentLPw(className, userId)) &#123; return; &#125; break; case COMPONENT_ENABLED_STATE_DEFAULT: //【*3.5】restore 组件； if (!pkgSetting.restoreComponentLPw(className, userId)) &#123; return; &#125; break; default: Slog.e(TAG, \"Invalid new component state: \" + newState); return; &#125; &#125; //【7】保存偏好设置文件； scheduleWritePackageRestrictionsLocked(userId); //【8】准备发送 Package Changed 广播，mPendingBroadcasts 用于保存需要延迟发送的b包广播; components = mPendingBroadcasts.get(userId, packageName); //【9】判断该 userId 下是否是第一次添加 package； final boolean newPackage = components == null; if (newPackage) &#123; components = new ArrayList&lt;String&gt;(); &#125; if (!components.contains(componentName)) &#123; components.add(componentName); &#125; //【10】如果没有设置 DONT_KILL_APP 标志，那么就会立即发送，sendNow 为 true； if ((flags&amp;PackageManager.DONT_KILL_APP) == 0) &#123; sendNow = true; //【10.1】因为是立即发送，所以会将这次处理的 package 从中移除； mPendingBroadcasts.remove(userId, packageName); &#125; else &#123; //【10.2】如果该 userId 下是第一次添加 package，那么我们会把对应关系保存到 mPendingBroadcasts 中！ if (newPackage) &#123; mPendingBroadcasts.put(userId, packageName, components); &#125; if (!mHandler.hasMessages(SEND_PENDING_BROADCAST)) &#123; // 延迟 10s 发送广播； mHandler.sendEmptyMessageDelayed(SEND_PENDING_BROADCAST, BROADCAST_DELAY); &#125; &#125; &#125; long callingId = Binder.clearCallingIdentity(); try &#123; //【11】这里是立即发送广播 Intent.ACTION_PACKAGE_CHANGED ! //（注意这里使用了 Binder 相关的方法，将发送广播的 uid 和 pid 变成了 system process） if (sendNow) &#123; packageUid = UserHandle.getUid(userId, pkgSetting.appId); //【*2.3.1】发送 PACKAGE CHANGED 的广播； sendPackageChangedBroadcast(packageName, (flags&amp;PackageManager.DONT_KILL_APP) != 0, components, packageUid); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125;&#125; Pms 内部有一个 PendingPackageBroadcasts 对象 mPendingBroadcasts，用于保存需要延迟返送的广播： 1final PendingPackageBroadcasts mPendingBroadcasts = new PendingPackageBroadcasts(); 我们来看下 PendingPackageBroadcasts 的定义： 12345678910 // Set of pending broadcasts for aggregating enable/disable of components. static class PendingPackageBroadcasts &#123; // for each user id, a map of &lt;package name -&gt; components within that package&gt; final SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;String&gt;&gt;&gt; mUidMap; public PendingPackageBroadcasts() &#123; mUidMap = new SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;String&gt;&gt;&gt;(2); &#125; ... ... ...&#125; 可以看到，其内部有一个 mUidMap 的 SparseArray 数组，保存的数据结构满足如下关系： 1userId --&gt; ArrayMap&lt; packageName --&gt; ArrayList&lt;componentName&gt; &gt; 2.3.1 sendPackageChangedBroadcast发送 ACTION_PACKAGE_CHANGED 的广播： 12345678910111213141516171819202122232425private void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList&lt;String&gt; componentNames, int packageUid) &#123; if (DEBUG_INSTALL) Log.v(TAG, \"Sending package changed: package=\" + packageName + \" components=\" + componentNames); //【1】保存要发送的一些数据； Bundle extras = new Bundle(4); extras.putString(Intent.EXTRA_CHANGED_COMPONENT_NAME, componentNames.get(0)); String nameList[] = new String[componentNames.size()]; componentNames.toArray(nameList); extras.putStringArray(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST, nameList); extras.putBoolean(Intent.EXTRA_DONT_KILL_APP, killFlag); extras.putInt(Intent.EXTRA_UID, packageUid); // If this is not reporting a change of the overall package, then only send it // to registered receivers. We don't want to launch a swath of apps for every // little component state change. final int flags = !componentNames.contains(packageName) ? Intent.FLAG_RECEIVER_REGISTERED_ONLY : 0; //【2】发送广播，这个方法前面看过，这里就不多说了。 sendPackageBroadcast(Intent.ACTION_PACKAGE_CHANGED, packageName, extras, flags, null, null, new int[] &#123;UserHandle.getUserId(packageUid)&#125;);&#125; 不多说了！ 3 PackageSetting下面的方法确切的讲是 PackageSetting 的父类 PackageSettingBase 父类的方法： 3.1 getEnabled获得指定 user 下的 app 的 enabled 状态： 1234int getEnabled(int userId) &#123; //【*3.1.1】读取指定 userId 下的 PackageUserState 实例： return readUserState(userId).enabled;&#125; 3.1.1 readUserStatePackageSetting 内部有一个 SparseArray 数组：userState 1234567public PackageUserState readUserState(int userId) &#123; PackageUserState state = userState.get(userId); if (state != null) &#123; return state; &#125; return DEFAULT_USER_STATE;&#125; 3.2 setEnabled设置指定 user 下的 app 的 enabled 状态： 1234567void setEnabled(int state, int userId, String callingPackage) &#123; //【*3.2.1】modify 和 read 的区别是，在没有对应的使用信息的情况下，modify 会创建新的使用信息对象； PackageUserState st = modifyUserState(userId); //【1】设置状态的值，和修改该值的 pkg； st.enabled = state; st.lastDisableAppCaller = callingPackage;&#125; 3.2.1 modifyUserState12345678private PackageUserState modifyUserState(int userId) &#123; PackageUserState state = userState.get(userId); if (state == null) &#123; state = new PackageUserState(); userState.put(userId, state); &#125; return state;&#125; 3.3 enableComponentLPwenable 指定组件： 12345678910boolean enableComponentLPw(String componentClassName, int userId) &#123; //【*3.3.1】返回对应的 PackageUserState 实例； PackageUserState state = modifyUserStateComponents(userId, false, true); //【1】changed 用来记录是否发生了变化； boolean changed = state.disabledComponents != null ? state.disabledComponents.remove(componentClassName) : false; //【2】将要 enable 的组件从 disabledComponents 移动到 enabledComponents 中； changed |= state.enabledComponents.add(componentClassName); return changed;&#125; 3.3.1 modifyUserStateComponentsmodify 方法是对 PackageUserState 做一个初始化，然后返回： 12345678910111213PackageUserState modifyUserStateComponents(int userId, boolean disabled, boolean enabled) &#123; //【*3.2.1】返回对应的 PackageUserState 对象； PackageUserState state = modifyUserState(userId); //【1】如果是 disable 的话，disabledComponents 为 null，那么会初始化该 set； if (disabled &amp;&amp; state.disabledComponents == null) &#123; state.disabledComponents = new ArraySet&lt;String&gt;(1); &#125; //【2】如果是 enable 的话，enabledComponents 为 null，那么会初始化该 set； if (enabled &amp;&amp; state.enabledComponents == null) &#123; state.enabledComponents = new ArraySet&lt;String&gt;(1); &#125; return state;&#125; PackageUserState 内部有两个 ArraySet 集合: 12public ArraySet&lt;String&gt; disabledComponents; // 禁用的组件；public ArraySet&lt;String&gt; enabledComponents; // 可用的组件； … … 3.3 disableComponentLPwdisable 指定组件： 12345678910boolean disableComponentLPw(String componentClassName, int userId) &#123; //【*3.3.1】返回对应的 PackageUserState 实例； PackageUserState state = modifyUserStateComponents(userId, true, false); //【1】changed 用来记录是否发生了变化； boolean changed = state.enabledComponents != null ? state.enabledComponents.remove(componentClassName) : false; //【2】将要 enable 的组件从 enabledComponents 移动到 disabledComponents 中； changed |= state.disabledComponents.add(componentClassName); return changed;&#125; 3.4 restoreComponentLPwrestore 指定组件： 1234567891011boolean restoreComponentLPw(String componentClassName, int userId) &#123; //【*3.3.1】返回对应的 PackageUserState 实例； PackageUserState state = modifyUserStateComponents(userId, true, true); //【1】changed 用来记录是否发生了变化； boolean changed = state.disabledComponents != null ? state.disabledComponents.remove(componentClassName) : false; //【2】将要 restore 的组件从 enabledComponents 和 disabledComponents 中都移除； changed |= state.enabledComponents != null ? state.enabledComponents.remove(componentClassName) : false; return changed;&#125; 不多说了！ 4 PackageHandler然后我们来看下 PackageHandler 对于消息的处理： 4.1 doHandleMessage[SEND_PENDING_BROADCAST]然后我们来看下延迟发送广播的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152case SEND_PENDING_BROADCAST: &#123; String packages[]; ArrayList&lt;String&gt; components[]; int size = 0; int uids[]; Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); synchronized (mPackages) &#123; if (mPendingBroadcasts == null) &#123; return; &#125; size = mPendingBroadcasts.size(); if (size &lt;= 0) &#123; // Nothing to be done. Just return return; &#125; //【1】保存所有 change 的 package； packages = new String[size]; //【2】保存所有 change 的 component； components = new ArrayList[size]; //【3】保存所有 change 的 package 的 uid； uids = new int[size]; int i = 0; // filling out the above arrays //【4】遍历 mPendingBroadcasts 数组，处理每一项； for (int n = 0; n &lt; mPendingBroadcasts.userIdCount(); n++) &#123; int packageUserId = mPendingBroadcasts.userIdAt(n); Iterator&lt;Map.Entry&lt;String, ArrayList&lt;String&gt;&gt;&gt; it = mPendingBroadcasts.packagesForUserId(packageUserId) .entrySet().iterator(); //【4.1】将 mPendingBroadcasts 中的每一项保存到 packages[i]，components[i] 和 uids[i] 中！ while (it.hasNext() &amp;&amp; i &lt; size) &#123; Map.Entry&lt;String, ArrayList&lt;String&gt;&gt; ent = it.next(); packages[i] = ent.getKey(); components[i] = ent.getValue(); PackageSetting ps = mSettings.mPackages.get(ent.getKey()); uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1; i++; &#125; &#125; size = i; mPendingBroadcasts.clear(); &#125; //【*2.3.1】发送 Package Changed 广播！ for (int i = 0; i &lt; size; i++) &#123; sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]); &#125; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); break;&#125; 5 不同的 enable 状态的区别","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 11 篇 - 通过 adb 指令分析 hide/unhide 过程","slug":"PMS11-hide_unhideThroughAdb","date":"2018-09-10T16:00:00.000Z","updated":"2019-01-27T09:50:42.000Z","comments":true,"path":"2018/09/11/PMS11-hide_unhideThroughAdb/","link":"","permalink":"https://coolqi.top/2018/09/11/PMS11-hide_unhideThroughAdb/","excerpt":"","text":"[toc] 基于 Android7.1.1 分析 PackageManagerService 的架构设计！ 0 综述本文来分析下 pms hide 相关的操作： adb shell pm hide adb shell pm unhide 这个指令可以让一个 package 被 hide，无法被找到，同样的，我们从 Pm 中看起！ 1 Pm1.1 run和其他方法的调用逻辑一样，进入 run 方法： 123456789101112131415161718192021222324252627282930313233public int run(String[] args) throws RemoteException &#123; boolean validCommand = false; if (args.length &lt; 1) &#123; return showUsage(); &#125; mAm = IAccountManager.Stub.asInterface(ServiceManager.getService(Context.ACCOUNT_SERVICE)); mUm = IUserManager.Stub.asInterface(ServiceManager.getService(Context.USER_SERVICE)); mPm = IPackageManager.Stub.asInterface(ServiceManager.getService(\"package\")); if (mPm == null) &#123; System.err.println(PM_NOT_RUNNING_ERR); return 1; &#125; mInstaller = mPm.getPackageInstaller(); mArgs = args; String op = args[0]; mNextArg = 1; ... ... ... if (\"hide\".equals(op)) &#123; //【*1.2】调用自身的另一个方法！ return runSetHiddenSetting(true); &#125; if (\"unhide\".equals(op)) &#123; //【*1.2】调用自身的另一个方法！ return runSetHiddenSetting(false); &#125; ... ... ...&#125; 1.2 runSetHiddenSetting我们来看下 runSetHiddenSetting 的调用逻辑： 1234567891011121314151617181920212223242526272829303132private int runSetHiddenSetting(boolean state) &#123; //【1】默认要 hide 所在的用户，为 USER_SYSTEM(0) int userId = UserHandle.USER_SYSTEM; String option = nextOption(); //【2】如果通过 --user 指定了 hide 的 user。那就初始化为该 user！ if (option != null &amp;&amp; option.equals(\"--user\")) &#123; String optionData = nextOptionData(); if (optionData == null || !isNumber(optionData)) &#123; System.err.println(\"Error: no USER_ID specified\"); return showUsage(); &#125; else &#123; userId = Integer.parseInt(optionData); &#125; &#125; //【3】获得要 hide 的应用包名； String pkg = nextArg(); if (pkg == null) &#123; System.err.println(\"Error: no package or component specified\"); return showUsage(); &#125; try &#123; //【*2.1】进入 pms！ mPm.setApplicationHiddenSettingAsUser(pkg, state, userId); System.out.println(\"Package \" + pkg + \" new hidden state: \" + mPm.getApplicationHiddenSettingAsUser(pkg, userId)); return 0; &#125; catch (RemoteException e) &#123; System.err.println(e.toString()); System.err.println(PM_NOT_RUNNING_ERR); return 1; &#125;&#125; 不多说了！ 2 PackageManagerService进入 pms 中去： 2.1 setApplicationHiddenSettingAsUser1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Overridepublic boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) &#123; //【1】首先校验下是否有 MANAGE_USERS 权限以及跨用户的权限； mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MANAGE_USERS, null); PackageSetting pkgSetting; final int uid = Binder.getCallingUid(); enforceCrossUserPermission(uid, userId, true /* requireFullPermission */, true /* checkShell */, \"setApplicationHiddenSetting for user \" + userId); //【2】如果要 hide 的 package 是 device admin，禁止 hide！ if (hidden &amp;&amp; isPackageDeviceAdmin(packageName, userId)) &#123; Slog.w(TAG, \"Not hiding package \" + packageName + \": has active device admin\"); return false; &#125; long callingId = Binder.clearCallingIdentity(); try &#123; boolean sendAdded = false; boolean sendRemoved = false; // writer synchronized (mPackages) &#123; //【3】获得该 package 对应的 PackageSetting 实例； pkgSetting = mSettings.mPackages.get(packageName); if (pkgSetting == null) &#123; return false; &#125; //【4】不允许 \"android\" 被 hide！ if (\"android\".equals(packageName)) &#123; Slog.w(TAG, \"Cannot hide package: android\"); return false; &#125; //【5】只允许受保护的 package hide 他们自己！ if (hidden &amp;&amp; !UserHandle.isSameApp(uid, pkgSetting.appId) &amp;&amp; mProtectedPackages.isPackageStateProtected(userId, packageName)) &#123; Slog.w(TAG, \"Not hiding protected package: \" + packageName); return false; &#125; //【6】处理 hide 状态，如果本次设置的和上一次的 hide 状态不一样，那么就需要更新 hide 状态！ //【*2.1.1】获得该 package 在 userId 下的 PackageUserState 实例，然后获得其 hide 值； if (pkgSetting.getHidden(userId) != hidden) &#123; //【*2.1.2】设置该 package 在 userId 下的 hide 状态！ pkgSetting.setHidden(hidden, userId); //【6.1】更新偏好设置的本地化文件； mSettings.writePackageRestrictionsLPr(userId); //【6.2】如果本次是 hide，sendRemoved 为 true；如果本次是 unhide，sendAdded 为 true； if (hidden) &#123; sendRemoved = true; &#125; else &#123; sendAdded = true; &#125; &#125; &#125; //【7】如果是 unhide，进入这里； if (sendAdded) &#123; //【*2.2】发送 pkg add 的广播！ sendPackageAddedForUser(packageName, pkgSetting, userId); return true; &#125; //【8】如果是 hide，进入这里； if (sendRemoved) &#123; //【*2.3】杀掉 pkg 进程； killApplication(packageName, UserHandle.getUid(userId, pkgSetting.appId), \"hiding pkg\"); //【*2.4】发送 pkg add 的广播！ sendApplicationHiddenForUser(packageName, pkgSetting, userId); return true; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; return false;&#125; 2.1.1 PackageSetting.getHidden1234boolean getHidden(int userId) &#123; //【*2.1.1.1】获得对应的 PackageUserState.hide 值； return readUserState(userId).hidden;&#125; 继续来看： 2.1.1.1 readUserState12345678public PackageUserState readUserState(int userId) &#123; //【1】在 userId 下的 PackageUserState 实例！ PackageUserState state = userState.get(userId); if (state != null) &#123; return state; &#125; return DEFAULT_USER_STATE;&#125; 2.1.2 PackageSetting.setHidden1234void setHidden(boolean hidden, int userId) &#123; //【*2.1.2.1】设置对应 userId 下的 PackageUserState 的 hide 状态； modifyUserState(userId).hidden = hidden;&#125; 2.1.2.1 modifyUserState该方法其实很简单，不多说了！ 12345678private PackageUserState modifyUserState(int userId) &#123; PackageUserState state = userState.get(userId); if (state == null) &#123; state = new PackageUserState(); userState.put(userId, state); &#125; return state;&#125; 2.2 sendPackageAddedForUser[3]给指定的 user 发送 Intent.ACTION_PACKAGE_ADDED 广播： 1234567private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) &#123; //【1】是不是 sys app; final boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting); //【*2.2.1】调用另一方法： sendPackageAddedForUser(packageName, isSystem, pkgSetting.appId, userId);&#125; 继续来看： 2.2.1 sendPackageAddedForUser[4]12345678910111213141516171819202122232425262728private void sendPackageAddedForUser(String packageName, boolean isSystem, int appId, int userId) &#123; Bundle extras = new Bundle(1); //【1】获得 inhide 的应用所在的 user！ extras.putInt(Intent.EXTRA_UID, UserHandle.getUid(userId, appId)); //【*2.2.1.1】发送 Intent.ACTION_PACKAGE_ADDED 广播； sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, 0, null, null, new int[] &#123;userId&#125;); try &#123; IActivityManager am = ActivityManagerNative.getDefault(); //【2】如果 unhide 的是 sys app，并且 userId 正在运行中； if (isSystem &amp;&amp; am.isUserRunning(userId, 0)) &#123; // The just-installed/enabled app is bundled on the system, so presumed // to be able to run automatically without needing an explicit launch. // Send it a BOOT_COMPLETED if it would ordinarily have gotten one. //【2.1】这里会发送一个 boot completed 广播给这个 pkg，给它一个引导； Intent bcIntent = new Intent(Intent.ACTION_BOOT_COMPLETED) .addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES) .setPackage(packageName); am.broadcastIntent(null, bcIntent, null, null, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false, userId); &#125; &#125; catch (RemoteException e) &#123; // shouldn't happen Slog.w(TAG, \"Unable to bootstrap installed package\", e); &#125;&#125; 不多说了！ 2.2.1.1 sendPackageBroadcast发送广播的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void sendPackageBroadcast(final String action, final String pkg, final Bundle extras, final int flags, final String targetPkg, final IIntentReceiver finishedReceiver, final int[] userIds) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; try &#123; final IActivityManager am = ActivityManagerNative.getDefault(); if (am == null) return; //【1】要发送的目标 userIds； final int[] resolvedUserIds; if (userIds == null) &#123; resolvedUserIds = am.getRunningUserIds(); &#125; else &#123; resolvedUserIds = userIds; &#125; //【2】开始发送广播： for (int id : resolvedUserIds) &#123; final Intent intent = new Intent(action, pkg != null ? Uri.fromParts(PACKAGE_SCHEME, pkg, null) : null); if (extras != null) &#123; intent.putExtras(extras); &#125; if (targetPkg != null) &#123; intent.setPackage(targetPkg); &#125; //【2.1】计算 package 在目标 userId 下的 uid！ int uid = intent.getIntExtra(Intent.EXTRA_UID, -1); if (uid &gt; 0 &amp;&amp; UserHandle.getUserId(uid) != id) &#123; uid = UserHandle.getUid(id, UserHandle.getAppId(uid)); intent.putExtra(Intent.EXTRA_UID, uid); &#125; //【2.2】计算目标 userId！ intent.putExtra(Intent.EXTRA_USER_HANDLE, id); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | flags); if (DEBUG_BROADCASTS) &#123; RuntimeException here = new RuntimeException(\"here\"); here.fillInStackTrace(); Slog.d(TAG, \"Sending to user \" + id + \": \" + intent.toShortString(false, true, false, false) + \" \" + intent.getExtras(), here); &#125; //【2.3】发送广播！ am.broadcastIntent(null, intent, null, finishedReceiver, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, finishedReceiver != null, false, id); &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125; &#125;);&#125; 这就不多说了！ 2.3 killApplication[3]杀掉应用的进程：1234private void killApplication(String pkgName, int appId, String reason) &#123; //【*2.3.1】调用另一个方法： killApplication(pkgName, appId, UserHandle.USER_ALL, reason);&#125; 2.3.1 killApplication[4]另一个 4 参数的 kill：123456789101112131415161718private void killApplication(String pkgName, int appId, int userId, String reason) &#123; // Request the ActivityManager to kill the process(only for existing packages) // so that we do not end up in a confused state while the user is still using the older // version of the application while the new one gets installed. final long token = Binder.clearCallingIdentity(); try &#123; IActivityManager am = ActivityManagerNative.getDefault(); if (am != null) &#123; try &#123; //【1】杀掉进程； am.killApplication(pkgName, appId, userId, reason); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125;&#125; 对于 killApplication 杀进程的流程，这里就不再分析了！ 2.4 sendApplicationHiddenForUser给指定的 user 发送 Intent.ACTION_PACKAGE_REMOVED 广播： 1234567891011private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) &#123; //【*2.4.1】创建了一个 PackageRemovedInfo！ final PackageRemovedInfo info = new PackageRemovedInfo(); //【1】初始化 removedPackage，removedUsers 和 uid； info.removedPackage = packageName; info.removedUsers = new int[] &#123;userId&#125;; info.uid = UserHandle.getUid(userId, pkgSetting.appId); //【*2.4.2】调用了 PackageRemovedInfo 的 sendPackageRemovedBroadcasts 方法！ info.sendPackageRemovedBroadcasts(true /*killApp*/);&#125; 这里不多数说了！ 2.4.1 new PackageRemovedInfo对于 PackageRemovedInfo 这里简单看下： 12345678910111213141516class PackageRemovedInfo &#123; String removedPackage; // 要 hide 的 packageName int uid = -1; // 该 pkg 在指定的 userId 下的 uid int removedAppId = -1; // 该 pkg 的 appId int[] origUsers; int[] removedUsers = null; // 要移除的 userId boolean isRemovedPackageSystemUpdate = false; boolean isUpdate; boolean dataRemoved; // 是否移除数据，默认 false 不移除 boolean removedForAllUsers; // 是否从所有 user 下移除，默认 false； // Clean up resources deleted packages. InstallArgs args = null; ArrayMap&lt;String, PackageRemovedInfo&gt; removedChildPackages; ArrayMap&lt;String, PackageInstalledInfo&gt; appearedChildPackages; ... ... ...&#125; 2.4.2 PackageRemovedInfo.sendPackageRemovedBroadcasts1234567891011void sendPackageRemovedBroadcasts(boolean killApp) &#123; //【*2.4.2.1】调用另一个 send 方法； sendPackageRemovedBroadcastInternal(killApp); //【1】对于 child packages 执行相同的操作！ final int childCount = removedChildPackages != null ? removedChildPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageRemovedInfo childInfo = removedChildPackages.valueAt(i); //【*2.4.2.1】调用另一个 send 方法； childInfo.sendPackageRemovedBroadcastInternal(killApp); &#125;&#125; 2.4.1.1 PackageRemovedInfo.sendPackageRemovedBroadcastInternal12345678910111213141516171819202122232425262728293031323334353637private void sendPackageRemovedBroadcastInternal(boolean killApp) &#123; //【1】创建了一个 Bundle 对象； Bundle extras = new Bundle(2); //【2】保存要发送的数据：uid，data_moved，kill_app 等； extras.putInt(Intent.EXTRA_UID, removedAppId &gt;= 0 ? removedAppId : uid); extras.putBoolean(Intent.EXTRA_DATA_REMOVED, dataRemoved); extras.putBoolean(Intent.EXTRA_DONT_KILL_APP, !killApp); //【3】显然，对于 hide 是不进入这里的； if (isUpdate || isRemovedPackageSystemUpdate) &#123; extras.putBoolean(Intent.EXTRA_REPLACING, true); &#125; extras.putBoolean(Intent.EXTRA_REMOVED_FOR_ALL_USERS, removedForAllUsers); //【4】准备发送广播： if (removedPackage != null) &#123; //【*2.2.1.1】发送 Intent.ACTION_PACKAGE_REMOVED 广播； sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED, removedPackage, extras, 0, null, null, removedUsers); //【4.1】如果需要移除数据，同时 remove 的是 sys app 自身，说明这是一个完全移除； //（hide 是不会进入这个逻辑的！） if (dataRemoved &amp;&amp; !isRemovedPackageSystemUpdate) &#123; //【*2.2.1.1】发送 Intent.ACTION_PACKAGE_FULLY_REMOVED 广播； sendPackageBroadcast(Intent.ACTION_PACKAGE_FULLY_REMOVED, removedPackage, extras, 0, null, null, removedUsers); &#125; &#125; //【5】如果 removedAppId &gt;= 0，说明应用对应的 uid 被移除了！ // 然而这里 app 被 hide 了，其 app id 依然存在，所以不会发送对应的广播； //（hide 是不会进入这个逻辑的！） if (removedAppId &gt;= 0) &#123; //【*2.2.1.1】发送 Intent.ACTION_UID_REMOVED 广播； sendPackageBroadcast(Intent.ACTION_UID_REMOVED, null, extras, 0, null, null, removedUsers); &#125;&#125; 这里就不多说了！！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 10 篇 - 通过 PackageInstaller 分析 uninstall 过程","slug":"PMS10-unisntallThroughPackageInstaller","date":"2018-09-09T16:00:00.000Z","updated":"2019-01-27T09:59:46.000Z","comments":true,"path":"2018/09/10/PMS10-unisntallThroughPackageInstaller/","link":"","permalink":"https://coolqi.top/2018/09/10/PMS10-unisntallThroughPackageInstaller/","excerpt":"","text":"[toc] 基于 Android7.1.1 分析 PackageManagerService 的架构设计！ 0 综述前面总结了通过 pm uninstall 的方式来卸载一个 apk，下面我们来分析下通过 PackageInstaller 来卸载应用！ 对于用户来说，他们最常用的卸载方式，就是进入应用管理，然后进入指定的应用界面，选择卸载应用： 我们通过 dumpsys window 指令，可以看到这个焦点弹窗： 1234567891011121314sailfish:/ $ dumpsys window | grep mF mLastSystemUiFlags=0x8008 mResettingSystemUiFlags=0x0 mForceClearedSystemUiFlags=0x0 mFocusedWindow=Window&#123;b272ea0 u0 com.google.android.packageinstaller/com.android.packageinstaller.UninstallerActivity&#125; mFocusedApp=Token&#123;b7d3821 ActivityRecord&#123;53e1688 u0 com.google.android.packageinstaller/com.android.packageinstaller.UninstallerActivity t55&#125;&#125; mForceStatusBar=false mForceStatusBarFromKeyguard=false mFillsParent=false mOrientation=-1 mFillsParent=true mOrientation=-1 mFillsParent=true mOrientation=-1 mFillsParent=true mOrientation=-1 mFillsParent=true mOrientation=-1 mFillsParent=true mOrientation=5 mFillsParent=true mOrientation=1 mPolicyVisibility=false mPolicyVisibilityAfterAnim=false mAppOpVisibility=true parentHidden=false mPermanentlyHidden=false mHiddenWhileSuspended=false mForceHideNonSystemOverlayWindow=false mFocusedApp=AppWindowToken&#123;5f12446 token=Token&#123;b7d3821 ActivityRecord&#123;53e1688 u0 com.google.android.packageinstaller/com.android.packageinstaller.UninstallerActivity t55&#125;&#125;&#125; 可以看到，这个看起来像弹窗的界面，实际上是一个 Activity： 1com.google.android.packageinstaller/com.android.packageinstaller.UninstallerActivity 也就是说，拉起了 packageInstaller 去进行卸载操作，当我们点击卸载后，会触发如下的代码： 1234567891011121314@VisibleForTestingvoid uninstallPkg(String packageName, boolean allUsers, boolean andDisable) &#123; stopListeningToPackageRemove(); // Create new intent to launch Uninstaller activity //【1】创建了一个 Uri，封装 packageName 的信息，然后通过 Intent 启动 UninstallerActivity！ Uri packageUri = Uri.parse(\"package:\" + packageName); Intent uninstallIntent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageUri); uninstallIntent.putExtra(Intent.EXTRA_UNINSTALL_ALL_USERS, allUsers); mMetricsFeatureProvider.action( mActivity, MetricsProto.MetricsEvent.ACTION_SETTINGS_UNINSTALL_APP); mFragment.startActivityForResult(uninstallIntent, mRequestUninstall); mDisableAfterUninstall = andDisable;&#125; 下面我们继续分析： 1 UninstallerActivity1.1 onCreate当我们点击了卸载时，会拉起 PackageInstaller 的 UninstallerActivity 界面： 卸载时，传入的 Uri 的格式如下： package://&lt;packageName&gt;#&lt;className&gt;，className 是额外的参数，如果被指定，表示用户要卸载的具体的 activity； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 @Override public void onCreate(Bundle icicle) &#123; super.onCreate(icicle); //【1】获得启动的 intent，以及其传递的 Uri！ final Intent intent = getIntent(); final Uri packageUri = intent.getData(); //【2】packageUri 不能为 null； if (packageUri == null) &#123; Log.e(TAG, \"No package URI in intent\"); showAppNotFound(); return; &#125;//【3】包名也不能为 null； mPackageName = packageUri.getEncodedSchemeSpecificPart(); if (mPackageName == null) &#123; Log.e(TAG, \"Invalid package name in URI: \" + packageUri); showAppNotFound(); return; &#125; //【4】获得 pms 代理对象； final IPackageManager pm = IPackageManager.Stub.asInterface( ServiceManager.getService(\"package\")); //【*1.1.1】创建一个 DialogInfo 对象，保存安装和显示相关的信息； mDialogInfo = new DialogInfo(); //【5】获得卸载时，指定的用户 user，如果没有指定，默认是当前用户； mDialogInfo.user = intent.getParcelableExtra(Intent.EXTRA_USER); if (mDialogInfo.user == null) &#123; mDialogInfo.user = android.os.Process.myUserHandle(); &#125; //【6】判断是否是从所有 user 下卸载；同时，获得卸载的回调 IBinder 对象； mDialogInfo.allUsers = intent.getBooleanExtra(Intent.EXTRA_UNINSTALL_ALL_USERS, false); mDialogInfo.callback = intent.getIBinderExtra(PackageInstaller.EXTRA_CALLBACK); //【7】获得要卸载的应用信息； try &#123; mDialogInfo.appInfo = pm.getApplicationInfo(mPackageName, PackageManager.GET_UNINSTALLED_PACKAGES, mDialogInfo.user.getIdentifier()); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"Unable to get packageName. Package manager is dead?\"); &#125; //【8】应用信息不能为 null if (mDialogInfo.appInfo == null) &#123; Log.e(TAG, \"Invalid packageName: \" + mPackageName); showAppNotFound(); return; &#125; // The class name may have been specified (e.g. when deleting an app from all apps) //【9】如果指定了 actiivity，那么要获得该 activity 的信息对象； final String className = packageUri.getFragment(); if (className != null) &#123; try &#123; mDialogInfo.activityInfo = pm.getActivityInfo( new ComponentName(mPackageName, className), 0, mDialogInfo.user.getIdentifier()); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"Unable to get className. Package manager is dead?\"); // Continue as the ActivityInfo isn't critical. &#125; &#125; //【*1.2】继续下一步的处理！ showConfirmationDialog(); &#125; 1.1.1 new DialogInfo这里创建了一个 DialogInfo 对象，1234567static class DialogInfo &#123; ApplicationInfo appInfo; ActivityInfo activityInfo; boolean allUsers; UserHandle user; IBinder callback;&#125; 1.2 showConfirmationDialog继续下一步的处理： 12345private void showConfirmationDialog() &#123; //【*1.2.1】这里是切换到了一个 fragment 来显示信息； //【*2】这里会进入到 UninstallAlertDialogFragment 界面中； showDialogFragment(new UninstallAlertDialogFragment());&#125; 1.2.1 showDialogFragment切换显示 Fragment： 12345678private void showDialogFragment(DialogFragment fragment) &#123; FragmentTransaction ft = getFragmentManager().beginTransaction(); Fragment prev = getFragmentManager().findFragmentByTag(\"dialog\"); if (prev != null) &#123; ft.remove(prev); &#125; fragment.show(ft, \"dialog\");&#125; 1.3 startUninstallProgress开始卸载： 12345678910111213141516171819void startUninstallProgress() &#123; //【1】创建 Intent，传递参数： Intent newIntent = new Intent(Intent.ACTION_VIEW); //【2】要卸载的目标 user！ newIntent.putExtra(Intent.EXTRA_USER, mDialogInfo.user); //【3】是否从所有用户下下载； newIntent.putExtra(Intent.EXTRA_UNINSTALL_ALL_USERS, mDialogInfo.allUsers); //【4】卸载回调 newIntent.putExtra(PackageInstaller.EXTRA_CALLBACK, mDialogInfo.callback); //【5】要卸载的 app info newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mDialogInfo.appInfo); if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) &#123; newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true); newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); &#125; newIntent.setClass(this, UninstallAppProgress.class); //【*3.1】进入 UninstallAppProgress 界面； startActivity(newIntent);&#125; 启动 UninstallAppProgress activity，进入卸载状态！ 2 UninstallAlertDialogFragmentUninstallAlertDialogFragment 是 DialogFragment 的子类，实现了 DialogInterface.OnClickListener 接口。 我们去他的 onCreateDialog 方法中看看： 2.1 onCreateDialog该方法会创建一个 Dialog： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState) &#123; final PackageManager pm = getActivity().getPackageManager(); //【*1.1】获得前面创建的 DialogInfo 实例 final DialogInfo dialogInfo = ((UninstallerActivity) getActivity()).mDialogInfo; final CharSequence appLabel = dialogInfo.appInfo.loadLabel(pm); AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity()); StringBuilder messageBuilder = new StringBuilder(); //【1】如果指定了 activity，那么同时 Activity label 不同于 App label // 这里就要显示的通知用户要卸载的 activity 属于该 app！ if (dialogInfo.activityInfo != null) &#123; final CharSequence activityLabel = dialogInfo.activityInfo.loadLabel(pm); if (!activityLabel.equals(appLabel)) &#123; // uninstall_activity_text：属于以下应用： messageBuilder.append( getString(R.string.uninstall_activity_text, activityLabel)); messageBuilder.append(\" \").append(appLabel).append(\".\\n\\n\"); &#125; &#125; //【2】判断下要卸载的应用是不是安装在 data 分区的 sys app 的更新； final boolean isUpdate = ((dialogInfo.appInfo.flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0); UserManager userManager = UserManager.get(getActivity()); if (isUpdate) &#123; //【3】如果卸载是安装在 data 分区的 sys app 的更新，那么要根据系统是否是 single user // 提示不同的信息！ if (isSingleUser(userManager)) &#123; //【*2.1.1】isSingleUser 判断是否是 single user！ // 提示：\"要将此应用替换为出厂版本吗？这样会移除所有数据。\" messageBuilder.append(getString(R.string.uninstall_update_text)); &#125; else &#123; // 提示：\"要将此应用替换为出厂版本吗？这样会移除所有数据，并会影响此设备的所有用户 //（包括已设置工作资料的用户）。\" messageBuilder.append(getString(R.string.uninstall_update_text_multiuser)); &#125; &#125; else &#123; //【4】如果卸载是安装在 data 分区的 user app，那么同样的，要根据系统是否是 single user // 以及卸载的 allUsers 参数来做不同的显示！ if (dialogInfo.allUsers &amp;&amp; !isSingleUser(userManager)) &#123; //【4.1】如果是要从所有用户下卸载，同时系统不是 single user 的，那么 // 提示：\"是否要为所有用户卸载此应用？系统将为设备上的所有用户删除此应用及其数据。\" messageBuilder.append(getString(R.string.uninstall_application_text_all_users)); &#125; else if (!dialogInfo.user.equals(android.os.Process.myUserHandle())) &#123; //【4.2】如果指定了要卸载的用户 user，同时该用户不是当前用户 user！ // 提示：\"您要为用户 user 卸载此应用吗？\" UserInfo userInfo = userManager.getUserInfo(dialogInfo.user.getIdentifier()); messageBuilder.append( getString(R.string.uninstall_application_text_user, userInfo.name)); &#125; else &#123; //【4.3】其他情况，提示：\"要卸载此应用吗？\" messageBuilder.append(getString(R.string.uninstall_application_text)); &#125; &#125; //【5】创建一个 Dialog 并返回！ dialogBuilder.setTitle(appLabel); dialogBuilder.setIcon(dialogInfo.appInfo.loadIcon(pm)); dialogBuilder.setPositiveButton(android.R.string.ok, this); dialogBuilder.setNegativeButton(android.R.string.cancel, this); dialogBuilder.setMessage(messageBuilder.toString()); return dialogBuilder.create();&#125; 整个过程很简单，不多说了！ 2.1.1 isSingleUser判断系统是否是单用户： 12345private boolean isSingleUser(UserManager userManager) &#123; final int userCount = userManager.getUserCount(); return userCount == 1 || (UserManager.isSplitSystemUser() &amp;&amp; userCount == 2);&#125; 2.2 onClick卸载的关键触发是在 UninstallAlertDialogFragment 的点击事件中： 123456789@Overridepublic void onClick(DialogInterface dialog, int which) &#123; if (which == Dialog.BUTTON_POSITIVE) &#123; //【*1.3】开始卸载！ ((UninstallerActivity) getActivity()).startUninstallProgress(); &#125; else &#123; ((UninstallerActivity) getActivity()).dispatchAborted(); &#125;&#125; 不多说了！！ 3 UninstallAppProgress3.1 onCreate下面是卸载界面的 onCreate 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Overridepublic void onCreate(Bundle icicle) &#123; super.onCreate(icicle); //【1】获得启动的 Intent； Intent intent = getIntent(); //【2】获得要卸载的 app info mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); //【3】获得安装回调； mCallback = intent.getIBinderExtra(PackageInstaller.EXTRA_CALLBACK); //【4】这里是因为 UninstallAppProgress 不支持 onDestroy-&gt;onCreate 的数据恢复； // 如果是这种情况，结束安装； if (icicle != null) &#123; mResultCode = PackageManager.DELETE_FAILED_INTERNAL_ERROR; //【4.1】如果指定了回调，那么会获得其代理对象，然后触发回调！ if (mCallback != null) &#123; final IPackageDeleteObserver2 observer = IPackageDeleteObserver2.Stub .asInterface(mCallback); try &#123; observer.onPackageDeleted(mAppInfo.packageName, mResultCode, null); &#125; catch (RemoteException ignored) &#123; &#125; finish(); &#125; else &#123; //【4.2】如果没有指定回调，那么会发送 resultCode！ setResultAndFinish(mResultCode); &#125; return; &#125; //【5】是否是从所有用户下下载； mAllUsers = intent.getBooleanExtra(Intent.EXTRA_UNINSTALL_ALL_USERS, false); //【6】如果是所有用户，而当前用户不是 AdminUser，那么会抛出异常； if (mAllUsers &amp;&amp; !UserManager.get(this).isAdminUser()) &#123; throw new SecurityException(\"Only admin user can request uninstall for all users\"); &#125; //【7】是否指定了 user，如果没有指定那么默认就是当前 user；如果指定了，那么该 user 必须存在！ mUser = intent.getParcelableExtra(Intent.EXTRA_USER); if (mUser == null) &#123; mUser = android.os.Process.myUserHandle(); &#125; else &#123; UserManager userManager = (UserManager) getSystemService(Context.USER_SERVICE); List&lt;UserHandle&gt; profiles = userManager.getUserProfiles(); if (!profiles.contains(mUser)) &#123; throw new SecurityException(\"User \" + android.os.Process.myUserHandle() + \" can't \" + \"request uninstall for user \" + mUser); &#125; &#125; //【*3.1.1】创建 PackageDeleteObserver 对象，接收卸载的回调； PackageDeleteObserver observer = new PackageDeleteObserver(); // 使窗口透明，直到调用 initView。 在许多情况下，我们可以避免显示UI，因为应用程序很快就会被卸载。 // 如果我们显示 UI 并立即删除它，它看起来就像一个闪烁。 getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); getWindow().setStatusBarColor(Color.TRANSPARENT); getWindow().setNavigationBarColor(Color.TRANSPARENT); //【*5】执行卸载操作！ getPackageManager().deletePackageAsUser(mAppInfo.packageName, observer, mAllUsers ? PackageManager.DELETE_ALL_USERS : 0, mUser.getIdentifier()); //【*4.1】延迟 500 ms，发送了 UNINSTALL_IS_SLOW 消息，初始化界面！ mHandler.sendMessageDelayed(mHandler.obtainMessage(UNINSTALL_IS_SLOW), QUICK_INSTALL_DELAY_MILLIS);&#125; 3.1.1 new PackageDeleteObserverPackageDeleteObserver 接收安装结果！ 123456789class PackageDeleteObserver extends IPackageDeleteObserver.Stub &#123; public void packageDeleted(String packageName, int returnCode) &#123; //【4.2】卸载完成后，会发送 UNINSTALL_COMPLETE 消息！ Message msg = mHandler.obtainMessage(UNINSTALL_COMPLETE); msg.arg1 = returnCode; // 保存了安装结果码； msg.obj = packageName; mHandler.sendMessage(msg); &#125;&#125; 这里就不多说了！ 3.2 initView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void initView() &#123; if (mIsViewInitialized) &#123; return; &#125; mIsViewInitialized = true; // We set the window background to translucent in constructor, revert this TypedValue attribute = new TypedValue(); getTheme().resolveAttribute(android.R.attr.windowBackground, attribute, true); if (attribute.type &gt;= TypedValue.TYPE_FIRST_COLOR_INT &amp;&amp; attribute.type &lt;= TypedValue.TYPE_LAST_COLOR_INT) &#123; getWindow().setBackgroundDrawable(new ColorDrawable(attribute.data)); &#125; else &#123; getWindow().setBackgroundDrawable(getResources().getDrawable(attribute.resourceId, getTheme())); &#125; getTheme().resolveAttribute(android.R.attr.navigationBarColor, attribute, true); getWindow().setNavigationBarColor(attribute.data); getTheme().resolveAttribute(android.R.attr.statusBarColor, attribute, true); getWindow().setStatusBarColor(attribute.data); //【1】判断下要卸载的应用是不是安装在 data 分区的 sys app 的更新，用于不同的显示！ boolean isUpdate = ((mAppInfo.flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0); setTitle(isUpdate ? R.string.uninstall_update_title : R.string.uninstall_application_title); setContentView(R.layout.uninstall_progress); // 设置布局！ //【2】初始化 view！ View snippetView = findViewById(R.id.app_snippet); //【3】使用 app info 初始化 snippetView，显示 app 信息！ PackageUtil.initSnippetForInstalledApp(this, mAppInfo, snippetView); //【4】初始化设备管理按钮和用户管理按钮，默认是 gone，同时设置点击事件！ mDeviceManagerButton = (Button) findViewById(R.id.device_manager_button); mUsersButton = (Button) findViewById(R.id.users_button); mDeviceManagerButton.setVisibility(View.GONE); mDeviceManagerButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(); intent.setClassName(\"com.android.settings\", \"com.android.settings.Settings$DeviceAdminSettingsActivity\"); intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); &#125; &#125;); mUsersButton.setVisibility(View.GONE); mUsersButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Settings.ACTION_USER_SETTINGS); intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); &#125; &#125;); //【5】初始化完成按钮，默认也是 gone 在布局里设置的！ mOkButton = (Button) findViewById(R.id.ok_button); mOkButton.setOnClickListener(this);&#125; 4 mHandler - mainLooper123private Handler mHandler = new Handler() &#123; ... ... ...&#125; mHandler 持有 main thead 的 looper 对象，消息都会发送到主线程操作！ 4.1 handleMessage[UNINSTALL_IS_SLOW]发送 UNINSTALL_IS_SLOW 消息，触发 initView 操作： 1234case UNINSTALL_IS_SLOW: //【*3.2】初始化 view！ initView(); break; 不多说了！ 4.2 handleMessage[UNINSTALL_COMPLETE]发送 UNINSTALL_COMPLETE 消息，处理卸载结果和最终的显示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162case UNINSTALL_COMPLETE: mHandler.removeMessages(UNINSTALL_IS_SLOW); if (msg.arg1 != PackageManager.DELETE_SUCCEEDED) &#123; //【*3.2】结果不是 success，再次初始化 view！ initView(); &#125; mResultCode = msg.arg1; final String packageName = (String) msg.obj; //【1】如果指定了回调，那就通过回调返回结果，并 finish 掉 UninstallAppProgress！ if (mCallback != null) &#123; final IPackageDeleteObserver2 observer = IPackageDeleteObserver2.Stub .asInterface(mCallback); try &#123; observer.onPackageDeleted(mAppInfo.packageName, mResultCode, packageName); &#125; catch (RemoteException ignored) &#123; &#125; finish(); return; &#125; //【2】如果 intent 指定了返回启动结果，那么就通过 intent 返回卸载结果， // 并 finish 掉 UninstallAppProgress！ if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) &#123; Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, mResultCode); setResult(mResultCode == PackageManager.DELETE_SUCCEEDED ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER, result); finish(); return; &#125; //【3】更新界面显示内容； final String statusText; switch (msg.arg1) &#123; //【3.1】卸载成功； case PackageManager.DELETE_SUCCEEDED: statusText = getString(R.string.uninstall_done); // Show a Toast and finish the activity Context ctx = getBaseContext(); Toast.makeText(ctx, statusText, Toast.LENGTH_LONG).show(); //【3.1.1】返回结果； setResultAndFinish(mResultCode); return; //【3.2】该 apk 是处于 active 状态的设备管理者，不可卸载； case PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER: &#123; UserManager userManager = (UserManager) getSystemService(Context.USER_SERVICE); IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface( ServiceManager.getService(Context.DEVICE_POLICY_SERVICE)); // Find out if the package is an active admin for some non-current user. //【3.2.1】获得当前的 user id； int myUserId = UserHandle.myUserId(); UserInfo otherBlockingUser = null; //【3.2.2】遍历所有的 user！ for (UserInfo user : userManager.getUsers()) &#123; //【3.2.2.1】找到不是当前 user 或者不是当前 user 的 profile 的 user！ if (isProfileOfOrSame(userManager, myUserId, user.id)) continue; try &#123; //【3.2.2.1】如果该 apk 在这个 user 下是活跃的设备管理者，将其保存到 // otherBlockingUser 中； if (dpm.packageHasActiveAdmins(packageName, user.id)) &#123; otherBlockingUser = user; break; &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"Failed to talk to package manager\", e); &#125; &#125; //【3.2.3】如果 otherBlockingUser 为 null，说明 apk 是当前 user 的活跃设备管理者； // 如果不为 null，说明在其他 user 下是活跃设备管理者； if (otherBlockingUser == null) &#123; Log.d(TAG, \"Uninstall failed because \" + packageName + \" is a device admin\"); //【3.2.3.1】可以看到，这里 mDeviceManagerButton 是可以点击的！！！ mDeviceManagerButton.setVisibility(View.VISIBLE); statusText = getString( R.string.uninstall_failed_device_policy_manager); &#125; else &#123; Log.d(TAG, \"Uninstall failed because \" + packageName + \" is a device admin of user \" + otherBlockingUser); mDeviceManagerButton.setVisibility(View.GONE); statusText = String.format( getString(R.string.uninstall_failed_device_policy_manager_of_user), otherBlockingUser.name); &#125; break; &#125; //【3.3】该 apk 被设备管理者标记为不可卸载； case PackageManager.DELETE_FAILED_OWNER_BLOCKED: &#123; UserManager userManager = (UserManager) getSystemService(Context.USER_SERVICE); IPackageManager packageManager = IPackageManager.Stub.asInterface( ServiceManager.getService(\"package\")); //【3.3.1】首先找到，在那个 user 下是不可卸载的，只会找到第一个 user！ List&lt;UserInfo&gt; users = userManager.getUsers(); int blockingUserId = UserHandle.USER_NULL; for (int i = 0; i &lt; users.size(); ++i) &#123; final UserInfo user = users.get(i); try &#123; if (packageManager.getBlockUninstallForUser(packageName, user.id)) &#123; blockingUserId = user.id; break; &#125; &#125; catch (RemoteException e) &#123; // Shouldn't happen. Log.e(TAG, \"Failed to talk to package manager\", e); &#125; &#125; int myUserId = UserHandle.myUserId(); //【3.3.2】如果该 user 是当前 user 或者是当前 user 的 profile， // 那么 Device Manager Button 可点击； // 否则 Users Button 可点击； if (isProfileOfOrSame(userManager, myUserId, blockingUserId)) &#123; mDeviceManagerButton.setVisibility(View.VISIBLE); &#125; else &#123; mDeviceManagerButton.setVisibility(View.GONE); mUsersButton.setVisibility(View.VISIBLE); &#125; // TODO: b/25442806 if (blockingUserId == UserHandle.USER_SYSTEM) &#123; // 提示：\"这是您的设备管理员要求必须安装的应用，因此无法卸载。\" statusText = getString(R.string.uninstall_blocked_device_owner); &#125; else if (blockingUserId == UserHandle.USER_NULL) &#123; Log.d(TAG, \"Uninstall failed for \" + packageName + \" with code \" + msg.arg1 + \" no blocking user\"); // 提示：\"卸载失败。\" statusText = getString(R.string.uninstall_failed); &#125; else &#123; // 如果是所有用户下卸载， // 提示：\"这是部分用户或个人资料所需的应用；已为其他用户或个人资料卸载此应用\" // 否则提示：\"这是您的个人资料所需的应用，因此无法卸载。\" statusText = mAllUsers ? getString(R.string.uninstall_all_blocked_profile_owner) : getString(R.string.uninstall_blocked_profile_owner); &#125; break; &#125; default: Log.d(TAG, \"Uninstall failed for \" + packageName + \" with code \" + msg.arg1); statusText = getString(R.string.uninstall_failed); break; &#125; findViewById(R.id.progress_view).setVisibility(View.GONE); findViewById(R.id.status_view).setVisibility(View.VISIBLE); ((TextView)findViewById(R.id.status_text)).setText(statusText); //【4】将完成按钮显示出来！ findViewById(R.id.ok_panel).setVisibility(View.VISIBLE); break; 5 PackageManagerService最终的卸载，进入了 pms：12345678@Overridepublic void deletePackageAsUser(String packageName, IPackageDeleteObserver observer, int userId, int flags) &#123; //【*important】这里和 adb uninstall 的逻辑一样了！ //【*5.1】对前面的回调做二次封装； deletePackage(packageName, new LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);&#125; 5.1 new LegacyPackageDeleteObserverLegacyPackageDeleteObserver 的定义是在 PackageManager.java 中： 123456789101112131415161718/** &#123;@hide&#125; */public static class LegacyPackageDeleteObserver extends PackageDeleteObserver &#123; private final IPackageDeleteObserver mLegacy; public LegacyPackageDeleteObserver(IPackageDeleteObserver legacy) &#123; mLegacy = legacy; &#125; @Override public void onPackageDeleted(String basePackageName, int returnCode, String msg) &#123; if (mLegacy == null) return; try &#123; //【*3.1.1】回调接口！ mLegacy.packageDeleted(basePackageName, returnCode); &#125; catch (RemoteException ignored) &#123; &#125; &#125;&#125; LegacyPackageDeleteObserver 实际上是对前面的回调的一次封装！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 9 篇 - 通过 adb 指令分析 uninstall 过程","slug":"PMS9-uninstallThroughAdb","date":"2018-08-31T16:00:00.000Z","updated":"2019-01-27T09:59:59.000Z","comments":true,"path":"2018/09/01/PMS9-uninstallThroughAdb/","link":"","permalink":"https://coolqi.top/2018/09/01/PMS9-uninstallThroughAdb/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现！ 0 综述本篇文章总结下 uninstall package 的过程，一般来说，卸载一个应用有如下的方式： adb uninstall（最终调用的还是 pm uninstall/cmd package uninstall）； adb cmd package uninstall; adb shell pm uninstall; 进入应用管理器中，手动触发卸载（进入 packageInstaller）； 这里我们先来看通过 adb 指令 uninstall 的过程： 1 adb uninstall - commandline::adb_commandline同样的 adb uninstall 的执行也是从 system/core/adb/commandline.cpp 开始： adb_commandline 中会设置到大量的 adb 指令的处理，这里我们只关注 adb install 的处理： 123456789101112131415int adb_commandline(int argc, const char **argv) &#123; ... ... ... else if (!strcmp(argv[0], \"uninstall\")) &#123; // adb uninstall 命令! if (argc &lt; 2) return usage(); if (_use_legacy_install()) &#123; //【*1.2.2】不支持 cmd 使用 pm 安装！ return uninstall_app_legacy(transport_type, serial, argc, argv); &#125; //【*1.2.1】支持 cmd 使用 cmd 安装！ return uninstall_app(transport_type, serial, argc, argv); &#125; ... ... ... usage(); return 1;&#125; 这里看到，如果支持 cmd 命令的情况下，_use_legacy_install() 方法返回 false，会调用 uninstall_app；不支持的话，执行 uninstall_app_legacy 方法！ Android cmd 命令功能非常强大，包含了我们之前使用 am pm 等等的命令，这里我们不深入分析 cmd 的命令的实现，我们关注和 uninstall 相关的逻辑！ 下面继续分析，进一步的安装过程： 1.1 cmd uninstall - 支持 cmd 指令1.1.1 commandline::uninstall_app1234567891011121314151617static int uninstall_app(TransportType transport, const char* serial, int argc, const char** argv) &#123; //【1】adb uninstall 会转为 cmd package uninstall，参数相同； std::string cmd = \"cmd package\"; while (argc-- &gt; 0) &#123; if (strcmp(*argv, \"-k\") == 0) &#123; printf( \"The -k option uninstalls the application while retaining the data/cache.\\n\" \"At the moment, there is no way to remove the remaining data.\\n\" \"You will have to reinstall the application with the same signature, and fully uninstall it.\\n\" \"If you truly wish to continue, execute 'adb shell cmd package uninstall -k'.\\n\"); return EXIT_FAILURE; &#125; cmd += \" \" + escape_arg(*argv++); &#125; //【*1.2.3】调用 send_shell_command 指令； return send_shell_command(transport, serial, cmd, false);&#125; 1.2 pm uninstall - 不支持 cmd 指令1.2.1 commandline::uninstall_app_legacy123456789101112131415static int uninstall_app_legacy(TransportType transport, const char* serial, int argc, const char** argv) &#123; int i; for (i = 1; i &lt; argc; i++) &#123; if (!strcmp(argv[i], \"-k\")) &#123; printf( \"The -k option uninstalls the application while retaining the data/cache.\\n\" \"At the moment, there is no way to remove the remaining data.\\n\" \"You will have to reinstall the application with the same signature, and fully uninstall it.\\n\" \"If you truly wish to continue, execute 'adb shell pm uninstall -k'\\n.\"); return EXIT_FAILURE; &#125; &#125; //【*1.2.2】调用 pm_command 指令； return pm_command(transport, serial, argc, argv);&#125; 1.2.2 commandline::pm_command12345678910static int pm_command(TransportType transport, const char* serial, int argc, const char** argv) &#123; //【1】adb uninstall 会转为 pm uninstall，参数相同； std::string cmd = \"pm\"; while (argc-- &gt; 0) &#123; cmd += \" \" + escape_arg(*argv++); &#125; //【*1.2.3】调用 send_shell_command 指令； return send_shell_command(transport, serial, cmd, false);&#125; 1.2.3 commandline::send_shell_command12345678910111213141516171819202122232425262728293031323334353637383940int send_shell_command(TransportType transport_type, const char* serial, const std::string&amp; command, bool disable_shell_protocol, StandardStreamsCallbackInterface* callback) &#123; int fd; bool use_shell_protocol = false; while (true) &#123; bool attempt_connection = true; // 使用 shell protocol if (!disable_shell_protocol) &#123; FeatureSet features; std::string error; if (adb_get_feature_set(&amp;features, &amp;error)) &#123; // 如果系统支持 shell_v2 的 feature，则使用 shell！！ use_shell_protocol = CanUseFeature(features, kFeatureShell2); &#125; else &#123; attempt_connection = false; &#125; &#125; if (attempt_connection) &#123; std::string error; // 如果是 pm uninstall 此时 command 中携带的就是以 pm 开头的命令； // 如果是 cmd package uninstall 此时 command 中携带的就是以 cmd 开头的命令； std::string service_string = ShellServiceString(use_shell_protocol, \"\", command); // 向 shell protocol 发送命令 fd = adb_connect(service_string, &amp;error); if (fd &gt;= 0) &#123; break; &#125; &#125; fprintf(stderr, \"- waiting for device -\\n\"); if (!wait_for_device(\"wait-for-device\", transport_type, serial)) &#123; return 1; &#125; &#125; // 处理命令执行结果！ int exit_code = read_and_dump(fd, use_shell_protocol, callback); if (adb_close(fd) &lt; 0) &#123; PLOG(ERROR) &lt;&lt; \"failure closing FD \" &lt;&lt; fd; &#125; return exit_code;&#125; 可以看到，最后都是调用 shell 执行相关指令！ 前面我们有分析过： cmd package uninstall 最后调用的是 PackageManagerShellCommand 相关方法； pm uninstall 最后调用的是 pm 相关方法； 2 Pm install对于 pm 命令的执行过程，我们不在过多分析，直接进入重点： 2.1 runUninstall1234private int runUninstall() &#123; //【*2.2】继续处理！ return runShellCommand(\"package\", mArgs);&#125; 2.2 runShellCommand我们看到，我们传入的 Service name 是 “package”，其实看到这里，我们已经能猜到了，其和 cmd install 一样，最后会调用了 PackageManagerShellCommand 的 onCommand 方法！ 1234567891011121314151617private int runShellCommand(String serviceName, String[] args) &#123; final HandlerThread handlerThread = new HandlerThread(\"results\"); handlerThread.start(); try &#123; //【*3.1】通过 pms 触发 PackageManagerShellCommand 的 onCommand 方法，最后会根据参数 // 最后会进入 runUninstall 方法中！ ServiceManager.getService(serviceName).shellCommand( FileDescriptor.in, FileDescriptor.out, FileDescriptor.err, args, new ResultReceiver(new Handler(handlerThread.getLooper()))); return 0; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; finally &#123; handlerThread.quitSafely(); &#125; return -1;&#125; 我们可以去 pms 的代码中看到，pms 有如下的逻辑： 1234567@Overridepublic void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ResultReceiver resultReceiver) &#123; //【*3.1】调用了 PackageManagerShellCommand 的接口！！ (new PackageManagerShellCommand(this)).exec( this, in, out, err, args, resultReceiver);&#125; PackageManagerShellCommand 继承了 ShellCommand， exec 内部会触发 onCommand 方法，有兴趣大家可以去学习，这里不关注！！ 3 PackageManagerShellCommand3.1 runUninstall我们来分析下 runUninstall 的逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int runUninstall() throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); int flags = 0; int userId = UserHandle.USER_ALL; // 默认所有用户！ String opt; //【1】读取额外参数 while ((opt = getNextOption()) != null) &#123; switch (opt) &#123; case \"-k\": //【1.1】是否再卸载后保留数据； flags |= PackageManager.DELETE_KEEP_DATA; break; case \"--user\": //【1.1】是否指定 user！ userId = UserHandle.parseUserArg(getNextArgRequired()); break; default: pw.println(\"Error: Unknown option: \" + opt); return 1; &#125; &#125; //【3】获得要卸载的应用包名； final String packageName = getNextArg(); if (packageName == null) &#123; pw.println(\"Error: package name not specified\"); return 1; &#125; //【4】获得要卸载的应用的 split apk 包名，如果指定的 split name，那就只卸载对应的 split apk！ final String splitName = getNextArg(); if (splitName != null) &#123; //【*3.2】移除 split apk！ return runRemoveSplit(packageName, splitName); &#125; //【*3.1.1】对 userId 做一个转换处理; userId = translateUserId(userId, \"runUninstall\"); if (userId == UserHandle.USER_ALL) &#123; //【5】如果是从所有用户下删除，那么 userId 变为 USER_SYSTEM； // flags 设置 DELETE_ALL_USERS 标志位； userId = UserHandle.USER_SYSTEM; flags |= PackageManager.DELETE_ALL_USERS; &#125; else &#123; //【6】如果是从指定用户下删除，那么要判断在该 userId 下是否有安装信息； final PackageInfo info = mInterface.getPackageInfo(packageName, 0, userId); if (info == null) &#123; pw.println(\"Failure [not installed for \" + userId + \"]\"); return 1; &#125; //【7】判断是否是 sys app，如果是的话 flags 增加 DELETE_SYSTEM_APP 标志位！ final boolean isSystem = (info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0; if (isSystem) &#123; flags |= PackageManager.DELETE_SYSTEM_APP; &#125; &#125; //【*3.1.2.1】这里是注册可以了本地监听器 LocalIntentReceiver，监听卸载结果，在 install 我们 // 有分析过，这里就不多说了！ final LocalIntentReceiver receiver = new LocalIntentReceiver(); //【*4.1】触发卸载； mInterface.getPackageInstaller().uninstall(packageName, null /*callerPackageName*/, flags, receiver.getIntentSender(), userId); //【*3.1.2.2】接收卸载结果，就是前面分析时，创建的 intent fillIn！！ final Intent result = receiver.getResult(); final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (status == PackageInstaller.STATUS_SUCCESS) &#123; pw.println(\"Success\"); return 0; &#125; else &#123; pw.println(\"Failure [\" + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + \"]\"); return 1; &#125;&#125; 这里的 mInterface.getPackageInstaller() 返回的是 PackageInstallerService，下面我们去 PackageInstallerService 中看看： 3.1.1 translateUserId如果 uninstall 指定的 user，那么这里会对 userId 做一个转换处理：1234private int translateUserId(int userId, String logContext) &#123; return ActivityManager.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, logContext, \"pm command\");&#125; 3.1.2 LocalIntentReceiverLocalIntentReceiver 主要用于接收最终的返回结果，以及和其他模块通信： 3.1.2.1 new LocalIntentReceiver1234567891011121314151617private static class LocalIntentReceiver &#123; //【1】内有一个阻塞队列，用于保存 intent！ private final SynchronousQueue&lt;Intent&gt; mResult = new SynchronousQueue&lt;&gt;(); //【2】发送 intent 给其他模块： private IIntentSender.Stub mLocalSender = new IIntentSender.Stub() &#123; @Override public void send(int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) &#123; try &#123; //【2.1】将 Proxy 传来的 intent 加入的阻塞队列中！ mResult.offer(intent, 5, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;; 不多数说了！！ 3.1.2.2 getIntentSender返回代理对象，用于跨进程通信：123public IntentSender getIntentSender() &#123; return new IntentSender((IIntentSender) mLocalSender);&#125; 3.1.2.2 getResult从内部的阻塞队列中返回结果！ 1234567public Intent getResult() &#123; try &#123; return mResult.take(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125;&#125; 3.2 runRemoveSplit我们来看下删除 split apk 的逻辑！ 参数 String packageName 是主 pkg，String splitName 则是 split apk 的包名！ 123456789101112131415161718192021222324252627282930313233343536private int runRemoveSplit(String packageName, String splitName) throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); //【1-review】这边创建了一个 SessionParams 实例，封装卸载的事务参数！ // 这里就不在分析了，前面看过！ final SessionParams sessionParams = new SessionParams(SessionParams.MODE_INHERIT_EXISTING); sessionParams.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; sessionParams.appPackageName = packageName; //【*3.2.1】创建一个卸载事务！ final int sessionId = doCreateSession(sessionParams, null /*installerPackageName*/, UserHandle.USER_ALL); boolean abandonSession = true; try &#123; //【*3.2.2】移除 split apk！ if (doRemoveSplit(sessionId, splitName, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; //【*3.2.3】提交事务 if (doCommitSession(sessionId, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; abandonSession = false; pw.println(\"Success\"); return 0; &#125; finally &#123; if (abandonSession) &#123; try &#123; doAbandonSession(sessionId, false /*logSuccess*/); &#125; catch (Exception ignore) &#123; &#125; &#125; &#125;&#125; 这里先创建了一个 SessionParams，参数均是 @hide 的，这里我省略了！ 123456789101112131415161718192021public static class SessionParams implements Parcelable &#123; public int mode = MODE_INVALID; public int installFlags; public int installLocation = PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY; // 默认为仅内置 public long sizeBytes = -1; public String appPackageName; // 这里其为主 pkg 的包名！ public Bitmap appIcon; public String appLabel; public long appIconLastModified = -1; public Uri originatingUri; public int originatingUid = UID_UNKNOWN; public Uri referrerUri; public String abiOverride; public String volumeUuid; public String[] grantedRuntimePermissions; public SessionParams(int mode) &#123; this.mode = mode; &#125; ... ... ...&#125; 可以看到，对于 remove split apk，其流程和 install 很类似！ 3.2.1 doCreateSession创建事务： 1234567891011121314private int doCreateSession(SessionParams params, String installerPackageName, int userId) throws RemoteException &#123; //【*3.1.1】对 user 进行一个转换； userId = translateUserId(userId, \"runInstallCreate\"); if (userId == UserHandle.USER_ALL) &#123; userId = UserHandle.USER_SYSTEM; params.installFlags |= PackageManager.INSTALL_ALL_USERS; &#125; //【*7.1.1】调用 PackageInstallerService 的 createSession 创建一个新的事务！ final int sessionId = mInterface.getPackageInstaller() .createSession(params, installerPackageName, userId); return sessionId;&#125; 这里和 install 很类似！ 3.2.2 doRemoveSplit移除 split apk，这里是真正的对 split apk 做处理，前面只是创建了一个主 apk 的 install 食物： 123456789101112131415161718192021222324private int doRemoveSplit(int sessionId, String splitName, boolean logSuccess) throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); PackageInstaller.Session session = null; try &#123; //【1-review】返回之前创建的 PackageInstallerSession，将其封装为 PackageInstaller.Session 实例！ //【*7.1.1.2】获得事务； session = new PackageInstaller.Session( mInterface.getPackageInstaller().openSession(sessionId)); //【*7.2.2】这个地方我们知道，最后调用了 PackageInstallerSession 的 removeSplit 方法! session.removeSplit(splitName); if (logSuccess) &#123; pw.println(\"Success\"); &#125; return 0; &#125; catch (IOException e) &#123; pw.println(\"Error: failed to remove split; \" + e.getMessage()); return 1; &#125; finally &#123; IoUtils.closeQuietly(session); &#125;&#125; Session 其实很简单：1234public static class Session implements Closeable &#123; private IPackageInstallerSession mSession; ... ... ...&#125; 不多数了！ 继续分析，我们看看 removeSplit 发生了什么： 3.2.3 doCommitSession提交事务： 123456789101112131415161718192021222324252627282930private int doCommitSession(int sessionId, boolean logSuccess) throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); PackageInstaller.Session session = null; try &#123; session = new PackageInstaller.Session( mInterface.getPackageInstaller().openSession(sessionId)); //【*3.1.2.1】这里是注册可以了本地监听器 LocalIntentReceiver，监听卸载结果，在 install 我们 // 有分析过，这里就不多说了！ final LocalIntentReceiver receiver = new LocalIntentReceiver(); //【*7.2.4】提交事务 session.commit(receiver.getIntentSender()); final Intent result = receiver.getResult(); final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (status == PackageInstaller.STATUS_SUCCESS) &#123; if (logSuccess) &#123; pw.println(\"Success\"); &#125; &#125; else &#123; pw.println(\"Failure [\" + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + \"]\"); &#125; return status; &#125; finally &#123; IoUtils.closeQuietly(session); &#125;&#125; 4 PackageInstallerService4.1 uninstall这里我们说一下参数 IntentSender statusReceiver，其是前面 LocalIntentReceiver.getIntentSender() 返回的 IntentSender 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void uninstall(String packageName, String callerPackageName, int flags, IntentSender statusReceiver, int userId) &#123; final int callingUid = Binder.getCallingUid(); //【1】会校验调用者是否具有 across user 的权限，同时也会调用 appOps 去检查 callingUid 和 callerPackageName // 是否匹配！ mPm.enforceCrossUserPermission(callingUid, userId, true, true, \"uninstall\"); if ((callingUid != Process.SHELL_UID) &amp;&amp; (callingUid != Process.ROOT_UID)) &#123; mAppOps.checkPackage(callingUid, callerPackageName); &#125; //【2】检查 caller 是否是设备用户自身！ DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService( Context.DEVICE_POLICY_SERVICE); boolean isDeviceOwner = (dpm != null) &amp;&amp; dpm.isDeviceOwnerAppOnCallingUser( callerPackageName); //【*4.1.1.1】创建一个 PackageDeleteObserverAdapter 监听卸载删除结果！ final PackageDeleteObserverAdapter adapter = new PackageDeleteObserverAdapter(mContext, statusReceiver, packageName, isDeviceOwner, userId); //【3】检查调用者是否有 DELETE_PACKAGES 的权限，如果有直接通过 pms 直接 deletePackage！ if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DELETE_PACKAGES) == PackageManager.PERMISSION_GRANTED) &#123; //【*5.1】继续卸载； mPm.deletePackage(packageName, adapter.getBinder(), userId, flags); &#125; else if (isDeviceOwner) &#123; //【4】检查调用者是否是 DeviceOwner，如果有直接通过 pms 直接 deletePackage！ // 这里会将调用者转为系统进程，继续处理！ long ident = Binder.clearCallingIdentity(); try &#123; //【*5.1】继续卸载； mPm.deletePackage(packageName, adapter.getBinder(), userId, flags); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; else &#123; //【5】这种情况需要通知用户，让用户主动卸载，会发送 Intent.ACTION_UNINSTALL_PACKAGE 给 PackageInstaller！ final Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE); intent.setData(Uri.fromParts(\"package\", packageName, null)); intent.putExtra(PackageInstaller.EXTRA_CALLBACK, adapter.getBinder().asBinder()); //【*4.1.1.2】通知用户！ adapter.onUserActionRequired(intent); &#125;&#125; 代码很简单，不多说了！ 4.1.1 PackageDeleteObserverAdapter4.1.1.1 new PackageInstallerService创建了一个 package delete 监听器！ boolean showNotification 表示是否需要显示通知，上面传入的是 isDeviceOwner，就是说如果是设备拥有者，那么一定会显示通知！ 12345678910111213141516171819202122static class PackageDeleteObserverAdapter extends PackageDeleteObserver &#123; private final Context mContext; private final IntentSender mTarget; // 对应的 LocalIntentReceiver.getIntentSender(！ private final String mPackageName; // 要卸载的 apk private final Notification mNotification; // 显示的通知！ public PackageDeleteObserverAdapter(Context context, IntentSender target, String packageName, boolean showNotification, int userId) &#123; mContext = context; mTarget = target; mPackageName = packageName; if (showNotification) &#123; mNotification = buildSuccessNotification(mContext, mContext.getResources().getString(R.string.package_deleted_device_owner), packageName, userId); &#125; else &#123; mNotification = null; &#125; &#125; ... ... ...&#125; 不多说了！ 4.1.1.2 onUserActionRequired当没有权限直接卸载时，需要用户参与卸载时，会触发该方法，可以看到，该方法最后会发送 Intent.ACTION_UNINSTALL_PACKAGE 到 PackageInstaller 中去！ 1234567891011121314151617@Overridepublic void onUserActionRequired(Intent intent) &#123; //【1】创建了一个新的 Intent fillIn； final Intent fillIn = new Intent(); //【2】卸载的 apk 包名； fillIn.putExtra(PackageInstaller.EXTRA_PACKAGE_NAME, mPackageName); //【3】卸载的结果 code！！ fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION); //【4】卸载后用于额外通信的的 Intent！！ fillIn.putExtra(Intent.EXTRA_INTENT, intent); try &#123; //【5】发送结果 fillIn 到 3.1.2.1！ mTarget.sendIntent(mContext, 0, fillIn, null, null); &#125; catch (SendIntentException ignored) &#123; &#125;&#125; 对于传入的参数 intent： 123456// action 是 Intent.ACTION_UNINSTALL_PACKAGE！final Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE);// 设置 data；intent.setData(Uri.fromParts(\"package\", packageName, null));// 设置额外的回调；intent.putExtra(PackageInstaller.EXTRA_CALLBACK, adapter.getBinder().asBinder()); 接着，在 onUserActionRequired 有对参数 intent 进行了进一步的安装！ 关于 PackageInstaller.STATUS_PENDING_USER_ACTION 的广播，我们后面再分析，这里先不关注！ 4.1.1.3 onPackageDeleted卸载成功后回调该接口： 1234567891011121314151617181920212223242526@Overridepublic void onPackageDeleted(String basePackageName, int returnCode, String msg) &#123; //【1】如果安装成功的话，会有通知！！ if (PackageManager.DELETE_SUCCEEDED == returnCode &amp;&amp; mNotification != null) &#123; NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE); notificationManager.notify(basePackageName, 0, mNotification); &#125; //【2】创建封装结果的 intent！ final Intent fillIn = new Intent(); //【3】卸载的 apk！ fillIn.putExtra(PackageInstaller.EXTRA_PACKAGE_NAME, mPackageName); //【4】卸载的结果 code！！ fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageManager.deleteStatusToPublicStatus(returnCode)); //【5】卸载的额外信息！！ fillIn.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, PackageManager.deleteStatusToString(returnCode, msg)); //【4】卸载的原始结果 code！！ fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode); try &#123; //【5】发送结果 fillIn 到 3.1.2.1！ mTarget.sendIntent(mContext, 0, fillIn, null, null); &#125; catch (SendIntentException ignored) &#123; &#125;&#125; 不多说了！！ 5 PackageManagerService卸载的核心接口在 PackageManagerService 中： 5.1 deletePackage开始卸载删除应用： 我们知道，在前面的时候，如果是从所有用户下卸载，那么 userId 和 flags 会有如下的变化： userId = UserHandle.USER_SYSTEM;flags |= PackageManager.DELETE_ALL_USERS; 如果是从指定用户下卸载，那么 userId 就是我们指定的用户！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Overridepublic void deletePackage(final String packageName, final IPackageDeleteObserver2 observer, final int userId, final int deleteFlags) &#123; mContext.enforceCallingOrSelfPermission( android.Manifest.permission.DELETE_PACKAGES, null); Preconditions.checkNotNull(packageName); Preconditions.checkNotNull(observer); final int uid = Binder.getCallingUid(); //【*5.1.1】首先判断该 apk 是否是孤立的； //【*5.1.2】同时判断是否允许静默卸载！ // 如果这个 apk 不是孤立的，并且不允许静默卸载，那么需要用户参与卸载，也就是通过 PackageInstaller // 这里会结束流程，同时调用 observer.onUserActionRequired 返回结果！ if (!isOrphaned(packageName) &amp;&amp; !isCallerAllowedToSilentlyUninstall(uid, packageName)) &#123; try &#123; final Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE); intent.setData(Uri.fromParts(PACKAGE_SCHEME, packageName, null)); intent.putExtra(PackageInstaller.EXTRA_CALLBACK, observer.asBinder()); //【*4.1.1.2】通知用户参与安装！ observer.onUserActionRequired(intent); &#125; catch (RemoteException re) &#123; &#125; return; &#125; //【2】判断是否是从所有 user 下卸载该应用，如果需要同时校验是否有 INTERACT_ACROSS_USERS_FULL 的权限！！ final boolean deleteAllUsers = (deleteFlags &amp; PackageManager.DELETE_ALL_USERS) != 0; final int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]&#123; userId &#125;; if (UserHandle.getUserId(uid) != userId || (deleteAllUsers &amp;&amp; users.length &gt; 1)) &#123; mContext.enforceCallingOrSelfPermission( android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, \"deletePackage for user \" + userId); &#125; //【*5.1.3】如果该用户下不允许卸载应用（用户限制） if (isUserRestricted(userId, UserManager.DISALLOW_UNINSTALL_APPS)) &#123; try &#123; //【*4.1.1.3】结束卸载，返回！ observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_USER_RESTRICTED, null); &#125; catch (RemoteException re) &#123; &#125; return; &#125; //【3】如果不是从所有的用户下卸载，并且该 apk 处于 BlockUninstall 状态 // 那么不能卸载！ //【*5.1.4】通过 getBlockUninstallForUser 来判断应用是否处于 Blockinstall 状态！ if (!deleteAllUsers &amp;&amp; getBlockUninstallForUser(packageName, userId)) &#123; try &#123; //【*4.1.1.3】结束卸载，返回！ observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_OWNER_BLOCKED, null); &#125; catch (RemoteException re) &#123; &#125; return; &#125; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"deletePackageAsUser: pkg=\" + packageName + \" user=\" + userId + \" deleteAllUsers: \" + deleteAllUsers ); &#125; //【4】这里的 mHandler 我们在 pms 的启动的时候有分析过，其持有子线程的 looper！ mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); int returnCode; //【4.1】如果不是从所有的 user 下卸载该 apk，进入 if 分支，否则，进入 else 分支！ if (!deleteAllUsers) &#123; //【*5.2】调用 deletePackageX 继续卸载！ returnCode = deletePackageX(packageName, userId, deleteFlags); &#125; else &#123; //【*5.1.4】先获得 pkg 在所有 user 下的 block unistall 状态！ int[] blockUninstallUserIds = getBlockUninstallForUsers(packageName, users); //【4.2】如果都不处于 block unistall，那么就直接卸载！ if (ArrayUtils.isEmpty(blockUninstallUserIds)) &#123; //【*5.2】调用 deletePackageX 继续卸载！ returnCode = deletePackageX(packageName, userId, deleteFlags); &#125; else &#123; //【4.3】flags 取消 DELETE_ALL_USERS 标志位！ final int userFlags = deleteFlags &amp; ~PackageManager.DELETE_ALL_USERS; for (int userId : users) &#123; //【4.3.1】只会卸载那些不处于 block unistall 状态下的 user 中的 apk！ if (!ArrayUtils.contains(blockUninstallUserIds, userId)) &#123; //【*5.2】调用 deletePackageX 继续卸载！ returnCode = deletePackageX(packageName, userId, userFlags); if (returnCode != PackageManager.DELETE_SUCCEEDED) &#123; Slog.w(TAG, \"Package delete failed for user \" + userId + \", returnCode \" + returnCode); &#125; &#125; &#125; //【4.4】由于在某些 user 下 pkg 处于 block uninstall 状态导致无法安装 // 所以需要返回给用户！ returnCode = PackageManager.DELETE_FAILED_OWNER_BLOCKED; &#125; &#125; try &#123; //【*4.1.1.3】返回结果！ observer.onPackageDeleted(packageName, returnCode, null); &#125; catch (RemoteException e) &#123; Log.i(TAG, \"Observer no longer exists.\"); &#125; //end catch &#125; //end run &#125;);&#125; 过程分析的很详细！ 5.1.1 isOrphaned判断该应用是否是孤立的： 1234567public boolean isOrphaned(String packageName) &#123; // reader synchronized (mPackages) &#123; //【*5.1.1.1】进一步判断！ return mSettings.isOrphaned(packageName); &#125;&#125; 5.1.1.1 Settings.isOrphaned12345678boolean isOrphaned(String packageName) &#123; final PackageSetting pkg = mPackages.get(packageName); if (pkg == null) &#123; throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; //【1】通过 PackageSetting 的 isOrphaned 属性判断！ return pkg.isOrphaned;&#125; 不多数了！！ 5.1.2 isCallerAllowedToSilentlyUninstall判断是否允许静默卸载： 12345678910111213141516171819202122232425262728293031323334private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) &#123; //【1】如果 callingUid 是 shell，root 或者 system，那么是可以静默卸载的！ if (callingUid == Process.SHELL_UID || callingUid == Process.ROOT_UID || callingUid == Process.SYSTEM_UID) &#123; return true; &#125; final int callingUserId = UserHandle.getUserId(callingUid); //【2】如果 caller 就是安装该 apk 的 installer，那么支持静默卸载！ //【*5.1.2.1】通过 getPackageUid 获得 package uid； //【*5.1.2.2】通过 getInstallerPackageName 获得 package 的安装者； if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) &#123; return true; &#125; //【3】如果 caller 是 package verifier，那么允许静默卸载！ if (mRequiredVerifierPackage != null &amp;&amp; callingUid == getPackageUid(mRequiredVerifierPackage, 0, callingUserId)) &#123; return true; &#125; //【4】如果 caller 是 package unstaller，那么允许静默卸载！ if (mRequiredUninstallerPackage != null &amp;&amp; callingUid == getPackageUid(mRequiredUninstallerPackage, 0, callingUserId)) &#123; return true; &#125; //【5】如果 caller 是 storage manager，那么允许静默卸载！ if (mStorageManagerPackage != null &amp;&amp; callingUid == getPackageUid(mStorageManagerPackage, 0, callingUserId)) &#123; return true; &#125; return false;&#125; 5.1.2.1 getPackageUid获得 pacakge 的 uid： 1234567891011121314151617181920212223@Overridepublic int getPackageUid(String packageName, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return -1; flags = updateFlagsForPackage(flags, userId, packageName); enforceCrossUserPermission(Binder.getCallingUid(), userId, false /* requireFullPermission */, false /* checkShell */, \"get package uid\"); // reader synchronized (mPackages) &#123; final PackageParser.Package p = mPackages.get(packageName); if (p != null &amp;&amp; p.isMatch(flags)) &#123; return UserHandle.getUid(userId, p.applicationInfo.uid); &#125; if ((flags &amp; MATCH_UNINSTALLED_PACKAGES) != 0) &#123; final PackageSetting ps = mSettings.mPackages.get(packageName); if (ps != null &amp;&amp; ps.isMatch(flags)) &#123; return UserHandle.getUid(userId, ps.appId); &#125; &#125; &#125; return -1;&#125; 5.1.2.2 getInstallerPackageName获得 package 的安装者： 1234567@Overridepublic String getInstallerPackageName(String packageName) &#123; synchronized (mPackages) &#123; //【*5.1.2.2.1】通过 Settings 获得该 pkg 的 installer！ return mSettings.getInstallerPackageNameLPr(packageName); &#125;&#125; 5.1.2.2.1 Settings.getInstallerPackageNameLPr12345678String getInstallerPackageNameLPr(String packageName) &#123; final PackageSetting pkg = mPackages.get(packageName); if (pkg == null) &#123; throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; //【1】返回 PackageSetting 的属性 installerPackageName return pkg.installerPackageName;&#125; 不多说了！ 5.1.3 isUserRestricted判断在 userId 是否有用户限制，限制由 restrictionKey 指定： 12345678boolean isUserRestricted(int userId, String restrictionKey) &#123; Bundle restrictions = sUserManager.getUserRestrictions(userId); if (restrictions.getBoolean(restrictionKey, false)) &#123; Log.w(TAG, \"User is restricted: \" + restrictionKey); return true; &#125; return false;&#125; 5.1.4 getBlockUninstallForUser判断该 package 是否处于 block uninstall 的状态： 123456789101112@Overridepublic boolean getBlockUninstallForUser(String packageName, int userId) &#123; synchronized (mPackages) &#123; PackageSetting ps = mSettings.mPackages.get(packageName); if (ps == null) &#123; Log.i(TAG, \"Package doesn't exist in get block uninstall \" + packageName); return false; &#125; //【*5.1.4.1】通过 PackageSetting 返回其 block uninstall 的状态！ return ps.getBlockUninstall(userId); &#125;&#125; 5.1.4.1 PackageSettingBase.getBlockUninstallPackageSetting 继承了 PackageSettingBase，getBlockUninstall 方法是在父类中： 1234boolean getBlockUninstall(int userId) &#123; //【*5.1.4.2】返回该 pkg 的使用状态对象：PackageUserState！ return readUserState(userId).blockUninstall;&#125; PackageUserState 实例，表示每个 pkg 在对应的 user 下的使用状态，其在我们分析 pms 的启动时有分析过，这里不多说了！ 5.1.4.2 PackageSettingBase.readUserState123456789public PackageUserState readUserState(int userId) &#123; PackageUserState state = userState.get(userId); if (state != null) &#123; //【1】如果有的话，就返回这个 user 下的 PackageUserState 实例！ return state; &#125; //【2】否则，返回默认的！ return DEFAULT_USER_STATE;&#125; 这里的 DEFAULT_USER_STATE 是一个 PackageUserState 对象！！ 1private static final PackageUserState DEFAULT_USER_STATE = new PackageUserState(); 5.1.5 getBlockUninstallForUsers该方法用于获得该 package 在多个 user 下的 block uninstall 状态： 1234567891011private int[] getBlockUninstallForUsers(String packageName, int[] userIds) &#123; int[] result = EMPTY_INT_ARRAY; for (int userId : userIds) &#123; //【*5.1.4】获得单个 user 下的 pkg 的 block uninstall 状态，并将状态为 true 的 user！ // 保存到数组中，返回！ if (getBlockUninstallForUser(packageName, userId)) &#123; result = ArrayUtils.appendInt(result, userId); &#125; &#125; return result;&#125; 不多说了！！ 5.2 deletePackageX接着是进入第二阶段的卸载： 如果可以卸载所有 user 下的安装，那么 deleteFlags 会被设置为 PackageManager.DELETE_ALL_USERS; 而 user 则是每一个用户； 如果是卸载指定的 user 下的安装，那么 deleteFlags 不会设置为 PackageManager.DELETE_ALL_USERS； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private int deletePackageX(String packageName, int userId, int deleteFlags) &#123; //【*5.2.1.1】创建一个 PackageRemovedInfo 对象！ final PackageRemovedInfo info = new PackageRemovedInfo(); final boolean res; //【1】这里对 user 又做了一次处理。如果是卸载所有用户下的安装，那么 removeUser 为 UserHandle.USER_ALL！ final int removeUser = (deleteFlags &amp; PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.USER_ALL : userId; //【*5.2.2】如果要卸载的 pkg 是用于设备管理的，那么禁止卸载，返回！ if (isPackageDeviceAdmin(packageName, removeUser)) &#123; Slog.w(TAG, \"Not removing package \" + packageName + \": has active device admin\"); return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER; &#125; PackageSetting uninstalledPs = null; // 要卸载的 apk 的安装信息！ int[] allUsers; synchronized (mPackages) &#123; //【2】获得上一次的安装信息，如果为 null，直接返回！！ uninstalledPs = mSettings.mPackages.get(packageName); if (uninstalledPs == null) &#123; Slog.w(TAG, \"Not removing non-existent package \" + packageName); return PackageManager.DELETE_FAILED_INTERNAL_ERROR; &#125; //【3】获得所用的 user，并判断 pkg 是安装在哪些 user 下的，返回这些 user 的数组！ allUsers = sUserManager.getUserIds(); info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true); &#125; final int freezeUser; // 用于保存卸载前，应用在那个 user 下处于冻结状态！ //【4】如果这是要卸载的应用是一个被覆盖安装更新过的 sys apk，同时 deleteFlags 没有设置 DELETE_SYSTEM_APP 位 // 那么，我们在所有用户下冻结，否则我们只在 removeUser 下冻结！ //【*5.2.3】isUpdatedSystemApp 判断是否是被覆盖安装更新过的 sys apk！ if (isUpdatedSystemApp(uninstalledPs) &amp;&amp; ((deleteFlags &amp; PackageManager.DELETE_SYSTEM_APP) == 0)) &#123; freezeUser = UserHandle.USER_ALL; &#125; else &#123; freezeUser = removeUser; &#125; synchronized (mInstallLock) &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"deletePackageX: pkg=\" + packageName + \" user=\" + userId); //【*5.2.4】在卸载前进入冻结状态！ try (PackageFreezer freezer = freezePackageForDelete(packageName, freezeUser, deleteFlags, \"deletePackageX\")) &#123; //【*5.3】继续卸载； res = deletePackageLIF(packageName, UserHandle.of(removeUser), true, allUsers, deleteFlags | REMOVE_CHATTY, info, true, null); &#125; synchronized (mPackages) &#123; if (res) &#123; mEphemeralApplicationRegistry.onPackageUninstalledLPw(uninstalledPs.pkg); &#125; &#125; &#125; //【5】res 为 true，表示卸载成功了，那么发送相关的广播！ if (res) &#123; final boolean killApp = (deleteFlags &amp; PackageManager.DELETE_DONT_KILL_APP) == 0; //【*5.2.1.2】发送 removed 广播； info.sendPackageRemovedBroadcasts(killApp); //【*5.2.1.3】发送 updated 广播； info.sendSystemPackageUpdatedBroadcasts(); //【*5.2.1.4】发送 appeared广播； info.sendSystemPackageAppearedBroadcasts(); &#125; Runtime.getRuntime().gc(); // gc 回收资源！！ // Delete the resources here after sending the broadcast to let // other processes clean up before deleting resources. if (info.args != null) &#123; synchronized (mInstallLock) &#123; //【*6.2.2.1.2】执行删除 apk 的操作！！ info.args.doPostDeleteLI(true); &#125; &#125; return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;&#125; 流程已经分析的很详细了！！ 5.2.1 PackageRemovedInfo5.2.1.1 new PackageRemovedInfo创建一个 PackageRemovedInfo 实例，分装要卸载的 apk 的相关信息！ 12345678910111213141516class PackageRemovedInfo &#123; String removedPackage; int uid = -1; int removedAppId = -1; int[] origUsers; int[] removedUsers = null; boolean isRemovedPackageSystemUpdate = false; boolean isUpdate; boolean dataRemoved; boolean removedForAllUsers; InstallArgs args = null; // 参数实例，用于执行卸载，清理的操作，后面会分析到！ ArrayMap&lt;String, PackageRemovedInfo&gt; removedChildPackages; ArrayMap&lt;String, PackageInstalledInfo&gt; appearedChildPackages; ... ... ...&#125; 同时，PackageRemovedInfo 内部也有很多的方法，用于发送广播，这里我们先分析当前流程能用的到的!! 5.2.1.2 sendPackageRemovedBroadcasts发送升级包被移除的广播： 12345678910void sendPackageRemovedBroadcasts(boolean killApp) &#123; //【*5.2.1.2.1】发送 removed 的广播； sendPackageRemovedBroadcastInternal(killApp); final int childCount = removedChildPackages != null ? removedChildPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageRemovedInfo childInfo = removedChildPackages.valueAt(i); //【*5.2.1.2.1】对 child pkg 一样的处理； childInfo.sendPackageRemovedBroadcastInternal(killApp); &#125; &#125; 逻辑简单，不多说了！ 5.2.1.2.1 sendPackageRemovedBroadcastInternal发送 removed 的广播： 1234567891011121314151617181920212223242526private void sendPackageRemovedBroadcastInternal(boolean killApp) &#123; Bundle extras = new Bundle(2); extras.putInt(Intent.EXTRA_UID, removedAppId &gt;= 0 ? removedAppId : uid); extras.putBoolean(Intent.EXTRA_DATA_REMOVED, dataRemoved); extras.putBoolean(Intent.EXTRA_DONT_KILL_APP, !killApp); if (isUpdate || isRemovedPackageSystemUpdate) &#123; extras.putBoolean(Intent.EXTRA_REPLACING, true); &#125; extras.putBoolean(Intent.EXTRA_REMOVED_FOR_ALL_USERS, removedForAllUsers); if (removedPackage != null) &#123; //【1】首先会发送 Intent.ACTION_PACKAGE_REMOVED 的广播； sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED , removedPackage, extras, 0, null, null, removedUsers); //【2】然后会发送 Intent.ACTION_PACKAGE_FULLY_REMOVED 的广播； // 但前提的是清楚了 data，并且本次是卸载的三方应用； if (dataRemoved &amp;&amp; !isRemovedPackageSystemUpdate) &#123; sendPackageBroadcast(Intent.ACTION_PACKAGE_FULLY_REMOVED, removedPackage, extras, 0, null, null, removedUsers); &#125; &#125; if (removedAppId &gt;= 0) &#123; //【3】最后，发送 Intent.ACTION_UID_REMOVED 广播！ sendPackageBroadcast(Intent.ACTION_UID_REMOVED, null, extras, 0, null, null, removedUsers); &#125;&#125; 这里就不不多说了！ 5.2.1.3 sendSystemPackageUpdatedBroadcasts发送 system app updated 广播： 123456789101112131415void sendSystemPackageUpdatedBroadcasts() &#123; if (isRemovedPackageSystemUpdate) &#123; //【*5.2.1.3.1】发送 system app updated 广播； sendSystemPackageUpdatedBroadcastsInternal(); final int childCount = (removedChildPackages != null) ? removedChildPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageRemovedInfo childInfo = removedChildPackages.valueAt(i); if (childInfo.isRemovedPackageSystemUpdate) &#123; //【*5.2.1.3.1】对 child pkg 一样的处理； childInfo.sendSystemPackageUpdatedBroadcastsInternal(); &#125; &#125; &#125;&#125; 逻辑简单，不多说了！ 5.2.1.3.1 sendSystemPackageUpdatedBroadcastsInternal核心方法： 123456789101112private void sendSystemPackageUpdatedBroadcastsInternal() &#123; Bundle extras = new Bundle(2); extras.putInt(Intent.EXTRA_UID, removedAppId &gt;= 0 ? removedAppId : uid); extras.putBoolean(Intent.EXTRA_REPLACING, true); //【1】依次发送如下的三个广播； sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, removedPackage, extras, 0, null, null, null); sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, removedPackage, extras, 0, null, null, null); sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, 0, removedPackage, null, null);&#125; 不多说了！ 5.2.1.4 sendSystemPackageAppearedBroadcasts发送 system app appeared 广播，针对于 child apk： 123456789101112void sendSystemPackageAppearedBroadcasts() &#123; final int packageCount = (appearedChildPackages != null) ? appearedChildPackages.size() : 0; for (int i = 0; i &lt; packageCount; i++) &#123; PackageInstalledInfo installedInfo = appearedChildPackages.valueAt(i); for (int userId : installedInfo.newUsers) &#123; //【*5.2.1.4.1】发送 child apk appeared 的广播！ sendPackageAddedForUser(installedInfo.name, true, UserHandle.getAppId(installedInfo.uid), userId); &#125; &#125;&#125; 5.2.1.4.1 sendPackageAddedForUser(of pms)1234567private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) &#123; //【1】判断是否是 sys app！ final boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting); //【*5.2.1.4.2】继续发送： sendPackageAddedForUser(packageName, isSystem, pkgSetting.appId, userId);&#125; 5.2.1.4.2 sendPackageAddedForUser(of pms)核心方法，这里的 boolean isSystem 传入的是 true： 123456789101112131415161718192021222324private void sendPackageAddedForUser(String packageName, boolean isSystem, int appId, int userId) &#123; Bundle extras = new Bundle(1); extras.putInt(Intent.EXTRA_UID, UserHandle.getUid(userId, appId)); //【1】发送 Intent.ACTION_PACKAGE_ADDED 广播！！ sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, 0, null, null, new int[] &#123;userId&#125;); try &#123; IActivityManager am = ActivityManagerNative.getDefault(); if (isSystem &amp;&amp; am.isUserRunning(userId, 0)) &#123; // The just-installed/enabled app is bundled on the system, so presumed // to be able to run automatically without needing an explicit launch. // Send it a BOOT_COMPLETED if it would ordinarily have gotten one. Intent bcIntent = new Intent(Intent.ACTION_BOOT_COMPLETED) .addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES) .setPackage(packageName); am.broadcastIntent(null, bcIntent, null, null, 0, null, null, null, android.app.AppOpsManager.OP_NONE, null, false, false, userId); &#125; &#125; catch (RemoteException e) &#123; // shouldn't happen Slog.w(TAG, \"Unable to bootstrap installed package\", e); &#125;&#125; 5.2.2 isPackageDeviceAdmin123456789101112131415161718192021222324252627282930313233private boolean isPackageDeviceAdmin(String packageName, int userId) &#123; IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface( ServiceManager.getService(Context.DEVICE_POLICY_SERVICE)); try &#123; if (dpm != null) &#123; final ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent( /* callingUserOnly =*/ false); final String deviceOwnerPackageName = deviceOwnerComponentName == null ? null : deviceOwnerComponentName.getPackageName(); // Does the package contains the device owner? // TODO Do we have to do it even if userId != UserHandle.USER_ALL? Otherwise, // this check is probably not needed, since DO should be registered as a device // admin on some user too. (Original bug for this: b/17657954) if (packageName.equals(deviceOwnerPackageName)) &#123; return true; &#125; // Does it contain a device admin for any user? int[] users; if (userId == UserHandle.USER_ALL) &#123; users = sUserManager.getUserIds(); &#125; else &#123; users = new int[]&#123;userId&#125;; &#125; for (int i = 0; i &lt; users.length; ++i) &#123; if (dpm.packageHasActiveAdmins(packageName, users[i])) &#123; return true; &#125; &#125; &#125; &#125; catch (RemoteException e) &#123; &#125; return false;&#125; 5.2.3 isUpdatedSystemApp123private static boolean isUpdatedSystemApp(PackageSetting ps) &#123; return (ps.pkgFlags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0;&#125; 5.2.4 freezePackageForInstall进入冻结状态！123456789public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) &#123; if ((installFlags &amp; PackageManager.INSTALL_DONT_KILL_APP) != 0) &#123; return new PackageFreezer(); &#125; else &#123; //【*5.2.4.1】对于卸载的情况，是进入这里的！ return freezePackage(packageName, userId, killReason); &#125;&#125; 5.2.4.1 freezePackage看代码是创建了一个 PackageFreezer 实例： 1234public PackageFreezer freezePackage(String packageName, int userId, String killReason) &#123; //【*5.2.4.2】创建一个 PackageFreezer 实例！ return new PackageFreezer(packageName, userId, killReason);&#125; 5.2.4.2 new PackageFreezerPackageFreezer 是一个冻结对象，在创建它的时候就会执行冻结操作！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private class PackageFreezer implements AutoCloseable &#123; private final String mPackageName; // 要被冻结的 pkg private final PackageFreezer[] mChildren; // 要被冻结的 child pkg private final boolean mWeFroze; private final AtomicBoolean mClosed = new AtomicBoolean(); private final CloseGuard mCloseGuard = CloseGuard.get(); public PackageFreezer() &#123; mPackageName = null; mChildren = null; mWeFroze = false; mCloseGuard.open(\"close\"); &#125; public PackageFreezer(String packageName, int userId, String killReason) &#123; synchronized (mPackages) &#123; mPackageName = packageName; //【1】将该 pkg 添加到 pms 的内部 mFrozenPackages 集合中！ mWeFroze = mFrozenPackages.add(mPackageName); //【2】返回 pkg 的安装信息，如果不会 null，那就 kill 掉该进程！ final PackageSetting ps = mSettings.mPackages.get(mPackageName); if (ps != null) &#123; //【2.1】kill app 进程，这里不过多关注！ killApplication(ps.name, ps.appId, userId, killReason); &#125; //【3】如果该 package 有 child package，做同样的处理！ final PackageParser.Package p = mPackages.get(packageName); if (p != null &amp;&amp; p.childPackages != null) &#123; final int N = p.childPackages.size(); mChildren = new PackageFreezer[N]; for (int i = 0; i &lt; N; i++) &#123; mChildren[i] = new PackageFreezer(p.childPackages.get(i).packageName, userId, killReason); &#125; &#125; else &#123; mChildren = null; &#125; &#125; mCloseGuard.open(\"close\"); &#125; ... ... ...&#125; 在 pms 的内部，有一个集合： 12@GuardedBy(\"mPackages\")final ArraySet&lt;String&gt; mFrozenPackages = new ArraySet&lt;&gt;(); 用于保存所有的处于冻结状态的 package！ 5.3 deletePackageLIF接着进入卸载的第三个阶段，我们来回归下参数： boolean deleteCodeAndResources：表示是否删除 apk 和资源，这里传入的是 true； int flags：卸载的 flags，传入 deleteFlags | REMOVE_CHATTY； boolean writeSettings：是否持久化处理的数据，这里传入的是 true； PackageParser.Package replacingPackage：用于取代的 pkg，这里传入的是 null； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) &#123; if (packageName == null) &#123; Slog.w(TAG, \"Attempt to delete null packageName.\"); return false; &#125; if (DEBUG_REMOVE) Slog.d(TAG, \"deletePackageLI: \" + packageName + \" user \" + user); PackageSetting ps; synchronized (mPackages) &#123; //【1】获得上一次的安装信息！ ps = mSettings.mPackages.get(packageName); if (ps == null) &#123; Slog.w(TAG, \"Package named '\" + packageName + \"' doesn't exist.\"); return false; &#125; //【2】如果卸载的是 child package，并且 // 其不是 sys app（无 FLAG_SYSTEM 标志位），或者是 sys app，且卸载 flags 设置了 DELETE_SYSTEM_APP 位！ // 那么这里立刻执行卸载！ if (ps.parentPackageName != null &amp;&amp; (!isSystemApp(ps) || (flags &amp; PackageManager.DELETE_SYSTEM_APP) != 0)) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Uninstalled child package:\" + packageName + \" for user:\" + ((user == null) ? UserHandle.USER_ALL : user)); &#125; final int removedUserId = (user != null) ? user.getIdentifier() : UserHandle.USER_ALL; //【*5.3.1】清理该 pkg 在 removedUserId 下的数据！ if (!clearPackageStateForUserLIF(ps, removedUserId, outInfo)) &#123; return false; &#125; //【*5.3.2】设置该 pkg 的使用状态信息！ markPackageUninstalledForUserLPw(ps, user); // 更新应用的偏好设置，这里我们就先不分析，有时间了加进去！ scheduleWritePackageRestrictionsLocked(user); return true; &#125; &#125; //【2】如果卸载的不是 sys app（无 FLAG_SYSTEM 标志位），或者卸载 flags 设置了 DELETE_SYSTEM_APP 位！ // 同时，只是在某个用户下卸载该 apk，进入下面的逻辑 // 可以看到：如果 apk 是 sys，那么还必须要设置 DELETE_SYSTEM_APP 标志位才行！ if (((!isSystemApp(ps) || (flags&amp;PackageManager.DELETE_SYSTEM_APP) != 0) &amp;&amp; user != null &amp;&amp; user.getIdentifier() != UserHandle.USER_ALL)) &#123; //【*5.3.2】设置该 pkg 的使用状态信息！ markPackageUninstalledForUserLPw(ps, user); //【2.1】如果是 data app，进入 if 分支，而 sys app 进入 else 分支！ if (!isSystemApp(ps)) &#123; //【*5.3.3】判断下该应用是否需要被缓存下来！！ boolean keepUninstalledPackage = shouldKeepUninstalledPackageLPr(packageName); //【2.1.1】该 apk 在一些用户下处于 install 状态，或者该 pkg 需要被 keep！ if (ps.isAnyInstalled(sUserManager.getUserIds()) || keepUninstalledPackage) &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Still installed by other users\"); //【*5.3.1】清理该 pkg 在 user 下的数据，清楚shibai！ if (!clearPackageStateForUserLIF(ps, user.getIdentifier(), outInfo)) &#123; return false; &#125; // 更新应用的偏好设置，这里我们就先不分析，有时间了加进去！ scheduleWritePackageRestrictionsLocked(user); return true; &#125; else &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Not installed by other users, full delete\"); //【2.1.1】该 apk 没有在任何 user 下安装，同时也不需要 keep，那么这里会将其在该 user 下的 // 的安装状态设置为 true，这样卸载广播就能正确的发出了（感觉像是解决一个 bug） ps.setInstalled(true, user.getIdentifier()); &#125; &#125; else &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Deleting system app\"); //【2.2】对于 sys app，所有用户都会有该 app，所以这里我们会清楚在该 user 下的数据！ //【*5.3.1】清理该 pkg 在 user 下的数据，清楚shibai！ if (!clearPackageStateForUserLIF(ps, user.getIdentifier(), outInfo)) &#123; return false; &#125; // 更新应用的偏好设置，这里我们就先不分析，有时间了加进去！ scheduleWritePackageRestrictionsLocked(user); return true; &#125; &#125; //【3】如果要卸载的 apk 是一个复合 apk，有 split apk，那么这里会对其 child pkg 做同样的处理！！ if (ps.childPackageNames != null &amp;&amp; outInfo != null) &#123; synchronized (mPackages) &#123; final int childCount = ps.childPackageNames.size(); //【*5.2.1】将每一个 child pkg 都封装成一个 PackageRemovedInfo 实例，并计算其 origUsers // 加到 parent pkg 的 outInfo.removedChildPackages 中！ outInfo.removedChildPackages = new ArrayMap&lt;&gt;(childCount); for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = ps.childPackageNames.get(i); PackageRemovedInfo childInfo = new PackageRemovedInfo(); childInfo.removedPackage = childPackageName; outInfo.removedChildPackages.put(childPackageName, childInfo); PackageSetting childPs = mSettings.peekPackageLPr(childPackageName); if (childPs != null) &#123; childInfo.origUsers = childPs.queryInstalledUsers(allUserHandles, true); &#125; &#125; &#125; &#125; boolean ret = false; //【4】进入核心的卸载阶段，这个阶段在返回后，会创建一个 InstallArgs 对象！！ if (isSystemApp(ps)) &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Removing system package: \" + ps.name); //【*6.1】卸载 sys app，如果 sys app 被覆盖安装过，那么会 fall back 回 sys app！ ret = deleteSystemPackageLIF(ps.pkg, ps, allUserHandles, flags, outInfo, writeSettings); &#125; else &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Removing non-system package: \" + ps.name); //【*6.1】卸载 data app! ret = deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles, outInfo, writeSettings, replacingPackage); &#125; //【5】这里是记录下我们是否是在所有用户下移除 pkg，对 child apk 也做同样的处理！ if (outInfo != null) &#123; outInfo.removedForAllUsers = mPackages.get(ps.name) == null; if (outInfo.removedChildPackages != null) &#123; synchronized (mPackages) &#123; final int childCount = outInfo.removedChildPackages.size(); for (int i = 0; i &lt; childCount; i++) &#123; PackageRemovedInfo childInfo = outInfo.removedChildPackages.valueAt(i); if (childInfo != null) &#123; childInfo.removedForAllUsers = mPackages.get( childInfo.removedPackage) == null; &#125; &#125; &#125; &#125; //【5.1】这里对被覆盖安装过的 sys app 又做了特殊处理！！我们知道当我们删除了位于 data 的 app 数据后 // 我们会恢复 sys app 的安装数据！这里主要是处理如下情况： // 如果 sys app 有 child pkg，但是可能有一些 child pkg 只申明在了 sys app 中，没有在 updated app 中 // 此时我们会重新创建 child pkg 的 PackageInstalledInfo，保存到 outInfo 中！ if (isSystemApp(ps)) &#123; synchronized (mPackages) &#123; PackageSetting updatedPs = mSettings.peekPackageLPr(ps.name); final int childCount = (updatedPs.childPackageNames != null) ? updatedPs.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = updatedPs.childPackageNames.get(i); //【5.1.1】如果 outInfo 没有保存该 child pkg，进行以下逻辑： if (outInfo.removedChildPackages == null || outInfo.removedChildPackages.indexOfKey(childPackageName) &lt; 0) &#123; PackageSetting childPs = mSettings.peekPackageLPr(childPackageName); if (childPs == null) &#123; continue; &#125; //【5.1.1】为该 child 创建一个 PackageInstalledInfo 实例，记录相关属性 // 保存到 outInfo.appearedChildPackages 集合中！ PackageInstalledInfo installRes = new PackageInstalledInfo(); installRes.name = childPackageName; installRes.newUsers = childPs.queryInstalledUsers(allUserHandles, true); installRes.pkg = mPackages.get(childPackageName); installRes.uid = childPs.pkg.applicationInfo.uid; if (outInfo.appearedChildPackages == null) &#123; outInfo.appearedChildPackages = new ArrayMap&lt;&gt;(); &#125; outInfo.appearedChildPackages.put(childPackageName, installRes); &#125; &#125; &#125; &#125; &#125; return ret;&#125; 到这里，这一阶段就分析结束了！ 5.3.1 clearPackageStateForUserLIF清理数据，可以看到这个方法里面执行的操作有很多：清楚数据等等： 1234567891011121314151617181920212223242526272829303132333435363738private boolean clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo) &#123; final PackageParser.Package pkg; synchronized (mPackages) &#123; pkg = mPackages.get(ps.name); &#125; //【1】如果是 UserHandle.USER_ALL，那么这里会返回当前的所有 user id！！ final int[] userIds = (userId == UserHandle.USER_ALL) ? sUserManager.getUserIds() : new int[] &#123;userId&#125;; //【2】遍历执行删除操作： for (int nextUserId : userIds) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Updating package:\" + ps.name + \" install state for user:\" + nextUserId); &#125; destroyAppDataLIF(pkg, userId, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); destroyAppProfilesLIF(pkg, userId); removeKeystoreDataIfNeeded(nextUserId, ps.appId); schedulePackageCleaning(ps.name, nextUserId, false); synchronized (mPackages) &#123; if (clearPackagePreferredActivitiesLPw(ps.name, nextUserId)) &#123; scheduleWritePackageRestrictionsLocked(nextUserId); &#125; resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId); &#125; &#125; if (outInfo != null) &#123; outInfo.removedPackage = ps.name; outInfo.removedAppId = ps.appId; outInfo.removedUsers = userIds; &#125; return true;&#125; 5.3.2 markPackageUninstalledForUserLPw修改在该 user 下的使用状态为 no install 的状态： 123456789101112131415private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) &#123; final int[] userIds = (user == null || user.getIdentifier() == UserHandle.USER_ALL) ? sUserManager.getUserIds() : new int[] &#123;user.getIdentifier()&#125;; for (int nextUserId : userIds) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Marking package:\" + ps.name + \" uninstalled for user:\" + nextUserId); &#125; //【1】设置对应的 PackageUserState 中的状态！ ps.setUserState(nextUserId, 0, COMPONENT_ENABLED_STATE_DEFAULT, false /*installed*/, true /*stopped*/, true /*notLaunched*/, false /*hidden*/, false /*suspended*/, null, null, null, false /*blockUninstall*/, ps.readUserState(nextUserId).domainVerificationStatus, 0); &#125;&#125; 方法很简单，就不多说了！ 5.3.3 shouldKeepUninstalledPackageLPr123private boolean shouldKeepUninstalledPackageLPr(String packageName) &#123; return mKeepUninstalledPackages != null &amp;&amp; mKeepUninstalledPackages.contains(packageName);&#125; 6 PackageManagerService接下来，我们分别分析下 sys app 和 data app 的卸载过程： 6.1 deleteSystemPackageLIF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151private boolean deleteSystemPackageLIF(PackageParser.Package deletedPkg, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) &#123; if (deletedPs.parentPackageName != null) &#123; Slog.w(TAG, \"Attempt to delete child system package \" + deletedPkg.packageName); return false; &#125; //【1】判断是否考虑用户限制！ final boolean applyUserRestrictions = (allUserHandles != null) &amp;&amp; (outInfo.origUsers != null); final PackageSetting disabledPs; //【2】判断该应用是否是一个被覆盖安装更新过的 sys app!! synchronized (mPackages) &#123; disabledPs = mSettings.getDisabledSystemPkgLPr(deletedPs.name); &#125; if (DEBUG_REMOVE) Slog.d(TAG, \"deleteSystemPackageLI: newPs=\" + deletedPkg.packageName + \" disabledPs=\" + disabledPs); //【3】只有覆盖安装过的 sys app 才能被卸载，实际上卸载的是处于 data 的那个 apk！ if (disabledPs == null) &#123; Slog.w(TAG, \"Attempt to delete unknown system package \"+ deletedPkg.packageName); return false; &#125; else if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Deleting system pkg from data partition\"); &#125; if (DEBUG_REMOVE) &#123; if (applyUserRestrictions) &#123; Slog.d(TAG, \"Remembering install states:\"); for (int userId : allUserHandles) &#123; final boolean finstalled = ArrayUtils.contains(outInfo.origUsers, userId); Slog.d(TAG, \" u=\" + userId + \" inst=\" + finstalled); &#125; &#125; &#125; //【4】设置 pkg 对应的 outInfo 的 isRemovedPackageSystemUpdate 为 true，表示移除的是更新！ // 如果 pkg 有 child pkg，也要设置其对应的属性！ outInfo.isRemovedPackageSystemUpdate = true; if (outInfo.removedChildPackages != null) &#123; final int childCount = (deletedPs.childPackageNames != null) ? deletedPs.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = deletedPs.childPackageNames.get(i); if (disabledPs.childPackageNames != null &amp;&amp; disabledPs.childPackageNames .contains(childPackageName)) &#123; PackageRemovedInfo childInfo = outInfo.removedChildPackages.get( childPackageName); if (childInfo != null) &#123; childInfo.isRemovedPackageSystemUpdate = true; &#125; &#125; &#125; &#125; //【5】判断下覆盖安装前后的 versioncode，如果覆盖前的小，那么本次卸载后，数据也会被清除； // 如果相等，那么就保留数据！ if (disabledPs.versionCode &lt; deletedPs.versionCode) &#123; flags &amp;= ~PackageManager.DELETE_KEEP_DATA; &#125; else &#123; flags |= PackageManager.DELETE_KEEP_DATA; &#125; //【*6.2】继续处理卸载，可以看到，此时和卸载 data app 的一样的了！ boolean ret = deleteInstalledPackageLIF(deletedPs, true, flags, allUserHandles, outInfo, writeSettings, disabledPs.pkg); if (!ret) &#123; return false; &#125; //【6】接着，需要恢复 sys app！ synchronized (mPackages) &#123; // Reinstate the old system package //【*6.1.1】恢复 sys app 的安装数据！ enableSystemPackageLPw(disabledPs.pkg); //【*6.1.2】移除所有的本地库！ removeNativeBinariesLI(deletedPs); &#125; //【7】准备重新扫描 sys app，首先会设置基本的扫描参数！ // 如果是 pri app，还要设置 PARSE_IS_PRIVILEGED 标志位！ if (DEBUG_REMOVE) Slog.d(TAG, \"Re-installing system package: \" + disabledPs); int parseFlags = mDefParseFlags | PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; //【*6.1.3】判断是否是 pri app！ if (locationIsPrivileged(disabledPs.codePath)) &#123; parseFlags |= PackageParser.PARSE_IS_PRIVILEGED; &#125; final PackageParser.Package newPkg; try &#123; //【8】重新扫描 sys app，这里我们在开机扫描的时候有分析过，不多说了！！ newPkg = scanPackageTracedLI(disabledPs.codePath, parseFlags, SCAN_NO_PATHS, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.w(TAG, \"Failed to restore system package:\" + deletedPkg.packageName + \": \" + e.getMessage()); return false; &#125; try &#123; //【*6.1.4】更新共享库！ updateSharedLibrariesLPw(newPkg, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"updateAllSharedLibrariesLPw failed: \" + e.getMessage()); &#125; //【*6.1.5】准备应用的数据目录！ prepareAppDataAfterInstallLIF(newPkg); //【9】最后就是要想最新的信息持久化到本地文件：包括安装信息，偏好设置，权限等等！ synchronized (mPackages) &#123; //【9.1】读取最新的安装信息！ PackageSetting ps = mSettings.mPackages.get(newPkg.packageName); //【9.2】将卸载前的权限授予信息拷贝到本次新安装的信息中！！ ps.getPermissionsState().copyFrom(deletedPs.getPermissionsState()); //【9.3-review】更新权限信息，这里我们在 pms 的启动时分析过，这里就不再细说了！ // 这里会更新所有应用的权限信息，移除过时的运行时权限，自动授予安装时权限等！ updatePermissionsLPw(newPkg.packageName, newPkg, UPDATE_PERMISSIONS_ALL | UPDATE_PERMISSIONS_REPLACE_PKG); //【9.4】如果需要应用用户限制，会进入这个分支！ if (applyUserRestrictions) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Propagating install state across reinstall\"); &#125; for (int userId : allUserHandles) &#123; final boolean installed = ArrayUtils.contains(outInfo.origUsers, userId); if (DEBUG_REMOVE) &#123; Slog.d(TAG, \" user \" + userId + \" =&gt; \" + installed); &#125; //【9.4.1】重新设置在每个用户下的 install 状态！ ps.setInstalled(installed, userId); //【9.4.2】持久化所有用户下的运行时权限信息！ mSettings.writeRuntimePermissionsForUserLPr(userId, false); &#125; //【9.4.3】持久化所有用户下的应用偏好设置！ mSettings.writeAllUsersPackageRestrictionsLPr(); &#125; //【9.5】持久化 Settings 中的数据，包括 packages.xml，packages.list 等等！ if (writeSettings) &#123; mSettings.writeLPr(); &#125; &#125; return true;&#125; 整个逻辑很详细了，不多说了！！ 6.1.1 enableSystemPackageLPw恢复 sys app 的安装信息！ 12345678910private void enableSystemPackageLPw(PackageParser.Package pkg) &#123; //【*6.1.1.1】恢复 pkg 的安装信息！ mSettings.enableSystemPackageLPw(pkg.packageName); //【*6.1.1.1】恢复 pkg 的 child pkg 的安装信息！ final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); mSettings.enableSystemPackageLPw(childPkg.packageName); &#125;&#125; 不多说了！ 6.1.1.1 Settings.enableSystemPackageLPw核心方法是在 Settings 中： 1234567891011121314151617181920212223PackageSetting enableSystemPackageLPw(String name) &#123; //【1】判断下是否被覆盖安装过！ PackageSetting p = mDisabledSysPackages.get(name); if(p == null) &#123; Log.w(PackageManagerService.TAG, \"Package \" + name + \" is not disabled\"); return null; &#125; //【2】取消掉 FLAG_UPDATED_SYSTEM_APP 标志位！ if((p.pkg != null) &amp;&amp; (p.pkg.applicationInfo != null)) &#123; p.pkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; //【3-review】创建一个新的 PackageSetting 实例，同时将其添加到 Settings 内部的集合中！ // 这个我们在 pms 开机中分析过！ PackageSetting ret = addPackageLPw(name, p.realName, p.codePath, p.resourcePath, p.legacyNativeLibraryPathString, p.primaryCpuAbiString, p.secondaryCpuAbiString, p.cpuAbiOverrideString, p.appId, p.versionCode, p.pkgFlags, p.pkgPrivateFlags, p.parentPackageName, p.childPackageNames); //【4】从 mDisabledSysPackages 删除信息！ mDisabledSysPackages.remove(name); return ret;&#125; 继续分析！ 6.1.2 removeNativeBinariesLI移除本地库： 123456789101112131415161718private void removeNativeBinariesLI(PackageSetting ps) &#123; //【1】移除 pkg 的本地库！ if (ps != null) &#123; NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString); //【1.1】移除 pkg 的 child pkg 的本地库！ final int childCount = (ps.childPackageNames != null) ? ps.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageSetting childPs = null; synchronized (mPackages) &#123; childPs = mSettings.peekPackageLPr(ps.childPackageNames.get(i)); &#125; if (childPs != null) &#123; NativeLibraryHelper.removeNativeBinariesLI(childPs .legacyNativeLibraryPathString); &#125; &#125; &#125;&#125; 核心是通过 NativeLibraryHelper 的相关接口来移除的，这里就不过多分析了！ 6.1.3 locationIsPrivileged判断是否是 pri app：1234567891011static boolean locationIsPrivileged(File path) &#123; try &#123; final String privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\") .getCanonicalPath(); //【1】核心逻辑，是否是以 /system/priv-app 开头的！ return path.getCanonicalPath().startsWith(privilegedAppDir); &#125; catch (IOException e) &#123; Slog.e(TAG, \"Unable to access code path \" + path); &#125; return false;&#125; 不多说了！！ 6.1.4 updateSharedLibrariesLPw更新共享库文件： 12345678910111213141516171819202122232425262728293031323334353637383940private void updateSharedLibrariesLPw(PackageParser.Package pkg, PackageParser.Package changingLib) throws PackageManagerException &#123; if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) &#123; //【1】用于手机该 pkg 需要的所有共享库！ final ArraySet&lt;String&gt; usesLibraryFiles = new ArraySet&lt;&gt;(); //【2】处理 pkg.usesLibraries 指定依赖的库 int N = pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0; for (int i=0; i&lt;N; i++) &#123; //【2.1】要尝试在系统已有的共享库中找到对应的库！ final SharedLibraryEntry file = mSharedLibraries.get(pkg.usesLibraries.get(i)); if (file == null) &#123; throw new PackageManagerException(INSTALL_FAILED_MISSING_SHARED_LIBRARY, \"Package \" + pkg.packageName + \" requires unavailable shared library \" + pkg.usesLibraries.get(i) + \"; failing!\"); &#125; //【*6.1.4.1】将依赖的库加入到 usesLibraryFiles 中！ addSharedLibraryLPw(usesLibraryFiles, file, changingLib); &#125; //【3】处理 pkg.usesOptionalLibraries 指定依赖的库 N = pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0; for (int i=0; i&lt;N; i++) &#123; final SharedLibraryEntry file = mSharedLibraries.get(pkg.usesOptionalLibraries.get(i)); if (file == null) &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" desires unavailable shared library \" + pkg.usesOptionalLibraries.get(i) + \"; ignoring!\"); &#125; else &#123; //【*6.1.4.1】将依赖的库加入到 usesLibraryFiles 中！ addSharedLibraryLPw(usesLibraryFiles, file, changingLib); &#125; &#125; //【4】最后将收集到的共享库文件路径保存到 pkg.usesLibraryFiles 中！ N = usesLibraryFiles.size(); if (N &gt; 0) &#123; pkg.usesLibraryFiles = usesLibraryFiles.toArray(new String[N]); &#125; else &#123; pkg.usesLibraryFiles = null; &#125; &#125;&#125; PackageParser.Package 内有如下的集合，表示该 pkg 依赖的共享库的名称：12public ArrayList&lt;String&gt; usesLibraries = null;public ArrayList&lt;String&gt; usesOptionalLibraries = null; 同时也有下面的集合，保存了依赖的所有的共享库的路径：1public String[] usesLibraryFiles = null; 不多说了！ 6.1.4.1 addSharedLibraryLPw参数 PackageParser.Package changingLib 表示我们改变了共享库的定义 apk，那么我们要将新的 apk 传进来，作为新的依赖！ 1234567891011121314151617181920private void addSharedLibraryLPw(ArraySet&lt;String&gt; usesLibraryFiles, SharedLibraryEntry file, PackageParser.Package changingLib) &#123; //【1】如果共享库的 path 不为 null，那就直接加入到 usesLibraryFiles 中！ if (file.path != null) &#123; usesLibraryFiles.add(file.path); return; &#125; //【2】否则就找到定义共享库的 apk！ PackageParser.Package p = mPackages.get(file.apk); if (changingLib != null &amp;&amp; changingLib.packageName.equals(file.apk)) &#123; //【2.1】如果此时 changingLib 不为 null，同时匹配，那么我们就依赖这个 changingLib！ if (p == null || p.packageName.equals(changingLib.packageName)) &#123; p = changingLib; &#125; &#125; //【3】依赖定义 lib 的 apk！ if (p != null) &#123; usesLibraryFiles.addAll(p.getAllCodePaths()); &#125;&#125; 不多说了！ 6.1.5 prepareAppDataAfterInstallLIF准备数据目录！12345678910111213141516171819202122232425private void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) &#123; final PackageSetting ps; synchronized (mPackages) &#123; //【1】保存 Kernel Map 数据！ ps = mSettings.mPackages.get(pkg.packageName); mSettings.writeKernelMappingLPr(ps); &#125; final UserManager um = mContext.getSystemService(UserManager.class); UserManagerInternal umInternal = getUserManagerInternal(); for (UserInfo user : um.getUsers()) &#123; final int flags; if (umInternal.isUserUnlockingOrUnlocked(user.id)) &#123; flags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE; &#125; else if (umInternal.isUserRunning(user.id)) &#123; flags = StorageManager.FLAG_STORAGE_DE; &#125; else &#123; continue; &#125; //【2】如果在该 user 下是安装状态，那就在该设备用户下准备数据目录！ if (ps.getInstalled(user.id)) &#123; //【*6.1.5.1】准备数据目录！ prepareAppDataLIF(pkg, user.id, flags); &#125; &#125;&#125; 继续分析： 6.1.5.1 prepareAppDataLIF这个方法会对 pkg 以及其 child pkg 准备目录： 12345678910111213private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【*6.1.5.2】准备父包的数据目录 prepareAppDataLeafLIF(pkg, userId, flags); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【*6.1.5.2】准备子包的数据目录 prepareAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 继续分析： 6.1.5.2 prepareAppDataLeafLIF该方法是核心的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (DEBUG_APP_DATA) &#123; Slog.v(TAG, \"prepareAppData for \" + pkg.packageName + \" u\" + userId + \" 0x\" + Integer.toHexString(flags)); &#125; final String volumeUuid = pkg.volumeUuid; final String packageName = pkg.packageName; final ApplicationInfo app = pkg.applicationInfo; final int appId = UserHandle.getAppId(app.uid); Preconditions.checkNotNull(app.seinfo); try &#123; //【1】通过 installd 来准备数据目录！ mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seinfo, app.targetSdkVersion); &#125; catch (InstallerException e) &#123; //【2】如果是系统应用，第一次准备失败后，还会在尝试一次！ if (app.isSystemApp()) &#123; logCriticalInfo(Log.ERROR, \"Failed to create app data for \" + packageName + \", but trying to recover: \" + e); //【2.1】先删除之前创建的脏目录！ destroyAppDataLeafLIF(pkg, userId, flags); try &#123; //【2.2】再次创建数据目录； mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seinfo, app.targetSdkVersion); logCriticalInfo(Log.DEBUG, \"Recovery succeeded!\"); &#125; catch (InstallerException e2) &#123; logCriticalInfo(Log.DEBUG, \"Recovery failed!\"); &#125; &#125; else &#123; Slog.e(TAG, \"Failed to create app data for \" + packageName + \": \" + e); &#125; &#125; if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; try &#123; // CE storage is unlocked right now, so read out the inode and // remember for use later when it's locked // TODO: mark this structure as dirty so we persist it! final long ceDataInode = mInstaller.getAppDataInode(volumeUuid, packageName, userId, StorageManager.FLAG_STORAGE_CE); synchronized (mPackages) &#123; final PackageSetting ps = mSettings.mPackages.get(packageName); if (ps != null) &#123; ps.setCeDataInode(ceDataInode, userId); &#125; &#125; &#125; catch (InstallerException e) &#123; Slog.e(TAG, \"Failed to find inode for \" + packageName + \": \" + e); &#125; &#125; //【*6.1.5.2】为 native libs 创建链接！ prepareAppDataContentsLeafLIF(pkg, userId, flags);&#125; 继续分析： 6.1.5.3 prepareAppDataContentsLeafLIF为 native libs 创建链接： 123456789101112131415161718private void prepareAppDataContentsLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; final String volumeUuid = pkg.volumeUuid; final String packageName = pkg.packageName; final ApplicationInfo app = pkg.applicationInfo; if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; //【1】只为 32 位的 native libs 创建 link！ if (app.primaryCpuAbi != null &amp;&amp; !VMRuntime.is64BitAbi(app.primaryCpuAbi)) &#123; final String nativeLibPath = app.nativeLibraryDir; try &#123; mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, nativeLibPath, userId); &#125; catch (InstallerException e) &#123; Slog.e(TAG, \"Failed to link native for \" + packageName + \": \" + e); &#125; &#125; &#125;&#125; 先分析到这里！ 6.2 deleteInstalledPackageLIF卸载三方应用，或者覆盖更新的 sys app，那么我们调用的是该方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private boolean deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) &#123; synchronized (mPackages) &#123; //【1】将要卸载的 apk 的 appid 保存到 PackageRemovedInfo 的 uid 属性中 // 如果有 child pkg，对其也这样处理！ if (outInfo != null) &#123; outInfo.uid = ps.appId; &#125; if (outInfo != null &amp;&amp; outInfo.removedChildPackages != null) &#123; final int childCount = (ps.childPackageNames != null) ? ps.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = ps.childPackageNames.get(i); PackageSetting childPs = mSettings.mPackages.get(childPackageName); if (childPs == null) &#123; return false; &#125; PackageRemovedInfo childInfo = outInfo.removedChildPackages.get( childPackageName); if (childInfo != null) &#123; childInfo.uid = childPs.appId; &#125; &#125; &#125; &#125; //【*6.2.1】删除 apk 的使用数据，如果有 child pkg，对其也这样处理！！ removePackageDataLIF(ps, allUserHandles, outInfo, flags, writeSettings); final int childCount = (ps.childPackageNames != null) ? ps.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageSetting childPs; synchronized (mPackages) &#123; childPs = mSettings.peekPackageLPr(ps.childPackageNames.get(i)); &#125; if (childPs != null) &#123; PackageRemovedInfo childOutInfo = (outInfo != null &amp;&amp; outInfo.removedChildPackages != null) ? outInfo.removedChildPackages.get(childPs.name) : null; //【2.1】对于 child pkg，这里的卸载 flags 比较特殊，如果 flags 设置了 DELETE_KEEP_DATA // 同时指定了 replacingPackage，而 replacingPackage 并不是其 parent pkg，这种情况， // 不需要保留数据，去掉 DELETE_KEEP_DATA 标志位； final int deleteFlags = (flags &amp; DELETE_KEEP_DATA) != 0 &amp;&amp; (replacingPackage != null &amp;&amp; !replacingPackage.hasChildPackage(childPs.name)) ? flags &amp; ~DELETE_KEEP_DATA : flags; //【*6.2.1】删除 child apk 的使用数据！ removePackageDataLIF(childPs, allUserHandles, childOutInfo, deleteFlags, writeSettings); &#125; &#125; //【2】只删除 pkg 的 apk 文件（child pkg 并不会被删除） if (ps.parentPackageName == null) &#123; if (deleteCodeAndResources &amp;&amp; (outInfo != null)) &#123; //【*6.2.2】创建一个 intallArgs，用于卸载！ outInfo.args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps)); if (DEBUG_SD_INSTALL) Slog.i(TAG, \"args=\" + outInfo.args); &#125; &#125; return true;&#125; 6.2.1 removePackageDataLIF删除 package 的数据！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113private void removePackageDataLIF(PackageSetting ps, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) &#123; String packageName = ps.name; if (DEBUG_REMOVE) Slog.d(TAG, \"removePackageDataLI: \" + ps); final PackageParser.Package deletedPkg; final PackageSetting deletedPs; synchronized (mPackages) &#123; //【1】获得要被删除的 apk 的 PackageSetting 和 PackageParser.Package 对象！ deletedPkg = mPackages.get(packageName); deletedPs = mSettings.mPackages.get(packageName); if (outInfo != null) &#123; outInfo.removedPackage = packageName; outInfo.removedUsers = deletedPs != null ? deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true) : null; &#125; &#125; //【*6.2.1.1】第一部移除，扫描的四大组件信息！ removePackageLI(ps, (flags &amp; REMOVE_CHATTY) != 0); //【2】如果 flags 没有设置 DELETE_KEEP_DATA，那么会清楚 apk 的数据！！ if ((flags &amp; PackageManager.DELETE_KEEP_DATA) == 0) &#123; final PackageParser.Package resolvedPkg; if (deletedPkg != null) &#123; resolvedPkg = deletedPkg; &#125; else &#123; resolvedPkg = new PackageParser.Package(ps.name); resolvedPkg.setVolumeUuid(ps.volumeUuid); &#125; //【*6.2.1.2】删除 apk 的 data 数据！！ destroyAppDataLIF(resolvedPkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); //【*6.2.1.3】删除 apk 的 profiles 数据！！ destroyAppProfilesLIF(resolvedPkg, UserHandle.USER_ALL); if (outInfo != null) &#123; outInfo.dataRemoved = true; // 表示数据移除了； &#125; //【*6.2.1.4】执行 package 清除！！ schedulePackageCleaning(packageName, UserHandle.USER_ALL, true); &#125; //【3】进一步处理！ synchronized (mPackages) &#123; if (deletedPs != null) &#123; //【3.1】如果 flags 没有设置 DELETE_KEEP_DATA 标志位，那么执行其他的清楚操作！ if ((flags &amp; PackageManager.DELETE_KEEP_DATA) == 0) &#123; //【3.1.1】清楚 intentfilter verify 和 默认浏览器的设置数据！ clearIntentFilterVerificationsLPw(deletedPs.name, UserHandle.USER_ALL); clearDefaultBrowserIfNeeded(packageName); if (outInfo != null) &#123; //【3.1.1.1】移除 key set 信息！ mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName); //【*6.2.1.5】删除 pkg 的 PackageSetting 数据！ outInfo.removedAppId = mSettings.removePackageLPw(packageName); &#125; //【3.1.2-review】更新权限信息，这里我们在 pms 的启动时分析过，这里就不再细说了！ // 这里会更新所有应用的权限信息，移除过时的运行时权限，自动授予安装时权限等！ updatePermissionsLPw(deletedPs.name, null, 0); //【3.1.3】如果该应用是共享 shared user 的，进入这里！ if (deletedPs.sharedUser != null) &#123; for (int userId : UserManagerService.getInstance().getUserIds()) &#123; //【3.1.3.1】更新该共享 shared uid 的权限，该 package 被移除掉，会导致和该 // 应用相关连的权限的变化，从而导致共享 shared uid 的 gids 发生变化！ final int userIdToKill = mSettings.updateSharedUserPermsLPw(deletedPs, userId); if (userIdToKill == UserHandle.USER_ALL || userIdToKill &gt;= UserHandle.USER_SYSTEM) &#123; //【3.1.3.1】如果共享 shared uid 的 gids 发生变化，杀掉该 uid 下的 // 所有的 app 进程！ mHandler.post(new Runnable() &#123; @Override public void run() &#123; killApplication(deletedPs.name, deletedPs.appId, KILL_APP_REASON_GIDS_CHANGED); &#125; &#125;); break; &#125; &#125; &#125; //【3.1.4】清除默认应用的数据，先不关注； clearPackagePreferredActivitiesLPw(deletedPs.name, UserHandle.USER_ALL); &#125; //【3.4】更新下在每个 user 下的安装状态！ if (allUserHandles != null &amp;&amp; outInfo != null &amp;&amp; outInfo.origUsers != null) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Propagating install state across downgrade\"); &#125; for (int userId : allUserHandles) &#123; final boolean installed = ArrayUtils.contains(outInfo.origUsers, userId); if (DEBUG_REMOVE) &#123; Slog.d(TAG, \" user \" + userId + \" =&gt; \" + installed); &#125; ps.setInstalled(installed, userId); &#125; &#125; &#125; //【3.5】持久化 Settings 中的数据！！ if (writeSettings) &#123; mSettings.writeLPr(); &#125; &#125; if (outInfo != null) &#123; //【4】移除 key-store！ removeKeystoreDataIfNeeded(UserHandle.USER_ALL, outInfo.removedAppId); &#125;&#125; 这里我们详细的分析了整个流程！！ 6.2.1.1 removePackageLI移除 PackageSetting 对应的扫描数据：123456789101112131415void removePackageLI(PackageSetting ps, boolean chatty) &#123; if (DEBUG_INSTALL) &#123; if (chatty) Log.d(TAG, \"Removing package \" + ps.name); &#125; synchronized (mPackages) &#123; //【1】移除扫描信息！ mPackages.remove(ps.name); final PackageParser.Package pkg = ps.pkg; if (pkg != null) &#123; //【*6.2.1.1.1】移除四大组件，共享库解析对象！ cleanPackageDataStructuresLILPw(pkg, chatty); &#125; &#125;&#125; 这个就不多说了！！ 6.2.1.1.1 cleanPackageDataStructuresLILPw用于删除 apk 的四大组件和共享库数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) &#123; //【1】移除 provider！ int N = pkg.providers.size(); StringBuilder r = null; int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); mProviders.removeProvider(p); if (p.info.authority == null) &#123; //【1.1】表示系统之前已经有相同 authority 的 provider，那么这个应用的 provider 是不会注册的！ // 对于没有注册的 provider 不处理！ continue; &#125; String names[] = p.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; if (mProvidersByAuthority.get(names[j]) == p) &#123; mProvidersByAuthority.remove(names[j]); if (DEBUG_REMOVE) &#123; if (chatty) Log.d(TAG, \"Unregistered content provider: \" + names[j] + \", className = \" + p.info.name + \", isSyncable = \" + p.info.isSyncable); &#125; &#125; &#125; if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Providers: \" + r); &#125; //【2】移除 service！ N = pkg.services.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Service s = pkg.services.get(i); mServices.removeService(s); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(s.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Services: \" + r); &#125; //【3】移除 receiver！ N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); mReceivers.removeActivity(a, \"receiver\"); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Receivers: \" + r); &#125; //【4】移除 activity！ N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); mActivities.removeActivity(a, \"activity\"); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Activities: \" + r); &#125; //【5】移除定义的 permission，设置了 appop 标志为的权限，从 mAppOpPermissionPackages 也要移除！ N = pkg.permissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Permission p = pkg.permissions.get(i); BasePermission bp = mSettings.mPermissions.get(p.info.name); if (bp == null) &#123; bp = mSettings.mPermissionTrees.get(p.info.name); &#125; if (bp != null &amp;&amp; bp.perm == p) &#123; bp.perm = null; if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if ((p.info.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; ArraySet&lt;String&gt; appOpPkgs = mAppOpPermissionPackages.get(p.info.name); if (appOpPkgs != null) &#123; appOpPkgs.remove(pkg.packageName); &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Permissions: \" + r); &#125; //【6】移除请求的 permission，设置了 appop 标志为的权限，从 mAppOpPermissionPackages 也要移除！！ N = pkg.requestedPermissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; String perm = pkg.requestedPermissions.get(i); BasePermission bp = mSettings.mPermissions.get(perm); if (bp != null &amp;&amp; (bp.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; ArraySet&lt;String&gt; appOpPkgs = mAppOpPermissionPackages.get(perm); if (appOpPkgs != null) &#123; appOpPkgs.remove(pkg.packageName); if (appOpPkgs.isEmpty()) &#123; mAppOpPermissionPackages.remove(perm); &#125; &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Permissions: \" + r); &#125; //【7】移除请求的 instrumentation！ N = pkg.instrumentation.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Instrumentation a = pkg.instrumentation.get(i); mInstrumentation.remove(a.getComponentName()); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Instrumentation: \" + r); &#125; //【8】移除 SharedLibraries！ r = null; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0) &#123; // Only system apps can hold shared libraries. if (pkg.libraryNames != null) &#123; for (i=0; i&lt;pkg.libraryNames.size(); i++) &#123; String name = pkg.libraryNames.get(i); SharedLibraryEntry cur = mSharedLibraries.get(name); if (cur != null &amp;&amp; cur.apk != null &amp;&amp; cur.apk.equals(pkg.packageName)) &#123; mSharedLibraries.remove(name); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(name); &#125; &#125; &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Libraries: \" + r); &#125;&#125; 该阶段的逻辑比较简单，不多说了！ 6.2.1.2 destroyAppDataLIF -&gt;[Leaf]12345678910111213private void destroyAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【1】删除父包的数据！！ destroyAppDataLeafLIF(pkg, userId, flags); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【2】删除子包的数据！ destroyAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 继续看：123456789101112131415161718private void destroyAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; final PackageSetting ps; synchronized (mPackages) &#123; //【1】获得该应用的安装信息 PackageSetting ！ ps = mSettings.mPackages.get(pkg.packageName); &#125; for (int realUserId : resolveUserIds(userId)) &#123; //【2】获得要删除的状态信息目录： final long ceDataInode = (ps != null) ? ps.getCeDataInode(realUserId) : 0; try &#123; //【3】调用了 Installd 删除指定目录！ mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ceDataInode); &#125; catch (InstallerException e) &#123; Slog.w(TAG, String.valueOf(e)); &#125; &#125;&#125; 这里使用了 PackageSetting.getCeDataInode 方法： 123long getCeDataInode(int userId) &#123; return readUserState(userId).ceDataInode;&#125; 该方法返回的是 PackageUserState.ceDataInode 的值！ 6.2.1.4 schedulePackageCleaning12345678910111213void schedulePackageCleaning(String packageName, int userId, boolean andCode) &#123; //【*6.2.1.1.3.1】这里会发送一个 START_CLEANING_PACKAGE 的消息给 PackageHandler ！ final Message msg = mHandler.obtainMessage(START_CLEANING_PACKAGE, userId, andCode ? 1 : 0, packageName); if (mSystemReady) &#123; msg.sendToTarget(); &#125; else &#123; if (mPostSystemReadyMessages == null) &#123; mPostSystemReadyMessages = new ArrayList&lt;&gt;(); &#125; mPostSystemReadyMessages.add(msg); &#125;&#125; 6.2.1.4.1 Packagehandler.doHandleMessage[START_CLEANING_PACKAGE]12345678910111213141516171819202122case START_CLEANING_PACKAGE: &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); final String packageName = (String)msg.obj; final int userId = msg.arg1; final boolean andCode = msg.arg2 != 0; synchronized (mPackages) &#123; if (userId == UserHandle.USER_ALL) &#123; int[] users = sUserManager.getUserIds(); for (int user : users) &#123; //【1】将 package 加入到 Settings 内部的 mPackagesToBeCleaned 集合中！ mSettings.addPackageToCleanLPw( new PackageCleanItem(user, packageName, andCode)); &#125; &#125; else &#123; mSettings.addPackageToCleanLPw( new PackageCleanItem(userId, packageName, andCode)); &#125; &#125; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //【*6.2.1.4.2】开始清理操作！ startCleaningPackages();&#125; break; 6.2.1.4.2 startCleaningPackages执行扩展存储清理操作：123456789101112131415161718192021222324void startCleaningPackages() &#123; // reader if (!isExternalMediaAvailable()) &#123; return; &#125; synchronized (mPackages) &#123; if (mSettings.mPackagesToBeCleaned.isEmpty()) &#123; return; &#125; &#125; //【1】发送 action PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE！ Intent intent = new Intent(PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE); //【2】目标组件服务：DefaultContainerService intent.setComponent(DEFAULT_CONTAINER_COMPONENT); IActivityManager am = ActivityManagerNative.getDefault(); if (am != null) &#123; try &#123; //【2.1】启动服务！ am.startService(null, intent, null, mContext.getOpPackageName(), UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; &#125; &#125;&#125; 进入 DefaultContainerService.onHandleIntent 方法：12345678910111213141516171819@Overrideprotected void onHandleIntent(Intent intent) &#123; if (PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE.equals(intent.getAction())) &#123; final IPackageManager pm = IPackageManager.Stub.asInterface( ServiceManager.getService(\"package\")); PackageCleanItem item = null; try &#123; while ((item = pm.nextPackageToClean(item)) != null) &#123; final UserEnvironment userEnv = new UserEnvironment(item.userId); eraseFiles(userEnv.buildExternalStorageAppDataDirs(item.packageName)); eraseFiles(userEnv.buildExternalStorageAppMediaDirs(item.packageName)); if (item.andCode) &#123; eraseFiles(userEnv.buildExternalStorageAppObbDirs(item.packageName)); &#125; &#125; &#125; catch (RemoteException e) &#123; &#125; &#125;&#125; 这里的逻辑就不多说了！ 6.2.1.5 Settings.removePackageLPw移除该 pkg 的安装信息：PackageSetting！123456789101112131415161718192021222324int removePackageLPw(String name) &#123; final PackageSetting p = mPackages.get(name); if (p != null) &#123; //【1】从 mPackages 中移除该 PackageSetting！！ mPackages .remove(name); //【*6.2.1.5.1】如果其实 installer，还要修改和其相关的其他 pkg 的属性！ removeInstallerPackageStatus(name); //【3】如果 pkg 是共享 uid，要解除相互引用！ if (p.sharedUser != null) &#123; p.sharedUser.removePackage(p); if (p.sharedUser.packages.size() == 0) &#123; mSharedUsers.remove(p.sharedUser.name); //【3.1-review】从相关集合中删除该 ps！ removeUserIdLPw(p.sharedUser.userId); return p.sharedUser.userId; &#125; &#125; else &#123; //【3.1-review】从相关集合中删除该 ps！ removeUserIdLPw(p.appId); return p.appId; &#125; &#125; return -1;&#125; 该方法最后会返回 pkg 的 appID! 6.2.1.5.1 Settings.removeInstallerPackageStatus如果该 pkg 是 installer，那么12345678910111213141516171819private void removeInstallerPackageStatus(String packageName) &#123; //【1】如果岂不是 installer，返回！ if (!mInstallerPackages.contains(packageName)) &#123; return; &#125; //【2】如果其是 installer，那么需要找到所有由其安装的 pkg，设置其属性！ for (int i = 0; i &lt; mPackages.size(); i++) &#123; final PackageSetting ps = mPackages.valueAt(i); final String installerPackageName = ps.getInstallerPackageName(); if (installerPackageName != null &amp;&amp; installerPackageName.equals(packageName)) &#123; //【2.1】置空其 InstallerPackageName 属性，同时设置 ps.isOrphaned 为 ture！ ps.setInstallerPackageName(null); ps.isOrphaned = true; &#125; &#125; //【3】从 mInstallerPackages 中移除该 pkg！ mInstallerPackages.remove(packageName);&#125; 不多说了！！ 6.2.2 createInstallArgsForExisting - 用于卸载 apk这里是针对已存在的应用创建一个 InstallArgs 123456789101112131415161718192021222324private InstallArgs createInstallArgsForExisting(int installFlags, String codePath, String resourcePath, String[] instructionSets) &#123; final boolean isInAsec; if (installOnExternalAsec(installFlags)) &#123; //【1】如果是安装到外置的，那就创建 AsecInstallArgs！ isInAsec = true; &#125; else if (installForwardLocked(installFlags) &amp;&amp; !codePath.startsWith(mDrmAppPrivateInstallDir.getAbsolutePath())) &#123; //【2】对于 forward lock 安装，如果目录是 drm app pri // 那就创建 AsecInstallArgs！ isInAsec = true; &#125; else &#123; isInAsec = false; &#125; if (isInAsec) &#123; //【3】创建 AsecInstallArgs 安装参数 return new AsecInstallArgs(codePath, instructionSets, installOnExternalAsec(installFlags), installForwardLocked(installFlags)); &#125; else &#123; //【*6.2.2.1.1】一般情况下，会创建 FileInstallArgs，这里通过 FileInstallArgs 的另一构造器 // 创建了实例，描述一个已经存在的 app！ return new FileInstallArgs(codePath, resourcePath, instructionSets); &#125;&#125; 这里又回到了 5.5.3.1 的 FileInstallArgs 的相关创建！ 6.2.2.1 FileInstallArgs6.2.2.1.1 new FileInstallArgs123456789101112131415161718192021222324252627282930class FileInstallArgs extends InstallArgs &#123; private File codeFile; private File resourceFile; // Example topology: // /data/app/com.example/base.apk // /data/app/com.example/split_foo.apk // /data/app/com.example/lib/arm/libfoo.so // /data/app/com.example/lib/arm64/libfoo.so // /data/app/com.example/dalvik/arm/base.apk@classes.dex //【1】安装一个新的 apk！ FileInstallArgs(InstallParams params) &#123; super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null /*instructionSets*/, params.packageAbiOverride, params.grantedRuntimePermissions, params.traceMethod, params.traceCookie, params.certificates); //【1.1】这里校验了下是否是 Forward Locked 的！ if (isFwdLocked()) &#123; throw new IllegalArgumentException(\"Forward locking only supported in ASEC\"); &#125; &#125; //【2】用于描述已存在的一个安装，显然，这里调用的是这个构造器！ FileInstallArgs(String codePath, String resourcePath, String[] instructionSets) &#123; super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, 0, null /*certificates*/); this.codeFile = (codePath != null) ? new File(codePath) : null; this.resourceFile = (resourcePath != null) ? new File(resourcePath) : null; &#125; ... ... ...&#125; 我们看到 FileInstallArgs 有两个构造器！ 一参数构造器用于创建安装过程中的 InstallArgs！ 三参数构造器，用于描述一个已存在的安装，主要用于清除旧的安装，或者作为移动应用的时候的源数据，我们在 pms 开机初始化的过程中就已经看到过了！ 6.2.2.1.2 doPostDeleteLI继续来看：12345boolean doPostDeleteLI(boolean delete) &#123; //【*6.2.2.1.3】清楚 apk 文件 和 dex 文件！ cleanUpResourcesLI(); return true;&#125; 继续分析： 6.2.2.1.3 cleanUpResourcesLI继续分析：12345678910111213141516void cleanUpResourcesLI() &#123; List&lt;String&gt; allCodePaths = Collections.EMPTY_LIST; if (codeFile != null &amp;&amp; codeFile.exists()) &#123; try &#123; //【1】收集 apk path！ final PackageLite pkg = PackageParser.parsePackageLite(codeFile, 0); allCodePaths = pkg.getAllCodePaths(); &#125; catch (PackageParserException e) &#123; // Ignored; we tried our best &#125; &#125; //【2】清除 apk 文件，调用 mInstaller.rmPackageDir 删除！ cleanUp(); //【3】清除 dex files，调用 mInstaller.rmdex 删除！ removeDexFiles(allCodePaths, instructionSets);&#125; 7 remove split apk - 移除 split（模块）apk在最上面的分析中，我们知道，如果要删除的是 split apk，那么会进入另外一个接口，这个接口和 install 的流程很类似，我们在这里做一下分析： 因为和 install 有很多相似之处，所以我省略掉一些无关紧要的代码段！！ 7.1 PackageInstallerService7.1.1 createSession(Internal) - 创建事务创建事务： 123456789@Overridepublic int createSession(SessionParams params, String installerPackageName, int userId) &#123; try &#123; //【1】继续来看！ return createSessionInternal(params, installerPackageName, userId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; createSession 方法调用了 createSessionInternal 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140private int createSessionInternal(SessionParams params, String installerPackageName, int userId) throws IOException &#123; final int callingUid = Binder.getCallingUid(); //【1】权限检查！ mPm.enforceCrossUserPermission(callingUid, userId, true, true, \"createSession\"); //【2】用户操作检查！ if (mPm.isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) &#123; throw new SecurityException(\"User restriction prevents installing\"); &#125; //【3】如果调用进程的 uid 是 SHELL_UID 或者 ROOT_UID，那么 installFlags 增加爱你 INSTALL_FROM_ADB // 表示通过 adb 进行安装！ if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) &#123; params.installFlags |= PackageManager.INSTALL_FROM_ADB; &#125; else &#123; // 如果不是 shell or root，校验下 package 是否属于 uid， mAppOps.checkPackage(callingUid, installerPackageName); // 取消 INSTALL_FROM_ADB 和 INSTALL_ALL_USERS 标志位，设置 INSTALL_REPLACE_EXISTING 标志位！ params.installFlags &amp;= ~PackageManager.INSTALL_FROM_ADB; params.installFlags &amp;= ~PackageManager.INSTALL_ALL_USERS; params.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; &#125; //【4】如果 installFlags 设置了 INSTALL_GRANT_RUNTIME_PERMISSIONS 标志位，那需要判断调用者是否有 // INSTALL_GRANT_RUNTIME_PERMISSIONS 权限！ if ((params.installFlags &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0 &amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission .INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) &#123; throw new SecurityException(\"You need the \" + \"android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission \" + \"to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag\"); &#125; //【5】调整应用的 icon 图标！ if (params.appIcon != null) &#123; final ActivityManager am = (ActivityManager) mContext.getSystemService( Context.ACTIVITY_SERVICE); final int iconSize = am.getLauncherLargeIconSize(); if ((params.appIcon.getWidth() &gt; iconSize * 2) || (params.appIcon.getHeight() &gt; iconSize * 2)) &#123; params.appIcon = Bitmap.createScaledBitmap(params.appIcon, iconSize, iconSize, true); &#125; &#125; //【6】检查 mode 取值是否正确！ switch (params.mode) &#123; case SessionParams.MODE_FULL_INSTALL: case SessionParams.MODE_INHERIT_EXISTING: break; default: throw new IllegalArgumentException(\"Invalid install mode: \" + params.mode); &#125; //【7】根据 installFlags 设置，调整安装位置，如果用户显示设置了位置，系统会对其进行检查，否则 // 系统会选择合适的位置！ if ((params.installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; //【7.1】如果显式指定内置，判断是否合适安装！ if (!PackageHelper.fitsOnInternal(mContext, params.sizeBytes)) &#123; throw new IOException(\"No suitable internal storage available\"); &#125; &#125; else if ((params.installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0) &#123; //【7.2】如果显式指定外置，判断是否合适安装！ if (!PackageHelper.fitsOnExternal(mContext, params.sizeBytes)) &#123; throw new IOException(\"No suitable external storage available\"); &#125; &#125; else if ((params.installFlags &amp; PackageManager.INSTALL_FORCE_VOLUME_UUID) != 0) &#123; params.setInstallFlagsInternal(); &#125; else &#123; //【7.4】默认情况下，进入这里，setInstallFlagsInternal 方法会设置 INSTALL_INTERNAL 标志位 // 取消 INSTALL_EXTERNAL 标志位！ params.setInstallFlagsInternal(); // 选择最好的位置来安装！ final long ident = Binder.clearCallingIdentity(); try &#123; params.volumeUuid = PackageHelper.resolveInstallVolume(mContext, params.appPackageName, params.installLocation, params.sizeBytes); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; final int sessionId; final PackageInstallerSession session; synchronized (mSessions) &#123; //【7.5-review】判断，同一个 uid 是否有过多的正在处理的 Session，如果超过了 1024 个，那就不能安装！ final int activeCount = getSessionCount(mSessions, callingUid); if (activeCount &gt;= MAX_ACTIVE_SESSIONS) &#123; throw new IllegalStateException( \"Too many active sessions for UID \" + callingUid); &#125; // 同样，判断同一个 uid，是否已经提交了过多的 Session，如果超过了 1048576 个，那当前就不能执行安装！ final int historicalCount = getSessionCount(mHistoricalSessions, callingUid); if (historicalCount &gt;= MAX_HISTORICAL_SESSIONS) &#123; throw new IllegalStateException( \"Too many historical sessions for UID \" + callingUid); &#125; //【7.6-review】给本次安装分配一个事务 id！ sessionId = allocateSessionIdLocked(); &#125; final long createdMillis = System.currentTimeMillis(); //【8】决定安装目录，因为默认是内置空间，这里会直接进入 buildStageDir 方法！ File stageDir = null; String stageCid = null; if ((params.installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; final boolean isEphemeral = (params.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0; //【8.1-review】创建文件临时目录；/data/app/vmdl[sessionId].tmp！ stageDir = buildStageDir(params.volumeUuid, sessionId, isEphemeral); &#125; else &#123; // 如果是外置，会直接返回 \"smdl\" + sessionId + \".tmp\" stageCid = buildExternalStageCid(sessionId); &#125; //【*7.2.1-review】创建 PackageInstallerSession 对象！ session = new PackageInstallerSession(mInternalCallback, mContext, mPm, mInstallThread.getLooper(), sessionId, userId, installerPackageName, callingUid, params, createdMillis, stageDir, stageCid, false, false); synchronized (mSessions) &#123; //【8】将新创建的 PackageInstallerSession 添加到 mSessions 集合中！ mSessions.put(sessionId, session); &#125; //【*9-review】通知有新的事务创建了，这里是直接回调 Callback 的接口！！ mCallbacks.notifySessionCreated(session.sessionId, session.userId); //【*10-review】持久化事务 Session！ writeSessionsAsync(); return sessionId;&#125; 整个流程和 install 很像，我们可以大胆推测，其在移除了 split apk 后，还会把主 apk 再 install 一次！！ 7.1.2 openSession - 获得事务openSession 方法可以获得 id 对应的 PackageInstallerSession！123456789@Overridepublic IPackageInstallerSession openSession(int sessionId) &#123; try &#123; //【×7.1.2.1】调用另外一个方法！ return openSessionInternal(sessionId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; 7.1.2.1 openSessionInternal1234567891011private IPackageInstallerSession openSessionInternal(int sessionId) throws IOException &#123; synchronized (mSessions) &#123; final PackageInstallerSession session = mSessions.get(sessionId); //【1-review】判断 uid 是否被允许获得该事务！ if (session == null || !isCallingUidOwner(session)) &#123; throw new SecurityException(\"Caller has no access to session \" + sessionId); &#125; session.open(); return session; &#125;&#125; 7.2 PackageInstallerSession7.2.1 new PackageInstallerSession - 事务实例创建 PackageInstallerSession，对前面的 SessionParams 再次封装！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class PackageInstallerSession extends IPackageInstallerSession.Stub &#123; public PackageInstallerSession(PackageInstallerService.InternalCallback callback, Context context, PackageManagerService pm, Looper looper, int sessionId, int userId, String installerPackageName, int installerUid, SessionParams params, long createdMillis, File stageDir, String stageCid, boolean prepared, boolean sealed) &#123; //【1-review】InternalCallback 回调！ mCallback = callback; mContext = context; mPm = pm; //【2】创建 Handler 绑定到子线程 mInstallThread，该子线程是在 PackageInstallerService 构造器中创建的！ //【2.1-review】这里通过 mHandlerCallback 指定了一个回调函数！ mHandler = new Handler(looper, mHandlerCallback); //【3】基本属性保存 this.sessionId = sessionId; this.userId = userId; this.installerPackageName = installerPackageName; this.installerUid = installerUid; this.params = params; this.createdMillis = createdMillis; this.stageDir = stageDir; // 内置临时目录：/data/app/vmdl[sessionId].tmp； this.stageCid = stageCid; // 默认为 null； if ((stageDir == null) == (stageCid == null)) &#123; throw new IllegalArgumentException( \"Exactly one of stageDir or stageCid stage must be set\"); &#125; mPrepared = prepared; // 传入 false； mSealed = sealed; // 传入 false； //【4】获得 DevicePolicyManager 对象，用于静默安装相关的判断，如果是安装者是设备拥有者， // 可以不检查权限，直接静默安装！ DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService( Context.DEVICE_POLICY_SERVICE); //【5】校验安装者 uid 是否有 INSTALL_PACKAGES 权限！ final boolean isPermissionGranted = (mPm.checkUidPermission(android.Manifest.permission.INSTALL_PACKAGES, installerUid) == PackageManager.PERMISSION_GRANTED); //【6】安装者是否是 root 用户！ final boolean isInstallerRoot = (installerUid == Process.ROOT_UID); //【7】是否强制提醒！ final boolean forcePermissionPrompt = (params.installFlags &amp; PackageManager.INSTALL_FORCE_PERMISSION_PROMPT) != 0; //【8】安装者是否是设备拥有者自身！ mIsInstallerDeviceOwner = (dpm != null) &amp;&amp; dpm.isDeviceOwnerAppOnCallingUser( installerPackageName); //【8】如果 mPermissionsAccepted 为 true，那么我们就可以静默安装！ if ((isPermissionGranted || isInstallerRoot || mIsInstallerDeviceOwner) &amp;&amp; !forcePermissionPrompt) &#123; mPermissionsAccepted = true; &#125; else &#123; mPermissionsAccepted = false; &#125; final long identity = Binder.clearCallingIdentity(); try &#123; final int uid = mPm.getPackageUid(PackageManagerService.DEFAULT_CONTAINER_PACKAGE, PackageManager.MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM); defaultContainerGid = UserHandle.getSharedAppGid(uid); &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; &#125; 可以看到 PackageInstallerSession 除了用来表示一个 Session 之外，由于继承了 IPackageInstallerSession.Stub，因此其还可以作为服务端的桩对象，进行跨进程的通信！ 7.2.2 removeSplit12345678910111213@Overridepublic void removeSplit(String splitName) &#123; //【1】首先如果要卸载 split apk，必须指定 parent pkg！ if (TextUtils.isEmpty(params.appPackageName)) &#123; throw new IllegalStateException(\"Must specify package name to remove a split\"); &#125; try &#123; //【*7.2.3】创建一个 mark 标记，来记录那些需要被移除的 split apk！！ createRemoveSplitMarker(splitName); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; 7.2.3 createRemoveSplitMarker123456789101112131415private void createRemoveSplitMarker(String splitName) throws IOException &#123; try &#123; //【1】创建了一个标记名称： final String markerName = splitName + REMOVE_SPLIT_MARKER_EXTENSION; if (!FileUtils.isValidExtFilename(markerName)) &#123; throw new IllegalArgumentException(\"Invalid marker: \" + markerName); &#125; //【2】在临时目录下创建创建了一个 \"splitName\".removed 的文件！ final File target = new File(resolveStageDir(), markerName); target.createNewFile(); Os.chmod(target.getAbsolutePath(), 0 /*mode*/); &#125; catch (ErrnoException e) &#123; throw e.rethrowAsIOException(); &#125;&#125; 这里的 REMOVE_SPLIT_MARKER_EXTENSION 是一个字符串后缀： 1private static final String REMOVE_SPLIT_MARKER_EXTENSION = \".removed\"; 7.2.3.1 resolveStageDir123456789101112131415161718private File resolveStageDir() throws IOException &#123; synchronized (mLock) &#123; if (mResolvedStageDir == null) &#123; if (stageDir != null) &#123; //【1】返回的就是前面的 stageDir！ mResolvedStageDir = stageDir; &#125; else &#123; final String path = PackageHelper.getSdDir(stageCid); if (path != null) &#123; mResolvedStageDir = new File(path); &#125; else &#123; throw new IOException(\"Failed to resolve path to container \" + stageCid); &#125; &#125; &#125; return mResolvedStageDir; &#125;&#125; 7.2.4 commitLocked按照流程，我们进入了 commitLocked 中： 参数 PackageInfo pkgInfo 和 ApplicationInfo appInfo 分别表示已经安装的主 apk 的信息对象！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899private void commitLocked(PackageInfo pkgInfo, ApplicationInfo appInfo) throws PackageManagerException &#123; if (mDestroyed) &#123; throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, \"Session destroyed\"); &#125; if (!mSealed) &#123; throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, \"Session not sealed\"); &#125; try &#123; //【*7.2.3.1】获得 tmp 目录，也就是前面我们的 .removed 文件所在的目录； resolveStageDir(); &#125; catch (IOException e) &#123; throw new PackageManagerException(INSTALL_FAILED_CONTAINER_ERROR, \"Failed to resolve stage location\", e); &#125; //【*7.2.4.1】校验安装有效性！ validateInstallLocked(pkgInfo, appInfo); Preconditions.checkNotNull(mPackageName); Preconditions.checkNotNull(mSignatures); Preconditions.checkNotNull(mResolvedBaseFile); if (!mPermissionsAccepted) &#123; // 这里我们就跳过，不分析，install 的时候分析过！ final Intent intent = new Intent(PackageInstaller.ACTION_CONFIRM_PERMISSIONS); intent.setPackage(mContext.getPackageManager().getPermissionControllerPackageName()); intent.putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId); try &#123; mRemoteObserver.onUserActionRequired(intent); &#125; catch (RemoteException ignored) &#123; &#125; close(); return; &#125; if (stageCid != null) &#123; final long finalSize = calculateInstalledSize(); resizeContainer(stageCid, finalSize); &#125; //【1】如果安装方式是继承已存在的 apk，那我们要尝试继承！！ // 显然，对于卸载 split apk 肯定是会走这一步的！！ if (params.mode == SessionParams.MODE_INHERIT_EXISTING) &#123; try &#123; //【1.1】mResolvedInheritedFiles 中都是需要从之前安装的目录下继承过来的 apk 和 odex 文件； final List&lt;File&gt; fromFiles = mResolvedInheritedFiles; //【1.2】这是我们本次安装的目录； final File toDir = resolveStageDir(); if (LOGD) Slog.d(TAG, \"Inherited files: \" + mResolvedInheritedFiles); if (!mResolvedInheritedFiles.isEmpty() &amp;&amp; mInheritedFilesBase == null) &#123; throw new IllegalStateException(\"mInheritedFilesBase == null\"); &#125; //【1.3】如果可以直接建立 link 的话，不行的话，就 copy！ if (isLinkPossible(fromFiles, toDir)) &#123; if (!mResolvedInstructionSets.isEmpty()) &#123; final File oatDir = new File(toDir, \"oat\"); createOatDirs(mResolvedInstructionSets, oatDir); &#125; linkFiles(fromFiles, toDir, mInheritedFilesBase); &#125; else &#123; //【1.4】拷贝已经安装的 apk 到新目录下！ copyFiles(fromFiles, toDir); &#125; &#125; catch (IOException e) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Failed to inherit existing install\", e); &#125; &#125; mInternalProgress = 0.5f; computeProgressLocked(true); extractNativeLibraries(mResolvedStageDir, params.abiOverride); if (stageCid != null) &#123; finalizeAndFixContainer(stageCid); &#125; final IPackageInstallObserver2 localObserver = new IPackageInstallObserver2.Stub() &#123; @Override public void onUserActionRequired(Intent intent) &#123; throw new IllegalStateException(); &#125; @Override public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) &#123;； destroyInternal(); dispatchSessionFinished(returnCode, msg, extras); &#125; &#125;; final UserHandle user; if ((params.installFlags &amp; PackageManager.INSTALL_ALL_USERS) != 0) &#123; user = UserHandle.ALL; &#125; else &#123; user = new UserHandle(userId); &#125; mRelinquished = true; //【2】开始安装！ mPm.installStage(mPackageName, stageDir, stageCid, localObserver, params, installerPackageName, installerUid, user, mCertificates);&#125; 对于卸载 split apk 的情况： 可以看到和 install 是一样的，唯独不一样的是，会将之前已经安装的 /data/app/package-Name/ 中除了要卸载的 split apk 以外的其他 apk 拷贝到新创建的目录下，重新安装； 7.2.4.1 validateInstallLocked校验安装有效性，这里的 mResolvedStageDir 就是前面的 /data/app/vmdl[sessionId].tmp 目录！ removeSplitList 用于表示要删除的 split apk 列表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164private void validateInstallLocked(PackageInfo pkgInfo, ApplicationInfo appInfo) throws PackageManagerException &#123; mPackageName = null; mVersionCode = -1; mSignatures = null; mResolvedBaseFile = null; mResolvedStagedFiles.clear(); mResolvedInheritedFiles.clear(); //【1】返回 /data/app/vmdl[sessionId].tmp 目录下所有的 .removed 文件！ // 去除后缀，将前缀名保存到 removeSplitList！ final File[] removedFiles = mResolvedStageDir.listFiles(sRemovedFilter); final List&lt;String&gt; removeSplitList = new ArrayList&lt;&gt;(); if (!ArrayUtils.isEmpty(removedFiles)) &#123; for (File removedFile : removedFiles) &#123; final String fileName = removedFile.getName(); final String splitName = fileName.substring( 0, fileName.length() - REMOVE_SPLIT_MARKER_EXTENSION.length()); removeSplitList.add(splitName); &#125; &#125; //【2】返回 /data/app/vmdl[sessionId].tmp 目录下所有的非 .removed 文件！ // 并判断是否正常，如果该目录下没有任何 apk 和 .removed 文件，那么抛出异常！ final File[] addedFiles = mResolvedStageDir.listFiles(sAddedFilter); if (ArrayUtils.isEmpty(addedFiles) &amp;&amp; removeSplitList.size() == 0) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"No packages staged\"); &#125; //【3】遍历该目录下的非 .removed 文件，解析其中的 apk 文件，也就是我们之前 copy 到这里的目标文件！ // 对于卸载 split apk 的情况，显然这里不会进入，因为我们的目录里面只有 .removed 文件！ final ArraySet&lt;String&gt; stagedSplits = new ArraySet&lt;&gt;(); for (File addedFile : addedFiles) &#123; final ApkLite apk; try &#123; //【3.1】解析要安装的 apk，具体的流程这里就不分析了！ apk = PackageParser.parseApkLite( addedFile, PackageParser.PARSE_COLLECT_CERTIFICATES); &#125; catch (PackageParserException e) &#123; throw PackageManagerException.from(e); &#125; //【3.2】将其添加到 stagedSplits 中，注意 base.apk 的 apk.splitName 为 null！ if (!stagedSplits.add(apk.splitName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Split \" + apk.splitName + \" was defined multiple times\"); &#125; //【3.3】将第一个被解析 apk 的包名，版本号，签名，证书保存下载，这个目录下的其他 apk // 的这几项要和其保持一致！ if (mPackageName == null) &#123; mPackageName = apk.packageName; mVersionCode = apk.versionCode; &#125; if (mSignatures == null) &#123; mSignatures = apk.signatures; mCertificates = apk.certificates; &#125; //【3.4】校验 apk 关联性，校验包名。版本号，签名； assertApkConsistent(String.valueOf(addedFile), apk); //【3.5】设置 apk 文件的目标名称！ final String targetName; if (apk.splitName == null) &#123; targetName = \"base.apk\"; // 一般情况下！ &#125; else &#123; targetName = \"split_\" + apk.splitName + \".apk\"; &#125; if (!FileUtils.isValidExtFilename(targetName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Invalid filename: \" + targetName); &#125; //【3.6】当 addedFile 命名不标准的话，会改名; final File targetFile = new File(mResolvedStageDir, targetName); if (!addedFile.equals(targetFile)) &#123; addedFile.renameTo(targetFile); &#125; //【3.7】找到了 base apk，将其保存到 mResolvedBaseFile！ // 同时将其添加到 mResolvedStagedFiles 中！ if (apk.splitName == null) &#123; mResolvedBaseFile = targetFile; &#125; mResolvedStagedFiles.add(targetFile); &#125; //【4】处理 .removed 文件，此时我们正在卸载 split apk，所以会进入这里！！ if (removeSplitList.size() &gt; 0) &#123; //【4.1】如果找不到该 split apk 文件的话，抛出异常！ for (String splitName : removeSplitList) &#123; if (!ArrayUtils.contains(pkgInfo.splitNames, splitName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Split not found: \" + splitName); &#125; &#125; //【4.2】再次获得要安装的应用的包名，版本号，签名！ if (mPackageName == null) &#123; mPackageName = pkgInfo.packageName; mVersionCode = pkgInfo.versionCode; &#125; if (mSignatures == null) &#123; mSignatures = pkgInfo.signatures; &#125; &#125; //【5】处理安装模式！ if (params.mode == SessionParams.MODE_FULL_INSTALL) &#123; //【5.1】全量安装必须要有 base.apk if (!stagedSplits.contains(null)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Full install must include a base package\"); &#125; &#125; else &#123; //【5.2】部分安装必须基于现有的安装！ if (appInfo == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Missing existing base package for \" + mPackageName); &#125; //【5.3】获得已存在的 apk 安装信息！ final PackageLite existing; final ApkLite existingBase; try &#123; //【5.3.1】对于安装 split apk，我们会解析下已存在的 split apk！！ existing = PackageParser.parsePackageLite(new File(appInfo.getCodePath()), 0); existingBase = PackageParser.parseApkLite(new File(appInfo.getBaseCodePath()), PackageParser.PARSE_COLLECT_CERTIFICATES); &#125; catch (PackageParserException e) &#123; throw PackageManagerException.from(e); &#125; //【*4.3.2.1】再次校验要本次要安装的 apk 和已存在的 apk 是有关联，包括包名，签名，版本号！ assertApkConsistent(\"Existing base\", existingBase); //【5.4】继承已有的 base apk，如果没有指定安装的 apk！！ if (mResolvedBaseFile == null) &#123; mResolvedBaseFile = new File(appInfo.getBaseCodePath()); mResolvedInheritedFiles.add(mResolvedBaseFile); &#125; //【5.5】继承已有的 split apk！！ if (!ArrayUtils.isEmpty(existing.splitNames)) &#123; for (int i = 0; i &lt; existing.splitNames.length; i++) &#123; final String splitName = existing.splitNames[i]; final File splitFile = new File(existing.splitCodePaths[i]); final boolean splitRemoved = removeSplitList.contains(splitName); if (!stagedSplits.contains(splitName) &amp;&amp; !splitRemoved) &#123; mResolvedInheritedFiles.add(splitFile); &#125; &#125; &#125; //【5.6】继承已有的 oat 相关文件！！ final File packageInstallDir = (new File(appInfo.getBaseCodePath())).getParentFile(); mInheritedFilesBase = packageInstallDir; final File oatDir = new File(packageInstallDir, \"oat\"); if (oatDir.exists()) &#123; final File[] archSubdirs = oatDir.listFiles(); if (archSubdirs != null &amp;&amp; archSubdirs.length &gt; 0) &#123; final String[] instructionSets = InstructionSets.getAllDexCodeInstructionSets(); for (File archSubDir : archSubdirs) &#123; // Skip any directory that isn't an ISA subdir. if (!ArrayUtils.contains(instructionSets, archSubDir.getName())) &#123; continue; &#125; // 将要继承的 oat 目录文件名添加到 mResolvedInstructionSets！ mResolvedInstructionSets.add(archSubDir.getName()); List&lt;File&gt; oatFiles = Arrays.asList(archSubDir.listFiles()); if (!oatFiles.isEmpty()) &#123; // 将要继承的 odex 相关文件添加到 mResolvedInheritedFiles！ mResolvedInheritedFiles.addAll(oatFiles); &#125; &#125; &#125; &#125; &#125;&#125; 其实这里，我们可以看到。对于卸载 split apk 的情况，我们会收集之前安装的目录下的所有不再 remove 列表中的 apk 文件到 mResolvedInheritedFiles 集合中！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 8 篇 - 通过 PackageInstaller 分析 Install 过程","slug":"PMS8-installThroughtPackageInstaller","date":"2018-07-22T16:00:00.000Z","updated":"2018-11-20T16:24:48.000Z","comments":true,"path":"2018/07/23/PMS8-installThroughtPackageInstaller/","link":"","permalink":"https://coolqi.top/2018/07/23/PMS8-installThroughtPackageInstaller/","excerpt":"","text":"[toc] 基于 Android7.1.1 分析 PackageManagerService 的逻辑，Android 版本虽然会不断更替，但是代码结构和思想史 0 综述前面总结了通过 pm install 的方式来安装一个 apk，但是这种方式用户是不经常使用的，用户使用的安装途径主要如下： 通过应用商店下载 apk，进行安装； 将 apk 文件移动到关键管理器，点击触发安装； 这里我们来看看第二种情况！ 对于第二种中情况，当我们触发安装的时候，实际上是发送了一个 intent，这个 intent 中携带了 apk 的文件路径等参数，在 sample 给出了如下的启动安装的方式： 1234567891011121314151617181920212223242526272829303132private OnClickListener mUnknownSourceListener = new OnClickListener() &#123; public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); intent.setData(Uri.fromFile(prepareApk(\"HelloActivity.apk\"))); startActivity(intent); &#125;&#125;;private OnClickListener mMySourceListener = new OnClickListener() &#123; public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); intent.setData(Uri.fromFile(prepareApk(\"HelloActivity.apk\"))); intent.putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true); intent.putExtra(Intent.EXTRA_RETURN_RESULT, true); intent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, getApplicationInfo().packageName); startActivityForResult(intent, REQUEST_INSTALL); &#125;&#125;;private OnClickListener mReplaceListener = new OnClickListener() &#123; public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); intent.setData(Uri.fromFile(prepareApk(\"HelloActivity.apk\"))); intent.putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true); intent.putExtra(Intent.EXTRA_RETURN_RESULT, true); intent.putExtra(Intent.EXTRA_ALLOW_REPLACE, true); intent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, getApplicationInfo().packageName); startActivityForResult(intent, REQUEST_INSTALL); &#125;&#125;; 那谁来接收这个 intent 呢？显而易见，PacakgeInstaller，我们去其说明书中看看： 1234567891011121314151617181920212223&lt;activity android:name=\".PackageInstallerActivity\" android:configChanges=\"orientation|keyboardHidden|screenSize\" android:excludeFromRecents=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;action android:name=\"android.intent.action.INSTALL_PACKAGE\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"file\" /&gt; &lt;data android:scheme=\"content\" /&gt; &lt;data android:mimeType=\"application/vnd.android.package-archive\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.INSTALL_PACKAGE\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"file\" /&gt; &lt;data android:scheme=\"package\" /&gt; &lt;data android:scheme=\"content\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.content.pm.action.CONFIRM_PERMISSIONS\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 我们看到 PackageInstallerActivity 接收了 android.intent.action.INSTALL_PACKAGE action！ 下面我们来分析下整个流程： 1 PackageInstallerActivity.onCreate这里我们进入 PackageInstallerActivity，看看其做了什么处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class PackageInstallerActivity extends Activity implements OnCancelListener, OnClickListener &#123; ... ... ... @Override protected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); //【1】获得安装传入的 Intent！ final Intent intent = getIntent(); mOriginatingUid = getOriginatingUid(intent); final Uri packageUri; if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) &#123; //【2】这个广播我们在 pm install 中有见过，当 install 需要确认权限信息的时候，会发送 intent // 其实是最终发送了这个 action 给 PackageInstaller 中了，同时会把 sessionId 发过来！ final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) &#123; Log.w(TAG, \"Session \" + mSessionId + \" in funky state; ignoring\"); finish(); return; &#125; mSessionId = sessionId; packageUri = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; &#125; else &#123; //【3】对于 install package 进入这里，会通过 getData 获得 packageUri！ mSessionId = -1; packageUri = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); &#125; //【4】如果 packageUri 为 null，那么这里会返回结果给启动安装的界面：INVALID_URI！ if (packageUri == null) &#123; Log.w(TAG, \"Unspecified source\"); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); finish(); return; &#125; if (DeviceUtils.isWear(this)) &#123; // 可穿戴设备的逻辑，不关注！ showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); return; &#125; //【5】初始化界面！ setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); mOk = (Button)findViewById(R.id.ok_button); mCancel = (Button)findViewById(R.id.cancel_button); mOk.setOnClickListener(this); mCancel.setOnClickListener(this); //【*1.1】解析传入的 packageUri！ boolean wasSetUp = processPackageUri(packageUri); if (!wasSetUp) &#123; return; &#125; //【*1.2】解析传入的 packageUri！ checkIfAllowedAndInitiateInstall(false); &#125; ... ... ...&#125; 我们看到 PackageInstallerActivity 方法实现了 OnCancelListener, OnClickListener，用于响应界面事件。。。 1.1 processPackageUri解析 Uri 被为要安装的 apk 设置合适的 installer，如果返回 true，表示设置成功了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private boolean processPackageUri(final Uri packageUri) &#123; mPackageURI = packageUri; //【1】获得 scheme 属性，对应资源使用的协议！ final String scheme = packageUri.getScheme(); final PackageUtil.AppSnippet as; switch (scheme) &#123; case SCHEME_PACKAGE: &#123; //【1.1】package 类型!！ try &#123; mPkgInfo = mPm.getPackageInfo(packageUri.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); &#125; catch (NameNotFoundException e) &#123; &#125; if (mPkgInfo == null) &#123; Log.w(TAG, \"Requested package \" + packageUri.getScheme() + \" not available. Discontinuing installation\"); //【*6/3】应用包异常，提示用户！ showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; &#125; //【*1.1.2.1】创建 AppSnippet 实例！ as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); &#125; break; case SCHEME_FILE: &#123; //【1.2】file 类型 File sourceFile = new File(packageUri.getPath()); //【*1.1.1】对 path 指定的 apk 进行解析，其实是创建了一个 PackageParser 对象，然后扫描 apk // 将结果封装为 PackageParser.Package 并返回！ PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); if (parsed == null) &#123; // 发生了 error！ Log.w(TAG, \"Parse error when parsing manifest. Discontinuing installation\"); //【*6/3】应用包异常，提示用户！ showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); return false; &#125; //【*1.1.2】将解析到的 Package 转为 PackageInfo 对象！ // 除了获取到了基本信息，这里还额外指定了获取该应用的定义的权限和申请的权限信息！ mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); //【*1.1.3】获得 apk 的 AppSnippet 实例！ as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); &#125; break; case SCHEME_CONTENT: &#123; //【1.3】content 类型 mStagingAsynTask = new StagingAsyncTask(); mStagingAsynTask.execute(packageUri); return false; &#125; default: &#123; //【1.4】不支持的资源协议，默认会进入这里！ Log.w(TAG, \"Unsupported scheme \" + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); clearCachedApkIfNeededAndFinish(); return false; &#125; &#125; //【*1.1.4】继续处理 AppSnippet 实例！ PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); return true;&#125; 对于安装文件管理器的 apk 的方式，其 scheme 值为 file，所以这里 对于 package 的解析流程，这里就不再多说了； 而 generatePackageInfo 方法的逻辑也很简单，flags 可以通过设置指定的位来获取特定的数据！ 1.1.1 PackageUtil.getPackageInfo12345678public static PackageParser.Package getPackageInfo(File sourceFile) &#123; final PackageParser parser = new PackageParser(); try &#123; return parser.parsePackage(sourceFile, 0); &#125; catch (PackageParserException e) &#123; return null; &#125;&#125; 1.1.2 PackageParser.generatePackageInfo将解析到的 Package 封装为指定的 PackageInfo 对象，除了基本的信息之外，还有通过 flags 指定的额外信息！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static PackageInfo generatePackageInfo(PackageParser.Package p, int gids[], int flags, long firstInstallTime, long lastUpdateTime, Set&lt;String&gt; grantedPermissions, PackageUserState state, int userId) &#123; if (!checkUseInstalledOrHidden(flags, state) || !p.isMatch(flags)) &#123; return null; &#125; //【1】创建一个 PackageInfo 实例！ PackageInfo pi = new PackageInfo(); pi.packageName = p.packageName; pi.splitNames = p.splitNames; pi.versionCode = p.mVersionCode; pi.baseRevisionCode = p.baseRevisionCode; pi.splitRevisionCodes = p.splitRevisionCodes; pi.versionName = p.mVersionName; pi.sharedUserId = p.mSharedUserId; pi.sharedUserLabel = p.mSharedUserLabel; pi.applicationInfo = generateApplicationInfo(p, flags, state, userId); pi.installLocation = p.installLocation; pi.coreApp = p.coreApp; if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0 || (pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) &#123; pi.requiredForAllUsers = p.mRequiredForAllUsers; &#125; pi.restrictedAccountType = p.mRestrictedAccountType; pi.requiredAccountType = p.mRequiredAccountType; pi.overlayTarget = p.mOverlayTarget; pi.firstInstallTime = firstInstallTime; pi.lastUpdateTime = lastUpdateTime; ... ... ... ... // 这里省略了其他的 flags 处理！ //【2】获得应用的权限信息 GET_PERMISSIONS！ if ((flags&amp;PackageManager.GET_PERMISSIONS) != 0) &#123; //【2.1】获得其定义的权限； int N = p.permissions.size(); if (N &gt; 0) &#123; pi.permissions = new PermissionInfo[N]; for (int i=0; i&lt;N; i++) &#123; pi.permissions[i] = generatePermissionInfo(p.permissions.get(i), flags); &#125; &#125; //【2.2】获得其申请的权限； N = p.requestedPermissions.size(); if (N &gt; 0) &#123; pi.requestedPermissions = new String[N]; pi.requestedPermissionsFlags = new int[N]; for (int i=0; i&lt;N; i++) &#123; final String perm = p.requestedPermissions.get(i); pi.requestedPermissions[i] = perm; //【2.2.1】更新申请的权限的 flags，设置 REQUESTED_PERMISSION_REQUIRED 标志位！ // 如果该权限已经被授予，那么还会增加 REQUESTED_PERMISSION_GRANTED 标志位！ pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_REQUIRED; if (grantedPermissions != null &amp;&amp; grantedPermissions.contains(perm)) &#123; pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_GRANTED; &#125; &#125; &#125; &#125; ... ... ... return pi;&#125; 这里涉及到了几个标志位： 1234// 表示该权限是应用程序运行必备的，用户不能 disable！public static final int REQUESTED_PERMISSION_REQUIRED = 1&lt;&lt;0;// 权限是否已经授予！public static final int REQUESTED_PERMISSION_GRANTED = 1&lt;&lt;1; 这两个标签都是在 generatePackageInfo 方法中，配合 GET_PERMISSIONS 方法使用！ 1.1.3 PackageUtil.getAppSnippet这个方法用于加载应用的 label 和 icon： 12345678910111213141516171819202122232425262728293031323334353637public static AppSnippet getAppSnippet( Activity pContext, ApplicationInfo appInfo, File sourceFile) &#123; final String archiveFilePath = sourceFile.getAbsolutePath(); Resources pRes = pContext.getResources(); AssetManager assmgr = new AssetManager(); //【1】设置资源加载路径！ assmgr.addAssetPath(archiveFilePath); Resources res = new Resources(assmgr, pRes.getDisplayMetrics(), pRes.getConfiguration()); CharSequence label = null; //【2】尝试先从资源文件中加载 label！ if (appInfo.labelRes != 0) &#123; try &#123; label = res.getText(appInfo.labelRes); &#125; catch (Resources.NotFoundException e) &#123; &#125; &#125; //【3】如果没有显式定义的话，那么就会使用包名； if (label == null) &#123; label = (appInfo.nonLocalizedLabel != null) ? appInfo.nonLocalizedLabel : appInfo.packageName; &#125; Drawable icon = null; //【4】尝试从资源文件获取图标，如果没有定义，那么我们会从系统中获取默认图标！ if (appInfo.icon != 0) &#123; try &#123; icon = res.getDrawable(appInfo.icon); &#125; catch (Resources.NotFoundException e) &#123; &#125; &#125; if (icon == null) &#123; icon = pContext.getPackageManager().getDefaultActivityIcon(); &#125; //【*1.1.2.1】创建了一个 AppSnippet 对象！ return new PackageUtil.AppSnippet(label, icon);&#125; 1.1.2.1 new AppSnippetAppSnippet 用于保存 apk 的 label 和 icon： 12345678static public class AppSnippet &#123; CharSequence label; Drawable icon; public AppSnippet(CharSequence label, Drawable icon) &#123; this.label = label; this.icon = icon; &#125;&#125; 1.1.4 PackageUtil.initSnippetForNewApp根据返回的 AppSnippet，初始化界面，显示应用的名称和 label：1234567public static View initSnippetForNewApp(Activity pContext, AppSnippet as, int snippetId) &#123; View appSnippet = pContext.findViewById(snippetId); ((ImageView)appSnippet.findViewById(R.id.app_icon)).setImageDrawable(as.icon); ((TextView)appSnippet.findViewById(R.id.app_name)).setText(as.label); return appSnippet;&#125; 1.2 checkIfAllowedAndInitiateInstall用于判断是否允许安装，如果允许安装，那就进行初始化；否则会弹出提示框，参数 ignoreUnknownSourcesSettings 表示是否忽视未知来源安装，这里我们传入的是 false； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void checkIfAllowedAndInitiateInstall(boolean ignoreUnknownSourcesSettings) &#123; //【*1.2.1】判断本次安装是否是来自未知来源！ final boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(getIntent()); if (!requestFromUnknownSource) &#123; //【*1.2.6】如果是特权应用发送的安装，那么就初始化安装！ initiateInstall(); &#125; //【1】判断当前所在 user 是否是在另外一个 user 的 profile 中！ final boolean isManagedProfile = mUserManager.isManagedProfile(); //【*1.2.2】判断当前用户是否设置了不允许位置来源的用户限制！ if (isUnknownSourcesDisallowed()) &#123; if ((mUserManager.getUserRestrictionSource(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, Process.myUserHandle()) &amp; UserManager.RESTRICTION_SOURCE_SYSTEM) != 0) &#123; if (ignoreUnknownSourcesSettings) &#123; //【*1.2.6】如果忽视未知来源，初始化安装！ initiateInstall(); &#125; else &#123; //【*6/1】显示 DLG_UNKNOWN_SOURCES 弹窗！ showDialogInner(DLG_UNKNOWN_SOURCES); &#125; &#125; else &#123; startActivity(new Intent(Settings.ACTION_SHOW_ADMIN_SUPPORT_DETAILS)); clearCachedApkIfNeededAndFinish(); &#125; &#125; else if (!isUnknownSourcesEnabled() &amp;&amp; isManagedProfile) &#123; //【*1.2.3】如果没有设置用户限制，但是用户关闭了设置中的可未知来源安装 // 同时当前用户是在另外用户的 profile 中！ // 显示 DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES 弹窗！ //【*6/2】提示用户！ showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); &#125; else if (!isUnknownSourcesEnabled()) &#123; //【*1.2.3】如果用户关闭了设置中的可未知来源安装，并且我们忽视位置来源 // 那么就立刻初始化！ if (ignoreUnknownSourcesSettings) &#123; //【*1.2.6】初始化安装！ initiateInstall(); &#125; else &#123; //【*6/1】显示 DLG_UNKNOWN_SOURCES 弹窗！ showDialogInner(DLG_UNKNOWN_SOURCES); &#125; &#125; else &#123; //【*1.2.6】如果不是来自未知来源的安装，那么就初始化安装！ initiateInstall(); &#125;&#125; 1.2.1 isInstallRequestFromUnknownSource判断本次安装是否来自未知来源： 1234567891011121314151617181920private boolean isInstallRequestFromUnknownSource(Intent intent) &#123; String callerPackage = getCallingPackage(); //【1】判断 intent 是否设置 EXTRA_NOT_UNKNOWN_SOURCE 为 true！ if (callerPackage != null &amp;&amp; intent.getBooleanExtra( Intent.EXTRA_NOT_UNKNOWN_SOURCE, false)) &#123; try &#123; mSourceInfo = mPm.getApplicationInfo(callerPackage, 0); if (mSourceInfo != null) &#123; if ((mSourceInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) &#123; //【1.1】如果设置了为 true，只有特权应用发起安装时才不会视为未知来源； return false; &#125; &#125; &#125; catch (NameNotFoundException e) &#123; &#125; &#125; //【2】其他情况，无论你是否设置，都会视为未知来源！ return true;&#125; 1.2.2 isUnknownSourcesDisallowed判断下当前设备用户是否限制来自未知来源的安装，也就是是否设置了 DISALLOW_INSTALL_UNKNOWN_SOURCES 用户限制： 123private boolean isUnknownSourcesDisallowed() &#123; return mUserManager.hasUserRestriction(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES);&#125; 1.2.3 isUnknownSourcesEnabled判断用户是否在设置中打开了位置来源限制： 1234private boolean isUnknownSourcesEnabled() &#123; return Settings.Secure.getInt(getContentResolver(), Settings.Secure.INSTALL_NON_MARKET_APPS, 0) &gt; 0;&#125; 1.2.6 initiateInstall初始化安装： 12345678910111213141516171819202122232425262728private void initiateInstall() &#123; //【1】获得要安装的应用包名！ String pkgName = mPkgInfo.packageName; //【2】判断下系统中是否存在该 pkg，但是被改为了其他名称，如果有，这里要调整下！ String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] &#123; pkgName &#125;); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) &#123; pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; &#125; //【3】判断该 pkg 是否已经安装过，如果是，弹出 replace 的弹窗； try &#123; //【3.1】这里通过 GET_UNINSTALLED_PACKAGES 标志为获得该应用的安装信息 // 如果该应用在系统中只有 data 数据，我们也会将其视为已经安装！ mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.GET_UNINSTALLED_PACKAGES); //【3.2】判断是否有 FLAG_INSTALLED 标志为，如果没有，那就是没有安装过！ if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) &#123; mAppInfo = null; &#125; &#125; catch (NameNotFoundException e) &#123; mAppInfo = null; &#125; //【*2】继续处理： startInstallConfirm();&#125; 2 PackageInstallerActivity.startInstallConfirm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117private void startInstallConfirm() &#123; //【1】初始化界面； ((TextView) findViewById(R.id.install_confirm_question)) .setText(R.string.install_confirm_question); findViewById(R.id.spacer).setVisibility(View.GONE); TabHost tabHost = (TabHost)findViewById(android.R.id.tabhost); tabHost.setup(); tabHost.setVisibility(View.VISIBLE); ViewPager viewPager = (ViewPager)findViewById(R.id.pager); TabsAdapter adapter = new TabsAdapter(this, tabHost, viewPager); //【2】判断应用是否支持运行时权限！ boolean supportsRuntimePermissions = mPkgInfo.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.M; boolean permVisible = false; mScrollView = null; mOkCanInstall = false; int msg = 0; //【*2.1】创建了一个 AppSecurityPermissions 实例，封装 apk 的权限 AppSecurityPermissions perms = new AppSecurityPermissions(this, mPkgInfo); //【*2.2】获得应用的申请的所有权限数量！ final int N = perms.getPermissionCount(AppSecurityPermissions.WHICH_ALL); //【3】初始化界面，这里会用 mScrollView 来显示所有的权限信息，mAppInfo 不为 null，说明应用 // 之前安装过！ if (mAppInfo != null) &#123; msg = (mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0 ? R.string.install_confirm_question_update_system : R.string.install_confirm_question_update; mScrollView = new CaffeinatedScrollView(this); mScrollView.setFillViewport(true); boolean newPermissionsFound = false; //【3.1】不支持运行时权限，这里会尝试先获取该应用的一些新的权限； if (!supportsRuntimePermissions) &#123; //【*2.2】获得应用的申请的所有被视为新的权限的数量！ newPermissionsFound = (perms.getPermissionCount(AppSecurityPermissions.WHICH_NEW) &gt; 0); if (newPermissionsFound) &#123; permVisible = true; mScrollView.addView(perms.getPermissionsView( AppSecurityPermissions.WHICH_NEW)); &#125; &#125; //【3.2】不支持运行时权限，同时没有新的申请的权限； if (!supportsRuntimePermissions &amp;&amp; !newPermissionsFound) &#123; LayoutInflater inflater = (LayoutInflater)getSystemService( Context.LAYOUT_INFLATER_SERVICE); TextView label = (TextView)inflater.inflate(R.layout.label, null); label.setText(R.string.no_new_perms); mScrollView.addView(label); &#125; //【3.3】这里会通过 tabHost 新增一个页面，用于显示申请的新增权限！ adapter.addTab(tabHost.newTabSpec(TAB_ID_NEW).setIndicator( getText(R.string.newPerms)), mScrollView); &#125; else &#123; findViewById(R.id.tabscontainer).setVisibility(View.GONE); findViewById(R.id.spacer).setVisibility(View.VISIBLE); &#125; //【3】如果不支持运行时权限，那么这里会处理申请的所有的权限！ if (!supportsRuntimePermissions &amp;&amp; N &gt; 0) &#123; permVisible = true; LayoutInflater inflater = (LayoutInflater)getSystemService( Context.LAYOUT_INFLATER_SERVICE); View root = inflater.inflate(R.layout.permissions_list, null); if (mScrollView == null) &#123; mScrollView = (CaffeinatedScrollView)root.findViewById(R.id.scrollview); &#125; ((ViewGroup)root.findViewById(R.id.permission_list)).addView( perms.getPermissionsView(AppSecurityPermissions.WHICH_ALL)); //【4】这里会通过 tabHost 新增一个页面，用于显示申请的所有的权限！ adapter.addTab(tabHost.newTabSpec(TAB_ID_ALL).setIndicator( getText(R.string.allPerms)), root); &#125; //【4】如果 permVisible 说明该应用没有要显示给用户的权限； if (!permVisible) &#123; if (mAppInfo != null) &#123; //【4.1】处理应用覆盖安装的情况，设置 msg 为没有 update_system_no_perms 或 update_no_perms！ // 这是资源 id，会在界面显示！ msg = (mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0 ? R.string.install_confirm_question_update_system_no_perms : R.string.install_confirm_question_update_no_perms; findViewById(R.id.spacer).setVisibility(View.VISIBLE); &#125; else &#123; //【4.1】处理应用全新安装的情况，设置 msg 为 no_perms，同上！ msg = R.string.install_confirm_question_no_perms; &#125; tabHost.setVisibility(View.INVISIBLE); mScrollView = null; &#125; if (msg != 0) &#123; ((TextView)findViewById(R.id.install_confirm_question)).setText(msg); &#125; mInstallConfirm.setVisibility(View.VISIBLE); //【6】设置安装 button 可以点击！ mOk.setEnabled(true); if (mScrollView == null) &#123; //【6.1】如果不需要用 mScrollView 显示内容，那就直接显示安装 mOk.setText(R.string.install); mOkCanInstall = true; &#125; else &#123; //【6.2】如果要显示权限信息，那么需要用户滚动界面，看完所有的权限信息 // 安装 button 才可用！ mScrollView.setFullScrollAction(new Runnable() &#123; @Override public void run() &#123; mOk.setText(R.string.install); mOkCanInstall = true; &#125; &#125;); &#125;&#125; 不多说了，继续看！ 2.1 new AppSecurityPermissionsAppSecurityPermissions 有多个构造器，这里调用了 AppSecurityPermissions 的双参构造函数，同时 AppSecurityPermissions 内部也有很多的成员变量，我们来分析下： 这里的 PackageInfo info 表示的是本次要安装的应用程序的 PackageInfo 实例！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AppSecurityPermissions &#123; ... ... ... public AppSecurityPermissions(Context context, PackageInfo info) &#123; this(context); //【1】创建了一个 Set 集合用于收集权限 Set&lt;MyPermissionInfo&gt; permSet = new HashSet&lt;MyPermissionInfo&gt;(); if(info == null) &#123; return; &#125; mPackageName = info.packageName; //【2】用于保存已经安装的相同包名应用的信息！ PackageInfo installedPkgInfo = null; //【3】如果应用有申请权限，那么就查询已经安装的同名应用（如果有） // 对应的权限信息，收集到 installedPkgInfo 中！ if (info.requestedPermissions != null) &#123; try &#123; installedPkgInfo = mPm.getPackageInfo(info.packageName, PackageManager.GET_PERMISSIONS); &#125; catch (NameNotFoundException e) &#123; &#125; //【*2.1.1】这里会比较本次安装的应用和已经安装的旧应用（如果有）的权限，做相应处理 // 最后将权限保存到 permSet 集合中！ extractPerms(info, permSet, installedPkgInfo); &#125; //【4】如果其是共享 uid 的，那么就要获得该 uid 的所有权限！ if (info.sharedUserId != null) &#123; int sharedUid; try &#123; sharedUid = mPm.getUidForSharedUser(info.sharedUserId); //【*2.1.2】获得该 shared uid 的权限信息！ getAllUsedPermissions(sharedUid, permSet); &#125; catch (NameNotFoundException e) &#123; Log.w(TAG, \"Couldn't retrieve shared user id for: \" + info.packageName); &#125; &#125; //【5】将搜集到的权限 set 集合加到 mPermsList 中！ mPermsList.addAll(permSet); //【*2.1.3】进一步设置权限！ setPermissions(mPermsList); &#125; ... ... ...&#125; AppSecurityPermissions 中有如下重要变量： 123456789101112131415//【1】所属的所有的权限组，组名和 MyPermissionGroupInfo 的映射关系；private final Map&lt;String, MyPermissionGroupInfo&gt; mPermGroups = new HashMap&lt;String, MyPermissionGroupInfo&gt;();//【2】所属的所有的权限组；private final List&lt;MyPermissionGroupInfo&gt; mPermGroupsList = new ArrayList&lt;MyPermissionGroupInfo&gt;();//【3】用于给权限组排序；private final PermissionGroupInfoComparator mPermGroupComparator = new PermissionGroupInfoComparator();//【4】用于给权限排序；private final PermissionInfoComparator mPermComparator = new PermissionInfoComparator();//【5】应用请求的权限信息！private final List&lt;MyPermissionInfo&gt; mPermsList = new ArrayList&lt;MyPermissionInfo&gt;();private final CharSequence mNewPermPrefix;private String mPackageName; 我们后面分析的时候会遇到！ 2.1.1 AppSecurityPermissions.extractPerms这里会比较本次安装的应用和已经安装的旧应用（如果有）的权限，做相应处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private void extractPerms(PackageInfo info, Set&lt;MyPermissionInfo&gt; permSet, PackageInfo installedPkgInfo) &#123; String[] strList = info.requestedPermissions; int[] flagsList = info.requestedPermissionsFlags; if ((strList == null) || (strList.length == 0)) &#123; return; &#125; //【1】遍历处理权限！ for (int i=0; i&lt;strList.length; i++) &#123; String permName = strList[i]; try &#123; //【1.1】获得权限对应的 PermissionInfo 对象 tmpPermInfo，如果为 null 跳过！ PermissionInfo tmpPermInfo = mPm.getPermissionInfo(permName, 0); if (tmpPermInfo == null) &#123; continue; &#125; //【1.2】判断新安装的应用的权限在已经安装的应用（如果有）中是否存在，如果有 existingIndex 不为 -1； // existingIndex 为其在已经安装的应用的权限列表中的下标！ int existingIndex = -1; if (installedPkgInfo != null &amp;&amp; installedPkgInfo.requestedPermissions != null) &#123; for (int j=0; j&lt;installedPkgInfo.requestedPermissions.length; j++) &#123; if (permName.equals(installedPkgInfo.requestedPermissions[j])) &#123; existingIndex = j; break; &#125; &#125; &#125; //【1.3】判断下该权限在已经安装的应用中的权限标志位； final int existingFlags = existingIndex &gt;= 0 ? installedPkgInfo.requestedPermissionsFlags[existingIndex] : 0; //【*2.1.1.1】判断该权限是否需要在界面给用户显示出来，不需要的话那就跳过该权限； if (!isDisplayablePermission(tmpPermInfo, flagsList[i], existingFlags)) &#123; continue; &#125; //【1.4】处理权限组名，默认为包名！ final String origGroupName = tmpPermInfo.group; String groupName = origGroupName; if (groupName == null) &#123; groupName = tmpPermInfo.packageName; tmpPermInfo.group = groupName; &#125; //【1.5】获得/创建权限所属的权限组！ MyPermissionGroupInfo group = mPermGroups.get(groupName); if (group == null) &#123; PermissionGroupInfo grp = null; if (origGroupName != null) &#123; grp = mPm.getPermissionGroupInfo(origGroupName, 0); &#125; if (grp != null) &#123; //【1.5.1】如果权限指定了所属的组，那么我们就查询组信息 // 然后创建 MyPermissionGroupInfo 实例，祖名为定义权限的包名！！ group = new MyPermissionGroupInfo(grp); &#125; else &#123; //【1.5.2】如果权限没有指定所属的组，或者组无法查到，那么我们就 // 新建 MyPermissionGroupInfo 实例.，默认权限组名为权限定义的包名！ tmpPermInfo.group = tmpPermInfo.packageName; group = mPermGroups.get(tmpPermInfo.group); if (group == null) &#123; group = new MyPermissionGroupInfo(tmpPermInfo); &#125; group = new MyPermissionGroupInfo(tmpPermInfo); &#125; //【1.5.3】将该组加入到内部集合 mPermGroups 中！ mPermGroups.put(tmpPermInfo.group, group); &#125; //【1.6】判断该权限是否是一个新的权限，如果应用已经被安装了，同时并没有被授予该权限！ final boolean newPerm = installedPkgInfo != null &amp;&amp; (existingFlags&amp;PackageInfo.REQUESTED_PERMISSION_GRANTED) == 0; //【×2.1.1.3】创建一个 MyPermissionInfo 对象，封装该权限信息； MyPermissionInfo myPerm = new MyPermissionInfo(tmpPermInfo); myPerm.mNewReqFlags = flagsList[i]; myPerm.mExistingReqFlags = existingFlags; // This is a new permission if the app is already installed and // doesn't currently hold this permission. myPerm.mNew = newPerm; //【1.7】将该权限加入到内部集合 permSet 中； permSet.add(myPerm); &#125; catch (NameNotFoundException e) &#123; Log.i(TAG, \"Ignoring unknown permission:\"+permName); &#125; &#125;&#125; 不多说了。。 2.1.1.1 AppSecurityPermissions.isDisplayablePermissionisDisplayablePermission 用于判断哪些权限会在界面中显示，那些不显示： 12345678910111213141516171819202122232425262728293031323334353637383940private boolean isDisplayablePermission(PermissionInfo pInfo, int newReqFlags, int existingReqFlags) &#123; //【1】获得基本权限类型； final int base = pInfo.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE; final boolean isNormal = (base == PermissionInfo.PROTECTION_NORMAL); //【2】如果是 normal 权限类型，那么我们不会在界面显示，返回 false； if (isNormal) &#123; return false; &#125; //【3】新应用的该权限是否是 dangerous 类型的权限； final boolean isDangerous = (base == PermissionInfo.PROTECTION_DANGEROUS) || ((pInfo.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_PRE23) != 0); //【3】新应用的该权限是否是运行必须的； final boolean isRequired = ((newReqFlags&amp;PackageInfo.REQUESTED_PERMISSION_REQUIRED) != 0); //【4】新应用的该权限是否是 development 的签名权限！ final boolean isDevelopment = ((pInfo.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0); //【5】已存在的应用的该权限是否是被授予的！ final boolean wasGranted = ((existingReqFlags&amp;PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0); //【6】新应用的该权限是否是授予的！ final boolean isGranted = ((newReqFlags&amp;PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0); //【7】如果该权限是 dangerous 的，那必须给用户显示出来！！ if (isDangerous &amp;&amp; (isRequired || wasGranted || isGranted)) &#123; return true; &#125; //【8】如果 development 的权限，并且已存在的应用的该权限是被授予的， // 那么我们会给用户显示出来！ if (isDevelopment &amp;&amp; wasGranted) &#123; if (localLOGV) Log.i(TAG, \"Special perm \" + pInfo.name + \": protlevel=0x\" + Integer.toHexString(pInfo.protectionLevel)); return true; &#125; return false;&#125; 不多说了！ 2.1.1.2 new MyPermissionGroupInfo创建一个权限组对象： 12345678910111213141516171819202122232425/** @hide */static class MyPermissionGroupInfo extends PermissionGroupInfo &#123; CharSequence mLabel; // 所有属于该权限组的该应用申请的被视为新的权限（很绕口我知道。。） final ArrayList&lt;MyPermissionInfo&gt; mNewPermissions = new ArrayList&lt;MyPermissionInfo&gt;(); // 所有属于该权限组的该应用申请的权限 final ArrayList&lt;MyPermissionInfo&gt; mAllPermissions = new ArrayList&lt;MyPermissionInfo&gt;(); MyPermissionGroupInfo(PermissionInfo perm) &#123; name = perm.packageName; // 权限组名； packageName = perm.packageName; // 所属包名； &#125; MyPermissionGroupInfo(PermissionGroupInfo info) &#123; super(info); &#125; public Drawable loadGroupIcon(Context context, PackageManager pm) &#123; if (icon != 0) &#123; return loadUnbadgedIcon(pm); &#125; else &#123; return context.getDrawable(R.drawable.ic_perm_device_info); &#125; &#125;&#125; 2.1.1.3 new MyPermissionInfo1234567891011121314151617/** @hide */private static class MyPermissionInfo extends PermissionInfo &#123; CharSequence mLabel; // 新安装的应用的该权限标志位，值来自 requestedPermissionsFlags int mNewReqFlags; // 已经被安装的应用（如果有）的该权限标志位，值来自 requestedPermissionsFlags int mExistingReqFlags; // 判断该应用是否被视为一个新的权限！ boolean mNew; MyPermissionInfo(PermissionInfo info) &#123; super(info); &#125;&#125; 2.1.2 AppSecurityPermissions.getAllUsedPermissions获得共享 uid 的权限！ 1234567891011private void getAllUsedPermissions(int sharedUid, Set&lt;MyPermissionInfo&gt; permSet) &#123; //【1】获得所有共享了该 uid 的 pkg！ String sharedPkgList[] = mPm.getPackagesForUid(sharedUid); if(sharedPkgList == null || (sharedPkgList.length == 0)) &#123; return; &#125; //【*2.1.2.1】获得其 request 的权限！ for(String sharedPkg : sharedPkgList) &#123; getPermissionsForPackage(sharedPkg, permSet); &#125;&#125; 2.1.2.1 AppSecurityPermissions.getPermissionsForPackage继续处理： 12345678910private void getPermissionsForPackage(String packageName, Set&lt;MyPermissionInfo&gt; permSet) &#123; try &#123; //【1】获得该 packageName 对应的应用程序！ PackageInfo pkgInfo = mPm.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS); //【*2.1.1】又调用了 extractPerms 方法！ extractPerms(pkgInfo, permSet, pkgInfo); &#125; catch (NameNotFoundException e) &#123; Log.w(TAG, \"Couldn't retrieve permissions for package: \" + packageName); &#125;&#125; 不多说了！ 2.1.3 AppSecurityPermissions.setPermissions设置权限，将权限设置到对应的权限组中！ 123456789101112131415161718192021222324252627282930313233343536373839404142private void setPermissions(List&lt;MyPermissionInfo&gt; permList) &#123; //【1】将申请的权限加入对应的 group 中！ if (permList != null) &#123; for (MyPermissionInfo pInfo : permList) &#123; if(localLOGV) Log.i(TAG, \"Processing permission:\"+pInfo.name); //【*2.1.1.1】调用 isDisplayablePermission 判断权限是否不用显示给用户！ if(!isDisplayablePermission(pInfo, pInfo.mNewReqFlags, pInfo.mExistingReqFlags)) &#123; if(localLOGV) Log.i(TAG, \"Permission:\"+pInfo.name+\" is not displayable\"); continue; &#125; //【1.2】将要申请的权限加入到对应的权限中！ MyPermissionGroupInfo group = mPermGroups.get(pInfo.group); if (group != null) &#123; pInfo.mLabel = pInfo.loadLabel(mPm); //【*2.1.3.1】添加到 group.mAllPermissions 内部集合中； addPermToList(group.mAllPermissions, pInfo); if (pInfo.mNew) &#123; //【*2.1.3.1】添加到 group.mNewPermissions 内部集合中； addPermToList(group.mNewPermissions, pInfo); &#125; &#125; &#125; &#125; //【2】设置每个权限组的 label！ for (MyPermissionGroupInfo pgrp : mPermGroups.values()) &#123; if (pgrp.labelRes != 0 || pgrp.nonLocalizedLabel != null) &#123; pgrp.mLabel = pgrp.loadLabel(mPm); &#125; else &#123; ApplicationInfo app; try &#123; app = mPm.getApplicationInfo(pgrp.packageName, 0); pgrp.mLabel = app.loadLabel(mPm); &#125; catch (NameNotFoundException e) &#123; pgrp.mLabel = pgrp.loadLabel(mPm); &#125; &#125; //【2.1】将权限添加到 mPermGroupsList 中！ mPermGroupsList.add(pgrp); &#125; //【3】对权限组进行排序！ Collections.sort(mPermGroupsList, mPermGroupComparator);&#125; 2.1.3.1 AppSecurityPermissions.setPermissions1234567891011121314private void addPermToList(List&lt;MyPermissionInfo&gt; permList, MyPermissionInfo pInfo) &#123; if (pInfo.mLabel == null) &#123; pInfo.mLabel = pInfo.loadLabel(mPm); &#125; //【1】这里会使用排序方式找到合适的位置，使用比较器是 mPermComparator！ int idx = Collections.binarySearch(permList, pInfo, mPermComparator); if(localLOGV) Log.i(TAG, \"idx=\"+idx+\", list.size=\"+permList.size()); if (idx &lt; 0) &#123; idx = -idx-1; //【1.1】插入到 permList 列表中； permList.add(idx, pInfo); &#125;&#125; 2.2 AppSecurityPermissions.getPermissionCount获得权限的数量： 12345678public int getPermissionCount(int which) &#123; int N = 0; for (int i=0; i&lt;mPermGroupsList.size(); i++) &#123; //【*2.2.1】返回每个 group 的权限个数！ N += getPermissionList(mPermGroupsList.get(i), which).size(); &#125; return N;&#125; 不多说了！ 2.2.1 AppSecurityPermissions.getPermissionList根据 which 指定的标志，返回 grp.mNewPermissions 或者 grp.mAllPermissions1234567private List&lt;MyPermissionInfo&gt; getPermissionList(MyPermissionGroupInfo grp, int which) &#123; if (which == WHICH_NEW) &#123; return grp.mNewPermissions; &#125; else &#123; return grp.mAllPermissions; &#125;&#125; 具体的意思很简单了，就不多说了！ 3 onClick -&gt; trigger to install12345678910111213141516171819202122232425262728public void onClick(View v) &#123; if (v == mOk) &#123; if (mOkCanInstall || mScrollView == null) &#123; if (mSessionId != -1) &#123; //【1】这里对应的是 onCreate 中的 confirm permission 的广播 // 这里会进入系统进程，通知权限确认完成，继续下一阶段安装！ //【*3.1】通知 PackageInstallerService 权限确认完成！ mInstaller.setPermissionsResult(mSessionId, true); clearCachedApkIfNeededAndFinish(); &#125; else &#123; //【*4】正常情况会进入 startInstall 阶段！ startInstall(); &#125; &#125; else &#123; //【2】强制滚动，让用户看完权限信息； mScrollView.pageScroll(View.FOCUS_DOWN); &#125; &#125; else if (v == mCancel) &#123; //【3】当然，如果用户点击了取消，如果 mSessionId 不为 -1， // 那么也需要进入系统进程，通知系统无需继续安装！ setResult(RESULT_CANCELED); if (mSessionId != -1) &#123; //【*3.1】通知 PackageInstallerService 权限确认完成！ mInstaller.setPermissionsResult(mSessionId, false); &#125; clearCachedApkIfNeededAndFinish(); &#125;&#125; 3.1 PackageInstallerService.setPermissionsResult123456789101112@Overridepublic void setPermissionsResult(int sessionId, boolean accepted) &#123; mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, TAG); synchronized (mSessions) &#123; PackageInstallerSession session = mSessions.get(sessionId); if (session != null) &#123; //【*3.2】根据指定的 sessionId，找到对应的 PackageInstallerSession session.setPermissionsResult(accepted); &#125; &#125;&#125; 3.2 PackageInstallerSession.setPermissionsResult1234567891011121314151617void setPermissionsResult(boolean accepted) &#123; if (!mSealed) &#123; throw new SecurityException(\"Must be sealed to accept permissions\"); &#125; if (accepted) &#123; //【1】这里设置了 mPermissionsAccepted 为 true，这样在下面的继续安装中，就不会重复确权了！ synchronized (mLock) &#123; mPermissionsAccepted = true; &#125; //【2】发送 MSG_COMMIT 消息，继续安装！ mHandler.obtainMessage(MSG_COMMIT).sendToTarget(); &#125; else &#123; destroyInternal(); dispatchSessionFinished(INSTALL_FAILED_ABORTED, \"User rejected permissions\", null); &#125;&#125; 下面，我们继续看 startInstall 方法： 4 PackageInstallerActivity.startInstall继续分析： 123456789101112131415161718192021222324252627282930313233343536private void startInstall() &#123; //【1】创建了一个 intent，封装要安装的应用程序！ Intent newIntent = new Intent(); //【2】传递要安装的应用程序的 ApplicationInfo 实例； newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); //【2】目标组件 InstallAppProgress！ newIntent.setClass(this, InstallAppProgress.class); String installerPackageName = getIntent().getStringExtra( Intent.EXTRA_INSTALLER_PACKAGE_NAME); if (mOriginatingURI != null) &#123; newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI); &#125; if (mReferrerURI != null) &#123; newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI); &#125; if (mOriginatingUid != VerificationParams.NO_UID) &#123; newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid); &#125; if (installerPackageName != null) &#123; newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName); &#125; //【3】如果安装的启动者 start 的时候，指定了接收返回结果，此时我们启动了一个新的 activity // InstallAppProgress，所以这里指定 InstallAppProgress 会将安装结果返回给启动者！ // 而不是启动 InstallAppProgress 的界面！ if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) &#123; newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true); //【3.1】这种效果是通过 FLAG_ACTIVITY_FORWARD_RESULT 标志位实现的！ newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); &#125; if(localLOGV) Log.i(TAG, \"downloaded app uri=\"+mPackageURI); startActivity(newIntent); finish();&#125; 关于 start activity，我们有在 ams 的相关内容中看到！ 5 InstallAppProgress5.1 onCreate12345678910111213141516171819202122232425@Overridepublic void onCreate(Bundle icicle) &#123; super.onCreate(icicle); Intent intent = getIntent(); mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); mPackageURI = intent.getData(); final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !\"file\".equals(scheme) &amp;&amp; !\"package\".equals(scheme)) &#123; throw new IllegalArgumentException(\"unexpected scheme \" + scheme); &#125; //【1】启动了一个 HandlerThread 用于安装； mInstallThread = new HandlerThread(\"InstallThread\"); mInstallThread.start(); mInstallHandler = new Handler(mInstallThread.getLooper()); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); //【*5.1.1】动态注册了一个广播接收者，监听 ACTION_INSTALL_COMMIT 广播！ registerReceiver( mBroadcastReceiver, intentFilter, BROADCAST_SENDER_PERMISSION, null /*scheduler*/); //【*5.2】初始化界面！ initView();&#125; InstallAppProgress 显示后，会注册一个接收者，监听下面的广播：12private static final String BROADCAST_ACTION = \"com.android.packageinstaller.ACTION_INSTALL_COMMIT\"; 并且发送者要具有这样的权限：12private static final String BROADCAST_SENDER_PERMISSION = \"android.permission.INSTALL_PACKAGES\"; 5.1.1 new BroadcastReceiver用于接收 com.android.packageinstaller.ACTION_INSTALL_COMMIT 广播！！ 123456789101112private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final int statusCode = intent.getIntExtra( PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (statusCode == PackageInstaller.STATUS_PENDING_USER_ACTION) &#123; context.startActivity((Intent)intent.getParcelableExtra(Intent.EXTRA_INTENT)); &#125; else &#123; onPackageInstalled(statusCode); &#125; &#125;&#125;; 我们在分析 pm install 的时候： 123456789101112131415161718//【1】mPermissionsAccepted 为 true，那么用户就可以静默安装了，如果为 false，那么就需要用户确认权限！！if (!mPermissionsAccepted) &#123; //【1.1】这里会创建一个 intent， action 为 PackageInstaller.ACTION_CONFIRM_PERMISSIONS // 目标应用是 PackageInstaller，这里会先进入 packageinstaller 中确认权限信息！ final Intent intent = new Intent(PackageInstaller.ACTION_CONFIRM_PERMISSIONS); intent.setPackage(mContext.getPackageManager().getPermissionControllerPackageName()); intent.putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId); // 事务 id 也要从传递过去！ try &#123; //【*4.1.1】回调了 PackageInstallObserverAdapter 的 onUserActionRequired 接口 // 将 intent 传递过去！ mRemoteObserver.onUserActionRequired(intent); &#125; catch (RemoteException ignored) &#123; &#125; //【*4.3.3】关闭该事务，使其从 active 变为 idle 状态！！ close(); // 停止安装，等待用户确认权限，用户在 PackageInstaller 点击安装，安装会继续！！ return;&#125; 当我们需要用户确认权限的时候，会创建一个 intent，action 为 ACTION_CONFIRM_PERMISSIONS，这里的逻辑，然后会掉 RemoteObserver.onUserActionRequired 方法！ 5.2 initView继续来看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384void initView() &#123; setContentView(R.layout.op_progress); //【1】这里有要创建一个 AppSnippet 实例！ final PackageUtil.AppSnippet as; final PackageManager pm = getPackageManager(); //【*5.2.1】解析安装标志位， 主要作用是指定安装方式，是取代已经存在的，还是全新安装！ final int installFlags = getInstallFlags(mAppInfo.packageName); if((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING )!= 0) &#123; Log.w(TAG, \"Replacing package:\" + mAppInfo.packageName); &#125; if (\"package\".equals(mPackageURI.getScheme())) &#123; //【*1.1.2.1】又创建了一个 AppSnippet 实例！ as = new PackageUtil.AppSnippet(pm.getApplicationLabel(mAppInfo), pm.getApplicationIcon(mAppInfo)); &#125; else &#123; //【*1.1.3】又创建了一个 AppSnippet 实例！ final File sourceFile = new File(mPackageURI.getPath()); as = PackageUtil.getAppSnippet(this, mAppInfo, sourceFile); &#125; mLabel = as.label; //【*1.1.4】初始化 AppSnippet 的相关属性，icon 等等！ PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); //【2】初始化界面！ mStatusTextView = (TextView)findViewById(R.id.center_text); mExplanationTextView = (TextView) findViewById(R.id.explanation); mProgressBar = (ProgressBar) findViewById(R.id.progress_bar); mProgressBar.setIndeterminate(true); // Hide button till progress is being displayed mOkPanel = findViewById(R.id.buttons_panel); mDoneButton = (Button)findViewById(R.id.done_button); mLaunchButton = (Button)findViewById(R.id.launch_button); mOkPanel.setVisibility(View.INVISIBLE); //【3】如果 scheme 指定的是 package，这种情况是安装一个已经存在的 pkg，会进入 if 分支！ // 如果是 file 类型，进入 else！ if (\"package\".equals(mPackageURI.getScheme())) &#123; try &#123; //【×5.2.2】调用 pms 的 installExistingPackage 方法执行安装！ pm.installExistingPackage(mAppInfo.packageName); //【×5.2.3】通知安装结果！ onPackageInstalled(PackageInstaller.STATUS_SUCCESS); &#125; catch (PackageManager.NameNotFoundException e) &#123; onPackageInstalled(PackageInstaller.STATUS_FAILURE_INVALID); &#125; &#125; else &#123; //【4】这里会创建一个 SessionParams 封装事务参数，这里在 pm install 中有讲过！ final PackageInstaller.SessionParams params = new PackageInstaller.SessionParams( PackageInstaller.SessionParams.MODE_FULL_INSTALL); params.referrerUri = getIntent().getParcelableExtra(Intent.EXTRA_REFERRER); params.originatingUri = getIntent().getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); params.originatingUid = getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID, UID_UNKNOWN); //【5】创建一个 File 对象，指向 apk 的路径！ File file = new File(mPackageURI.getPath()); try &#123; //【6】解析 package，获得 PackageLite 对象，parsePackageLite 我们在开机启动中有讲过，这里就不多说了！ PackageLite pkg = PackageParser.parsePackageLite(file, 0); //【7】设置包名，安装路径，大小到 SessionParams 中！ params.setAppPackageName(pkg.packageName); params.setInstallLocation(pkg.installLocation); params.setSize( PackageHelper.calculateInstalledSize(pkg, false, params.abiOverride)); &#125; catch (PackageParser.PackageParserException e) &#123; Log.e(TAG, \"Cannot parse package \" + file + \". Assuming defaults.\"); Log.e(TAG, \"Cannot calculate installed size \" + file + \". Try only apk size.\"); params.setSize(file.length()); &#125; catch (IOException e) &#123; Log.e(TAG, \"Cannot calculate installed size \" + file + \". Try only apk size.\"); params.setSize(file.length()); &#125; //【8】在子线程中，执行安装！ mInstallHandler.post(new Runnable() &#123; @Override public void run() &#123; //【×5.3】触发安装！ doPackageStage(pm, params); &#125; &#125;); &#125;&#125; 5.2.1 getInstallFlags1234567891011121314int getInstallFlags(String packageName) &#123; PackageManager pm = getPackageManager(); try &#123; //【1】尝试获得包名为本次要安装的应用的安装信息! PackageInfo pi = pm.getPackageInfo(packageName, PackageManager.GET_UNINSTALLED_PACKAGES); if (pi != null) &#123; //【2】如果已经安装了，那么会返回 INSTALL_REPLACE_EXISTING！ return PackageManager.INSTALL_REPLACE_EXISTING; &#125; &#125; catch (NameNotFoundException e) &#123; &#125; return 0;&#125; 5.2.2 PackageManagerService.installExistingPackage安装一个系统中已存在的包，这是一个 hide 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic int installExistingPackageAsUser(String packageName, int userId) &#123; mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null); PackageSetting pkgSetting; final int uid = Binder.getCallingUid(); //【1】校验权限！ enforceCrossUserPermission(uid, userId, true /* requireFullPermission */, true /* checkShell */, \"installExistingPackage for user \" + userId); //【2】如果设置了不能安装应用的用户限制； if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) &#123; return PackageManager.INSTALL_FAILED_USER_RESTRICTED; &#125; long callingId = Binder.clearCallingIdentity(); try &#123; boolean installed = false; synchronized (mPackages) &#123; //【3】判断该应用是否存在，不存在的话，返回 INSTALL_FAILED_INVALID_URI！ pkgSetting = mSettings.mPackages.get(packageName); if (pkgSetting == null) &#123; return PackageManager.INSTALL_FAILED_INVALID_URI; &#125; //【4】更新 pkg 的 install 状态为 true，hide 状态为 false，并更新偏好设置！ if (!pkgSetting.getInstalled(userId)) &#123; pkgSetting.setInstalled(true, userId); pkgSetting.setHidden(false, userId); mSettings.writePackageRestrictionsLPr(userId); installed = true; &#125; &#125; if (installed) &#123; if (pkgSetting.pkg != null) &#123; synchronized (mInstallLock) &#123; //【4】准备数据目录！ prepareAppDataAfterInstallLIF(pkgSetting.pkg); &#125; &#125; //【5】发送 Intent.ACTION_PACKAGE_ADDED 给所有的设备用户！！ sendPackageAddedForUser(packageName, pkgSetting, userId); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; return PackageManager.INSTALL_SUCCEEDED;&#125; 不多说了！ 5.2.3 onPackageInstalled发送 INSTALL_COMPLETE 消息给主线程的 Handler： 123456void onPackageInstalled(int statusCode) &#123; //【*5.2.3.1】进入主线程的 handler！ Message msg = mHandler.obtainMessage(INSTALL_COMPLETE); msg.arg1 = statusCode; mHandler.sendMessage(msg);&#125; 5.2.3.1 Handler.handleMessage[INSTALL_COMPLETE]主要根据安装的结果！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case INSTALL_COMPLETE: //【1】判断下本次安装是否需要返回结果给启动安装的程序，如果需要，那就返回结果！ // 返回！ if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) &#123; Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, msg.arg1); setResult(msg.arg1 == PackageInstaller.STATUS_SUCCESS ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER, result); clearCachedApkIfNeededAndFinish(); return; &#125; //【2】更新界面显示！ mProgressBar.setVisibility(View.GONE); // Show the ok button int centerTextLabel; int centerExplanationLabel = -1; //【3】处理返回结果码！ if (msg.arg1 == PackageInstaller.STATUS_SUCCESS) &#123; //【3.1】安装成功的情况！ mLaunchButton.setVisibility(View.VISIBLE); ((ImageView)findViewById(R.id.center_icon)) .setImageDrawable(getDrawable(R.drawable.ic_done_92)); centerTextLabel = R.string.install_done; // Enable or disable launch button mLaunchIntent = getPackageManager().getLaunchIntentForPackage( mAppInfo.packageName); boolean enabled = false; if(mLaunchIntent != null) &#123; List&lt;ResolveInfo&gt; list = getPackageManager(). queryIntentActivities(mLaunchIntent, 0); if (list != null &amp;&amp; list.size() &gt; 0) &#123; enabled = true; &#125; &#125; if (enabled) &#123; mLaunchButton.setOnClickListener(InstallAppProgress.this); &#125; else &#123; mLaunchButton.setEnabled(false); &#125; &#125; else if (msg.arg1 == PackageInstaller.STATUS_FAILURE_STORAGE)&#123; //【3.2】空间不足安装失败！ showDialogInner(DLG_OUT_OF_SPACE); return; &#125; else &#123; //【3.2】空间不足安装失败！ ((ImageView)findViewById(R.id.center_icon)) .setImageDrawable(getDrawable(R.drawable.ic_report_problem_92)); centerExplanationLabel = getExplanationFromErrorCode(msg.arg1); centerTextLabel = R.string.install_failed; mLaunchButton.setVisibility(View.GONE); &#125; if (centerExplanationLabel != -1) &#123; mExplanationTextView.setText(centerExplanationLabel); findViewById(R.id.center_view).setVisibility(View.GONE); ((TextView)findViewById(R.id.explanation_status)).setText(centerTextLabel); findViewById(R.id.explanation_view).setVisibility(View.VISIBLE); &#125; else &#123; ((TextView)findViewById(R.id.center_text)).setText(centerTextLabel); findViewById(R.id.center_view).setVisibility(View.VISIBLE); findViewById(R.id.explanation_view).setVisibility(View.GONE); &#125; mDoneButton.setOnClickListener(InstallAppProgress.this); mOkPanel.setVisibility(View.VISIBLE); break; default: break; &#125; &#125;&#125;; 不多说了！ 5.3 doPackageStage到这里，已经和 pm install 中很类似了：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void doPackageStage(PackageManager pm, PackageInstaller.SessionParams params) &#123; final PackageInstaller packageInstaller = pm.getPackageInstaller(); PackageInstaller.Session session = null; try &#123; final String packageLocation = mPackageURI.getPath(); final File file = new File(packageLocation); //【1】这里奉陪了一个 sessionid 给本次安装，这个方法我们在 pm install 中分析过！ final int sessionId = packageInstaller.createSession(params); final byte[] buffer = new byte[65536]; //【2】这里根据上面分配的 sessionid，创建了一个 Session，这个方法我们在 pm install 中分析过！ session = packageInstaller.openSession(sessionId); final InputStream in = new FileInputStream(file); final long sizeBytes = file.length(); final OutputStream out = session.openWrite(\"PackageInstaller\", 0, sizeBytes); try &#123; int c; while ((c = in.read(buffer)) != -1) &#123; out.write(buffer, 0, c); if (sizeBytes &gt; 0) &#123; final float fraction = ((float) c / (float) sizeBytes); session.addProgress(fraction); &#125; &#125; session.fsync(out); &#125; finally &#123; IoUtils.closeQuietly(in); IoUtils.closeQuietly(out); &#125; //【2】创建了一个 PendingIntent 封装了上面的 action： com.android.packageinstaller.ACTION_INSTALL_COMMIT Intent broadcastIntent = new Intent(BROADCAST_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast( InstallAppProgress.this /*context*/, sessionId, broadcastIntent, PendingIntent.FLAG_UPDATE_CURRENT); //【4】提交事务，触发安装，这个方法我们在 pm install 中分析过！ // 这里将 PendingIntent 的 IntentSender 传递给了系统进程，后续系统进程会通过 binder 通信触发 intent！ session.commit(pendingIntent.getIntentSender()); &#125; catch (IOException e) &#123; //【*5.2.3】异常情况，回调并结束！！ onPackageInstalled(PackageInstaller.STATUS_FAILURE); &#125; finally &#123; IoUtils.closeQuietly(session); &#125;&#125; 按照结束后，pendingIntent 会被触发，然后发送 com.android.packageinstaller.ACTION_INSTALL_COMMIT 广播！ 6 onCreateDialog -&gt; notify user下面我们来看下 onCreateDialog 的函数逻辑，这个会在安装过程中提示用户： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Overridepublic Dialog onCreateDialog(int id, Bundle bundle) &#123; switch (id) &#123; //【1】提示本次安装了来自位置来源！ case DLG_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setMessage(R.string.unknown_apps_dlg_text) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; Log.i(TAG, \"Finishing off activity so that user can navigate to settings manually\"); finishAffinity(); &#125;&#125;) .setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; Log.i(TAG, \"Launching settings\"); //【6.1】设置未知来源开关！ launchSecuritySettings(); &#125; &#125;) .setOnCancelListener(this) .create(); //【2】当前用户是在另外用户的 profile 中，同时用户关闭了未知来源设置 // 此时不能继续安装！ case DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setMessage(R.string.unknown_apps_admin_dlg_text) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setOnCancelListener(this) .create(); //【3】当前用户是在另外用户的 profile 中，同时用户关闭了未知来源设置 // 此时不能继续安装！！ case DLG_PACKAGE_ERROR : return new AlertDialog.Builder(this) .setMessage(R.string.Parse_error_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setOnCancelListener(this) .create(); //【4】安装空间不足，此时不能继续安装！！ case DLG_OUT_OF_SPACE: CharSequence appTitle = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText = getString(R.string.out_of_space_dlg_text, appTitle.toString()); return new AlertDialog.Builder(this) .setMessage(dlgText) .setPositiveButton(R.string.manage_applications, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; //【4.1】进入空间管理界面，用户可以选择释放空间！ Intent intent = new Intent(\"android.intent.action.MANAGE_PACKAGE_STORAGE\"); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); &#125; &#125;) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; Log.i(TAG, \"Canceling installation\"); finish(); &#125; &#125;) .setOnCancelListener(this) .create(); //【5】安装失败！！ case DLG_INSTALL_ERROR : CharSequence appTitle1 = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText1 = getString(R.string.install_failed_msg, appTitle1.toString()); return new AlertDialog.Builder(this) .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setMessage(dlgText1) .setOnCancelListener(this) .create(); //【6】这个是 WEAR 可穿戴设备上的逻辑，这里不关注！ case DLG_NOT_SUPPORTED_ON_WEAR: return new AlertDialog.Builder(this) .setMessage(R.string.wear_not_allowed_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; setResult(RESULT_OK); clearCachedApkIfNeededAndFinish(); &#125; &#125;) .setOnCancelListener(this) .create(); &#125; return null;&#125; 不多说了！ 6.1 launchSecuritySettings进入设置，让用户选择是否打开未知来源设置：1234private void launchSecuritySettings() &#123; Intent launchSettingsIntent = new Intent(Settings.ACTION_SECURITY_SETTINGS); startActivityForResult(launchSettingsIntent, REQUEST_ENABLE_UNKNOWN_SOURCES);&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"Choreographer 第一篇 Choreographer  原理分析","slug":"Choreographer-1-choreographerAnalysize","date":"2018-07-15T12:46:25.000Z","updated":"2019-10-19T13:13:52.344Z","comments":true,"path":"2018/07/15/Choreographer-1-choreographerAnalysize/","link":"","permalink":"https://coolqi.top/2018/07/15/Choreographer-1-choreographerAnalysize/","excerpt":"","text":"本篇文章基于 Android N（7.1.1）主要分析下 Choreographer 的原理，以对 Android 系统有更好的理解。 1 回顾1.1 scheduleTraversals - 核心触发视图遍历： 1234567891011121314151617void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; //【1】表示是否已经发起重绘，这是要设置为 true； mTraversalScheduled = true; //【1】在主线程的消息队列中放一个障栅； mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //【--&gt;10.5】设置一个回调到编舞者 Choreographer 中，在下一次的绘制触发时，执行 mTraversalRunnable // mTraversalRunnable 是一个 runnbale 实例； mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 前面分析 View 的绘制的时候，有讲到，Choreographer 会请求 Vsync 信号，然后在 Vsync 信号触发后，执行布局和绘制任务！ 这一篇，我们来分析下 Choreographer！ 2 什么是 Choreographer（这一部分来自 SDK 的翻译，其实 SDK 的注释已经将 Choreographer 的作用讲的很清楚了） 编舞者，作用是协调动画，输入和绘图的时间； 编舞者会从显示子系统接收定时脉冲（也就是垂直同步 Vsync 信号），然后触发指定的工作，结果会作为渲染下一个显示帧的一部分； 应用一般使用动画框架或视图层次结构中的更高级别的抽象间接地和编舞者交互。 下面是一些可以使用的高级 API，用于和 Choreographer 间接通信： ValueAnimator.start：用于使用与显示框架渲染同步的要在常规时间进行处理的动画 View.postOnAnimation：传入一个 Runnable，在下一个显示帧的开头被调用一次； View.postOnAnimationDelayed：传入一个 Runnable，在下一个显示帧的开头延迟指定时间被调用一次； View.postInvalidateOnAnimation：在下一个显示帧开始时触发 View.invalidate 一次； 为确保 View 的内容平滑滚动并与显示框架渲染同步绘制，请不要执行任何操作。系统会自动处理，View.onDraw 将在适当的时候被调用。 但是，在某些情况下，您可能希望直接在应用程序中使用编舞者的功能。譬如说： Choreographer.postFrameCallback：如果应用使用 GL，或完全不使用动画框架或视图层次结构在其他线程中进行渲染，并且你想确保它与显示适当同步。 每个 Looper 线程 都有自己的编舞者。其他线程可以发布回调以在编舞者上运行，但是它们将持有编舞者所属的 Looper。 3 Choreographer我们来开始分析 Choreographer 的代码： 3.1 getInstance()编舞者是线程单例模式，每一个线程都会有一个：ThreadLocal 12345678910111213141516171819202122232425public final class Choreographer &#123; //【1】通过 ThreadLocal 实现线程单例模式； private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; //【2】获取当前线程的 looper 对象； Looper looper = Looper.myLooper(); if (looper == null) &#123; throw new IllegalStateException(\"The current thread must have a looper!\"); &#125; //【--&gt;3.2】创建 Choreographer 对象； Choreographer choreographer = new Choreographer(looper, VSYNC_SOURCE_APP); if (looper == Looper.getMainLooper()) &#123; //【3】如果 looper 是 ui thread 的，会保存到内部的 mMainInstance； mMainInstance = choreographer; &#125; return choreographer; &#125; &#125;; public static Choreographer getInstance() &#123; return sThreadInstance.get(); &#125;&#125; 3.2 new Choreographer创建 Choreographer: 123456789101112131415161718192021private Choreographer(Looper looper, int vsyncSource) &#123; //【1】线程的 looper 实例； mLooper = looper; //【--&gt;6.1】创建 FrameHandler 对象，用于处理消息； mHandler = new FrameHandler(looper); //【2】创建 VSYNC 的信号接受对象； mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource) : null; //【3】初始化上一个 frame 渲染的时间点 mLastFrameTimeNanos = Long.MIN_VALUE; //【4】计算帧率，也就是一帧所需的渲染时间，getRefreshRate 是刷新率，一般是 60； mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); //【5】创建消息处理队列 mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; for (int i = 0; i &lt;= CALLBACK_LAST; i++) &#123; mCallbackQueues[i] = new CallbackQueue(); &#125; // b/68769804: For low FPS experiments. setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, 1));&#125; USE_VSYNC 的值来自下面： 123//【1】判断系统是否打开了 vsync，读取 \"debug.choreographer.vsync\" 属性；private static final boolean USE_VSYNC = SystemProperties.getBoolean( \"debug.choreographer.vsync\", true); 如果开启了 Vsync，就会创建一个 FrameDisplayEventReceiver 实例，用于请求并接收 Vsync 事件： Choreographer 创建了一个大小为 3 的 CallbackQueue 数组，用于保存不同类型的 Callback； 12public static final int CALLBACK_COMMIT = 3;private static final int CALLBACK_LAST = CALLBACK_COMMIT; 3.3 postCallback[Delayed][DelayedInternal]callbackType 表示回调的类型！ 1234public void postCallback(int callbackType, Runnable action, Object token) &#123; //【1】继续调用； postCallbackDelayed(callbackType, action, token, 0);&#125; 进入 postCallbackDelayed 方法： 123456public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; ... ... ...// 省略对 action 和 callbackType 的判断； postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125; 进入 postCallbackDelayedInternal 方法： 123456789101112131415161718192021222324252627private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"PostCallback: type=\" + callbackType + \", action=\" + action + \", token=\" + token + \", delayMillis=\" + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; // delayMillis 是我们设置的延迟，这里为 0； //【1】可以看到其将 action 根据 callbackType 放入了 mCallbackQueues 数组中； mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; //【--&gt;3.4】延迟时间到了，请求一个 Vsync 信号； scheduleFrameLocked(now); &#125; else &#123; //【--&gt;6.X】时间没到，那就创建一个 MSG_DO_SCHEDULE_CALLBACK 的异步消息， // 用于异步执行 action 任务，延迟 dueTime 发送给 FrameHandler 处理； Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); // 注意：这是异步的！ mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 3.3.1 CallbackQueuesCallbackQueues 是一个用于链表实现的队列，用于保存每种类型的回调链表： 12345private final class CallbackQueue &#123; //【--&gt;3.3.2】回调链表的 head； private CallbackRecord mHead; ... ... ...// 省略掉操作链表的方法；&#125; CallbackQueue 数组由三种类型不同 CallbackQueue，每个都有一个 CallbackRecord 链表，链表按照任务触发时间由小到大排列。 123public static final int CALLBACK_INPUT = 0;public static final int CALLBACK_ANIMATION = 1;public static final int CALLBACK_TRAVERSAL = 2; 内部的 CallbackRecord 以链表组织，以执行时间 3.3.1.1 extractDueCallbacksLocked返回要执行的 CallbackRecord 子链表： 123456789101112131415161718192021public CallbackRecord extractDueCallbacksLocked(long now) &#123; CallbackRecord callbacks = mHead; if (callbacks == null || callbacks.dueTime &gt; now) &#123; return null; &#125; //【1】last/next 指针；用于断开链表； CallbackRecord last = callbacks; CallbackRecord next = last.next; while (next != null) &#123; //【2】找到执行时间晚于 now 的了，断开； if (next.dueTime &gt; now) &#123; last.next = null; break; &#125; last = next; next = next.next; &#125; mHead = next; //【3】返回执行时间早于 now 的子链表； return callbacks;&#125; 3.3.1.2 addCallbackLocked添加一个 CallbackRecord 到链表： 12345678910111213141516171819202122232425public void addCallbackLocked(long dueTime, Object action, Object token) &#123; //【1】返回一个可复用的 CallbackRecord 实例； // obtainCallbackLocked 方法会返回这个复用的实例，代码简单就不多数了； CallbackRecord callback = obtainCallbackLocked(dueTime, action, token); CallbackRecord entry = mHead; if (entry == null) &#123; mHead = callback; return; &#125; //【2】判断下 head； if (dueTime &lt; entry.dueTime) &#123; callback.next = entry; mHead = callback; return; &#125; //【3】遍历链表，找到合适的地方插入； while (entry.next != null) &#123; if (dueTime &lt; entry.next.dueTime) &#123; callback.next = entry.next; break; &#125; entry = entry.next; &#125; entry.next = callback;&#125; 编舞者内部有一个 mCallbackPool 实例，表示一个可复用的 CallbackRecord 对象； 1private CallbackRecord mCallbackPool; obtainCallbackLocked 方法会返回这个复用的实例： 如果 mCallbackPool 不为 null，就设置值，返回； 如果 mCallbackPool 为 null，初始化新的，再设置值，返回； 3.3.2.3 hasDueCallbacksLocked判断是否有已经触发的回调： 1234public boolean hasDueCallbacksLocked(long now) &#123; //【1】就是比较下时间； return mHead != null &amp;&amp; mHead.dueTime &lt;= now;&#125; 3.3.2 CallbackRecord每一个回调： 1234567891011121314private static final class CallbackRecord &#123; public CallbackRecord next; // 指向下一个对象； public long dueTime; public Object action; // Runnable or FrameCallback public Object token; public void run(long frameTimeNanos) &#123; if (token == FRAME_CALLBACK_TOKEN) &#123; ((FrameCallback)action).doFrame(frameTimeNanos); &#125; else &#123; ((Runnable)action).run(); &#125; &#125;&#125; 根据 token 不同，执行不同的处理： FrameCallback 的 token 是 FRAME_CALLBACK_TOKEN Runnable 的 token 为 null； 3.4 scheduleFrameLocked请求一个 Vsync 信号： 1234567891011121314151617181920212223242526272829303132333435363738private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; //【1】设置 mFrameScheduled 为 true； mFrameScheduled = true; if (USE_VSYNC) &#123; //【1】如果开启了 Vsync（默认开启） if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame on vsync.\"); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. // 这里会判断下 ？Looper.myLooper() == mLooper，如果一样; if (isRunningOnLooperThreadLocked()) &#123; //【--&gt;3.4.1】立刻请求 Vsync 信号； scheduleVsyncLocked(); &#125; else &#123; //【--&gt;6.1】发送一个 异步 msg[MSG_DO_SCHEDULE_VSYNC] 给 Framehandler; // 这个异步消息会在 message queue 的队头； Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; //【2】没有开启了 Vsync，那么这里会手动计算一个 delay 时间； final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\"); &#125; //【--&gt;6.X】发送一个 异步 msg[MSG_DO_FRAME] 给 Framehander； Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 3.4.1 scheduleVsyncLocked1234private void scheduleVsyncLocked() &#123; //【--&gt;4.2】通过 FrameDisplayEventReceiver 请求 vSync 信号； mDisplayEventReceiver.scheduleVsync();&#125; 4 FrameDisplayEventReceiverFrameDisplayEventReceiver 用于请求和接受 vsync 信号： 4.1 new FrameDisplayEventReceiverFrameDisplayEventReceiver 继承了 DisplayEventReceiver，同时注意，也是实现了 Runnable： 1234567891011private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; private boolean mHavePendingVsync; private long mTimestampNanos; private int mFrame; public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123; super(looper, vsyncSource); &#125; ... ... ...&#125; 我们来看看其父类 DisplayEventReceiver： 123456789101112public DisplayEventReceiver(Looper looper, int vsyncSource) &#123; if (looper == null) &#123; throw new IllegalArgumentException(\"looper must not be null\"); &#125; //【1】获取到当前 looper 的 MessageQueue； mMessageQueue = looper.getQueue(); //【--&gt;4.1.1】创建 NativeDisplayEventReceiver； mReceiverPtr = nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue, vsyncSource); mCloseGuard.open(\"dispose\");&#125; NativeDisplayEventReceiver 中会获取 Java MessageQueue 对应的 NativeMessageQueue，这个和前面的 input 很类似了； 4.1.1 nativeInit用于初始化 NativeDisplayEventReceiver 12345678910111213141516171819202122232425static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverObj, jobject messageQueueObj) &#123; //【1】获取 NativeMessageQueue 实例； sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, \"MessageQueue is not initialized.\"); return 0; &#125; //【--&gt;5.1】创建 NativeDisplayEventReceiver 实例； sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverObj, messageQueue); //【--&gt;5.2】初始化 receiver； status_t status = receiver-&gt;initialize(); if (status) &#123; String8 message; message.appendFormat(\"Failed to initialize display event receiver. status=%d\", status); jniThrowRuntimeException(env, message.string()); return 0; &#125; //【2】增加强引用计数； receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 4.2 scheduleVsync请求一个 Vsync 信号，父类方法： 123456789public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; //【--&gt;4.2.1】进入 native 层； nativeScheduleVsync(mReceiverPtr); &#125;&#125; 4.2.1 nativeScheduleVsync1234567891011static void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123; sp&lt;NativeDisplayEventReceiver&gt; receiver = reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr); //【--&gt;5.3】进入 native 的 DisplayEventReceiver 请求 Vsync 信号； status_t status = receiver-&gt;scheduleVsync(); if (status) &#123; String8 message; message.appendFormat(\"Failed to schedule next vertical sync pulse. status=%d\", status); jniThrowRuntimeException(env, message.string()); &#125;&#125; 4.3 dispatchVsync这个方法是在父类里面： 123456// Called from native code.@SuppressWarnings(\"unused\")private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; //【--&gt;4.4】处理 Vsync 信号 onVsync(timestampNanos, builtInDisplayId, frame);&#125; 4.4 onVsync处理 Vsync 信号； 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; //【1】忽略来自第二显示屏的 Vsync 信号； if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, \"Received vsync from secondary display, but we don't support \" + \"this case yet. Choreographer needs a way to explicitly request \" + \"vsync for a specific display to ensure it doesn't lose track \" + \"of its scheduled vsync.\"); //【--&gt;5.3】请求下一个 Vsync； scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. //【1】调整 Vsync 时间； long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, \"Frame time is \" + ((timestampNanos - now) * 0.000001f) + \" ms in the future! Check that graphics HAL is generating vsync \" + \"timestamps using the correct timebase.\"); timestampNanos = now; &#125; //【2】设置 mHavePendingVsync 为 ture，表示正在有一个处理中的 Vsync 信号； if (mHavePendingVsync) &#123; Log.w(TAG, \"Already have a pending vsync event. There should only be \" + \"one at a time.\"); &#125; else &#123; mHavePendingVsync = true; &#125; //【--&gt;6.X】发送一个消息给 FrameHandler，该消息的 callback 为当前对象 FrameDisplayEventReceiver； mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); // 注意：这是异步消息； mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125; 还记得为什么是异步消息吗？ 这是因为，Vsync 信号是优先级很高的信号，所以，要优先处理他，这里将其设置成异步的。 好处是可以通过设置障栅，阻塞同步，优先处理异步消息，这个在 view draw 中有使用到； 重点： 当 Vsync 请求到后，这里会把 FrameDisplayEventReceiver 最为 callback，通过 msg 发送给 Handler； 4.5 run执行任务： 123456@Overridepublic void run() &#123; mHavePendingVsync = false; //【--&gt;7.2】处理这一帧！ doFrame(mTimestampNanos, mFrame);&#125; 5 NativeDisplayEventReceiver（以及父类）我们去看看 native 的逻辑： 5.1 new NativeDisplayEventReceiverNativeDisplayEventReceiver 继承 DisplayEventDispatcher： 123456789101112131415161718class NativeDisplayEventReceiver : public DisplayEventDispatcher &#123;public: NativeDisplayEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue);private: jobject mReceiverWeakGlobal; // 全局引用，指向 java 层的 FrameDisplayEventReceiver 实例； sp&lt;MessageQueue&gt; mMessageQueue; // NativeMessageQueue 实例； DisplayEventReceiver mReceiver; // frameworks/nivate/libs/gui/DisplayEventReceiver.cpp bool mWaitingForVsync; // 表示是否正在等待 Vsync，初始化为 false； NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue) : DisplayEventDispatcher(messageQueue-&gt;getLooper()), // 调用父类的构造器； mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)), mMessageQueue(messageQueue), mWaitingForVsync(false) &#123; ALOGV(\"receiver %p ~ Initializing display event receiver.\", this);&#125; 去看看父类的构造器： DisplayEventDispatcher 123456789101112131415class DisplayEventDispatcher : public LooperCallback &#123;public: DisplayEventDispatcher(const sp&lt;Looper&gt;&amp; looper);... ... ...private: sp&lt;Looper&gt; mLooper; // NativeMessageQueue 对应的 Looper 实例； DisplayEventReceiver mReceiver; bool mWaitingForVsync; DisplayEventDispatcher::DisplayEventDispatcher(const sp&lt;Looper&gt;&amp; looper) : mLooper(looper), mWaitingForVsync(false) &#123; ALOGV(\"dispatcher %p ~ Initializing display event dispatcher.\", this);&#125; 5.2 initialize初始化： 123456789101112131415status_t DisplayEventDispatcher::initialize() &#123; status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW(\"Failed to initialize display event receiver, status=%d\", result); return result; &#125; //【1】使用 NativeMessageQueue 的 Looper 对象监听 mReceiver.getFd 返回的文件句柄。 // 同时将自己作为回调！ int rc = mLooper-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL); if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; 5.3 scheduleVsync1234567891011121314151617181920212223status_t DisplayEventDispatcher::scheduleVsync() &#123; if (!mWaitingForVsync) &#123; ALOGV(\"dispatcher %p ~ Scheduling vsync.\", this); // Drain all pending events. nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123; ALOGE(\"dispatcher %p ~ last event processed while scheduling was for %\" PRId64 \"\", this, ns2ms(static_cast&lt;nsecs_t&gt;(vsyncTimestamp))); &#125; //【1】请求下一次 Vsync 信息! status_t status = mReceiver.requestNextVsync(); if (status) &#123; ALOGW(\"Failed to request next vsync, status=%d\", status); return status; &#125; mWaitingForVsync = true; &#125; return OK;&#125; 5.4 handleEvent前面我们看到，native Looper 监听指定的 fd，当 fd 由事件写入后，handleEvent 就会触发： 123456789101112131415161718192021222324252627int DisplayEventDispatcher::handleEvent(int, int events, void*) &#123; if (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123; ALOGE(\"Display event receiver pipe was closed or an error occurred. \" \"events=0x%x\", events); return 0; // remove the callback &#125; if (!(events &amp; Looper::EVENT_INPUT)) &#123; ALOGW(\"Received spurious callback for unhandled poll event. \" \"events=0x%x\", events); return 1; // keep the callback &#125; nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; //【--&gt;5.4.1】获取最后一次的 Vsync。 if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123; ALOGV(\"dispatcher %p ~ Vsync pulse: timestamp=%\" PRId64 \", id=%d, count=%d\", this, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount); mWaitingForVsync = false; //【--&gt;5.5】分发最后一次的 Vsync。 dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount); &#125; return 1; // keep the callback&#125; 5.4.1 processPendingEvents前面我们看到，Native Looper 监听指定的 fd，当 fd 由事件写入后，handleEvent 就会触发： 12345678910111213141516171819202122232425262728293031323334bool DisplayEventDispatcher::processPendingEvents( nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; //【1】通过 mReceiver.getEvents 获取 event，保存到 buf 中； while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123; ALOGV(\"dispatcher %p ~ Read %d events.\", this, int(n)); for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; //【2】判断 event 的 type； switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: 、 //【3】最新的 Vsync 将会覆盖之前的消息，也就是说我们获取的是最近的那个； // 并设置 gotVsync 为 true！ gotVsync = true; *outTimestamp = ev.header.timestamp; *outId = ev.header.id; *outCount = ev.vsync.count; break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected); break; default: ALOGW(\"dispatcher %p ~ ignoring unknown event type %#x\", this, ev.header.type); break; &#125; &#125; &#125; if (n &lt; 0) &#123; ALOGW(\"Failed to get events from display event dispatcher, status=%d\", status_t(n)); &#125; return gotVsync; // 返回 gotVsync；&#125; 5.5 dispatchVsync分发 Vsync 信号： 1234567891011121314void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); //【1】这个就是 java 层的 FrameDisplayEventReceiver 实例； ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal)); if (receiverObj.get()) &#123; ALOGV(\"receiver %p ~ Invoking vsync handler.\", this); //【--&gt;4.3】调用 FrameDisplayEventReceiver 的 dispatchVsync 方法； env-&gt;CallVoidMethod(receiverObj.get(), gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count); ALOGV(\"receiver %p ~ Returned from vsync handler.\", this); &#125; mMessageQueue-&gt;raiseAndClearException(env, \"dispatchVsync\");&#125; 6 FrameHandlerFrameHandler 主要用于处理内部消息，触发响应机制。 6.1 new FrameHandler12345678910111213141516171819202122232425private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_FRAME: //【1】这个消息是没有开启 VSYNC 的时候，java 层通过延迟模拟 Vsync 信号； // 延迟发送 doFrame 消息； //【--&gt;7.2】处理这一帧； doFrame(System.nanoTime(), 0); break; case MSG_DO_SCHEDULE_VSYNC: //【2】这个消息用于请求 Vsync 信号； //【--&gt;7.1】请求 Vsync 信号； doScheduleVsync(); break; case MSG_DO_SCHEDULE_CALLBACK: doScheduleCallback(msg.arg1); break; &#125; &#125;&#125; 7 Choreographer - back这里我们再次回到了 Choreographer： 7.1 doScheduleVsyncdoScheduleVsync 方法只是再次调用 scheduleVsyncLocked 方法； 12345678void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; //【--&gt;3.4.1】涛声依旧&lt;sub&gt;&lt;/sub&gt; scheduleVsyncLocked(); &#125; &#125;&#125; 不多说了！ 7.2 doFrame处理当前帧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; return; //【1】如果 mFrameScheduled 为 false，则不需要处理当前帧； &#125; if (DEBUG_JANK &amp;&amp; mDebugPrintNextFrameTimeDelta) &#123; mDebugPrintNextFrameTimeDelta = false; Log.d(TAG, \"Frame time delta: \" + ((frameTimeNanos - mLastFrameTimeNanos) * 0.000001f) + \" ms\"); &#125; long intendedFrameTimeNanos = frameTimeNanos; // 预期帧时间 startNanos = System.nanoTime(); //【2】计算时间差值：当前时间 - 帧触发的时间； final long jitterNanos = startNanos - frameTimeNanos; //【3】判断时间差值是否超过 mFrameIntervalNanos，说明此时已经不满足 16ms 一帧了； if (jitterNanos &gt;= mFrameIntervalNanos) &#123; //【3.1】计算下跳过了多少帧。 final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; Log.i(TAG, \"Skipped \" + skippedFrames + \" frames! \" + \"The application may be doing too much work on its main thread.\"); &#125; //【3.2】余下的偏移量； final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; if (DEBUG_JANK) &#123; Log.d(TAG, \"Missed vsync by \" + (jitterNanos * 0.000001f) + \" ms \" + \"which is more than the frame interval of \" + (mFrameIntervalNanos * 0.000001f) + \" ms! \" + \"Skipping \" + skippedFrames + \" frames and setting frame \" + \"time to \" + (lastFrameOffset * 0.000001f) + \" ms in the past.\"); &#125; //【3.3】当前时间 - 余下的偏移量，作为本帧的实际时间； frameTimeNanos = startNanos - lastFrameOffset; &#125; //【4】如果帧触发时间比上一帧的时间早，那就要重新请求 Vsync 信号； if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123; if (DEBUG_JANK) &#123; Log.d(TAG, \"Frame time appears to be going backwards. May be due to a \" + \"previously skipped frame. Waiting for next vsync.\"); &#125; //【--&gt;3.4.1】重新请求 Vsync 信号； scheduleVsyncLocked(); return; &#125; if (mFPSDivisor &gt; 1) &#123; // 针对于低 FPs 的情况，这里没看懂； long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos; if (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; 0) &#123; scheduleVsyncLocked(); return; &#125; &#125; //【--&gt;8.2】保存帧信息（预期帧时间, 实际帧时间） mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); //【4】设置 mFrameScheduled 为 false； mFrameScheduled = false; //【5】保存当前帧时间到 mLastFrameTimeNanos； mLastFrameTimeNanos = frameTimeNanos; &#125; //【6】核心来了，这里会执行 CallbackQueue 中的 CallbackRecord！ try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\"); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); //【--&gt;8.3】标记 input 处理，动画开始，PerformTraversals 开始的时间 mFrameInfo.markInputHandlingStart(); //【--&gt;7.3】执行 CALLBACK_INPUT 类型的 CallbackQueue 中的 CallbackRecord！ doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); // same; //【--&gt;7.3】执行 CALLBACK_ANIMATION 类型的 CallbackQueue 中的 CallbackRecord！ doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); // same; //【--&gt;7.3】执行 CALLBACK_TRAVERSAL 类型的 CallbackQueue 中的 CallbackRecord！ doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; if (DEBUG_FRAMES) &#123; final long endNanos = System.nanoTime(); Log.d(TAG, \"Frame \" + frame + \": Finished, took \" + (endNanos - startNanos) * 0.000001f + \" ms, latency \" + (startNanos - frameTimeNanos) * 0.000001f + \" ms.\"); &#125;&#125; FrameInfo 表示帧信息，是编舞者的内部成员： 1FrameInfo mFrameInfo = new FrameInfo(); 这里看到有一个对帧时间调整的操作： 预期帧时间，就是 Vsync 触发的时间，但是对于实际帧时间，可能因为做一些耗时操作，导致延后，错过多个帧时间周期； jitterNanos = startNanos - frameTimeNanos，就是计算错过的总时间； skippedFrames = jitterNanos / mFrameIntervalNanos，计算出了实际错过了帧数； lastFrameOffset = jitterNanos % mFrameIntervalNanos，计算出余下的不满一帧的时间，然后要做调整； frameTimeNanos = startNanos - lastFrameOffset，当前时间减去不满一帧的时间，保证相同的时间周期； 接下来就是核心了，和前面看的一样， 执行 CallbackQueue 中的 CallbackRecord，次序： Choreographer.CALLBACK_INPUT； Choreographer.CALLBACK_ANIMATION； Choreographer.CALLBACK_TRAVERSAL； 7.3 doCallbacks执行 CallBack： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; // We use \"now\" to determine when callbacks become due because it's possible // for earlier processing phases in a frame to post callbacks that should run // in a following phase, such as an input event that causes an animation to start. final long now = System.nanoTime(); //【--&gt;3.3.1】返回指定类型 callbackType 对应的 CallbackRecord， // 通过 last/next 两个指针，找到 CallbackRecord 所有执行时间早于 now 的（也就是已经到执行时间的） // CallbackRecord, 以链表形式返回（头结点，断开链表） callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS); if (callbacks == null) &#123; return; &#125; //【1】讲 mCallbacksRunning 设置为 true； mCallbacksRunning = true; // Update the frame time if necessary when committing the frame. // We only update the frame time if we are more than 2 frames late reaching // the commit phase. This ensures that the frame time which is observed by the // callbacks will always increase from one frame to the next and never repeat. // We never want the next frame's starting frame time to end up being less than // or equal to the previous frame's commit frame time. Keep in mind that the // next frame has most likely already been scheduled by now so we play it // safe by ensuring the commit time is always at least one frame behind. //【2】针对于最后一种类型 CALLBACK_COMMIT；会重新调整一次 mLastFrameTimeNanos。 // CALLBACK_COMMIT 没有对应的 CallbackQueues； if (callbackType == Choreographer.CALLBACK_COMMIT) &#123; final long jitterNanos = now - frameTimeNanos; Trace.traceCounter(Trace.TRACE_TAG_VIEW, \"jitterNanos\", (int) jitterNanos); if (jitterNanos &gt;= 2 * mFrameIntervalNanos) &#123; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos + mFrameIntervalNanos; if (DEBUG_JANK) &#123; Log.d(TAG, \"Commit callback delayed by \" + (jitterNanos * 0.000001f) + \" ms which is more than twice the frame interval of \" + (mFrameIntervalNanos * 0.000001f) + \" ms! \" + \"Setting frame time to \" + (lastFrameOffset * 0.000001f) + \" ms in the past.\"); mDebugPrintNextFrameTimeDelta = true; &#125; frameTimeNanos = now - lastFrameOffset; //【2.1】更新 mLastFrameTimeNanos； mLastFrameTimeNanos； = frameTimeNanos; &#125; &#125; &#125; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]); //【--&gt;3.3.2】遍历要执行的 CallbackRecord 链表，执行 run 方法； for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"RunCallback: type=\" + callbackType + \", action=\" + c.action + \", token=\" + c.token + \", latencyMillis=\" + (SystemClock.uptimeMillis() - c.dueTime)); &#125; c.run(frameTimeNanos); // run &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; //【3】回收子链表中的节点，其实就是逐个断开链接，置空属性，在 recycleCallbackLocked 方法中； do &#123; final CallbackRecord next = callbacks.next; recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 不多数了。 现在我们回过头看回顾哪里，显然： 123456789final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; //【--&gt;5.7】开始遍历； doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 开始遍历和绘制的操作这里就开始了； 7.4 doScheduleCallback显然，这里依然从 CallbackQueues 判断 callbackType 是否有回调时间到了； 123456789101112void doScheduleCallback(int callbackType) &#123; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; final long now = SystemClock.uptimeMillis(); //【--&gt;3.3.2.3】判断时间是否到了； if (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123; //【--&gt;3.4】 涛声依旧了~ scheduleFrameLocked(now); &#125; &#125; &#125;&#125; 不多说了； 8 FrameInfo用于表示帧的信息： 8.1 new FrameInfo123final class FrameInfo &#123; long[] mFrameInfo = new long[9];&#125; 内部有一个数组：mFrameInfo，每一个元素的下标和存储的值得含义如下： 123456789private static final int INTENDED_VSYNC = 1; // 预期帧时间, 和 Vsync 相关，不受抖动调整；private static final int VSYNC = 2; // 实际帧时间，会被抖动调整，是动画和绘图系统的时间输入private static final int OLDEST_INPUT_EVENT = 3; // 最旧的输入事件的时间；private static final int NEWEST_INPUT_EVENT = 4; // 最新的输入事件的时间；private static final int HANDLE_INPUT_START = 5; // 输入事件开始处理时的时间；private static final int ANIMATION_START = 6; // 动画评估开始的时间；private static final int PERFORM_TRAVERSALS_START = 7; // ViewRootImpl#performTraversals() 开始的时间； private static final int DRAW_START = 8; // Draw 方法开始的时间； 8.2 setVsync设置同步信息： 1234567public void setVsync(long intendedVsync, long usedVsync) &#123; mFrameInfo[INTENDED_VSYNC] = intendedVsync; mFrameInfo[VSYNC] = usedVsync; mFrameInfo[OLDEST_INPUT_EVENT] = Long.MAX_VALUE; mFrameInfo[NEWEST_INPUT_EVENT] = 0; mFrameInfo[FLAGS] = 0;&#125; 8.3 markInputHandlingStart (Animations/PerformTraversals)标记 input 处理，动画开始，PerformTraversals 开始的时间：System.nanoTime 1234567891011public void markInputHandlingStart() &#123; mFrameInfo[HANDLE_INPUT_START] = System.nanoTime();&#125;public void markAnimationsStart() &#123; mFrameInfo[ANIMATION_START] = System.nanoTime();&#125;public void markPerformTraversalsStart() &#123; mFrameInfo[PERFORM_TRAVERSALS_START] = System.nanoTime();&#125; 9 总结我们来看下整个流程： 创建编舞者 流程图如下： 请求 Vsync 信号 流程图如下： 触发 Callback 流程图如下： ViewRootImpl -> Choreographer: getInstance (线程单例) Choreographer -> Choreographer: 2.new Choreographer Choreographer -> FrameHandler: 3.new FrameHandler（ui 线程 Handler） Choreographer -> FrameDisplayEventReceiver: 4.new FrameDisplayEventReceiver（用于请求 Vsync） Note over FrameDisplayEventReceiver,NativeDisplayEventReceiver: Java 这之间隔着一层 jni 调用层(...) Native FrameDisplayEventReceiver -> FrameDisplayEventReceiver: 5.nativeInit Note right of NativeDisplayEventReceiver: 创建时，会获取 java MQ 对应的 \\n native MQ，以及 native Looper FrameDisplayEventReceiver -> NativeDisplayEventReceiver: 6.new NativeDisplayEventReceiver NativeDisplayEventReceiver --> FrameDisplayEventReceiver: 6.return NativeDisplayEventReceiver FrameDisplayEventReceiver -> NativeDisplayEventReceiver: 7.initialize （监听 mReceiver.getFd 返回的文件句柄） Choreographer --> ViewRootImpl: return Choreographer{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);ViewRootImpl -> Choreographer: 5.postCallback（请求 Vsync） Choreographer -> Choreographer: 6.postCallbackDelayed Choreographer -> Choreographer: 7.postCallbackDelayedInternal Choreographer -> CallbackQueue: 8.addCallbackLocked (将回调根据 type 加入到不同 CallbackQueue 中) CallbackQueue -> CallbackQueue: 9.obtainCallbackLocked (创建新的/使用缓存) CallbackQueue -> CallbackRecord: 10.new CallbackRecord CallbackRecord --> CallbackQueue: 10.return CallbackRecord/temp one Choreographer -> Choreographer : 11.scheduleFrameLocked (调度帧操作) Choreographer -> Choreographer : 12.scheduleVsyncLocked Choreographer -> FrameDisplayEventReceiver: 13.scheduleVsync FrameDisplayEventReceiver -> FrameDisplayEventReceiver: 14.nativeScheduleVsync FrameDisplayEventReceiver -> [extends DisplayEventDispatcher] \\n NativeDisplayEventReceiver : 15.scheduleVsync (最后进入 native 层请求 Vsync){\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-1-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-1\", options);NativeDisplayEventReceiver -> NativeDisplayEventReceiver : 1.handleEvent（Looper 监听到 fd 变化回调） NativeDisplayEventReceiver -> NativeDisplayEventReceiver : 2.processPendingEvents NativeDisplayEventReceiver -> NativeDisplayEventReceiver : 3.dispatchVsync Note over FrameDisplayEventReceiver, NativeDisplayEventReceiver: Native 这之间隔着一层 jni 调用层(...) Java NativeDisplayEventReceiver -> FrameDisplayEventReceiver : 4.dispatchVsync FrameDisplayEventReceiver -> FrameHandler : 5.sendMessageAtTime（将自己作为 runnable 传过去） FrameHandler --> FrameDisplayEventReceiver : 6.run FrameDisplayEventReceiver -> Choreographer : 7.doFrame Choreographer -> FrameInfo : 8.setVsync (设置帧信息) Choreographer -> Choreographer : 9.doCallbacks{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-2-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-2-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-2\", options);","categories":[{"name":"View 视图","slug":"View-视图","permalink":"https://coolqi.top/categories/View-视图/"},{"name":"Choreographer 编舞者","slug":"View-视图/Choreographer-编舞者","permalink":"https://coolqi.top/categories/View-视图/Choreographer-编舞者/"}],"tags":[{"name":"Choreographer","slug":"Choreographer","permalink":"https://coolqi.top/tags/Choreographer/"}]},{"title":"ViewDraw 第三篇 requestLayout 流程分析","slug":"ViewDraw-3-performTraversals","date":"2018-07-01T12:46:25.000Z","updated":"2019-10-10T21:11:31.548Z","comments":true,"path":"2018/07/01/ViewDraw-3-performTraversals/","link":"","permalink":"https://coolqi.top/2018/07/01/ViewDraw-3-performTraversals/","excerpt":"","text":"本篇文章基于 Android N（7.1.1）主要分析下 View 的加载 requestLayout 的流程，以对 View 架构有更好的理解。 1 回顾前面我们分析 setContentView 的时候，最后阶段，会执行如下的几个核心方法： 1234567891011121314151617public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; //【1】请求布局操作； requestLayout(); //【2】重绘； invalidate(true); //【3】会调用 child.requestLayout() 方法，因为设置了新的布局参数； // 必须要等到 DecorView 的 requestLayout 执行完成后才会执行； addViewInner(child, index, params, false);&#125; 本篇文章：我们先来看看 requestLayout 方法！ 2 View2.1 requestLayout请求布局： 123456789101112131415161718192021222324252627@CallSuperpublic void requestLayout() &#123; //【1】清空测量缓存； if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123; // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123; if (!viewRoot.requestLayoutDuringLayout(this)) &#123; return; &#125; &#125; mAttachInfo.mViewRequestingLayout = this; &#125; mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; mParent.requestLayout(); &#125; if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123; mAttachInfo.mViewRequestingLayout = null; &#125;&#125; 2.2 requestLayout1234567891011/** * Gets the view root associated with the View. * @return The view root, or null if none. * @hide */public ViewRootImpl getViewRootImpl() &#123; if (mAttachInfo != null) &#123; return mAttachInfo.mViewRootImpl; &#125; return null;&#125;","categories":[{"name":"View 视图","slug":"View-视图","permalink":"https://coolqi.top/categories/View-视图/"},{"name":"View 的加载和绘制","slug":"View-视图/View-的加载和绘制","permalink":"https://coolqi.top/categories/View-视图/View-的加载和绘制/"}],"tags":[{"name":"ViewDraw","slug":"ViewDraw","permalink":"https://coolqi.top/tags/ViewDraw/"}]},{"title":"ViewDraw 第二篇 new ViewRootImpl 流程分析","slug":"ViewDraw-2-newViewRootImpl","date":"2018-06-15T12:46:25.000Z","updated":"2019-10-19T13:08:28.786Z","comments":true,"path":"2018/06/15/ViewDraw-2-newViewRootImpl/","link":"","permalink":"https://coolqi.top/2018/06/15/ViewDraw-2-newViewRootImpl/","excerpt":"","text":"本篇文章基于 Android N - 7.1.1 主要分析下 Activity 中 setContentView 的流程，但是此时 UI 还没有显示出来； 真正显示 ui 是在 onResume 方法调用后，这个流程会创建 ViewRootImpl 类，并设置 setView 操作； 1 回顾我们来回顾下 activity 的 onResume 方法的执行。 1.1 ActivityThread核心的入口是在 handleResumeActivity 方法中； 1.1.1 handleResumeActivity我们来看看核心的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ... ... ... //【1】拉起 activity 的 onResume 方法； r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; ... ... ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //【1】获得 activity 的 PhoneWindow 对象，setContentView 时创建； r.window = r.activity.getWindow(); //【2】获得 PhoneWindow 内部的 DecorView 对象，并设置其为不可见； View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //【3】获得 WindowManagerImpl 对象； ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; // 这是复用之前的 window，我们不关注； a.mWindowAdded = true; r.mPreserveWindow = false; // 通常，ViewRoot 在 addView-&gt; ViewRootImpl.setView 中使用 Activity 设置回调。 // 如果我们改为重用装饰视图，则必须通知视图根回调可能已更改。 ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; //【4】如果 activity 还没有被加入到 wms，那么这里会 add window！ if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //【--&gt;2.2】添加 DecorView； wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, \"Launch \" + r + \" mStartedActivity set\"); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (r.newConfig != null) &#123; performConfigurationChangedForActivity(r, r.newConfig, REPORT_TO_ACTIVITY); if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \" + r.activityInfo.name + \" with newConfig \" + r.activity.mCurrentConfig); r.newConfig = null; &#125; if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\" + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; ... ... ... &#125; else &#123; try &#123; ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125;&#125; 这里，我们省略了一些不重要的代码，关注核心！ 核心逻辑： 12345678910111213141516171819//【1】获得 activity 的 PhoneWindow 对象，setContentView 时创建；r.window = r.activity.getWindow();//【2】获得 PhoneWindow 内部的 DecorView 对象，并设置其为不可见；View decor = r.window.getDecorView();decor.setVisibility(View.INVISIBLE);//【3】获得 WindowManagerImpl 对象；ViewManager wm = a.getWindowManager();WindowManager.LayoutParams l = r.window.getAttributes();a.mDecor = decor;l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;l.softInputMode |= forwardBit;... ... ... //【--&gt;3.2】如果 activity 还没有被加入到 wms，那么这里会 add window！if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l);&#125; 可以看到，核心的逻辑在 wm.addView(decor, l) 这个地方！ decor：我们的 DecorView; l：PhoneWindow 中的布局参数； 2 WindowManagerImpl这里我们进入了 WindowManagerImpl，这个类是在 activity.attach 方法中创建的。 2.1 new WindowManagerImpl我们来看下 WindowManagerImpl 的创建； 1234567891011121314151617public final class WindowManagerImpl implements WindowManager &#123; //【--&gt;3.1】内部有一个 wmGlobal 单例对象，impl 都是通过这个 global 来操作 view 的； private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; //【1】这个是我们的 PhoneWindow 实例； private final Window mParentWindow; private IBinder mDefaultToken; public WindowManagerImpl(Context context) &#123; this(context, null); &#125; private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow; &#125; WindowManager 又继承了 ViewManager： 123public interface WindowManager extends ViewManager &#123; ... ... ...// 先省略下；&#125; ViewManager 是一个接口，提供了两个函数接口： 1234public interface ViewManager &#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params);&#125; 根据注释： addView 的操作主要是：添加一个 view 到一个 window，同时分配布局属性给 view； 会抛出如下异常： android.view.WindowManager.BadTokenException：在没有移除已经存在的 view 的情况下，添加新的 view，也就是说一个 window 对应一个 View！ android.view.WindowManager.InvalidDisplayException：当我们讲一个 window 添加到 display，但是其不存在或者无效的时候； 可以看到，根据继承和实现的关系，我们知道： WindowManagerImpl： 是最终的实现类，和 window、view 相关的操作都在其内部实现； WindowManager：提供了和 window 相关的操作，已经一些和 window 相关的常量，共有变量，异常定义等等； ViewManager：提供了和 view 添加和更新相关的操作； 各司其职，各司其职！ 2.2 addView我们来看看 1234567@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; //【--&gt;2.2.1】申请默认的令牌 token； applyDefaultToken(params); //【--&gt;3.2】添加 view； mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; 2.2.1 applyDefaultToken123456789101112131415private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) &#123; //【1】如果 mParentWindow 为 null 的话，那么这里会分配默认的 token； if (mDefaultToken != null &amp;&amp; mParentWindow == null) &#123; //【1.1】判断参数类型； if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; //【1.2】分配默认的 token； final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (wparams.token == null) &#123; wparams.token = mDefaultToken; &#125; &#125;&#125; 如果 mParentWindow 为 null 的话，那么这里会分配默认的 token； 3 WindowManagerGlobalWindowManagerImpl 将操作交给 WindowManagerGlobal 完成，这里使用了桥接模式； 3.1 getInstance他是一个单例模式： 12345678910private static WindowManagerGlobal sDefaultWindowManager;public static WindowManagerGlobal getInstance() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sDefaultWindowManager == null) &#123; sDefaultWindowManager = new WindowManagerGlobal(); &#125; return sDefaultWindowManager; &#125;&#125; 这个不多说了； 3.2 addView添加 view： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //【1】判空处理； if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; //【2】获得 window 的布局参数； final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; //【3】针对 parentWindow 进行处理，我们知道对于 activity，这里的 parentWindow 实际上就是 PhoneWindow； // 所以是不为 null 的； if (parentWindow != null) &#123; //【--&gt;4.1】针对于 window 的类型，调整下布局参数 parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // 调整硬件加速的； final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; //【4】这里就是我们说的核心：ViewRootImpl ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; //【5】监听系统属性的变化； if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; //【5.1】当系统属性变化后，会触发所有 ViewRootImpl 的 loadSystemProperties 方法； mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; //【6】判断该 view 是否已经被添加了，实际上就是去 mViews 中找； // 如果能找到，并且他不在 mDyingViews 中，那么会抛出异常！ int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; //【6.1】如果其在 mDyingViews 中，那么不等待 MSG_DIE 消息出发，而是立即销毁！ mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(\"View \" + view + \" has already been added to the window manager.\"); &#125; // The previous removeView() had not completed executing. Now it has. &#125; //【7】如果该 window 是一个 sub window，那么我们会找到一个 token 和其一样的 view，作为 prarent； if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; //【--&gt;5.1】创建 ViewRootImpl 实例，并设置 view 的布局参数； root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); //【1】将 View，新创建的 ViewRootImpl 和 LayoutParams 加入到内部的 list 中； // 注意，这里是有序的排列； mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; try &#123; //【--&gt;5.2】添加 view； root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125;&#125; WindowManagerGlobal 内部有如下的 list，作用如下： 123456789101112// 保存所有已经被添加的 View！private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();// 保存所有的 ViewRootImpl！private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();// 保存所有的布局属性：WindowManager.LayoutParams；private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();// 保存所有的被删除销毁的 View，是那些已经调用 removeView 方法但是删除操作还未完成的 Window 对象；private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); 不多说了； 3.3 getWindowSession创建一个 window session： 123456789101112131415161718192021222324public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; //【1】获得 imm 对象，持有 ims 的代理对象； InputMethodManager imm = InputMethodManager.getInstance(); //【--&gt;3.3.1】获得 wms 的代理对象 IWindowManager windowManager = getWindowManagerService(); //【2】创建一个 window session； sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; WindowManagerGlobal 内部还有如下的属性： 12private static IWindowManager sWindowManagerService; // wms 代理；private static IWindowSession sWindowSession; // session 代理； 可以看到，这里的 sWindowSession 是一个 IWindowSession 类型的实例； 3.3.1 getWindowManagerService获得 wms 的代理对象： 12345678910111213141516public static IWindowManager getWindowManagerService() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowManagerService == null) &#123; //【1】获取 wms proxy 对象； sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(\"window\")); try &#123; sWindowManagerService = getWindowManagerService(); ValueAnimator.setDurationScale(sWindowManagerService.getCurrentAnimatorScale()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowManagerService; &#125;&#125; 4 Window（PhoneWindow）其实这里的 parentWindow 是 PhoneWindow： 4.1 adjustLayoutParamsForSubWindow该方法的作用是针对于 sub window 调整下布局参数！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 // --&gt; Window.javavoid adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123; CharSequence curTitle = wp.getTitle(); //【1】针对于 window type 来做不同的处理！ if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; //【1.1】针对于 sub window 的处理，可以看到，token 来自于 DecorView！ if (wp.token == null) &#123; View decor = peekDecorView(); if (decor != null) &#123; wp.token = decor.getWindowToken(); &#125; &#125; // 设置 title 和包名； if (curTitle == null || curTitle.length() == 0) &#123; final StringBuilder title = new StringBuilder(32); if (wp.type == WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA) &#123; title.append(\"Media\"); &#125; else if (wp.type == WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA_OVERLAY) &#123; title.append(\"MediaOvr\"); &#125; else if (wp.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) &#123; title.append(\"Panel\"); &#125; else if (wp.type == WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL) &#123; title.append(\"SubPanel\"); &#125; else if (wp.type == WindowManager.LayoutParams.TYPE_APPLICATION_ABOVE_SUB_PANEL) &#123; title.append(\"AboveSubPanel\"); &#125; else if (wp.type == WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG) &#123; title.append(\"AtchDlg\"); &#125; else &#123; title.append(wp.type); &#125; if (mAppName != null) &#123; title.append(\":\").append(mAppName); &#125; wp.setTitle(title); &#125; &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123; //【1.2】针对于 system window 的处理，这里不会针对于 system window 设置令牌 token； // 因为他的生命周期应该是独立的，当 app 的进程被杀掉/或者死亡了，system window 不会受影响； if (curTitle == null || curTitle.length() == 0) &#123; final StringBuilder title = new StringBuilder(32); title.append(\"Sys\").append(wp.type); if (mAppName != null) &#123; title.append(\":\").append(mAppName); &#125; wp.setTitle(title); &#125; &#125; else &#123; // 对于 activity 则会进入这里； //【1.3】设置令牌 token，这个令牌保存在 PhoneWindow 中； if (wp.token == null) &#123; wp.token = mContainer == null ? mAppToken : mContainer.mAppToken; &#125; // 设置 title； if ((curTitle == null || curTitle.length() == 0) &amp;&amp; mAppName != null) &#123; wp.setTitle(mAppName); &#125; &#125; //【2】设置了 window 的所属包名； if (wp.packageName == null) &#123; wp.packageName = mContext.getPackageName(); &#125; if (mHardwareAccelerated || (mWindowAttributes.flags &amp; FLAG_HARDWARE_ACCELERATED) != 0) &#123; wp.flags |= FLAG_HARDWARE_ACCELERATED; &#125; &#125; 这个方法主要是针对于不同的 window 做不同的处理； system window 是不会有 token 的； sub window 的 token 来自 DecorView(View).mAttachInfo.mWindowToken，通过 View.getWindowToken() 获得； 我们再来看看几个方法： peekDecorView 返回的是 DecorView，这个可以从前面文章看出来： 123456// ----&gt; Window.java/PhoneWindow.java@Overridepublic final View peekDecorView() &#123; // 返回的是 DecorView 实例； return mDecor;&#125; decor.getWindowToken()，实际上是父类 View 的方法： 123public IBinder getWindowToken() &#123; return mAttachInfo != null ? mAttachInfo.mWindowToken : null;&#125; 关于这个 mAttachInfo 我们后面再看； 5 ViewRootImpl123@SuppressWarnings(&#123;\"EmptyCatchBlock\", \"PointlessBooleanExpression\"&#125;)public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.HardwareDrawCallbacks &#123; 可以看到 ViewRootImpl 实现了 ViewParent 接口，View.AttachInfo.Callbacks 接口，ThreadedRenderer.HardwareDrawCallbacks 接口； 5.1 new ViewRootImplViewRootImpl 内部的成员变量很多，这里我们来看看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ViewRootImpl(Context context, Display display) &#123; mContext = context; // 上下文环境； //【--&gt;3.3】获得一个窗口事务对象； mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; // 目标显示器 display； mBasePackageName = context.getBasePackageName(); mThread = Thread.currentThread(); // 当前线程，其实就是主线程； mLocation = new WindowLeaked(null); // 是 AndroidRuntimeException 的子类 mLocation.fillInStackTrace(); mWidth = -1; // 宽和高； mHeight = -1; mDirty = new Rect(); mTempRect = new Rect(); mVisRect = new Rect(); mWinFrame = new Rect(); //【--&gt;6.1】创建可一个 W 对象，其继承了 IWindow.Stub，用于跨进程通信； mWindow = new W(this); mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion; // 目标 sdk mViewVisibility = View.GONE; // 可见行，默认为 GONE； mTransparentRegion = new Region(); // 和透明区域相关； mPreviousTransparentRegion = new Region(); mFirst = true; // 为 true 表示这个 view 是第一次 add； mAdded = false; //【--&gt;7.1】创建了一个 View.AttachInfo 实例； mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); // 和辅助服务功能相关，这里先不关注； mAccessibilityManager = AccessibilityManager.getInstance(context); mAccessibilityInteractionConnectionManager = new AccessibilityInteractionConnectionManager(); mAccessibilityManager.addAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mHighContrastTextManager = new HighContrastTextManager(); mAccessibilityManager.addHighTextContrastStateChangeListener( mHighContrastTextManager); mViewConfiguration = ViewConfiguration.get(context); // view 的配置属性； mDensity = context.getResources().getDisplayMetrics().densityDpi; // 屏幕像素 mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi; mFallbackEventHandler = new PhoneFallbackEventHandler(context); mChoreographer = Choreographer.getInstance(); //【--&gt;10.5】编舞者实例； mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE); // 显示器管理服务； //【--&gt;5.5】加载系统属性； loadSystemProperties();&#125; 我们看到了变量还是很多的，这里一起列举下核心的几个： W mWindow： mWindowSession： 下面的还回遇到一些重要的成员变量，我们也在这里一起来看看： SurfaceHolder.Callback2 mSurfaceHolderCallback： BaseSurfaceHolder mSurfaceHolder： 5.2 setView - 核心代码添加 View，参数 panelParentView 表示要 attach 的 view： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; //【*1】将要 add 的 view 保存到 ViewRootImpl.mView 中； mView = view; //【*2】获得最新显示器的状态； mAttachInfo.mDisplayState = mDisplay.getState(); // 同时注册显示器监听器监听变化； //【--&gt;9.1】将 mDisplayListener 注册到了 mDisplayManager 中，监听显示变化； //【--&gt;9.2】同时将 ViewRootHandler 注册到了 mDisplayManager 中； mDisplayManager.registerDisplayListener(mDisplayListener, mHandler); mViewLayoutDirectionInitial = mView.getRawLayoutDirection(); mFallbackEventHandler.setView(view); //【*3】拷贝一份布局参数到 mWindowAttributes 中，更新下包名，然后设置 attrs; mWindowAttributes.copyFrom(attrs); if (mWindowAttributes.packageName == null) &#123; mWindowAttributes.packageName = mBasePackageName; &#125; attrs = mWindowAttributes; setTag(); if (DEBUG_KEEP_SCREEN_ON &amp;&amp; (mClientWindowLayoutFlags &amp; WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) != 0 &amp;&amp; (attrs.flags&amp;WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) == 0) &#123; Slog.d(mTag, \"setView: FLAG_KEEP_SCREEN_ON changed from true to false!\"); &#125; //【4】将布局属性中的 flags 保存到 ViewRootImpl.mClientWindowLayoutFlags 中； mClientWindowLayoutFlags = attrs.flags; //【5】和辅助服务功能相关，这里先不关注； setAccessibilityFocus(null, null); //【*6】DecorView 实现了 RootViewSurfaceTaker 接口，所以会进入这里； if (view instanceof RootViewSurfaceTaker) &#123; //【6.1】如果是 activity 这种情况，willYouTakeTheSurface() 返回值为 null； // mSurfaceHolderCallback 是 SurfaceHolder.Callback2 实例，用于感知 Surface 的创建、销毁或者改变； mSurfaceHolderCallback = ((RootViewSurfaceTaker)view).willYouTakeTheSurface(); if (mSurfaceHolderCallback != null) &#123; //【6.2】如果 mSurfaceHolderCallback 不会 null，这里会再创建一个 SurfaceHolder 实例：mSurfaceHolder // 提供访问和控制 Surface 相关的方法； mSurfaceHolder = new TakenSurfaceHolder(); mSurfaceHolder.setFormat(PixelFormat.UNKNOWN); &#125; &#125; // Compute surface insets required to draw at specified Z value. // TODO: Use real shadow insets for a constant max Z. if (!attrs.hasManualSurfaceInsets) &#123; attrs.setSurfaceInsets(view, false /*manual*/, true /*preservePrevious*/); &#125; CompatibilityInfo compatibilityInfo = mDisplay.getDisplayAdjustments().getCompatibilityInfo(); mTranslator = compatibilityInfo.getTranslator(); //【7】如果持有了 surface，那就不开启硬件加速，显然，这里是开启的！ if (mSurfaceHolder == null) &#123; enableHardwareAcceleration(attrs); &#125; boolean restore = false; if (mTranslator != null) &#123; mSurface.setCompatibilityTranslator(mTranslator); restore = true; attrs.backup(); mTranslator.translateWindowLayout(attrs); &#125; if (DEBUG_LAYOUT) Log.d(mTag, \"WindowLayout in setView:\" + attrs); if (!compatibilityInfo.supportsScreen()) &#123; attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW; mLastInCompatMode = true; &#125; mSoftInputMode = attrs.softInputMode; //【*8】标注 window 的属性发生了变化； mWindowAttributesChanged = true; mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED; //【*9】将要添加的 view 设置到 mAttachInfo.mRootView 上； mAttachInfo.mRootView = view; mAttachInfo.mScalingRequired = mTranslator != null; mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale; if (panelParentView != null) &#123; mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken(); &#125; //【*10】将 mAdded 设置为 ture，表示已经添加了； mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ //【--&gt;5.3】请求布局，这里在将 window 添加到 wms 之前，做了一个布局操作， // 在和 wms 建立关系之前，完成布局，这样不影响事件的接收。 requestLayout(); //【*11】LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL 这个 feature 表示不接受输入事件， // 一般没人无聊这样干，所以这里会创建一个 InputChannel，用于接收输入事件； if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; //【--&gt;9.5】InputChannel，用于接收输入事件； mInputChannel = new InputChannel(); &#125; mForceDecorViewVisibility = (mWindowAttributes.privateFlags &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0; try &#123; //【*12】将布局参数中的 window type 类型，保存到 mOrigWindowType 中； mOrigWindowType = mWindowAttributes.type; //【*13】表示重新计算属性； mAttachInfo.mRecomputeGlobalAttributes = true; //【--&gt;5.4】重新搜集 view 的布局属性； collectViewAttributes(); //【*12】将 window 加入到 wms 中，建立当前视图窗口与系统 WindowManagerService 服务的关联； // 会在 WindowManagerService 服务中为该 APP 窗口生成两个 InputQueue, // 其中一个会调用 InputQueue.transferTo() 返回到当前 APP 进程窗口; // 另外一个保留在 WindowManagerService 为当前 APP 窗口创建的 WindowState 中; res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(\"Adding window failed\", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; if (mTranslator != null) &#123; mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets); &#125; mPendingOverscanInsets.set(0, 0, 0, 0); mPendingContentInsets.set(mAttachInfo.mContentInsets); mPendingStableInsets.set(mAttachInfo.mStableInsets); mPendingVisibleInsets.set(0, 0, 0, 0); mAttachInfo.mAlwaysConsumeNavBar = (res &amp; WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR) != 0; mPendingAlwaysConsumeNavBar = mAttachInfo.mAlwaysConsumeNavBar; if (DEBUG_LAYOUT) Log.v(mTag, \"Added window \" + mWindow); //【13】处理添加显示的结果，如果不是 WindowManagerGlobal.ADD_OKAY，那么就是异常的； if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123; mAttachInfo.mRootView = null; mAdded = false; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); switch (res) &#123; case WindowManagerGlobal.ADD_BAD_APP_TOKEN: case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN: throw new WindowManager.BadTokenException( \"Unable to add window -- token \" + attrs.token + \" is not valid; is your activity running?\"); case WindowManagerGlobal.ADD_NOT_APP_TOKEN: throw new WindowManager.BadTokenException( \"Unable to add window -- token \" + attrs.token + \" is not for an application\"); case WindowManagerGlobal.ADD_APP_EXITING: throw new WindowManager.BadTokenException( \"Unable to add window -- app for token \" + attrs.token + \" is exiting\"); case WindowManagerGlobal.ADD_DUPLICATE_ADD: throw new WindowManager.BadTokenException( \"Unable to add window -- window \" + mWindow + \" has already been added\"); case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED: // Silently ignore -- we would have just removed it // right away, anyway. return; case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON: throw new WindowManager.BadTokenException(\"Unable to add window \" + mWindow + \" -- another window of type \" + mWindowAttributes.type + \" already exists\"); case WindowManagerGlobal.ADD_PERMISSION_DENIED: throw new WindowManager.BadTokenException(\"Unable to add window \" + mWindow + \" -- permission denied for window type \" + mWindowAttributes.type); case WindowManagerGlobal.ADD_INVALID_DISPLAY: throw new WindowManager.InvalidDisplayException(\"Unable to add window \" + mWindow + \" -- the specified display can not be found\"); case WindowManagerGlobal.ADD_INVALID_TYPE: throw new WindowManager.InvalidDisplayException(\"Unable to add window \" + mWindow + \" -- the specified window type \" + mWindowAttributes.type + \" is not valid\"); &#125; throw new RuntimeException( \"Unable to add window -- unknown error code \" + res); &#125; //【】根据前面知道，DecorView 实现了 RootViewSurfaceTaker 接口，所以这里为 true； // 创建 InputQueue 的 create 和 destroy 的监听对象, //【--&gt;8.2】如果是 activity 这种情况，willYouTakeTheInputQueue() 返回值为 null； if (view instanceof RootViewSurfaceTaker) &#123; mInputQueueCallback = ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue(); &#125; //【14】从上面可以知道，正常情况，窗口是会接受输入事件的，所以 if 为 true； if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; // 这里为 false，原因见上面； mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; //【--&gt;9.4】创建一个接受输入事件的处理对象，绑定当前窗口的 InputChannel； mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; //【--&gt;5.2.1】将 ViewRootImpl 设置为其 parent； view.assignParent(this); mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0; mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0; if (mAccessibilityManager.isEnabled()) &#123; mAccessibilityInteractionConnectionManager.ensureConnection(); &#125; if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123; view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES); &#125; //【15】这里设置当前各种不同类别输入事件到来时候按对应类型依次分别调用的处理对象 CharSequence counterSuffix = attrs.getTitle(); mSyntheticInputStage = new SyntheticInputStage(); InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage); InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, \"aq:native-post-ime:\" + counterSuffix); InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage); InputStage imeStage = new ImeInputStage(earlyPostImeStage, \"aq:ime:\" + counterSuffix); InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, \"aq:native-pre-ime:\" + counterSuffix); mFirstInputStage = nativePreImeStage; mFirstPostImeInputStage = earlyPostImeStage; mPendingInputEventQueueLengthCounterName = \"aq:pending:\" + counterSuffix; &#125; &#125;&#125; 我们看到，这个流程还涉及到了 ViewRootImpl 的一些其他核心属性，这里简单看看： 123456789101112131415View mView // 就是要添加的 DecorView 实例；WindowManager.LayoutParams mWindowAttributes // DecorView 的布局参数拷贝；int mClientWindowLayoutFlags // 布局参数的 flags 属性；int mOrigWindowType = -1; // 布局参数的 type 属性；SurfaceHolder.Callback2 mSurfaceHolderCallback; // 用于感知 Surface 的创建、销毁或者改变；BaseSurfaceHolder mSurfaceHolder; // 提供访问和控制 Surface 相关的方法;boolean mWindowAttributesChanged = false; // 表示 window 的属性是否发生变化；boolean mAdded; // 是否已经添加到 wms 中；final View.AttachInfo mAttachInfo; // 当 view 绑定到 window 上时，用户保存一些核心数据；InputChannel mInputChannel; // 输入渠道，用于接受 input 事件；WindowInputEventReceiver mInputEventReceiver // 用于从 mInputChannel 中读取事件并分发； 同样的，还涉及到了 AttachInfo 的一些属性： 12 5.2.1 View.assignParent给 View 分配 Parent！ 1234567891011void assignParent(ViewParent parent) &#123; if (mParent == null) &#123; // 这里的 mParent 是 ViewParent 的实例； mParent = parent; &#125; else if (parent == null) &#123; mParent = null; &#125; else &#123; throw new RuntimeException(\"view \" + this + \" being added, but\" + \" it already has a parent\"); &#125;&#125; 我们知道 ViewRootImpl 是实现了 ViewParent 接口的： 12// 表示这个 view 绑定的 parent，可以通过 getParent 获取； protected ViewParent mParent; 5.3 requestLayout - 核心代码请求布局； 12345678910@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //【--&gt;5.3.1】检测线程； checkThread(); mLayoutRequested = true; //【--&gt;5.6】这里就要进入核心的逻辑了； scheduleTraversals(); &#125;&#125; 可以看到，这里最后调用了 scheduleTraversals 方法！ 5.3.1 checkThread在请求布局的时候，需要检查当前线程是否是 main thread： 1234567void checkThread() &#123; //【1】检测当前线程是否是主线程，不是的话，异常！ if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125;&#125; 只有主线程才能操作 ui！ 5.4 collectViewAttributes收集并更新 view 的属性； 12345678910111213141516171819202122232425262728private boolean collectViewAttributes() &#123; //【1】这里我们知道，前面将其设置成了 true； if (mAttachInfo.mRecomputeGlobalAttributes) &#123; //Log.i(mTag, \"Computing view hierarchy attributes!\"); mAttachInfo.mRecomputeGlobalAttributes = false; // 然后将其再设置成 false； boolean oldScreenOn = mAttachInfo.mKeepScreenOn; //【2】下面会将布局参数 mWindowAttributes 和 mAttachInfo 中的属性进行比较； // 更新 mWindowAttributes 和 mAttachInfo； mAttachInfo.mKeepScreenOn = false; mAttachInfo.mSystemUiVisibility = 0; mAttachInfo.mHasSystemUiListeners = false; mView.dispatchCollectViewAttributes(mAttachInfo, 0); mAttachInfo.mSystemUiVisibility &amp;= ~mAttachInfo.mDisabledSystemUiVisibility; WindowManager.LayoutParams params = mWindowAttributes; mAttachInfo.mSystemUiVisibility |= getImpliedSystemUiVisibility(params); if (mAttachInfo.mKeepScreenOn != oldScreenOn || mAttachInfo.mSystemUiVisibility != params.subtreeSystemUiVisibility || mAttachInfo.mHasSystemUiListeners != params.hasSystemUiListeners) &#123; applyKeepScreenOnFlag(params); params.subtreeSystemUiVisibility = mAttachInfo.mSystemUiVisibility; params.hasSystemUiListeners = mAttachInfo.mHasSystemUiListeners; mView.dispatchWindowSystemUiVisiblityChanged(mAttachInfo.mSystemUiVisibility); return true; &#125; &#125; return false;&#125; 下面就不再多说了； 5.5 loadSystemProperties加载系统属性： 12345678910111213141516171819202122232425262728public void loadSystemProperties() &#123; //【--&gt;9.1】这里的 Handler 就是 ViewRootHandler mHandler.post(new Runnable() &#123; @Override public void run() &#123; //【1】读取 viewroot.profile_rendering 属性，判断是否强制视图层次以 60 Hz 的频率呈现。 mProfileRendering = SystemProperties.getBoolean(PROPERTY_PROFILE_RENDERING, false); profileRendering(mAttachInfo.mHasWindowFocus); //【2】读取和硬件渲染相关的属性； if (mAttachInfo.mHardwareRenderer != null) &#123; if (mAttachInfo.mHardwareRenderer.loadSystemProperties()) &#123; invalidate(); &#125; &#125; //【3】用于 debug 布局； boolean layout = SystemProperties.getBoolean(View.DEBUG_LAYOUT_PROPERTY, false); if (layout != mAttachInfo.mDebugLayout) &#123; mAttachInfo.mDebugLayout = layout; //【--&gt;9.1】发送 MSG_INVALIDATE_WORLD 给 ViewRootHandler 进行全局的重绘制； if (!mHandler.hasMessages(MSG_INVALIDATE_WORLD)) &#123; mHandler.sendEmptyMessageDelayed(MSG_INVALIDATE_WORLD, 200); &#125; &#125; &#125; &#125;);&#125; 这里不再细看。 5.6 scheduleTraversals - 核心触发视图遍历： 12345678910111213141516171819void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; //【1】表示是否已经发起重绘，这是要设置为 true； mTraversalScheduled = true; //【2】在主线程的消息队列中放一个障栅； mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //【--&gt;10.5】设置一个回调到编舞者 Choreographer 中，在下一次的绘制触发时，执行 mTraversalRunnable // mTraversalRunnable 是一个 runnbale 实例； mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); //【3】如果此时有未处理的 input 事件， if (!mUnbufferedInputDispatch) &#123; //【--&gt;5.8】处理 input 事件； scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 我们来看看 Choreographer.postCallback 的第一个参数： Choreographer.CALLBACK_TRAVERSAL：表示该回调是一个绘制回调； 其实在 Choreographer 一共有三种回调类型，分别是： CALLBACK_INPUT：事件回调； CALLBACK_ANIMATION：动画回调； CALLBACK_TRAVERSAL：绘制回调； 对于编舞者，这里就不详细分析了； 5.6.1 TraversalRunnable.runTraversalRunnable 只是一个 runnable，其内部会调用另外一个方法：doTraversal() 12345678final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; //【--&gt;5.7】开始遍历； doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 5.7 doTraversal开始遍历了： 12345678910111213141516171819void doTraversal() &#123; if (mTraversalScheduled) &#123; //【1】要设置为 false，否则下一次重绘制没法触发； mTraversalScheduled = false; //【2】移出障栅； mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; 我们看到，最后调用了 performTraversals 方法！ 关于 performTraversals 下一篇文章来分析！ 5.8 scheduleConsumeBatchedInput处理 input 事件： 1234567void scheduleConsumeBatchedInput() &#123; if (!mConsumeBatchedInputScheduled) &#123; mConsumeBatchedInputScheduled = true; mChoreographer.postCallback(Choreographer.CALLBACK_INPUT, mConsumedBatchedInputRunnable, null); &#125;&#125; 这个和之前的逻辑就很类似了！ 5.8.1 ConsumeBatchedInputRunnable.run和之前的逻辑是一样的，只不过是针对于 input 的： 123456789final ConsumeBatchedInputRunnable mConsumedBatchedInputRunnable = new ConsumeBatchedInputRunnable();final class ConsumeBatchedInputRunnable implements Runnable &#123; @Override public void run() &#123; doConsumeBatchedInput(mChoreographer.getFrameTimeNanos()); &#125; &#125; 当然对于 input 的处理，这里不是本文的重点！ 6 ViewRootImpl.WW 类（这名字，估计 Google 也想不到应该启什么名字了），使用于跨进程通信的，当 wms 需要通知应用客户端去做一些事的时候，那么就会通过 Binder 通信，调用 W 类的相关方法！ 而每一个 W 又和一个 ViewRootImpl 相关联，所以 W 的会将操作交给 ViewRootImpl； 6.1 new W我们来看看 W 的构造器： 1234567891011static class W extends IWindow.Stub &#123; //【--&gt;5】可以看到，内部有一个 ViewRootImpl 弱引用： private final WeakReference&lt;ViewRootImpl&gt; mViewAncestor; //【1】持有一个窗口事务，来自 ViewRootImpl private final IWindowSession mWindowSession; W(ViewRootImpl viewAncestor) &#123; mViewAncestor = new WeakReference&lt;ViewRootImpl&gt;(viewAncestor); mWindowSession = viewAncestor.mWindowSession; &#125;&#125; 7 AttachInfo我们知道，如果一个 window 是 sub window 的话，他会被绑定（attach）到令牌 token 一样的 parent window 上，那么这个 AttachInfo 会用保存和 attach 相关的信息； AttachInfo 是 View 的内部类！ 7.1 new AttachInfo 参数 IWindowSession session：窗口事务； 参数 IWindow window：就是 ViewRootImpl 中的 W 实例：mWindow； 参数 Handler handler：这个是 ViewRootImpl 内部的 mHandler 实例； 12345678910111213AttachInfo(IWindowSession session, IWindow window, Display display, ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer, Context context) &#123; mSession = session; //【1】窗口事务 session 实例； mWindow = window; //【2】W 对象； mWindowToken = window.asBinder(); //【3】将 W 实例转为 Binder 对象； mDisplay = display; //【4】目标显示器 Display 实例； mViewRootImpl = viewRootImpl; //【5】所属的 viewRootImpl 实例； mHandler = handler; //【--&gt;9.1】viewRootImpl 内部的 ViewRootHandler 实例 mRootCallbacks = effectPlayer; //【6】所属的 viewRootImpl 实例； //【--&gt;9.3】ViewTreeObserver 用于监听 view tree 的全局变化，包括布局改变，绘制开始，触摸模式改变等等； mTreeObserver = new ViewTreeObserver(context);&#125; 关于 ViewTreeObserver 这里就先不关注了。 8 DecorView (RootViewSurfaceTaker)8.1 willYouTakeTheSurface是否让 View 持有监听 surface 变化的回调： 123public android.view.SurfaceHolder.Callback2 willYouTakeTheSurface() &#123; return mFeatureId &lt; 0 ? mWindow.mTakeSurfaceCallback : null;&#125; 这里的 mFeatureId 在 activity 的情况下是 -1，所以会返回 null； 8.2 willYouTakeTheInputQueue是否让 View 持有 InputQueue： 123public InputQueue.Callback willYouTakeTheInputQueue() &#123; return mFeatureId &lt; 0 ? mWindow.mTakeInputQueueCallback : null;&#125; 和上面是一样的！ 9 总结我们来分析下整个流程： ActivityThread -> ActivityThread: 1.handleResumeActivity ActivityThread -> WindowManagerImpl: 2.addView WindowManagerImpl -> ViewRootImpl: 3.new ViewRootImpl ViewRootImpl --> WindowManagerImpl: 4.return root:ViewRootImpl WindowManagerImpl -> ViewRootImpl: 5.setView ViewRootImpl -> ViewRootImpl: 6.requestLayout{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"View 视图","slug":"View-视图","permalink":"https://coolqi.top/categories/View-视图/"},{"name":"View 的加载和绘制","slug":"View-视图/View-的加载和绘制","permalink":"https://coolqi.top/categories/View-视图/View-的加载和绘制/"}],"tags":[{"name":"ViewDraw","slug":"ViewDraw","permalink":"https://coolqi.top/tags/ViewDraw/"}]},{"title":"ViewDraw 第一篇 setContentView 流程分析","slug":"ViewDraw-1-setContentView","date":"2018-06-01T12:46:25.000Z","updated":"2019-10-19T13:10:38.243Z","comments":true,"path":"2018/06/01/ViewDraw-1-setContentView/","link":"","permalink":"https://coolqi.top/2018/06/01/ViewDraw-1-setContentView/","excerpt":"","text":"本篇文章基于 Android N（7.1.1）主要分析下 View 的加载 setContentView 的流程，以对 View 架构有更好的理解。 1 概述setContentView 这个方法用于设置视图布局文件，在 Activity 的 onCreate 方法中，我们会通过该方法传入一个资源 id： 123456789101112public class SplashActivity extends AppCompatActivity &#123; private SplashHandler mSplashHandler; private static boolean sendMsg = true; // 避免重复进入handleMessage处理逻辑 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //【--&gt;2.1】核心方法，设置布局； setContentView(R.layout.splash_layout); &#125; &#125; 下面我们来一起跟踪下 setContentView 的流程! 2 启动流程回顾我们在之前分析 activity 启动的时候，应用进程的核心逻辑是在 ActivityThread 中，我们来去回顾下核心的代码： 2.1 ActivityThread2.1.1 handleLaunchActivity这个方法是在主线程的 H 中调用的，H 会收到来自 Stub 的 LAUNCH_ACTIVITY 的消息： 123456789101112switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); //【1】获取到传递的 ActivityClientRecord 实例； final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //【2】调用 handleLaunchActivity 方法； handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 我们接着看： 12345678910private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... ... ... //【1】初始化 WindowManagerGlobal 实例； WindowManagerGlobal.initialize(); //【--&gt;2.1.2】调用另外一个方法; Activity a = performLaunchActivity(r, customIntent); ... ... ...&#125; 当 ActivityManagerService 接收到启动 Activity 的请求之后会通过 binder 跨进程通信，通知 activity 所在进程的 ApplicationThread 对象，然后执行：handleLauncherActivity方法； 会初始化一个 WindowManagerGlobal 实例； 调用 performLaunchActivity 方法； 2.1.2 performLaunchActivity继续看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println(\"##### [\" + System.currentTimeMillis() + // \"] ActivityThread.performLaunchActivity(\" + r + \")\"); ... ... ... Activity activity = null; try &#123; //【1】通过反射来创建 Activity 实例； java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... ... ... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); //【1】尝试复用上一次的的 window 实例； Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; //【--&gt;2.2.1】执行 attach 绑定操作； activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; //【--&gt;3.1】这个方法会调用 activity 的 onCreate 方法； // 然后调用 setContextView 方法； activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... ... ... &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); &#125; &#125; return activity;&#125; 反射来创建 Activity 实例； 执行 activity.attach 方法； 调用 onCreate 方法，在 onCreate 方法中，会调用 setContextView 方法； 这里涉及到 ActivityClientRecord.token 这个是怎么来的呢，我们简单回顾下： 123456// ActivityStackSupervisor --&gt; realStartActivityLocked 方法中：app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 可以看到传入的是 ActivityRecord.appToken，我们来看一个简单的调用栈： 1234ActivityManagerService.startActivity(IApplicationThread, ....) -&gt;ActivityManagerService.startActivityAsUser(IApplicationThread, ...) --&gt;ActivityStack.startActivityMayWait(IApplicationThread, ...) --&gt;ActivityStack.startActivityLocked(IApplicationThread, ...) 这里会创建 ActivityRecord 实例，内部会创建一个 token 实例： 12345ActivityRecord(ActivityManagerService _service, ProcessRecord _caller, ...) &#123; service = _service; appToken = new Token(this, service); ... ... ... ...&#125; 这个 token 是 ActivityRecord 的内部类，继承了 IApplicationToken.Stub 类： 12345678910static class Token extends IApplicationToken.Stub &#123; private final WeakReference&lt;ActivityRecord&gt; weakActivity; private final ActivityManagerService mService; Token(ActivityRecord activity, ActivityManagerService service) &#123; weakActivity = new WeakReference&lt;&gt;(activity); mService = service; &#125; ... ... ...&#125; 这个 Token 会传递进入应用进程，保存到应用进程，然后在 addView 的时候再传递进系统进程的。 2.2 Activity2.2.1 attach - 核心方法关键核心代码在 attach： 123456789101112131415161718192021222324252627282930313233343536373839404142434445final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); //【--&gt;2.3.1】创建了 PhoneWindow 实例; mWindow = new PhoneWindow(this, window); //【--&gt;5.3.x】并设置 activity 为 callback； mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; // 紧接着，设置了 uiOptions（包含动画等属性）; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; // 令牌 token； mIdent = ident; ... ... ... //【--&gt;2.4.1】设置 wms 的代理对象到 PhoneWindow 中； mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; //【1】获得 wms 代理的应用； mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;&#125; 整体流程比较清晰，这里的 mToken 是一个 Binder 引用： 1private IBinder mToken; 继续！ 2.3 PhoneWindowPhoneWindow 继承了 Window 抽象类，他也是 window 类的唯一实现！ PhoneWindow 将 DecorView 作为 root view，这里的 DecorView 实际上是一个 FrameLayout！ 每一个 activity 都会有一个 PhoneWindow，他是 Activity 和 View 交互的中间层！ 123public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; ... ... ...&#125; 2.3.1 new PhoneWindow创建一个 PhoneWindow 实例，同时创建 LayoutInflater 实例，其用于加载布局文件！ 参数：Context context 是所属的 activity； 123456789101112131415161718192021222324// 这个构造器用于创建 activity 对应的 window；public PhoneWindow(Context context, Window preservedWindow) &#123; this(context); //【1】mUseDecorContext 默认是 false，只有创建 activity 对应的 window，才会使用 decor context； // 其他的 window 都是直接使用传入的 context； mUseDecorContext = true; if (preservedWindow != null) &#123; mDecor = (DecorView) preservedWindow.getDecorView(); mElevation = preservedWindow.getElevation(); mLoadElevation = false; mForceDecorInstall = true; // If we're preserving window, carry over the app token from the preserved // window, as we'll be skipping the addView in handleResumeActivity(), and // the token will not be updated as for a new window. getAttributes().token = preservedWindow.getAttributes().token; &#125; // 和画中画模式相关，即使系统不支持画中画模式，用于也可以通过开发者选项强行开启； boolean forceResizable = Settings.Global.getInt(context.getContentResolver(), DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0; mSupportsPictureInPicture = forceResizable || context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_PICTURE_IN_PICTURE);&#125; 其实 PhoneWindow 里面有很多的成员，这里我们先不关注，因为太多了。。。 2.4 WindowWindow 是一个抽象类，它提供了一系列窗口的接口，比如：setContentView、findViewById 等等，而其唯一实现类则是 PhoneWindow。 也就是说，其内部的一些抽象方法的最终实现，均是由 PhoneWindow。 2.4.1 setWindowManager1234567891011121314151617181920public void setWindowManager(WindowManager wm, IBinder appToken, String appName) &#123; //【1】调用了另外一个构造器； setWindowManager(wm, appToken, appName, false);&#125;public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; //【2】记录下了令牌 token； mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) &#123; //【2】如果 wm 为 null，那就获取 wms 的代理对象； wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; //【--&gt;2.5】创建 wmImpl 实例； mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125; 2.5 WindowManagerImplWindowManagerImpl 实现了 WindowManager 接口，是对 wms 的代理的一个包装类： 123456789private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow;&#125;// 参数是 PhoneWindow；public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; 该类用于和 wms 进行通信！！ 可以看到，createLocalWindowManager 方法传入的 parentWindow 就是我们的 PhoneWindow； 2.6 类图总结我们来通过类图看看整个流程中，这几个伙伴之间的关系，也便于对整体有个把握，方便后续的分析： 3 Activity下面，我们就来从 activity 入手： 3.1 setContentViewsetContextView 有三个重载方法，但是本质上是一样的： 123456789101112131415161718public void setContentView(@LayoutRes int layoutResID) &#123; //【--&gt;3.2】返回 PhoneWindow， //【--&gt;4.1】调用其 setContextView 方法； getWindow().setContentView(layoutResID); //【3.4】设置 actionBar initWindowDecorActionBar();&#125;// 下面两个方法如出一辙，不再关注；public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar();&#125;public void setContentView(View view, ViewGroup.LayoutParams params) &#123; getWindow().setContentView(view, params); initWindowDecorActionBar();&#125; 3.2 getWindow这里的 getWindow 返回的是什么呢，就是 PhoneWindow 1234public Window getWindow() &#123; //【--&gt;4.1】就是前面创建的 PhoneWindow return mWindow;&#125; 3.3 onWindowAttributesChanged通知 activity 窗口的属性发生变化了！ 123456789101112public void onWindowAttributesChanged(WindowManager.LayoutParams params) &#123; // Update window manager if: we have a view, that view is // attached to its parent (which will be a RootView), and // this activity is not embedded. if (mParent == null) &#123; View decor = mDecor; if (decor != null &amp;&amp; decor.getParent() != null) &#123; //【1】通知 wms 更新 view 布局； getWindowManager().updateViewLayout(decor, params); &#125; &#125;&#125; 这里我们先不继续分析； 3.4 initWindowDecorActionBar设置 actionbar： 1234567891011121314151617private void initWindowDecorActionBar() &#123; //【1】获得 PhoneWindow 实例； Window window = getWindow(); window.getDecorView(); if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) &#123; return; &#125; //【2】设置 actionBar； mActionBar = new WindowDecorActionBar(this); mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp); mWindow.setDefaultIcon(mActivityInfo.getIconResource()); mWindow.setDefaultLogo(mActivityInfo.getLogoResource());&#125; 这里有一个 isChild() ：判断一个 activity 是否嵌入到另一个 activity 中，如果是一个 chile activity，mParent 不为 null，一般哦们不用这种特性： 123456Activity mParent; /** Is this activity embedded inside of another activity? */public final boolean isChild() &#123; return mParent != null;&#125; 就不多说了！ 4 PhoneWindow下面的逻辑就进入了 PhoneWindow 中了； 4.1 setContentView我们在 activity 中一般是通过传入 layoutResID 来设置布局的： 123456789101112131415161718192021222324252627282930@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. //【1】第一次进入的 mContentParent 肯定是 null 的，所以进入了 installDecor 方法中； if (mContentParent == null) &#123; //【--&gt;4.2】创建 DecorView！ installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; //【2】这里和场景动画 Scene 有关系，这里先不关注； if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //【*important 3】加载我们设置的布局到 mContentParent； // 这里又会调用 ViewGroup.addView 方法，涛声依旧了； // requestLayout(); --&gt; invalidate(true); --&gt; addViewInner(... ...) mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 可以看到，在将 setContentView 设置的 布局 加载到 mContentParent 之前，还是设置了很多的工作的：installDecor！ 这里的对于 mLayoutInflater.inflate 的加载机制，就先不分析了，后面单独开一帖； 当然，PhoneWindow 也有其他两个 serContentView 方法： setContentView(View view) 12345@Overridepublic void setContentView(View view) &#123; //【1】调用另外一个 set 方法，第二个参数表示布局属性； setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125; setContentView(View view, ViewGroup.LayoutParams params) 12345678910111213141516171819202122232425@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: ... ... if (mContentParent == null) &#123; //【--&gt;4.2】创建 DecorView！！ installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; //【2】这里和场景动画 Scene 有关系，这里先不关注； if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; //【3】加载布局文件到 mContentParent； mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 这里的 mContentParent 是一个 ViewGroup 实例，很简单不多说； 4.2 installDecor创建 DecorView： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private void installDecor() &#123; mForceDecorInstall = false; //【1】第一次的话，mDecor 肯定是 null 的，那么这里就会创建 DecorView 实例； if (mDecor == null) &#123; //【--&gt;4.2.1】通过 generateDecor 方法创建 DecorView，参数为 -1； mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; //【2】同样的第一次，mContentParent 为 null； if (mContentParent == null) &#123; //【--&gt;4.2.2】加载 content root 布局，并返回 view 实例； mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); //【2.1】 R.id.decor_content_parent 对应的 view 是 root view； // 这里尝试将获取的 view 转为一个 DecorContentParent 实例，实际上 R.id.decor_content_parent 对应的 // view 是 ActionBarOverlayLayout，其实现了 DecorContentParent 接口； // 根据 root 布局文件，有这个 view 的只有：screen_toolbar.xml / screen_action_bar.xml final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); //【2.2】针对不同的情况，做不同的处理； if (decorContentParent != null) &#123; //【2.2.1】将其保存到 PhoneWindow.DecorContentParent mDecorContentParent = decorContentParent; //【2.2.2】给 PhoneWindow.DecorContentParent 设置 window callback(就是 acitivty) mDecorContentParent.setWindowCallback(getCallback()); if (mDecorContentParent.getTitle() == null) &#123; // 设置了 title mDecorContentParent.setWindowTitle(mTitle); &#125; final int localFeatures = getLocalFeatures(); for (int i = 0; i &lt; FEATURE_MAX; i++) &#123; if ((localFeatures &amp; (1 &lt;&lt; i)) != 0) &#123; mDecorContentParent.initFeature(i); &#125; &#125; mDecorContentParent.setUiOptions(mUiOptions); // 设置 icon； if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) != 0 || (mIconRes != 0 &amp;&amp; !mDecorContentParent.hasIcon())) &#123; mDecorContentParent.setIcon(mIconRes); &#125; else if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_ICON) == 0 &amp;&amp; mIconRes == 0 &amp;&amp; !mDecorContentParent.hasIcon()) &#123; mDecorContentParent.setIcon( getContext().getPackageManager().getDefaultActivityIcon()); mResourcesSetFlags |= FLAG_RESOURCE_SET_ICON_FALLBACK; &#125; if ((mResourcesSetFlags &amp; FLAG_RESOURCE_SET_LOGO) != 0 || (mLogoRes != 0 &amp;&amp; !mDecorContentParent.hasLogo())) &#123; mDecorContentParent.setLogo(mLogoRes); &#125; // ... 这里我们不过多关注； PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false); if (!isDestroyed() &amp;&amp; (st == null || st.menu == null) &amp;&amp; !mIsStartingWindow) &#123; invalidatePanelMenu(FEATURE_ACTION_BAR); &#125; &#125; else &#123; //【2.2.3】如果没有 R.id.decor_content_parent，那么肯定是其他的 root view // 这里尝试获取 R.id.title/R.id.title_container 然后设置可见性，标题等； mTitleView = (TextView) findViewById(R.id.title); if (mTitleView != null) &#123; if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123; final View titleContainer = findViewById(R.id.title_container); if (titleContainer != null) &#123; titleContainer.setVisibility(View.GONE); &#125; else &#123; mTitleView.setVisibility(View.GONE); &#125; mContentParent.setForeground(null); &#125; else &#123; mTitleView.setText(mTitle); &#125; &#125; &#125; if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; // 下面这部分和场景动画有关系，不再我们这篇文章的范围之内，省略掉先； if (hasFeature(FEATURE_ACTIVITY_TRANSITIONS)) &#123; ... ... ... &#125; &#125;&#125; 这里的 mDecor 和 mContentParent 分别是如下的类型： 12345// 表示当前 window 的 top level 的视图 view！private DecorView mDecor;// 这个表示的是 @android:id/content 对应的 view，我们设置的 view 会被 add 到里面；ViewGroup mContentParent; 4.2.1 generateDecor创建 DecorView 实例： 参数 int featureId：用于表示是是否一个 activity 类型的 window（-1 表示是 activity 类型的 window） 123456789101112131415161718192021222324protected DecorView generateDecor(int featureId) &#123; // System process doesn't have application context and in that case we need to directly use // the context we have. Otherwise we want the application context, so we don't cling to the // activity. //【1】创建上下文； Context context; //【2】mUseDecorContext 表示是否使用 decor context，默认是 false 的； // 但是如果我们启动的是 activity，那么 mUseDecorContext 为 true； if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); if (applicationContext == null) &#123; context = getContext(); &#125; else &#123; context = new DecorContext(applicationContext, getContext().getResources()); if (mTheme != -1) &#123; context.setTheme(mTheme); &#125; &#125; &#125; else &#123; context = getContext(); &#125; //【--&gt;6.1】创建了 DecorView 实例； return new DecorView(context, featureId, this, getAttributes());&#125; 对于创建 Context 这里，我们不过多关注！ 4.2.2 generateLayout加载布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383 protected ViewGroup generateLayout(DecorView decor) &#123; //【1】这里获取窗口的样式，读取的是 com.android.internal.R.styleable.Window 属性； // 其实就是 activity 的 theme 配置 TypedArray a = getWindowStyle(); if (false) &#123; System.out.println(\"From style:\"); String s = \"Attrs:\"; for (int i = 0; i &lt; R.styleable.Window.length; i++) &#123; s = s + \" \" + Integer.toHexString(R.styleable.Window[i]) + \"=\" + a.getString(i); &#125; System.out.println(s); &#125; //【2】判断是否是悬浮的 window； mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); //【2.1】获取要更新的 falags，其实就是 FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR； int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); //【3】针对悬浮属性做处理； if (mIsFloating) &#123; //【--&gt;5.4】如果是悬浮 window，那么肯定不是全屏的，这里会将默认的 MATCH_PARENT // 改为 WRAP_CONTENT； setLayout(WRAP_CONTENT, WRAP_CONTENT); //【--&gt;5.5】设置 flags，去掉 flagsToUpdate； setFlags(0, flagsToUpdate); &#125; else &#123; //【--&gt;5.5】设置 flags，增加 FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR； setFlags(FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR, flagsToUpdate); &#125; //【4】统一处理一些窗口特性； //【--&gt;4.2.1.1】设置 feture！ if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; //【4.1】设置了 notitle； requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; //【4.2】设置 actionbar！ requestFeature(FEATURE_ACTION_BAR); &#125; if (a.getBoolean(R.styleable.Window_windowActionBarOverlay, false)) &#123; //【4.3】设置覆盖模式，也就是说 actionbar 会覆盖在 window content 上； // 和 FEATURE_ACTION_BAR 一起使用； requestFeature(FEATURE_ACTION_BAR_OVERLAY); &#125; if (a.getBoolean(R.styleable.Window_windowActionModeOverlay, false)) &#123; //【4.4】设置 FEATURE_ACTION_MODE_OVERLAY； requestFeature(FEATURE_ACTION_MODE_OVERLAY); &#125; if (a.getBoolean(R.styleable.Window_windowSwipeToDismiss, false)) &#123; //【4.5】开启了滑动退出，那就设置 FEATURE_SWIPE_TO_DISMISS； requestFeature(FEATURE_SWIPE_TO_DISMISS); &#125; //【5】处理一些 flags 设置； //【--&gt;5.4】设置 flags； if (a.getBoolean(R.styleable.Window_windowFullscreen, false)) &#123; //【5.1】隐藏状态栏全屏显示 Window，设置 FLAG_FULLSCREEN 标志； setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowTranslucentStatus, false)) &#123; //【5.1】使状态栏透明同时会拉伸 window 到全屏的状态（保留 NavigationBar 高度）， // 假如有 ActionBar，ActionBar 依旧会显示，设置 FLAG_FULLSCREEN 标志； setFlags(FLAG_TRANSLUCENT_STATUS, FLAG_TRANSLUCENT_STATUS &amp; (~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowTranslucentNavigation, false)) &#123; //【5.2】NavigationBar 透明同时会拉伸 Window 到全屏，不保留 StatusBar 和 NavigationBar 的高度 // 设置 FLAG_TRANSLUCENT_NAVIGATION 位； setFlags(FLAG_TRANSLUCENT_NAVIGATION, FLAG_TRANSLUCENT_NAVIGATION &amp; (~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowOverscan, false)) &#123; //【5.3】允许 window contents 扩展到屏幕中的缩放区域内，如果有缩放区域的话； // 设置 FLAG_LAYOUT_IN_OVERSCAN 位； setFlags(FLAG_LAYOUT_IN_OVERSCAN, FLAG_LAYOUT_IN_OVERSCAN&amp;(~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowShowWallpaper, false)) &#123; //【5.4】使用系统桌面背景作为应用的背景，设置 FLAG_SHOW_WALLPAPER 位； setFlags(FLAG_SHOW_WALLPAPER, FLAG_SHOW_WALLPAPER&amp;(~getForcedWindowFlags())); &#125; if (a.getBoolean(R.styleable.Window_windowEnableSplitTouch, getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB)) &#123; //【5.5】支持触摸事件序列的拆分，设置 FLAG_SPLIT_TOUCH 位； setFlags(FLAG_SPLIT_TOUCH, FLAG_SPLIT_TOUCH&amp;(~getForcedWindowFlags())); &#125; //【6】获取和 Width/Height 相关的属性； a.getValue(R.styleable.Window_windowMinWidthMajor, mMinWidthMajor); a.getValue(R.styleable.Window_windowMinWidthMinor, mMinWidthMinor); if (DEBUG) Log.d(TAG, \"Min width minor: \" + mMinWidthMinor.coerceToString() + \", major: \" + mMinWidthMajor.coerceToString()); if (a.hasValue(R.styleable.Window_windowFixedWidthMajor)) &#123; if (mFixedWidthMajor == null) mFixedWidthMajor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedWidthMajor, mFixedWidthMajor); &#125; if (a.hasValue(R.styleable.Window_windowFixedWidthMinor)) &#123; if (mFixedWidthMinor == null) mFixedWidthMinor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedWidthMinor, mFixedWidthMinor); &#125; if (a.hasValue(R.styleable.Window_windowFixedHeightMajor)) &#123; if (mFixedHeightMajor == null) mFixedHeightMajor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedHeightMajor, mFixedHeightMajor); &#125; if (a.hasValue(R.styleable.Window_windowFixedHeightMinor)) &#123; if (mFixedHeightMinor == null) mFixedHeightMinor = new TypedValue(); a.getValue(R.styleable.Window_windowFixedHeightMinor, mFixedHeightMinor); &#125; //【7】又处理一些 flags 设置； //【--&gt;5.4】设置 flags； if (a.getBoolean(R.styleable.Window_windowContentTransitions, false)) &#123; //【7.1】开启了 content 过渡(动画)，设置 FEATURE_CONTENT_TRANSITIONS requestFeature(FEATURE_CONTENT_TRANSITIONS); &#125; if (a.getBoolean(R.styleable.Window_windowActivityTransitions, false)) &#123; //【7.2】开启了 acitivty 过渡(动画)，设置 FEATURE_ACTIVITY_TRANSITIONS requestFeature(FEATURE_ACTIVITY_TRANSITIONS); &#125; mIsTranslucent = a.getBoolean(R.styleable.Window_windowIsTranslucent, false); final Context context = getContext(); //【8】获取和平台版本相关的属性； final int targetSdk = context.getApplicationInfo().targetSdkVersion; final boolean targetPreHoneycomb = targetSdk &lt; android.os.Build.VERSION_CODES.HONEYCOMB; final boolean targetPreIcs = targetSdk &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH; final boolean targetPreL = targetSdk &lt; android.os.Build.VERSION_CODES.LOLLIPOP; final boolean targetHcNeedsOptions = context.getResources().getBoolean( R.bool.target_honeycomb_needs_options_menu); final boolean noActionBar = !hasFeature(FEATURE_ACTION_BAR) || hasFeature(FEATURE_NO_TITLE); //【9】根据当前 sdk 的版本判断需不需要加入 menukey if (targetPreHoneycomb || (targetPreIcs &amp;&amp; targetHcNeedsOptions &amp;&amp; noActionBar)) &#123; setNeedsMenuKey(WindowManager.LayoutParams.NEEDS_MENU_SET_TRUE); &#125; else &#123; setNeedsMenuKey(WindowManager.LayoutParams.NEEDS_MENU_SET_FALSE); &#125; //【10】如果应用没有强制设置 Status Bar 和 Navigation Bar 的颜色，那就使用默认颜色； if (!mForcedStatusBarColor) &#123; mStatusBarColor = a.getColor(R.styleable.Window_statusBarColor, 0xFF000000); &#125; if (!mForcedNavigationBarColor) &#123; mNavigationBarColor = a.getColor(R.styleable.Window_navigationBarColor, 0xFF000000); &#125; //【11】获取 window 的布局参数； WindowManager.LayoutParams params = getAttributes(); //【12】如果不是浮动的 window 同时环视，如果 sdk 是 5.0 以上，同时 theme 设置了 // 可绘制 sysetem bar 的背景，那就设置 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS 标志位； if (!mIsFloating &amp;&amp; ActivityManager.isHighEndGfx()) &#123; if (!targetPreL &amp;&amp; a.getBoolean( R.styleable.Window_windowDrawsSystemBarBackgrounds, false)) &#123; setFlags(FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS &amp; ~getForcedWindowFlags()); &#125; if (mDecor.mForceWindowDrawsStatusBarBackground) &#123; params.privateFlags |= PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND; &#125; &#125; //【13】设置状态栏为浅色； if (a.getBoolean(R.styleable.Window_windowLightStatusBar, false)) &#123; decor.setSystemUiVisibility( decor.getSystemUiVisibility() | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; //【14】设置点击 window 的外面，就关闭 window！ if (mAlwaysReadCloseOnTouchAttr || getContext().getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123; if (a.getBoolean( R.styleable.Window_windowCloseOnTouchOutside, false)) &#123; setCloseOnTouchOutsideIfNotSet(true); &#125; &#125; //【15】设置软键盘交互效果！ if (!hasSoftInputMode()) &#123; params.softInputMode = a.getInt( R.styleable.Window_windowSoftInputMode, params.softInputMode); &#125; //【16】设置 window 的幕布，也就是背景层，dimAmount 在 0.0f 和 1.0f 之间， // 0.0f 完全不暗，即背景是可见的 ，1.0f 时候，背景全部变黑暗。 if (a.getBoolean(R.styleable.Window_backgroundDimEnabled, mIsFloating)) &#123; /* All dialogs should have the window dimmed */ if ((getForcedWindowFlags()&amp;WindowManager.LayoutParams.FLAG_DIM_BEHIND) == 0) &#123; //【16.1】布局参数增加 FLAG_DIM_BEHIND 标志位； params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND; &#125; if (!haveDimAmount()) &#123; params.dimAmount = a.getFloat( android.R.styleable.Window_backgroundDimAmount, 0.5f); &#125; &#125; //【17】设置窗口动画； if (params.windowAnimations == 0) &#123; params.windowAnimations = a.getResourceId( R.styleable.Window_windowAnimationStyle, 0); &#125; //【18】返回该 window 的容器，如果为 null，那么其是 top 级别的 window，也就是我们的 activity！ // 这里主要是一些背景色的设置； if (getContainer() == null) &#123; if (mBackgroundDrawable == null) &#123; if (mBackgroundResource == 0) &#123; mBackgroundResource = a.getResourceId( R.styleable.Window_windowBackground, 0); &#125; if (mFrameResource == 0) &#123; mFrameResource = a.getResourceId(R.styleable.Window_windowFrame, 0); &#125; mBackgroundFallbackResource = a.getResourceId( R.styleable.Window_windowBackgroundFallback, 0); if (false) &#123; System.out.println(\"Background: \" + Integer.toHexString(mBackgroundResource) + \" Frame: \" + Integer.toHexString(mFrameResource)); &#125; &#125; if (mLoadElevation) &#123; mElevation = a.getDimension(R.styleable.Window_windowElevation, 0); &#125; mClipToOutline = a.getBoolean(R.styleable.Window_windowClipToOutline, false); mTextColor = a.getColor(R.styleable.Window_textColor, Color.TRANSPARENT); &#125; //【19】核心代码：--&gt; 加载布局文件！ int layoutResource; int features = getLocalFeatures(); // 通过对 features 和 mIsFloating 的判断，为 layoutResource 进行赋值， // 所以 requestFeature 要在 setContentView 之前进行； if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; //【19.1】如果支持滑动退出，那么会加载 R.layout.screen_swipe_dismiss 这个布局文件； layoutResource = R.layout.screen_swipe_dismiss; &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; //【19.2】如果在标题栏显示左右的按钮，那么根据是否是浮动，加载不同的布局； if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; //【19.2.2】加载 R.layout.screen_title_icons 这个布局文件 layoutResource = R.layout.screen_title_icons; &#125; //【19.2.2】移除 action bar 特性； removeFeature(FEATURE_ACTION_BAR); // System.out.println(\"Title Icons!\"); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; //【19.3】如果 window 只设置了一个 progress bar // 那么加载 R.layout.screen_progress 布局； layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123;//【19.4】如果 window 设置了定制的 title 特性，如果是悬浮的 window，那么会加载一个 dialog 的布局 // 否则加载 R.layout.screen_custom_title 布局； if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; // 移除 action bar 特性； removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; //【19.5】如果 window 设置了 no title 特性，如果是悬浮的 window，那么会加载一个 dialog 的布局 // 否则如果设置了 action bar 特性，那么就加载 R.layout.screen_action_bar 的布局； // 其他情况，加载 R.layout.screen_custom_title 布局； if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; //【19.5】如果设置了 action mode overlay 特性，那么 action bar 会覆盖在 content 上面 // 加载 R.layout.screen_simple_overlay_action_mode 布局； layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; //【19.6】在没有设置任何 feature（也就是装饰）时选用默认布局 layoutResource = R.layout.screen_simple; &#125; //【--&gt;6.3】标记 DecorView 正准备加载； mDecor.startChanging(); //【--&gt;6.4】开始加载布局文件， mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); //【20】找到内置布局里面的 id 为 ID_ANDROID_CONTENT 的 ViewGroup，保存到 contentParent 临时变量中； // 目的很明显，要加载 setContentView 设置的布局了； ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123; ProgressBar progress = getCircularProgressBar(false); if (progress != null) &#123; progress.setIndeterminate(true); &#125; &#125; if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; registerSwipeCallbacks(); &#125; //【21】只针对于 top level 的 window 才会进行处理； if (getContainer() == null) &#123; final Drawable background; //【21.1】PhoneWindow 有一个 setBackgroundDrawable 方法可以用来设置 mBackgroundResource； if (mBackgroundResource != 0) &#123; background = getContext().getDrawable(mBackgroundResource); &#125; else &#123; background = mBackgroundDrawable; &#125; //【--&gt;6.5】设置 window 背景，最终会触发 drawableChanged 方法； mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) &#123; frame = getContext().getDrawable(mFrameResource); &#125; else &#123; frame = null; &#125; //【--&gt;6.5】设置 window Frame，最终会触发 drawableChanged 方法； mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) &#123; setTitle(mTitle); &#125; if (mTitleColor == 0) &#123; mTitleColor = mTextColor; &#125; setTitleColor(mTitleColor); &#125; //【--&gt;6.3】此时，DecorView 中的 root view 已经加载完了 // 包括背景，标题什么都已经设置完成了，这里会结束 changing，触发 drawableChanged 方法； mDecor.finishChanging(); return contentParent; &#125; 这里大家对下面的计算可能摸不着头脑： 1setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags())); 分情况下： 如果 getForcedWindowFlags() 没有设置 FLAG_FULLSCREEN，那么 FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()) 为 FLAG_FULLSCREEN 如果 getForcedWindowFlags() 设置了 FLAG_FULLSCREEN，那么 FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()) 为 0； 然后大家可以分析 setLayout 方法是如何处理的了； 其实，整个过程： 第一个阶段，是在处理 window 的 theme 和 flags，因为这些设置会影响 window 的特性； 第二个阶段，是选择 root 布局，并加载到 DecorView； 4.2.2.1 requestFeature应用窗口特性： 参数 featureId 是特性的 id，需要将其转为对应的二进制序列：(1 &lt;&lt; featureId)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic boolean requestFeature(int featureId) &#123; if (mContentParentExplicitlySet) &#123; throw new AndroidRuntimeException(\"requestFeature() must be called before adding content\"); &#125; //【1】获取默认的 feture！，getFeatures 返回的是 window.mFeatures，这就不再分析了； final int features = getFeatures(); //【2】设置新的 feature； final int newFeatures = features | (1 &lt;&lt; featureId); //【3】然后做一些冲突判断； if ((newFeatures &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0 &amp;&amp; (newFeatures &amp; ~CUSTOM_TITLE_COMPATIBLE_FEATURES) != 0) &#123; //【3.1】如果设置了 FEATURE_CUSTOM_TITLE ，那么是不能设置其他和 title 类型不兼容的 feature 的！ throw new AndroidRuntimeException( \"You cannot combine custom titles with other title features\"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0 &amp;&amp; featureId == FEATURE_ACTION_BAR) &#123; //【3.2】如果要设置的是 action bar，然而 feature 已经设置了 no title，设置失败！ return false; &#125; if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0 &amp;&amp; featureId == FEATURE_NO_TITLE) &#123; //【3.3】如果要设置的是 no title，然而 feature 已经设置了 actionbar，那就要去掉 actionbar； removeFeature(FEATURE_ACTION_BAR); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0 &amp;&amp; featureId == FEATURE_SWIPE_TO_DISMISS) &#123; //【3.4】如果要设置的是右滑退出（swipe to dismiss），但是 feature 已经有 action bar 了 // 这里会产生冲突； throw new AndroidRuntimeException( \"You cannot combine swipe dismissal and the action bar.\"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0 &amp;&amp; featureId == FEATURE_ACTION_BAR) &#123; //【3.5】如果要设置的是 action bar ，但是 feature 已经有 右滑退出（swipe to dismiss）了 // 冲突！！ throw new AndroidRuntimeException( \"You cannot combine swipe dismissal and the action bar.\"); &#125; if (featureId == FEATURE_INDETERMINATE_PROGRESS &amp;&amp; getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) &#123; //【3.6】如果要设置的是 不确定的进度 特性，且此时平台是 watch，那就会抛出异常； throw new AndroidRuntimeException(\"You cannot use indeterminate progress on a watch.\"); &#125; //【4】设置新的 feature 位到 mFeatures 和 mLocalFeatures！ return super.requestFeature(featureId);&#125; 这里就不再继续分析了～～ 下面是默认特性（DEFAULT_FEATURES）、和 CUSTOM_TITLE 特性兼容的特性的定义！ 123456789101112// --&gt; Window.java@Deprecated@SuppressWarnings(&#123;\"PointlessBitwiseExpression\"&#125;)protected static final int DEFAULT_FEATURES = (1 &lt;&lt; FEATURE_OPTIONS_PANEL) | (1 &lt;&lt; FEATURE_CONTEXT_MENU);// --&gt; PhoneWindow.javaprivate static final int CUSTOM_TITLE_COMPATIBLE_FEATURES = DEFAULT_FEATURES | (1 &lt;&lt; FEATURE_CUSTOM_TITLE) | (1 &lt;&lt; FEATURE_CONTENT_TRANSITIONS) | (1 &lt;&lt; FEATURE_ACTIVITY_TRANSITIONS) | (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY); 关于上面的特性具体的意思，这里不在详细分析。 4.2.2.2 Root 布局分析上面的 xml 文件位于 frameworks/base/core/res/res/layout 下，我们选择几个来看看： 4.2.2.2.1 默认布局（不使用 feature）123456789101112131415161718192021&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;!--action bar--&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"?attr/actionBarTheme\" /&gt; &lt;!--content--&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:foregroundInsidePadding=\"false\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt;&lt;/LinearLayout&gt; 4.2.2.2.2 支持滑动退出的布局12345678&lt;!--content--&gt;&lt;com.android.internal.widget.SwipeDismissLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@android:id/content\" android:fitsSystemWindows=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 4.2.2.2.3 只有一个进度条的布局1234567891011121314151617181920&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;!--content--&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:foregroundInsidePadding=\"false\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt; &lt;!--action bar--&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"?attr/actionBarTheme\" /&gt;&lt;/FrameLayout&gt; 4.2.2.2.4 总结通过布局的分析，我们可以知道： 所有的布局都会有一个 id 为 “@android:id/content” 的 Layout，这个 Layout 就是用来放置我们 setContentView 设置的 content 的； 4.2 dispatchWindowAttributesChanged12345678@Overrideprotected void dispatchWindowAttributesChanged(WindowManager.LayoutParams attrs) &#123; //【--&gt;5.6】先调用了父类的 dispatchWindowAttributesChanged 方法 super.dispatchWindowAttributesChanged(attrs); if (mDecor != null) &#123; mDecor.updateColorViews(null /* insets */, true /* animate */); &#125;&#125; 5 Window是一个抽象类，定义了窗口的所有公共操作和属性，phoneWindow 是他的唯一实现类； 5.1 new Window由于 PhoneWindow 是其唯一的实现类，所以一般只有通过 new PhoneWindow 才能触发父类构造器： 123456public Window(Context context) &#123; //【1】就是 activity，不多说了！ mContext = context; //【2】获取默认的 feature！ mFeatures = mLocalFeatures = getDefaultFeatures(context);&#125; 方法很简单，Window 内部也有很多的成员变量，这里我们不一一分析，我们后面会边跟代码，边分析内部的变量！ mFeatures 和 mLocalFeatures 是 window 内部的窗口特性，是一个二进制序列； getDefaultFeatures：获取默认的 feature 配置，这个方法不太重要，就不单独列出来了！ 123456789101112131415public static int getDefaultFeatures(Context context) &#123; int features = 0; final Resources res = context.getResources(); //【1】是否启用 “选项面板” 功能，默认已启用，设置 FEATURE_OPTIONS_PANEL 位； if (res.getBoolean(com.android.internal.R.bool.config_defaultWindowFeatureOptionsPanel)) &#123; features |= 1 &lt;&lt; FEATURE_OPTIONS_PANEL; &#125; if (res.getBoolean(com.android.internal.R.bool.config_defaultWindowFeatureContextMenu)) &#123; features |= 1 &lt;&lt; FEATURE_CONTEXT_MENU; &#125; return features;&#125; 这里我们先来看看 Window 内部的几个接口，activity 都实现了这几个接口！ 5.1.1 内部接口5.1.1.1 Callback这个接口用于处理事件的分发，菜单操作，窗口属性变化等事件回调： 1234567/*** API from a Window back to its caller. This allows the client to* intercept key dispatching, panels and menus, etc.*/public interface Callback &#123; ... ... ...// 先不关注，接口太多了：&#125; 下面是其内部的方法，具体实现都在 activity 里面： 其内部接口很多，我们这里不过多分析！！ 5.1.1.2 WindowControllerCallback和窗口控制相关的回调接口：比如：退出 FreeForm 模式，进入画中画模式等等； 1234567891011/** @hide */public interface WindowControllerCallback &#123; // 退出 freeform 模式，（翻译注释）其实就是将 activity 从 freeform stack 移动到 full screen stack void exitFreeformMode() throws RemoteException; // 如果 acitivity 支持画中画模式，就进入画中画模式（@see android.R.attr#supportsPictureInPicture） void enterPictureInPictureModeIfPossible(); /** Returns the current stack Id for the window. */ int getWindowStackId() throws RemoteException;&#125; 不多说了！ 5.1.1.3 OnWindowDismissedCallbackwindow 被销毁触发的回调： 12345/** @hide */public interface OnWindowDismissedCallback &#123; // window 被销毁触发，通知 activity finsh 掉自己，参数 finishTask 为 ture 表示同时清理掉所在的 task void onWindowDismissed(boolean finishTask);&#125; 5.2 设置 window 回调window 有下面三个成员变量，其实都是所属的 activity，因为 activity 实现了这几个接口； 123private Callback mCallback;private OnWindowDismissedCallback mOnWindowDismissedCallback;private WindowControllerCallback mWindowControllerCallback; 具体的作用我们后面再分析； 5.2.1 setCallback123public void setCallback(Callback callback) &#123; mCallback = callback;&#125; 5.2.2 setWindowControllerCallback1234/** @hide */public final void setWindowControllerCallback(WindowControllerCallback wccb) &#123; mWindowControllerCallback = wccb;&#125; 5.2.3 setOnWindowDismissedCallback1234/** @hide */public final void setOnWindowDismissedCallback(OnWindowDismissedCallback dcb) &#123; mOnWindowDismissedCallback = dcb;&#125; 5.3 getAttributes获得当前的 activity 的 window 布局属性： 123public final WindowManager.LayoutParams getAttributes() &#123; return mWindowAttributes;&#125; 这里的 mWindowAttributes 是抽象类 Window 的内部属性，表示当前 window 的布局属性： 123// --&gt; Window.javaprivate final WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams(); 不多说了！ 5.4 setLayout设置布局属性： 1234567public void setLayout(int width, int height) &#123; final WindowManager.LayoutParams attrs = getAttributes(); attrs.width = width; attrs.height = height; //【--&gt;4.2】分发 window 布局属性改变的消息； dispatchWindowAttributesChanged(attrs);&#125; 这个方法用于设置 window 的 width/height 布局属性，默认是 MATCH_PARENT，表示的是全屏的 window！！！ 如果是 WRAP_CONTENT 的话，那就不是全屏（full-screen）的 window！！ dispatchWindowAttributesChanged 方法，其子类 PhoneWindow 覆写了该方法！！ 5.5 setFlags用于设置窗口的 flags 位： int flags：表示新的 flags 位； int mask：要修改的窗口标志位； 123456789public void setFlags(int flags, int mask) &#123; //【--&gt; 5.3】返回 window 的布局属性： final WindowManager.LayoutParams attrs = getAttributes(); //【1】这里先是从 attrs.flags 中去掉 mask 中的标志，然后再加上了 flags 和 mask 相同的标志； attrs.flags = (attrs.flags&amp;~mask) | (flags&amp;mask); mForcedWindowFlags |= mask; //【--&gt;4.x】分发 window 布局属性改变的消息； dispatchWindowAttributesChanged(attrs);&#125; 我们看到，其实最终生效的 flags，是保存在 WindowManager.LayoutParams 中！ 这里的 mForcedWindowFlags 用来保存：应用程序显式设置的 flags 标志位，默认值为 0； 123456private int mForcedWindowFlags = 0;// 该方法用于返回 mForcedWindowFlags；protected final int getForcedWindowFlags() &#123; return mForcedWindowFlags;&#125; addFlags：增加一个标志位！ 123public void addFlags(int flags) &#123; setFlags(flags, flags);&#125; clearFlags：去掉一个标志位！ 123public void clearFlags(int flags) &#123; setFlags(0, flags);&#125; 5.6 dispatchWindowAttributesChanged分发窗口属性变化的消息： 1234567protected void dispatchWindowAttributesChanged(WindowManager.LayoutParams attrs) &#123; //【1】这里的 mCallback 就是 activity； if (mCallback != null) &#123; //【--&gt;3.2】回调 mCallback 的 onWindowAttributesChanged 方法： mCallback.onWindowAttributesChanged(attrs); &#125;&#125; 回调通知，不多说。 6 DecorView可以看到 DecorView 本质上是一个 FrameLayout！ 123456789/** @hide */public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; ... ... ... //【1】表示所属的 PhoneWindow； private PhoneWindow mWindow; //【2】我们通过 setContentView 设置的布局 view； ViewGroup mContentRoot; ... ... ... &#125; 同时他也实现了 RootViewSurfaceTaker 和 WindowCallbacks 接口！ 当然，对于 DecorView 其内部成员也很多，这里也就不一一分析。。。 6.1 new DecorView我们来看看创建 DecorView 实例： 123456789101112131415161718192021222324252627282930DecorView(Context context, int featureId, PhoneWindow window, WindowManager.LayoutParams params) &#123; super(context); //【1】用于指定 window 的类型，-1 表示是 activity 的 window； mFeatureId = featureId; //【2】这一些是和系统特性，动画相关的一些成员，我们不关注； mShowInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.linear_out_slow_in); mHideInterpolator = AnimationUtils.loadInterpolator(context, android.R.interpolator.fast_out_linear_in); mBarEnterExitDuration = context.getResources().getInteger( R.integer.dock_enter_exit_duration); mForceWindowDrawsStatusBarBackground = context.getResources().getBoolean( R.bool.config_forceWindowDrawsStatusBarBackground) &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= N; mSemiTransparentStatusBarColor = context.getResources().getColor( R.color.system_bar_background_semi_transparent, null /* theme */); //【3】读取可用的屏幕宽度； updateAvailableWidth(); //【--&gt;6.2】设置所属 window； setWindow(window); updateLogTag(params); mResizeShadowSize = context.getResources().getDimensionPixelSize( R.dimen.resize_shadow_size); initResizingPaints();&#125; 这个 mFeatureId 是 DecorView 的成员： 12/** The feature ID of the panel, or -1 if this is the application's DecorView */private final int mFeatureId; 6.2 setWindow将 PhoneWindow 和 Context 的实例保存到 DecorView 中； 12345678910void setWindow(PhoneWindow phoneWindow) &#123; //【1】保存 PhoneWindow ，Context 的实例到内部成员变量中； mWindow = phoneWindow; Context context = getContext(); //【2】如果 Context 是 DecorContext 的实例，那么 DecorContext 也会持有 PhoneWindow 的引用； if (context instanceof DecorContext) &#123; DecorContext decorContext = (DecorContext) context; decorContext.setPhoneWindow(mWindow); &#125;&#125; 不多说了！ 6.3 startChanging / finishChanging用于（结束）标记 DecorView 正在加载： 123456789void startChanging() &#123; mChanging = true;&#125;void finishChanging() &#123; mChanging = false; //【--&gt;6.5】可绘制的区域发生的变化； drawableChanged();&#125; 6.4 onResourcesLoaded加载布局资源： 123456789101112131415161718192021222324252627282930313233void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; //【1】获取当前 window 所在的 stack！ mStackId = getStackId(); if (mBackdropFrameRenderer != null) &#123; loadBackgroundDrawablesIfNeeded(); mBackdropFrameRenderer.onResourcesLoaded( this, mResizingBackgroundDrawable, mCaptionBackgroundDrawable, mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState), getCurrentColor(mNavigationColorViewState)); &#125; //【2】创建一个 DecorCaptionView，类似于是一个中间层的封装； mDecorCaptionView = createDecorCaptionView(inflater); //【3】通过 LayoutInflater 加载 layoutResource 对应的布局文件！ final View root = inflater.inflate(layoutResource, null); if (mDecorCaptionView != null) &#123; //【4】如果 mDecorCaptionView 不为 null，那么会先将 mDecorCaptionView 加入到 DecorView 中； // 最后将 root 加入到 mDecorCaptionView 中； if (mDecorCaptionView.getParent() == null) &#123; addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; //【4】设置 content root view！ mContentRoot = (ViewGroup) root; initializeElevation();&#125; 可以看到： 主要流程就是加载 layoutResource 对应的布局文件（content root），加载的 view 会保存到 DecorView.mContentRoot 中； 然后通过 addView 将 content root 其加载到 DecorView 中去； 我们去看看 ViewGroup 的 addView 方法，可以看到也调用了 requestLayout() 和 invalidate(true) 方法！ 1234567891011121314151617public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; //【1】请求布局操作； requestLayout(); //【2】重绘； invalidate(true); //【3】会调用 child.requestLayout() 方法，因为设置了新的布局参数； // 必须要等到 DecorView 的 requestLayout 执行完成后才会执行； addViewInner(child, index, params, false);&#125; 这里虽然调用了 requestLayout 和 invalidate 实际上并没有开始布局和绘制，原因是 ViewRootImpl 还没有创建； 6.5 setWindowBackground / setWindowFrame设置 window 背景和 frame： 123456789101112131415161718192021222324252627282930313233public void setWindowBackground(Drawable drawable) &#123; if (getBackground() != drawable) &#123; setBackgroundDrawable(drawable); if (drawable != null) &#123; mResizingBackgroundDrawable = enforceNonTranslucentBackground(drawable, mWindow.isTranslucent() || mWindow.isShowingWallpaper()); &#125; else &#123; mResizingBackgroundDrawable = getResizingBackgroundDrawable( getContext(), 0, mWindow.mBackgroundFallbackResource, mWindow.isTranslucent() || mWindow.isShowingWallpaper()); &#125; if (mResizingBackgroundDrawable != null) &#123; mResizingBackgroundDrawable.getPadding(mBackgroundPadding); &#125; else &#123; mBackgroundPadding.setEmpty(); &#125; //【--&gt;6.6】可绘制的区域发生的变化 drawableChanged(); &#125;&#125;public void setWindowFrame(Drawable drawable) &#123; if (getForeground() != drawable) &#123; setForeground(drawable); if (drawable != null) &#123; drawable.getPadding(mFramePadding); &#125; else &#123; mFramePadding.setEmpty(); &#125; //【--&gt;6.6】可绘制的区域发生的变化 drawableChanged(); &#125;&#125; 可以看到，这里都调用了 drawableChanged 方法： 6.6 drawableChanged可绘制的区域发生的变化，实际上就是 window 的属性发生了变化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private void drawableChanged() &#123; if (mChanging) &#123; return; &#125; //【1】设置内容的 padding 距离； setPadding(mFramePadding.left + mBackgroundPadding.left, mFramePadding.top + mBackgroundPadding.top, mFramePadding.right + mBackgroundPadding.right, mFramePadding.bottom + mBackgroundPadding.bottom); //【2】请求布局； requestLayout(); //【3】触发绘制； invalidate(); //【4】根据 PixelFormat 类型设置窗口的默认格式，这里我们先不看； int opacity = PixelFormat.OPAQUE; if (StackId.hasWindowShadow(mStackId)) &#123; // If the window has a shadow, it must be translucent. opacity = PixelFormat.TRANSLUCENT; &#125; else&#123; // Note: If there is no background, we will assume opaque. The // common case seems to be that an application sets there to be // no background so it can draw everything itself. For that, // we would like to assume OPAQUE and let the app force it to // the slower TRANSLUCENT mode if that is really what it wants. Drawable bg = getBackground(); Drawable fg = getForeground(); if (bg != null) &#123; if (fg == null) &#123; opacity = bg.getOpacity(); &#125; else if (mFramePadding.left &lt;= 0 &amp;&amp; mFramePadding.top &lt;= 0 &amp;&amp; mFramePadding.right &lt;= 0 &amp;&amp; mFramePadding.bottom &lt;= 0) &#123; // If the frame padding is zero, then we can be opaque // if either the frame -or- the background is opaque. int fop = fg.getOpacity(); int bop = bg.getOpacity(); if (false) Log.v(mLogTag, \"Background opacity: \" + bop + \", Frame opacity: \" + fop); if (fop == PixelFormat.OPAQUE || bop == PixelFormat.OPAQUE) &#123; opacity = PixelFormat.OPAQUE; &#125; else if (fop == PixelFormat.UNKNOWN) &#123; opacity = bop; &#125; else if (bop == PixelFormat.UNKNOWN) &#123; opacity = fop; &#125; else &#123; opacity = Drawable.resolveOpacity(fop, bop); &#125; &#125; else &#123; // For now we have to assume translucent if there is a // frame with padding... there is no way to tell if the // frame and background together will draw all pixels. if (false) Log.v(mLogTag, \"Padding: \" + mFramePadding); opacity = PixelFormat.TRANSLUCENT; &#125; &#125; if (false) Log.v(mLogTag, \"Background: \" + bg + \", Frame: \" + fg); &#125; if (false) Log.v(mLogTag, \"Selected default opacity: \" + opacity); mDefaultOpacity = opacity; if (mFeatureId &lt; 0) &#123; mWindow.setDefaultWindowFormat(opacity); &#125;&#125; 这里核心的代码就是： 12345678910//【1】设置内容的 padding 距离；setPadding(mFramePadding.left + mBackgroundPadding.left,mFramePadding.top + mBackgroundPadding.top,mFramePadding.right + mBackgroundPadding.right,mFramePadding.bottom + mBackgroundPadding.bottom);//【2】请求布局；requestLayout();//【3】触发绘制；invalidate(); 这里就不再继续跟踪了，requestLayout 和 invalidate 后面再分析。 7 总结我们来看下整个的流程吧： 我画出了整个的流程图，可以发现，其实逻辑不是很复杂； 8 拓展分析8.1 requestFeature前面我们分析了 window feature 的概念，其实我们也可以动态设置 feature，比如我们在自己的代码中这样： 1getWindow().requestFeature(..) 这是通过 PhoneWindow 提供的如下方法来设置的： 注意： 这个方法一定要在 setContentView 之前调用，可以调用多次！ 一旦设置了 feature，那就不能关闭； FEATURE_CUSTOM_TITLE 不能和其他的 title feature 一起使用； 123456public boolean requestFeature(int featureId) &#123; final int flag = 1&lt;&lt;featureId; mFeatures |= flag; mLocalFeatures |= mContainer != null ? (flag&amp;~mContainer.mFeatures) : flag; return (mFeatures&amp;flag) != 0;&#125; 其实就是在 mFeatures 和 mLocalFeatures 的基础上，增加了 featureId 的值；ActivityThread -> ActivityThread : 1.handleLaunchActivity ActivityThread -> WindowManagerGlobal : 2.initialize（初始化 wmg 进程单例） ActivityThread -> ActivityThread : 3.performLaunchActivity ActivityThread -> Activity : 4.attach（开始绑定） Activity -> PhoneWindow: 5.new PhoneWindow（创建 PhoneWindow 实例） PhoneWindow --> Activity: 5.return mWindow: PhoneWindow Activity -> PhoneWindow: 6.setWindowControllerCallback（设置回调） Activity -> PhoneWindow: 7.setCallback Activity -> PhoneWindow: 8.setOnWindowDismissedCallback Activity -> PhoneWindow: 9.setWindowManager Activity -> PhoneWindow: 10.getWindowManager PhoneWindow --> Activity: 10.return WindowManagerImpl ActivityThread -> Activity: 11.OnCreate Activity -> Activity: 12.setContentView (设置 layout 布局资源) Activity -> Activity: 13.getWindow Activity -> PhoneWindow: 14.setContentView PhoneWindow -> PhoneWindow: 15.installDecor PhoneWindow -> PhoneWindow: 16.generateDecor PhoneWindow -> DecorView: 17.new DecorView DecorView --> PhoneWindow: 18.return DecorView DecorView -> DecorView: 19.setWindow (设置 PhoneWindow) PhoneWindow -> PhoneWindow: 20.generateLayout(加载布局文件) onResourcesLoaded PhoneWindow -> DecorView: 21.onResourcesLoaded（该方法通过 LayoutInflater 加载布局，addView）{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"sequence-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"sequence-0-options\").value)); var diagram = Diagram.parse(code); diagram.drawSVG(\"sequence-0\", options);","categories":[{"name":"View 视图","slug":"View-视图","permalink":"https://coolqi.top/categories/View-视图/"},{"name":"View 的加载和绘制","slug":"View-视图/View-的加载和绘制","permalink":"https://coolqi.top/categories/View-视图/View-的加载和绘制/"}],"tags":[{"name":"ViewDraw","slug":"ViewDraw","permalink":"https://coolqi.top/tags/ViewDraw/"}]},{"title":"PMS 第 7 篇 - 通过 pm 指令分析 Install 过程","slug":"PMS7-installThroughAdb","date":"2018-05-02T16:00:00.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/05/03/PMS7-installThroughAdb/","link":"","permalink":"https://coolqi.top/2018/05/03/PMS7-installThroughAdb/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现！ 0 综述本篇文章总结下 install package 的过程，在 Abdroid 7.1.1 上安装一个应用有如下的方式： adb install（根据情况转为 cmd package install 或者 pm install） adb shell cmd package install（目前都是优先使用） adb shell pm install; 拷贝 apk 到文件管理器中触发安装； 通过应用商店安装； 这里我们先从 adb install 入手，对于其他的安装方式，我们后面再分析！ 1 adb install - commandline::adb_commandlineadb install 的执行从 system/core/adb/commandline.cpp 开始： adb_commandline 中会涉及到大量的 adb 指令的处理，这里我们只关注 adb install 的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041int adb_commandline(int argc, const char **argv) &#123; ... ... ... else if (!strcmp(argv[0], \"push\")) &#123; // adb push 命令！ bool copy_attrs = false; std::vector&lt;const char*&gt; srcs; const char* dst = nullptr; parse_push_pull_args(&amp;argv[1], argc - 1, &amp;srcs, &amp;dst, &amp;copy_attrs); if (srcs.empty() || !dst) return usage(); return do_sync_push(srcs, dst) ? 0 : 1; &#125; ... ... ... else if (!strcmp(argv[0], \"install\")) &#123; //【1.2】adb install 命令！ if (argc &lt; 2) return usage(); if (_use_legacy_install()) &#123; //【1.2】正常情况下调用 install_app_legacy！ return install_app_legacy(transport_type, serial, argc, argv); &#125; // 如果支持 FeatureCmd，那就调用 install_app return install_app(transport_type, serial, argc, argv); &#125; else if (!strcmp(argv[0], \"install-multiple\")) &#123; // adb install-multiple 命令 if (argc &lt; 2) return usage(); return install_multiple_app(transport_type, serial, argc, argv); &#125; else if (!strcmp(argv[0], \"uninstall\")) &#123; // adb uninstall 命令 if (argc &lt; 2) return usage(); if (_use_legacy_install()) &#123; return uninstall_app_legacy(transport_type, serial, argc, argv); &#125; return uninstall_app(transport_type, serial, argc, argv); &#125; ... ... ... usage(); return 1;&#125; 这里看到： 如果支持 cmd 命令的情况下，会调用 install_app； 如果不支持，执行 install_app_legacy 方法！ 1.1 cmd install - 支持 cmd 指令1.1.1 commandline::install_app123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static int install_app(TransportType transport, const char* serial, int argc, const char** argv) &#123; // The last argument must be the APK file const char* file = argv[argc - 1]; const char* dot = strrchr(file, '.'); bool found_apk = false; struct stat sb; if (dot &amp;&amp; !strcasecmp(dot, \".apk\")) &#123; if (stat(file, &amp;sb) == -1 || !S_ISREG(sb.st_mode)) &#123; fprintf(stderr, \"Invalid APK file: %s\\n\", file); return EXIT_FAILURE; &#125; found_apk = true; &#125; if (!found_apk) &#123; fprintf(stderr, \"Missing APK file\\n\"); return EXIT_FAILURE; &#125; int localFd = adb_open(file, O_RDONLY); if (localFd &lt; 0) &#123; fprintf(stderr, \"Failed to open %s: %s\\n\", file, strerror(errno)); return 1; &#125; std::string error; //【1】使用 cmd package 命令！ std::string cmd = \"exec:cmd package\"; // don't copy the APK name, but, copy the rest of the arguments as-is while (argc-- &gt; 1) &#123; cmd += \" \" + escape_arg(std::string(*argv++)); &#125; // add size parameter [required for streaming installs] // do last to override any user specified value cmd += \" \" + android::base::StringPrintf(\"-S %\" PRIu64, static_cast&lt;uint64_t&gt;(sb.st_size)); int remoteFd = adb_connect(cmd, &amp;error); if (remoteFd &lt; 0) &#123; fprintf(stderr, \"Connect error for write: %s\\n\", error.c_str()); adb_close(localFd); return 1; &#125; char buf[BUFSIZ]; copy_to_file(localFd, remoteFd); read_status_line(remoteFd, buf, sizeof(buf)); adb_close(localFd); adb_close(remoteFd); if (strncmp(\"Success\", buf, 7)) &#123; fprintf(stderr, \"Failed to install %s: %s\", file, buf); return 1; &#125; fputs(buf, stderr); return 0;&#125; 1.1.5 new PackageManagerShellCommand1.1.5.1 onCommand最终，会调用 PackageManagerShellCommand 的 onCommand 方法： 1234567891011121314151617181920212223242526272829303132333435class PackageManagerShellCommand extends ShellCommand &#123; ... ... ... ... @Override public int onCommand(String cmd) &#123; if (cmd == null) &#123; return handleDefaultCommands(cmd); &#125; final PrintWriter pw = getOutPrintWriter(); try &#123; switch(cmd) &#123; case \"install\": //【*1.1.5.2】对于 install 调用，调用 runInstall 方法： return runInstall(); case \"install-abandon\": case \"install-destroy\": return runInstallAbandon(); case \"install-commit\": return runInstallCommit(); case \"install-create\": return runInstallCreate(); case \"install-remove\": return runInstallRemove(); case \"install-write\": return runInstallWrite(); ... ... ... default: return handleDefaultCommands(cmd); &#125; &#125; catch (RemoteException e) &#123; pw.println(\"Remote exception: \" + e); &#125; return -1; &#125;&#125; 这里我们先看 runInstall，其他指令相对于 runInstall 简单了不少！ 1.1.5.2 runInstall123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private int runInstall() throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); //【*1.1.5.2.1】这个和 pm install 的流程是一样的，虽然这个同名方法是在 PackageManagerShellCommand 中，但实际上 // 两个方法的代码一模一样，大家可以参考【*2.9.1】 final InstallParams params = makeInstallParams(); final String inPath = getNextArg(); // 获得安装包的 path！ boolean installExternal = (params.sessionParams.installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0; if (params.sessionParams.sizeBytes &lt; 0 &amp;&amp; inPath != null) &#123; File file = new File(inPath); if (file.isFile()) &#123; if (installExternal) &#123; try &#123; //【1】解析 apk，用于计算 apk 大小！！ ApkLite baseApk = PackageParser.parseApkLite(file, 0); PackageLite pkgLite = new PackageLite(null, baseApk, null, null, null); //【*4.2.3.4.1】调用 PackageHelper 计算空间大小； params.sessionParams.setSize( PackageHelper.calculateInstalledSize(pkgLite, false, params.sessionParams.abiOverride)); &#125; catch (PackageParserException | IOException e) &#123; pw.println(\"Error: Failed to parse APK file : \" + e); return 1; &#125; &#125; else &#123; params.sessionParams.setSize(file.length()); &#125; &#125; &#125; //【*1.1.5.2.2】创建安装事务，返回事务 id！ final int sessionId = doCreateSession(params.sessionParams, params.installerPackageName, params.userId); boolean abandonSession = true; try &#123; if (inPath == null &amp;&amp; params.sessionParams.sizeBytes == 0) &#123; pw.println(\"Error: must either specify a package size or an APK file\"); return 1; &#125; //【*1.1.5.2.3】进一步处理事务，我们可以看到，这种方法只能装 base apk！！ if (doWriteSplit(sessionId, inPath, params.sessionParams.sizeBytes, \"base.apk\", false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; //【*1.1.5.2.4】提交事务！！ if (doCommitSession(sessionId, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; abandonSession = false; pw.println(\"Success\"); return 0; &#125; finally &#123; if (abandonSession) &#123; try &#123; doAbandonSession(sessionId, false /*logSuccess*/); &#125; catch (Exception ignore) &#123; &#125; &#125; &#125;&#125; 1.1.5.2.1 makeInstallParams这个和 pm install 的流程是一样的，虽然这个同名方法是在 PackageManagerShellCommand 中，但实际上两个方法的代码一模一样，大家可以参考【*2.9.1】! 123456789101112131415161718192021private InstallParams makeInstallParams() &#123; //【1】这个 InstallParams 也是内部类，但是和 pm install 中的代码是一样的！ final SessionParams sessionParams = new SessionParams(SessionParams.MODE_FULL_INSTALL); final InstallParams params = new InstallParams(); params.sessionParams = sessionParams; String opt; while ((opt = getNextOption()) != null) &#123; switch (opt) &#123; case \"-l\": sessionParams.installFlags |= PackageManager.INSTALL_FORWARD_LOCK; break; case \"-r\": sessionParams.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; break; ... ... ... default: throw new IllegalArgumentException(\"Unknown option \" + opt); &#125; &#125; return params;&#125; 不多说了！ 1.1.5.2.2 doCreateSession这个和 pm install 的流程是一样的，虽然这个同名方法是在 PackageManagerShellCommand 中，但实际上两个方法的代码几乎一模一样，大家可以参考【*2.9.2】! 123456789101112private int doCreateSession(SessionParams params, String installerPackageName, int userId) throws RemoteException &#123; userId = translateUserId(userId, \"runInstallCreate\"); if (userId == UserHandle.USER_ALL) &#123; userId = UserHandle.USER_SYSTEM; params.installFlags |= PackageManager.INSTALL_ALL_USERS; &#125; //【*3.1】调用 PackageInstallerService 的 createSession 方法，创建实例！ final int sessionId = mInterface.getPackageInstaller() .createSession(params, installerPackageName, userId); return sessionId;&#125; 这里的 mInterface 是 PMS 的代理对象，通过 getPackageInstaller 获得了 PackageInstallerService 实例！ 1.1.5.2.3 doWriteSplitdoWriteSplit 方法和 2.9.3 Pm.doWriteSession 是一样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private int doWriteSplit(int sessionId, String inPath, long sizeBytes, String splitName, boolean logSuccess) throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); if (sizeBytes &lt;= 0) &#123; pw.println(\"Error: must specify a APK size\"); return 1; &#125; if (inPath != null &amp;&amp; !\"-\".equals(inPath)) &#123; pw.println(\"Error: APK content must be streamed\"); return 1; &#125; inPath = null; //【*3.3.2】根据前面创建的 Session id，获得本次安装事务对象！ final SessionInfo info = mInterface.getPackageInstaller().getSessionInfo(sessionId); PackageInstaller.Session session = null; InputStream in = null; OutputStream out = null; try &#123; //【*3.2.1】通过 PackageInstallerService.openSession 获得对应的 PackageInstallerSession 对象！ //【*2.9.3.1】封装成 Session 实例！ session = new PackageInstaller.Session( mInterface.getPackageInstaller().openSession(sessionId)); if (inPath != null) &#123; in = new FileInputStream(inPath); &#125; else &#123; in = new SizedInputStream(getRawInputStream(), sizeBytes); &#125; //【*2.9.3.1.1】定义输出流对象，指向待安装 APK 对应文件的源地址！ out = session.openWrite(splitName, 0, sizeBytes); int total = 0; byte[] buffer = new byte[65536]; int c; while ((c = in.read(buffer)) != -1) &#123; total += c; //【1】拷贝文件到 /data/app/ 目标目录！ out.write(buffer, 0, c); if (info.sizeBytes &gt; 0) &#123; final float fraction = ((float) c / (float) info.sizeBytes); //【2】同时更新进度！ session.addProgress(fraction); &#125; &#125; session.fsync(out); if (logSuccess) &#123; pw.println(\"Success: streamed \" + total + \" bytes\"); &#125; return 0; &#125; catch (IOException e) &#123; pw.println(\"Error: failed to write; \" + e.getMessage()); return 1; &#125; finally &#123; IoUtils.closeQuietly(out); IoUtils.closeQuietly(in); IoUtils.closeQuietly(session); &#125;&#125; 不多说了！ 1.1.5.2.4 doCommitSessiondoWriteSplit 方法和 2.9.4 Pm.doCommitSession 是一样的： 1234567891011121314151617181920212223242526272829private int doCommitSession(int sessionId, boolean logSuccess) throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); PackageInstaller.Session session = null; try &#123; //【×2.9.3.1】和前面一样，重新获得一个 Session 对象！ session = new PackageInstaller.Session( mInterface.getPackageInstaller().openSession(sessionId)); //【×2.9.4.1】创建了一个 LocalIntentReceiver！ final LocalIntentReceiver receiver = new LocalIntentReceiver(); //【×2.9.4.2】将 receiver.getIntentSender() 传递给 pms，用户客户端进程获得安装结果 //【×2.9.4.3】调用 PackageInstallerSession 的 commit 方法，提交事务！ session.commit(receiver.getIntentSender()); //【×2.9.4.4】处理返回结果！ final Intent result = receiver.getResult(); final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (status == PackageInstaller.STATUS_SUCCESS) &#123; if (logSuccess) &#123; pw.println(\"Success\"); &#125; &#125; else &#123; pw.println(\"Failure [\" + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + \"]\"); &#125; return status; &#125; finally &#123; IoUtils.closeQuietly(session); &#125;&#125; 1.2 pm install - 不支持 cmd 指令1.2.1 commandline::install_app_legacy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static int install_app_legacy(TransportType transport, const char* serial, int argc, const char** argv) &#123; // 此时我们需要先将 apk 将拷贝到手机的指定目录下！ //【1】如果是要安装到内部存储，目标路径是 DATA_DEST，如果是存储则是 SD_DEST！ static const char *const DATA_DEST = \"/data/local/tmp/%s\"; static const char *const SD_DEST = \"/sdcard/tmp/%s\"; const char* where = DATA_DEST; int i; struct stat sb; //【2】如果 adb 指令设置了 -s 参数，那就安装到外置存储，默认是内置存储！ for (i = 1; i &lt; argc; i++) &#123; if (!strcmp(argv[i], \"-s\")) &#123; where = SD_DEST; &#125; &#125; //【3】判断是否有 apk 文件参数！ int last_apk = -1; for (i = argc - 1; i &gt;= 0; i--) &#123; const char* file = argv[i]; const char* dot = strrchr(file, '.'); if (dot &amp;&amp; !strcasecmp(dot, \".apk\")) &#123; if (stat(file, &amp;sb) == -1 || !S_ISREG(sb.st_mode)) &#123; fprintf(stderr, \"Invalid APK file: %s\\n\", file); return EXIT_FAILURE; &#125; last_apk = i; break; &#125; &#125; if (last_apk == -1) &#123; fprintf(stderr, \"Missing APK file\\n\"); return EXIT_FAILURE; &#125; int result = -1; std::vector&lt;const char*&gt; apk_file = &#123;argv[last_apk]&#125;; //【4】计算目标位置，将要安装的 apk 拷贝到目标缓存位置 // 同时将 adb 命令的最后一个参数改为 apk 拷贝后的目标缓存位置！ // 目标位置：/data/local/tmp/name.apk! std::string apk_dest = android::base::StringPrintf( where, adb_basename(argv[last_apk]).c_str());、 // do_sync_push 将此 apk 文件传输到目标路径，失败的话将跳转到 clenaup_apk if (!do_sync_push(apk_file, apk_dest.c_str())) goto cleanup_apk; // 设置新位置！ argv[last_apk] = apk_dest.c_str(); //【*1.2.2】执行安装 result = pm_command(transport, serial, argc, argv);cleanup_apk: // 删除目标缓存 apk 文件，PMS 会把该 apk 拷贝到 /data/app 目录下，所以这个缓存中的 apk 没用了！ delete_file(transport, serial, apk_dest); return result;&#125; 其实整个过程很简单，不多说了！ 1.2.2 commandline::pm_command我们继续来分析：12345678910static int pm_command(TransportType transport, const char* serial, int argc, const char** argv) &#123; // 我们看到，这里会将 adb install 命令和参数，转为 pm 指令！ std::string cmd = \"pm\"; while (argc-- &gt; 0) &#123; cmd += \" \" + escape_arg(*argv++); &#125; //【*1.2.3】继续调用 send_shell_command 方法！ return send_shell_command(transport, serial, cmd, false);&#125; 1.2.3 commandline::send_shell_command1234567891011121314151617181920212223242526272829303132333435363738394041424344int send_shell_command(TransportType transport_type, const char* serial, const std::string&amp; command, bool disable_shell_protocol, StandardStreamsCallbackInterface* callback) &#123; int fd; bool use_shell_protocol = false; while (true) &#123; bool attempt_connection = true; // 使用 shell protocol if (!disable_shell_protocol) &#123; FeatureSet features; std::string error; if (adb_get_feature_set(&amp;features, &amp;error)) &#123; // 如果定义了 feature，则替换 shell protocol! use_shell_protocol = CanUseFeature(features, kFeatureShell2); &#125; else &#123; attempt_connection = false; &#125; &#125; if (attempt_connection) &#123; std::string error; // 此时 command 中携带的就是以 pm 开头的命令 std::string service_string = ShellServiceString(use_shell_protocol, \"\", command); // 向 shell protocol 发送命令 fd = adb_connect(service_string, &amp;error); if (fd &gt;= 0) &#123; break; &#125; &#125; fprintf(stderr, \"- waiting for device -\\n\"); if (!wait_for_device(\"wait-for-device\", transport_type, serial)) &#123; return 1; &#125; &#125; // 处理命令执行结果！ int exit_code = read_and_dump(fd, use_shell_protocol, callback); if (adb_close(fd) &lt; 0) &#123; PLOG(ERROR) &lt;&lt; \"failure closing FD \" &lt;&lt; fd; &#125; return exit_code;&#125; 到这里，我们知道，最后其实是向 shell 服务发送 pm 命令，触发 apk 的安装！ 2 pm installcmd 的调用上面已经分析了，其实和 pm install 没有区别！ 这里我们来看下 pm 命令的主要用法，通过 pm install 继续分析安装： 12345678910111213141516171819202122232425262728293031323334usage: pm path [--user USER_ID] PACKAGE pm dump PACKAGE pm install [-lrtsfd] [-i PACKAGE] [--user USER_ID] [PATH] pm install-create [-lrtsfdp] [-i PACKAGE] [-S BYTES] [--install-location 0/1/2] [--force-uuid internal|UUID] pm install-write [-S BYTES] SESSION_ID SPLIT_NAME [PATH] pm install-commit SESSION_ID pm install-abandon SESSION_ID pm uninstall [-k] [--user USER_ID] [--versionCode VERSION_CODE] PACKAGE pm set-installer PACKAGE INSTALLER pm move-package PACKAGE [internal|UUID] pm move-primary-storage [internal|UUID] pm clear [--user USER_ID] PACKAGE pm enable [--user USER_ID] PACKAGE_OR_COMPONENT pm disable [--user USER_ID] PACKAGE_OR_COMPONENT pm disable-user [--user USER_ID] PACKAGE_OR_COMPONENT pm disable-until-used [--user USER_ID] PACKAGE_OR_COMPONENT pm default-state [--user USER_ID] PACKAGE_OR_COMPONENT pm set-user-restriction [--user USER_ID] RESTRICTION VALUE pm hide [--user USER_ID] PACKAGE_OR_COMPONENT pm unhide [--user USER_ID] PACKAGE_OR_COMPONENT pm grant [--user USER_ID] PACKAGE PERMISSION pm revoke [--user USER_ID] PACKAGE PERMISSION pm reset-permissions pm set-app-link [--user USER_ID] PACKAGE &#123;always|ask|never|undefined&#125; pm get-app-link [--user USER_ID] PACKAGE pm set-install-location [0/auto] [1/internal] [2/external] pm get-install-location pm set-permission-enforced PERMISSION [true|false] pm trim-caches DESIRED_FREE_SPACE [internal|UUID] pm create-user [--profileOf USER_ID] [--managed] [--restricted] [--ephemeral] [--guest] USER_NAME pm remove-user USER_ID pm get-max-users pm 命令的源码位于 frameworks/base/cmds/pm 中，我们直接去看下目录结构： 1234567891011.├── Android.mk├── MODULE_LICENSE_APACHE2├── NOTICE├── pm└── src └── com └── android └── commands └── pm └── Pm.java 我们先来看看 Android.mk 中的内容： 1234567891011121314# Copyright 2007 The Android Open Source Project#LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_MODULE := pminclude $(BUILD_JAVA_LIBRARY)include $(CLEAR_VARS)ALL_PREBUILT += $(TARGET_OUT)/bin/pm$(TARGET_OUT)/bin/pm : $(LOCAL_PATH)/pm | $(ACP) $(transform-prebuilt-to-target) 可以看到，编译期间，编译系统会将 pm 脚本放置到 /system/bin/ 目录下。 接着，来看看 pm 脚本的内容：123456# Script to start \"pm\" on the device, which has a very rudimentary# shell.#base=/systemexport CLASSPATH=$base/framework/pm.jarexec app_process $base/bin com.android.commands.pm.Pm \"$@\" 该脚本的作用是通过 app_process 启动 pm java 进程！ 2.1 app_process::mainapp_process 其实就是 Zygote 的源码，在开机篇我们已经分析过了 Zygote 的启动，这里略过和 Zygote 相关的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int main(int argc, char* const argv[]) &#123; ... ... ... ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; //【1】获得要启动的 java 进程的 className className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; //【2】根据 application 的取值，判断我们启动的是应用类型进程，还是工具类型进程！ args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; ... ... ...// zygote 启动才会进入！ &#125; if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; //【2.2】非 Zygote 进程的启动方式如下 runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 接下来，会进入 AndroidRuntime 中去！！ 2.2 AndroidRuntime::start这里的 className 传入的值为 com.android.internal.os.RuntimeInit！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); static const String8 startSystemServer(\"start-system-server\"); for (size_t i = 0; i &lt; options.size(); ++i) &#123; if (options[i] == startSystemServer) &#123; /* track our progress through the boot sequence */ const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); &#125; &#125; const char* rootDir = getenv(\"ANDROID_ROOT\"); if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1); &#125; //const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\"); //ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack); //【1】启动虚拟机！ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); //【2】注册 Android 函数！ if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; //【3】创建一个 String 数组来保存传递进来的参数！ jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; //【4】启动虚拟机的主线程，该主线程不会退出，直到虚拟机退出！ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //【2.3】反射调用 RuntimeInit.main 函数，从 native 层进入 java 世界！ jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; free(slashClassName); ALOGD(\"Shutting down VM\\n\"); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(\"Warning: unable to detach main thread\\n\"); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(\"Warning: VM did not shut down cleanly\\n\");&#125; 通过反射，进入 RuntimeInit 中！ 2.3 RuntimeInit.main12345678910111213141516public static final void main(String[] argv) &#123; enableDdms(); if (argv.length == 2 &amp;&amp; argv[1].equals(\"application\")) &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application\"); redirectLogStreams(); &#125; else &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting tool\"); &#125; //【1】进程一些初始化的操作，比如设置线程的默认异常处理 Handler，设置 Log 系统等等，在进程的启动时，我们分析过！！ commonInit(); //【2.4】这里的关键点在这里！ nativeFinishInit(); if (DEBUG) Slog.d(TAG, \"Leaving RuntimeInit!\");&#125; nativeFinishInit 调用的是 native 方法，位于 AndroidRuntime.cpp 文件中！ 2.4 AR::com_android_internal_os_RuntimeInit_nativeFinishInit12345static void com_android_internal_os_RuntimeInit_nativeFinishInit(JNIEnv* env, jobject clazz)&#123; //【2.5】gCurRuntime 是 AndroidRuntime 子类 AppRuntime 的实例！ gCurRuntime-&gt;onStarted();&#125; 实际上 AndroidRuntime 并没有实现 onStarted 方法，真正是实现是在 App_main.cpp 中的 AppRuntime 类中，他是 AndroidRuntime 的子类！ 2.5 AppRuntime::onStarted1234567891011virtual void onStarted()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool(); //【2.6】执行 AndroidRuntime 的 callMain 方法！ AndroidRuntime* ar = AndroidRuntime::getRuntime(); ar-&gt;callMain(mClassName, mClass, mArgs); IPCThreadState::self()-&gt;stopProcess();&#125; 2.6 AndroidRuntime::callMain12345678910111213141516171819202122232425262728293031323334status_t AndroidRuntime::callMain(const String8&amp; className, jclass clazz, const Vector&lt;String8&gt;&amp; args)&#123; JNIEnv* env; jmethodID methodId; ALOGD(\"Calling main entry %s\", className.string()); env = getJNIEnv(); if (clazz == NULL || env == NULL) &#123; return UNKNOWN_ERROR; &#125; methodId = env-&gt;GetStaticMethodID(clazz, \"main\", \"([Ljava/lang/String;)V\"); if (methodId == NULL) &#123; ALOGE(\"ERROR: could not find method %s.main(String[])\\n\", className.string()); return UNKNOWN_ERROR; &#125; //【1】创建一个 String 数组来封装参数！ jclass stringClass; jobjectArray strArray; const size_t numArgs = args.size(); stringClass = env-&gt;FindClass(\"java/lang/String\"); strArray = env-&gt;NewObjectArray(numArgs, stringClass, NULL); for (size_t i = 0; i &lt; numArgs; i++) &#123; jstring argStr = env-&gt;NewStringUTF(args[i].string()); env-&gt;SetObjectArrayElement(strArray, i, argStr); &#125; //【*2.7】最终反射调用了 Pm.main 方法！ env-&gt;CallStaticVoidMethod(clazz, methodId, strArray); return NO_ERROR;&#125; 2.7 Pm.main1234567891011121314public static void main(String[] args) &#123; int exitCode = 1; try &#123; //【*2.8】执行 Pm.run f方法！ exitCode = new Pm().run(args); &#125; catch (Exception e) &#123; Log.e(TAG, \"Error\", e); System.err.println(\"Error: \" + e); if (e instanceof RemoteException) &#123; System.err.println(PM_NOT_RUNNING_ERR); &#125; &#125; System.exit(exitCode);&#125; 2.8 Pm.runrun 方法中涉及到的命令有很多，这里我们重点关注和 install 相关的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public int run(String[] args) throws RemoteException &#123; boolean validCommand = false; if (args.length &lt; 1) &#123; return showUsage(); &#125; mAm = IAccountManager.Stub.asInterface(ServiceManager.getService(Context.ACCOUNT_SERVICE)); mUm = IUserManager.Stub.asInterface(ServiceManager.getService(Context.USER_SERVICE)); //【1】获得 PacakgeManager 对象！ mPm = IPackageManager.Stub.asInterface(ServiceManager.getService(\"package\")); if (mPm == null) &#123; System.err.println(PM_NOT_RUNNING_ERR); return 1; &#125; //【2】获得 PackageInstallerService 代理对象！ mInstaller = mPm.getPackageInstaller(); mArgs = args; String op = args[0]; mNextArg = 1; ... ... ... //【*2.9】runInstall 方法，执行执行安装！ if (\"install\".equals(op)) &#123; return runInstall(); &#125; ... ... ... ... try &#123; if (args.length == 1) &#123; if (args[0].equalsIgnoreCase(\"-l\")) &#123; validCommand = true; return runShellCommand(\"package\", new String[] &#123; \"list\", \"package\" &#125;); &#125; else if (args[0].equalsIgnoreCase(\"-lf\")) &#123; validCommand = true; return runShellCommand(\"package\", new String[] &#123; \"list\", \"package\", \"-f\" &#125;); &#125; &#125; else if (args.length == 2) &#123; if (args[0].equalsIgnoreCase(\"-p\")) &#123; validCommand = true; return displayPackageFilePath(args[1], UserHandle.USER_SYSTEM); &#125; &#125; return 1; &#125; finally &#123; if (validCommand == false) &#123; if (op != null) &#123; System.err.println(\"Error: unknown command '\" + op + \"'\"); &#125; showUsage(); &#125; &#125;&#125; 继续看！ 2.9 Pm.runInstall我们继续分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private int runInstall() throws RemoteException &#123; //【*2.9.1】创建安装参数 final InstallParams params = makeInstallParams(); final String inPath = nextArg(); // 获得安装 apk 的路径！ boolean installExternal = (params.sessionParams.installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0; if (params.sessionParams.sizeBytes &lt; 0 &amp;&amp; inPath != null) &#123; File file = new File(inPath); if (file.isFile()) &#123; if (installExternal) &#123; try &#123; //【1】解析 apk，用于计算 apk 大小！ ApkLite baseApk = PackageParser.parseApkLite(file, 0); PackageLite pkgLite = new PackageLite(null, baseApk, null, null, null); params.sessionParams.setSize( PackageHelper.calculateInstalledSize(pkgLite, false, params.sessionParams.abiOverride)); &#125; catch (PackageParserException | IOException e) &#123; System.err.println(\"Error: Failed to parse APK file : \" + e); return 1; &#125; &#125; else &#123; params.sessionParams.setSize(file.length()); &#125; &#125; &#125; //【*2.9.2】创建安装 Session！ final int sessionId = doCreateSession(params.sessionParams, params.installerPackageName, params.userId); try &#123; if (inPath == null &amp;&amp; params.sessionParams.sizeBytes == 0) &#123; System.err.println(\"Error: must either specify a package size or an APK file\"); return 1; &#125; //【*2.9.3】该过程其实是将 inPath 指向的 apk 写入到 .tmp 目录下，指定了文件名是 \"base.apk\" if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, \"base.apk\", false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; //【*2.9.4】提交 Session 触发安装！ if (doCommitSession(sessionId, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; System.out.println(\"Success\"); return 0; &#125; finally &#123; try &#123; //【*2.9.5】如果安装异常，忽视本次事务！ mInstaller.abandonSession(sessionId); &#125; catch (Exception ignore) &#123; &#125; &#125;&#125; 2.9.1 Pm.makeInstallParams - 创建事务参数Pm 中会根据传入的安装参数，创建 InstallParams，封装安装参数！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private InstallParams makeInstallParams() &#123; //【*2.9.1.1】创建 SessionParams 实例，封装安装参数！ final SessionParams sessionParams = new SessionParams(SessionParams.MODE_FULL_INSTALL); //【*2.9.1.2】创建 InstallParams，解耦合！ final InstallParams params = new InstallParams(); params.sessionParams = sessionParams; // 设置引用关系！ String opt; //【1】根据额外的参数，设置安装参数！ while ((opt = nextOption()) != null) &#123; switch (opt) &#123; case \"-l\": //【1.1】该应用以 forward locked 方式安装，在该模式下，只有应用自己能够访问自己的代码 // 和非资源文件！ sessionParams.installFlags |= PackageManager.INSTALL_FORWARD_LOCK; break; case \"-r\": //【1.2】替换已存在的 apk sessionParams.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; break; case \"-i\": // 显式指定安装器 params.installerPackageName = nextArg(); if (params.installerPackageName == null) &#123; throw new IllegalArgumentException(\"Missing installer package\"); &#125; break; case \"-t\": // 允许测试应用安装（设置了 android:testOnly） sessionParams.installFlags |= PackageManager.INSTALL_ALLOW_TEST; break; case \"-s\": // 安装到外置存储 sessionParams.installFlags |= PackageManager.INSTALL_EXTERNAL; break; case \"-f\": // 安装到内置存储 sessionParams.installFlags |= PackageManager.INSTALL_INTERNAL; break; case \"-d\": //【1.3】允许降级安装！ sessionParams.installFlags |= PackageManager.INSTALL_ALLOW_DOWNGRADE; break; case \"-g\": //【1.4】授予运行时权限 sessionParams.installFlags |= PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS; break; case \"--dont-kill\": // 安装不会杀 app 进程 sessionParams.installFlags |= PackageManager.INSTALL_DONT_KILL_APP; break; case \"--originating-uri\": sessionParams.originatingUri = Uri.parse(nextOptionData()); break; case \"--referrer\": sessionParams.referrerUri = Uri.parse(nextOptionData()); break; case \"-p\": //【1.5】继承已存在的 apk，appPackageName 用以保存要继承的包名，也就是主 apk 的报名！ sessionParams.mode = SessionParams.MODE_INHERIT_EXISTING; sessionParams.appPackageName = nextOptionData(); if (sessionParams.appPackageName == null) &#123; throw new IllegalArgumentException(\"Missing inherit package name\"); &#125; break; case \"-S\": // 显式指定应用的大小 sessionParams.setSize(Long.parseLong(nextOptionData())); break; case \"--abi\": // 显式指定 abi sessionParams.abiOverride = checkAbiArgument(nextOptionData()); break; case \"--ephemeral\": // 作为一个 lightweight \"ephemeral\" 应用！ sessionParams.installFlags |= PackageManager.INSTALL_EPHEMERAL; break; case \"--user\": // 指定安装的 userId params.userId = UserHandle.parseUserArg(nextOptionData()); break; case \"--install-location\": // 指定安装位置 sessionParams.installLocation = Integer.parseInt(nextOptionData()); break; case \"--force-uuid\": sessionParams.installFlags |= PackageManager.INSTALL_FORCE_VOLUME_UUID; sessionParams.volumeUuid = nextOptionData(); if (\"internal\".equals(sessionParams.volumeUuid)) &#123; sessionParams.volumeUuid = null; &#125; break; case \"--force-sdk\": sessionParams.installFlags |= PackageManager.INSTALL_FORCE_SDK; break; default: throw new IllegalArgumentException(\"Unknown option \" + opt); &#125; &#125; return params;&#125; 额外的参数很多，根据额外的参数，对 SessionParams 进行了属性设置！ sessionParams.installFlags 会根据不同的额外参数，设置不同的二进制位，具体的含义我上面也简单的注释了下。大家可以自己去看源码！ 这里我们要注意下： 如果我们安装的是 split apk 的话，那么我们可以指定 -p 参数，后面指定主 apk 的包名，后面我们会分析其作用！ 2.9.1.1 new SessionParamsSessionParams 定义在 PackageInstaller.java 文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static class SessionParams implements Parcelable &#123; /** &#123;@hide&#125; */ public int mode = MODE_INVALID; /** &#123;@hide&#125; */ public int installFlags; /** &#123;@hide&#125; */ public int installLocation = PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY; // 默认为仅内置 /** &#123;@hide&#125; */ public long sizeBytes = -1; /** &#123;@hide&#125; */ public String appPackageName; // 要继承的主 apk 的包名； /** &#123;@hide&#125; */ public Bitmap appIcon; /** &#123;@hide&#125; */ public String appLabel; /** &#123;@hide&#125; */ public long appIconLastModified = -1; /** &#123;@hide&#125; */ public Uri originatingUri; /** &#123;@hide&#125; */ public int originatingUid = UID_UNKNOWN; /** &#123;@hide&#125; */ public Uri referrerUri; /** &#123;@hide&#125; */ public String abiOverride; /** &#123;@hide&#125; */ public String volumeUuid; /** &#123;@hide&#125; */ public String[] grantedRuntimePermissions; public SessionParams(int mode) &#123; this.mode = mode; &#125; /** &#123;@hide&#125; */ public SessionParams(Parcel source) &#123; mode = source.readInt(); installFlags = source.readInt(); installLocation = source.readInt(); sizeBytes = source.readLong(); appPackageName = source.readString(); appIcon = source.readParcelable(null); appLabel = source.readString(); originatingUri = source.readParcelable(null); originatingUid = source.readInt(); referrerUri = source.readParcelable(null); abiOverride = source.readString(); volumeUuid = source.readString(); grantedRuntimePermissions = source.readStringArray(); &#125; ... ... ... ...&#125; 这里我们来说下 mode 属性，它可以取三个值： 12345678public static final int MODE_INVALID = -1;// 表示：完全替换已存在的 apkpublic static final int MODE_FULL_INSTALL = 1;// 表示：会继承已存在的 apk，可以用于给 apk 添加 split APKS，如果没有已存在的 apk，// 效果和 MODE_FULL_INSTALL 是一样的！public static final int MODE_INHERIT_EXISTING = 2; 我们省略掉暂时用不到的一些接口，后面有机会再分析！ 2.9.1.2 new Pm.InstallParamsInstallParams 类很简单，内部有一个 SessionParams 实例变量，封装安装参数！12345private static class InstallParams &#123; SessionParams sessionParams; String installerPackageName; // 安装器的名字！ int userId = UserHandle.USER_ALL;&#125; 2.9.2 Pm.doCreateSession - 创建事务创建 install Session 对象！ 1234567891011private int doCreateSession(SessionParams params, String installerPackageName, int userId) throws RemoteException &#123; userId = translateUserId(userId, \"runInstallCreate\"); if (userId == UserHandle.USER_ALL) &#123; userId = UserHandle.USER_SYSTEM; params.installFlags |= PackageManager.INSTALL_ALL_USERS; &#125; //【*3.1】进入 PackageInstallerService！ final int sessionId = mInstaller.createSession(params, installerPackageName, userId); return sessionId;&#125; 进入了 PackageInstallerService 服务，创建 Session 对象！ 2.9.3 Pm.doWriteSession - 写入事务（实际上是拷贝文件）回顾下参数： 12//【*2.9.3】将安装 Session 持久化到本地文件！if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, \"base.apk\",...)) 这里的 splitName 值为 “base.apk”； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private int doWriteSession(int sessionId, String inPath, long sizeBytes, String splitName, boolean logSuccess) throws RemoteException &#123; //【1】这里的 inPath 就是前面创建的 /data/local/tmp/ 目录！ if (\"-\".equals(inPath)) &#123; inPath = null; &#125; else if (inPath != null) &#123; final File file = new File(inPath); if (file.isFile()) &#123; sizeBytes = file.length(); &#125; &#125; //【*3.3.2】根据前面创建的 Session id，获得本次安装事务对象！ final SessionInfo info = mInstaller.getSessionInfo(sessionId); PackageInstaller.Session session = null; InputStream in = null; OutputStream out = null; try &#123; //【*3.2.1】通过 PackageInstallerService.openSession 获得对应的 PackageInstallerSession 对象！ //【*2.9.3.1】封装成 Session 实例！ session = new PackageInstaller.Session( mInstaller.openSession(sessionId)); //【3】 定义输入流对象，指向待安装 APK 对应文件的源地址！ if (inPath != null) &#123; in = new FileInputStream(inPath); &#125; else &#123; in = new SizedInputStream(System.in, sizeBytes); &#125; //【*2.9.3.1.1】 定义输出流对象，指向待安装 APK 对应文件的源地址！ out = session.openWrite(splitName, 0, sizeBytes); int total = 0; byte[] buffer = new byte[65536]; int c; while ((c = in.read(buffer)) != -1) &#123; total += c; //【5】拷贝文件到 /data/app/vmdl[sessionId].tmp 目标目录！ out.write(buffer, 0, c); if (info.sizeBytes &gt; 0) &#123; final float fraction = ((float) c / (float) info.sizeBytes); //【6】同时更新拷贝进度 session.addProgress(fraction); &#125; &#125; session.fsync(out); if (logSuccess) &#123; System.out.println(\"Success: streamed \" + total + \" bytes\"); &#125; //【3】拷贝完成，返回 STATUS_SUCCESS！ return PackageInstaller.STATUS_SUCCESS; &#125; catch (IOException e) &#123; System.err.println(\"Error: failed to write; \" + e.getMessage()); return PackageInstaller.STATUS_FAILURE; &#125; finally &#123; IoUtils.closeQuietly(out); IoUtils.closeQuietly(in); IoUtils.closeQuietly(session); &#125;&#125; doWriteSession 整个流程其实就是进行 apk 的拷贝操作！ 2.9.3.1 new PackageInstaller.SessionSession 是对 PackageInstallerSession 的简单封装！ 1234567public static class Session implements Closeable &#123; private IPackageInstallerSession mSession; /** &#123;@hide&#125; */ public Session(IPackageInstallerSession session) &#123; mSession = session; &#125; mSession 指向了对应的 PackageInstallerSession 实例！ 同时其还提供了很多借口，来操作 PackageInstallerSession，这里我们用一张图先简单的看下： 12345678910Session.setProgress -&gt; PackageInstallerSession.setClientProgressSession.setStagingProgress -&gt; PackageInstallerSession.setClientProgressSession.addProgress -&gt; PackageInstallerSession.addClientProgressSession.openWrite -&gt; PackageInstallerSession.openWriteSession.openRead -&gt; PackageInstallerSession.openReadSession.commit -&gt; PackageInstallerSession.commitSession.abandon -&gt; PackageInstallerSession.abandon... ... ... 这里我们先来看目前已经涉及到的一些重要方法： 2.9.3.1.1 Session.openWrite这里的 name 传入的是 base.apk： 12345678910111213141516public @NonNull OutputStream openWrite(@NonNull String name, long offsetBytes, long lengthBytes) throws IOException &#123; try &#123; //【*4.1】这里会调用 PackageInstallerSession 的 openWrite 方法 // 将前面创建 Session 的文件目录 /data/app/vmdl[sessionId].tmp 封装成一个文件描述符对象！ final ParcelFileDescriptor clientSocket = mSession.openWrite(name, offsetBytes, lengthBytes); //【2】获得该文件描述符输出流！ return new FileBridge.FileBridgeOutputStream(clientSocket); &#125; catch (RuntimeException e) &#123; ExceptionUtils.maybeUnwrapIOException(e); throw e; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; mSession.openWrite 方法涉及到了文件相关处理，这里就不过多关注！ 2.9.3.1.2 Session.addProgress123456789public void addProgress(float progress) &#123; try &#123; //【*2.9.3.1.2.1】这里会调用 PackageInstallerSession 的 addClientProgress 方法 // 更新文件读写进度！ mSession.addClientProgress(progress); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 继续来看： 2.9.3.1.2.1 PackageInstallerSession.addClientProgress1234567@Overridepublic void addClientProgress(float progress) &#123; synchronized (mLock) &#123; //【*2.9.3.1.2.2】调用了 setClientProgress 方法！ setClientProgress(mClientProgress + progress); &#125;&#125; 2.9.3.1.2.2 PackageInstallerSession.setClientProgress12345678910@Overridepublic void setClientProgress(float progress) &#123; synchronized (mLock) &#123; //【1】用于第一次更新进度！ final boolean forcePublish = (mClientProgress == 0); mClientProgress = progress; //【*2.9.3.1.2.3】最终，调用 computeProgressLocked 方法！ computeProgressLocked(forcePublish); &#125;&#125; 2.9.3.1.2.3 PackageInstallerSession.computeProgressLocked1234567891011private void computeProgressLocked(boolean forcePublish) &#123; //【1】计算进度！ mProgress = MathUtils.constrain(mClientProgress * 0.8f, 0f, 0.8f) + MathUtils.constrain(mInternalProgress * 0.2f, 0f, 0.2f); //【2】更新进度 if (forcePublish || Math.abs(mProgress - mReportedProgress) &gt;= 0.01) &#123; mReportedProgress = mProgress; //【*3.1.4.2】同时通知事务观察者，进度的变化！ mCallback.onSessionProgressChanged(this, mProgress); &#125;&#125; 逻辑很简单，这里就不多说了！ 2.9.4 Pm.doCommitSession - 提交事务12345678910111213141516171819202122232425262728293031private int doCommitSession(int sessionId, boolean logSuccess) throws RemoteException &#123; PackageInstaller.Session session = null; try &#123; //【*2.9.3.1】获得前面创建的 Session 对象！ session = new PackageInstaller.Session( mInstaller.openSession(sessionId)); //【*2.9.4.1】创建了一个 LocalIntentReceiver！ final LocalIntentReceiver receiver = new LocalIntentReceiver(); //【*2.9.4.2】将 receiver.getIntentSender() 传递给 pms，用户客户端进程获得安装结果 //【*2.9.4.3】调用 PackageInstallerSession 的 commit 方法，提交事务！ session.commit(receiver.getIntentSender()); //【*2.9.4.4】处理返回结果！ final Intent result = receiver.getResult(); final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (status == PackageInstaller.STATUS_SUCCESS) &#123; if (logSuccess) &#123; System.out.println(\"Success\"); &#125; &#125; else &#123; System.err.println(\"Failure [\" + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + \"]\"); &#125; return status; &#125; finally &#123; IoUtils.closeQuietly(session); &#125;&#125; 到这里，提交过程就结束了，最终的逻辑是在 PackageInstallerService 中实现！ 2.9.4.1 new LocalIntentReceiver - 跨进程返回结果LocalIntentReceiver 用来接收安装结果！ 1234567891011121314151617private static class LocalIntentReceiver &#123; //【1】以 Intent 的方式保存安装结果！ private final SynchronousQueue&lt;Intent&gt; mResult = new SynchronousQueue&lt;&gt;(); private IIntentSender.Stub mLocalSender = new IIntentSender.Stub() &#123; @Override public void send(int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) &#123; try &#123; //【1.1】将结果保存到 mResult 中！ mResult.offer(intent, 5, TimeUnit.SECONDS); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;; ... ... ... LocalIntentReceiver 有一个内部成员 mLocalSender，实现了 IIntentSender.Stub，用于跨进程通信！ 系统进程会持有 mLocalSender 对应的代理对象，通过 send 方法，将安装的状态或者结果返回保存到 mResult 中！ 2.9.4.2 LocalIntentReceiver.getIntentSendergetIntentSender 将 getIntentSender 封装到 IntentSender 中，由于 IntentSender 实现了 Parcelable，所以可以跨进程传递： 123public IntentSender getIntentSender() &#123; return new IntentSender((IIntentSender) mLocalSender);&#125; 2.9.4.3 Session.commit12345678public void commit(@NonNull IntentSender statusReceiver) &#123; try &#123; //【*4.2】最终，调用了 PackageInstallerSession 的 commit 方法，进入系统进程！ mSession.commit(statusReceiver); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 继续来看： 2.9.4.4 LocalIntentReceiver.getResultgetResult 用于获得安装结果！ 12345678public Intent getResult() &#123; try &#123; //【1】返回安装结果！ return mResult.take(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125;&#125; 就先分析到这里： #3 PackageInstallerService 下面来分析下 PackageInstallerService 中的逻辑，我们先来看看 PackageInstallerService 的创建，当然，这部分的逻辑是在开机的时候，这里我们再回顾下： 1234567891011121314151617181920212223242526272829303132333435public PackageInstallerService(Context context, PackageManagerService pm) &#123; mContext = context; mPm = pm; //【1】启动了一个 HandlerThread 线程！ mInstallThread = new HandlerThread(TAG); mInstallThread.start(); //【2】创建了 mInstallThread 对应的 Handler； mInstallHandler = new Handler(mInstallThread.getLooper()); //【*3.1.4.1】创建了 Callbacks 实例，用于处理安装回调，传入了子线程的 Loopder！ mCallbacks = new Callbacks(mInstallThread.getLooper()); //【3】创建了 sessions 本地持久化文件和目录对象！ mSessionsFile = new AtomicFile( new File(Environment.getDataSystemDirectory(), \"install_sessions.xml\")); mSessionsDir = new File(Environment.getDataSystemDirectory(), \"install_sessions\"); mSessionsDir.mkdirs(); synchronized (mSessions) &#123; //【4】读取本次持久化文件中的事务，创建对应的 PackageInstallerSession 实例！ readSessionsLocked(); //【5】解决临时拷贝目录和持久化事务的冲突，过程很简单，移除那些没有持久化事务的临时拷贝文件！ reconcileStagesLocked(StorageManager.UUID_PRIVATE_INTERNAL, false /*isEphemeral*/); reconcileStagesLocked(StorageManager.UUID_PRIVATE_INTERNAL, true /*isEphemeral*/); final ArraySet&lt;File&gt; unclaimedIcons = newArraySet( mSessionsDir.listFiles()); for (int i = 0; i &lt; mSessions.size(); i++) &#123; final PackageInstallerSession session = mSessions.valueAt(i); unclaimedIcons.remove(buildAppIconFile(session.sessionId)); &#125; for (File icon : unclaimedIcons) &#123; Slog.w(TAG, \"Deleting orphan icon \" + icon); icon.delete(); &#125; &#125;&#125; 关于 PackageInstallerService 这里就不在过多分析，我们继续看！！ 3.1 PackageInstallerS.createSession(Internal) - 创建事务123456789@Overridepublic int createSession(SessionParams params, String installerPackageName, int userId) &#123; try &#123; //【1】继续来看！ return createSessionInternal(params, installerPackageName, userId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; createSession 方法调用了 createSessionInternal 方法！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private int createSessionInternal(SessionParams params, String installerPackageName, int userId) throws IOException &#123; final int callingUid = Binder.getCallingUid(); //【1】权限检查！ mPm.enforceCrossUserPermission(callingUid, userId, true, true, \"createSession\"); //【2】用户操作检查！ if (mPm.isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) &#123; throw new SecurityException(\"User restriction prevents installing\"); &#125; //【3】如果调用进程的 uid 是 SHELL_UID 或者 ROOT_UID，那么 installFlags 增加爱你 INSTALL_FROM_ADB // 表示通过 adb 进行安装！ if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) &#123; params.installFlags |= PackageManager.INSTALL_FROM_ADB; &#125; else &#123; // 如果是 shell or root，校验下 package 是否属于 uid， mAppOps.checkPackage(callingUid, installerPackageName); // 取消 INSTALL_FROM_ADB 和 INSTALL_ALL_USERS 标志位，设置 INSTALL_REPLACE_EXISTING 标志位！ params.installFlags &amp;= ~PackageManager.INSTALL_FROM_ADB; params.installFlags &amp;= ~PackageManager.INSTALL_ALL_USERS; params.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; &#125; //【4】如果 installFlags 设置了 INSTALL_GRANT_RUNTIME_PERMISSIONS 标志位，那需要判断调用者是否有 // INSTALL_GRANT_RUNTIME_PERMISSIONS 权限！ if ((params.installFlags &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0 &amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission .INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) &#123; throw new SecurityException(\"You need the \" + \"android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission \" + \"to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag\"); &#125; //【5】调整应用的 icon 图标！ if (params.appIcon != null) &#123; final ActivityManager am = (ActivityManager) mContext.getSystemService( Context.ACTIVITY_SERVICE); final int iconSize = am.getLauncherLargeIconSize(); if ((params.appIcon.getWidth() &gt; iconSize * 2) || (params.appIcon.getHeight() &gt; iconSize * 2)) &#123; params.appIcon = Bitmap.createScaledBitmap(params.appIcon, iconSize, iconSize, true); &#125; &#125; //【6】检查 mode 取值是否正确！ switch (params.mode) &#123; case SessionParams.MODE_FULL_INSTALL: case SessionParams.MODE_INHERIT_EXISTING: break; default: throw new IllegalArgumentException(\"Invalid install mode: \" + params.mode); &#125; //【7】根据 installFlags 设置，调整安装位置，如果用户显示设置了位置，系统会对其进行检查，否则 // 系统会选择合适的位置！ if ((params.installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; //【7.1】如果显式指定内置，判断是否合适安装！ if (!PackageHelper.fitsOnInternal(mContext, params.sizeBytes)) &#123; throw new IOException(\"No suitable internal storage available\"); &#125; &#125; else if ((params.installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0) &#123; //【7.2】如果显式指定外置，判断是否合适安装！ if (!PackageHelper.fitsOnExternal(mContext, params.sizeBytes)) &#123; throw new IOException(\"No suitable external storage available\"); &#125; &#125; else if ((params.installFlags &amp; PackageManager.INSTALL_FORCE_VOLUME_UUID) != 0) &#123; params.setInstallFlagsInternal(); &#125; else &#123; //【7.4】默认情况下，进入这里，setInstallFlagsInternal 方法会设置 INSTALL_INTERNAL 标志位 // 取消 INSTALL_EXTERNAL 标志位！ params.setInstallFlagsInternal(); // 选择最好的位置来安装！ final long ident = Binder.clearCallingIdentity(); try &#123; params.volumeUuid = PackageHelper.resolveInstallVolume(mContext, params.appPackageName, params.installLocation, params.sizeBytes); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; final int sessionId; final PackageInstallerSession session; synchronized (mSessions) &#123; //【*3.1.1】判断，同一个 uid 是否有过多的正在处理的 Session，如果超过了 1024 个，那当前就不能执行安装！ final int activeCount = getSessionCount(mSessions, callingUid); if (activeCount &gt;= MAX_ACTIVE_SESSIONS) &#123; throw new IllegalStateException( \"Too many active sessions for UID \" + callingUid); &#125; // 同样。判断同一个 uid，是否已经提交了过多的 Session，如果超过了 1048576 个，那当前就不能执行安装！ final int historicalCount = getSessionCount(mHistoricalSessions, callingUid); if (historicalCount &gt;= MAX_HISTORICAL_SESSIONS) &#123; throw new IllegalStateException( \"Too many historical sessions for UID \" + callingUid); &#125; //【*3.1.2】给本次安装分配一个事务 id！ sessionId = allocateSessionIdLocked(); &#125; final long createdMillis = System.currentTimeMillis(); //【8】决定安装目录，因为默认是内置空间，这里会直接进入 buildStageDir 方法！ File stageDir = null; String stageCid = null; if ((params.installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; final boolean isEphemeral = (params.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0; //【*3.1.3】创建文件临时目录；/data/app/vmdl[sessionId].tmp！ stageDir = buildStageDir(params.volumeUuid, sessionId, isEphemeral); &#125; else &#123; // 如果是外置，会直接返回 \"smdl\" + sessionId + \".tmp\" stageCid = buildExternalStageCid(sessionId); &#125; //【*3.1.4】创建 PackageInstallerSession 对象！ session = new PackageInstallerSession(mInternalCallback, mContext, mPm, mInstallThread.getLooper(), sessionId, userId, installerPackageName, callingUid, params, createdMillis, stageDir, stageCid, false, false); synchronized (mSessions) &#123; //【9】将新创建的 PackageInstallerSession 添加到 mSessions 集合中！ mSessions.put(sessionId, session); &#125; //【*3.1.4.2】通知有新的事务创建了，这里是直接回调 Callback 的接口！！ mCallbacks.notifySessionCreated(session.sessionId, session.userId); //【*3.1.6】持久化事务 Session！ writeSessionsAsync(); return sessionId;&#125; 3.1.1 PackageInstallerS.getSessionCount获得 installerUid 创建的 Session 总数： 12345678910111213private static int getSessionCount(SparseArray&lt;PackageInstallerSession&gt; sessions, int installerUid) &#123; int count = 0; final int size = sessions.size(); for (int i = 0; i &lt; size; i++) &#123; final PackageInstallerSession session = sessions.valueAt(i); //【1】匹配创建者的 uid！ if (session.installerUid == installerUid) &#123; count++; &#125; &#125; return count;&#125; PackageInstallerService 有两个 SparseBooleanArray 成员变量： 12@GuardedBy(\"mSessions\")private final SparseArray&lt;PackageInstallerSession&gt; mSessions = new SparseArray&lt;&gt;(); mSessions 保存了所有正在处理的 Session 实例，下标为创建事务的 uid，值为 PackageInstallerSession 是对 Session 的封装！ 123/** Historical sessions kept around for debugging purposes */@GuardedBy(\"mSessions\")private final SparseArray&lt;PackageInstallerSession&gt; mHistoricalSessions = new SparseArray&lt;&gt;(); mHistoricalSessions 保存了所有已经处理的 Session 实例，下标为创建事务的 uid，值为 PackageInstallerSession 是对 Session 的封装！ ###3.1.2 PackageInstallerS.allocateSessionIdLocked allocateSessionIdLocked 方法用于给新的 Session 分配 id！ 12345678910111213private int allocateSessionIdLocked() &#123; int n = 0; int sessionId; do &#123; sessionId = mRandom.nextInt(Integer.MAX_VALUE - 1) + 1; if (!mAllocatedSessions.get(sessionId, false)) &#123; mAllocatedSessions.put(sessionId, true); return sessionId; &#125; &#125; while (n++ &lt; 32); throw new IllegalStateException(\"Failed to allocate session ID\");&#125; PackageInstallerService 还有一个 SparseBooleanArray 成员变量： 123/** All sessions allocated */@GuardedBy(\"mSessions\")private final SparseBooleanArray mAllocatedSessions = new SparseBooleanArray(); mAllocatedSessions 保存了所有的 Session 实例，包括正在处理和已经处理的（mSessions 和 mHistoricalSessions），下标为创建事务的 uid，值为 PackageInstallerSession 是对 Session 的封装！ 3.1.3 PackageInstallerS.buildStageDir1234private File buildStageDir(String volumeUuid, int sessionId, boolean isEphemeral) &#123; final File stagingDir = buildStagingDir(volumeUuid, isEphemeral); return new File(stagingDir, \"vmdl\" + sessionId + \".tmp\");&#125; 我们可以看到，在安装时，创建的临时文件目录是 /data/app/vmdl[sessionId].tmp！！ 3.1.3.1 PackageInstallerS.buildStagingDirbuildStagingDir 用于返回文件根目录！ 12345678private File buildStagingDir(String volumeUuid, boolean isEphemeral) &#123; if (isEphemeral) &#123; // 如果显示指定了 ephemeral 参数的话，返回的是 /data/app-ephemeral 目录！ return Environment.getDataAppEphemeralDirectory(volumeUuid); &#125; //【1】默认情况，返回的是 /data/app 目录！ return Environment.getDataAppDirectory(volumeUuid);&#125; 3.1.4 new PackageInstallerSession - 事务实例创建 PackageInstallerSession，对前面的 SessionParams 再次封装！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class PackageInstallerSession extends IPackageInstallerSession.Stub &#123; public PackageInstallerSession(PackageInstallerService.InternalCallback callback, Context context, PackageManagerService pm, Looper looper, int sessionId, int userId, String installerPackageName, int installerUid, SessionParams params, long createdMillis, File stageDir, String stageCid, boolean prepared, boolean sealed) &#123; //【×3.1.4.1】InternalCallback 回调！ mCallback = callback; mContext = context; mPm = pm; //【2】创建 Handler 绑定到子线程 mInstallThread，该子线程是在 PackageInstallerService 构造器中创建的！ //【*4.2】这里通过 mHandlerCallback 指定了一个回调函数！ mHandler = new Handler(looper, mHandlerCallback); //【3】基本属性保存 this.sessionId = sessionId; this.userId = userId; this.installerPackageName = installerPackageName; this.installerUid = installerUid; this.params = params; this.createdMillis = createdMillis; this.stageDir = stageDir; // 内置临时目录：/data/app/vmdl[sessionId].tmp； this.stageCid = stageCid; // 默认为 null； if ((stageDir == null) == (stageCid == null)) &#123; throw new IllegalArgumentException( \"Exactly one of stageDir or stageCid stage must be set\"); &#125; mPrepared = prepared; // 传入 false； mSealed = sealed; // 传入 false； //【4】获得 DevicePolicyManager 对象，用于静默安装相关的判断，如果是安装者是设备拥有者， // 可以不检查权限，直接静默安装！ DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService( Context.DEVICE_POLICY_SERVICE); //【5】校验安装者 uid 是否有 INSTALL_PACKAGES 权限！ final boolean isPermissionGranted = (mPm.checkUidPermission(android.Manifest.permission.INSTALL_PACKAGES, installerUid) == PackageManager.PERMISSION_GRANTED); //【6】安装者是否是 root 用户！ final boolean isInstallerRoot = (installerUid == Process.ROOT_UID); //【7】是否强制提醒！ final boolean forcePermissionPrompt = (params.installFlags &amp; PackageManager.INSTALL_FORCE_PERMISSION_PROMPT) != 0; //【8】安装者是否是设备拥有者自身！ mIsInstallerDeviceOwner = (dpm != null) &amp;&amp; dpm.isDeviceOwnerAppOnCallingUser( installerPackageName); //【8】如果 mPermissionsAccepted 为 true，那么我们就可以静默安装！ if ((isPermissionGranted || isInstallerRoot || mIsInstallerDeviceOwner) &amp;&amp; !forcePermissionPrompt) &#123; mPermissionsAccepted = true; &#125; else &#123; mPermissionsAccepted = false; &#125; final long identity = Binder.clearCallingIdentity(); try &#123; //【1】获得 container 的 uid 和 gid！ final int uid = mPm.getPackageUid(PackageManagerService.DEFAULT_CONTAINER_PACKAGE, PackageManager.MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM); defaultContainerGid = UserHandle.getSharedAppGid(uid); &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; &#125; 可以看到 PackageInstallerSession 除了用来表示一个 Session 之外，由于继承了 IPackageInstallerSession.Stub，因此其还可以作为服务端的桩对象，进行跨进程的通信！ 这里的 DEFAULT_CONTAINER_PACKAGE 是一个字符串常量：1static final String DEFAULT_CONTAINER_PACKAGE = \"com.android.defcontainer\"; 3.1.4.1 new InternalCallback在创建 PackageInstallerSession 时，我们传入了一个回调对象 InternalCallback： 1private final InternalCallback mInternalCallback = new InternalCallback(); InternalCallback 类定义在 PackageInstallerService 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class InternalCallback &#123; public void onSessionBadgingChanged(PackageInstallerSession session) &#123; mCallbacks.notifySessionBadgingChanged(session.sessionId, session.userId); //【*3.1.6】更新持久化文件 writeSessionsAsync(); &#125; //【1】当 Session 的活跃状态发生变化时，回调触发！ public void onSessionActiveChanged(PackageInstallerSession session, boolean active) &#123; mCallbacks.notifySessionActiveChanged(session.sessionId, session.userId, active); &#125; //【2】当 Session 的进度发生了变化，会触发该方法！ public void onSessionProgressChanged(PackageInstallerSession session, float progress) &#123; mCallbacks.notifySessionProgressChanged(session.sessionId, session.userId, progress); &#125; //【3】当 Session 完成后，会触发该方法！ public void onSessionFinished(final PackageInstallerSession session, boolean success) &#123; mCallbacks.notifySessionFinished(session.sessionId, session.userId, success); mInstallHandler.post(new Runnable() &#123; @Override public void run() &#123; synchronized (mSessions) &#123; mSessions.remove(session.sessionId); mHistoricalSessions.put(session.sessionId, session); final File appIconFile = buildAppIconFile(session.sessionId); if (appIconFile.exists()) &#123; appIconFile.delete(); &#125; //【*3.1.6.1】更新持久化文件 writeSessionsLocked(); &#125; &#125; &#125;); &#125; public void onSessionPrepared(PackageInstallerSession session) &#123; //【*3.1.6】更新持久化文件 writeSessionsAsync(); &#125; public void onSessionSealedBlocking(PackageInstallerSession session) &#123; synchronized (mSessions) &#123; //【*3.1.6.1】更新持久化文件 writeSessionsLocked(); &#125; &#125;&#125; 可以看到，当 Session 的状态发生变化后，InternalCallback 回调会触发！ 同时会回调 mCallbacks 的一些接口，而 mCallbacks 是在 PackageInstallerService 中创建的： 123456public PackageInstallerService(Context context, PackageManagerService pm) &#123; ... ... ... //【*3.1.4.1.1】初始化 Callbacks！ mCallbacks = new Callbacks(mInstallThread.getLooper()); ... ... ...&#125; 我们来看下 Callbacks 的逻辑！ 3.1.4.1.1 new CallbacksCallbacks 是 Handler 的子类，持有子线程 mInstallThread 的 looper，Callbacks 是在 12345678910111213141516private static class Callbacks extends Handler &#123; private static class Callbacks extends Handler &#123; //【1】内部会处理的消息！ private static final int MSG_SESSION_CREATED = 1; private static final int MSG_SESSION_BADGING_CHANGED = 2; private static final int MSG_SESSION_ACTIVE_CHANGED = 3; private static final int MSG_SESSION_PROGRESS_CHANGED = 4; private static final int MSG_SESSION_FINISHED = 5; //【2】监听安装状态的观察者 list private final RemoteCallbackList&lt;IPackageInstallerCallback&gt; mCallbacks = new RemoteCallbackList&lt;&gt;(); public Callbacks(Looper looper) &#123; super(looper); &#125; Callbacks 内部有一个 list，保存了所有监听 Session 状态变化的观察者，同时提供了 register 接口，动态注册观察者！1234567public void register(IPackageInstallerCallback callback, int userId) &#123; mCallbacks.register(callback, new UserHandle(userId));&#125;public void unregister(IPackageInstallerCallback callback) &#123; mCallbacks.unregister(callback);&#125; Callbacks 内部有如下的 notify 接口，来通知 Session 的状态变化！ 3.1.4.1.2 Callbacks.notifySessionXXXX1234567891011121314151617181920 private void notifySessionCreated(int sessionId, int userId) &#123; obtainMessage(MSG_SESSION_CREATED, sessionId, userId).sendToTarget(); &#125; private void notifySessionBadgingChanged(int sessionId, int userId) &#123; obtainMessage(MSG_SESSION_BADGING_CHANGED, sessionId, userId).sendToTarget(); &#125; private void notifySessionActiveChanged(int sessionId, int userId, boolean active) &#123; obtainMessage(MSG_SESSION_ACTIVE_CHANGED, sessionId, userId, active).sendToTarget(); &#125; private void notifySessionProgressChanged(int sessionId, int userId, float progress) &#123; obtainMessage(MSG_SESSION_PROGRESS_CHANGED, sessionId, userId, progress).sendToTarget(); &#125; public void notifySessionFinished(int sessionId, int userId, boolean success) &#123; obtainMessage(MSG_SESSION_FINISHED, sessionId, userId, success).sendToTarget(); &#125;&#125; 本质上是发送不同的 msg，下面来看看： 3.1.4.1.3 Callbacks.handleMessage12345678910111213141516171819@Overridepublic void handleMessage(Message msg) &#123; final int userId = msg.arg2; final int n = mCallbacks.beginBroadcast(); for (int i = 0; i &lt; n; i++) &#123; //【1】遍历所有的观察者 final IPackageInstallerCallback callback = mCallbacks.getBroadcastItem(i); final UserHandle user = (UserHandle) mCallbacks.getBroadcastCookie(i); // TODO: dispatch notifications for slave profiles if (userId == user.getIdentifier()) &#123; try &#123; //【*3.1.4.1.3】分发 Session 消息给观察者！ invokeCallback(callback, msg); &#125; catch (RemoteException ignored) &#123; &#125; &#125; &#125; mCallbacks.finishBroadcast();&#125; 最后调用了 invokeCallback，其实可以看到 IPackageInstallerCallback 针对于不同的消息也有不同的接口： 3.1.4.1.4 Callbacks.invokeCallback继续分析：123456789101112131415161718192021private void invokeCallback(IPackageInstallerCallback callback, Message msg) throws RemoteException &#123; final int sessionId = msg.arg1; switch (msg.what) &#123; case MSG_SESSION_CREATED: callback.onSessionCreated(sessionId); break; case MSG_SESSION_BADGING_CHANGED: callback.onSessionBadgingChanged(sessionId); break; case MSG_SESSION_ACTIVE_CHANGED: callback.onSessionActiveChanged(sessionId, (boolean) msg.obj); break; case MSG_SESSION_PROGRESS_CHANGED: callback.onSessionProgressChanged(sessionId, (float) msg.obj); break; case MSG_SESSION_FINISHED: callback.onSessionFinished(sessionId, (boolean) msg.obj); break; &#125;&#125; 这里我们先分析到这里！ 3.1.6 PackageInstallerS.writeSessionsAsync - 持久化事务1234567891011private void writeSessionsAsync() &#123; IoThread.getHandler().post(new Runnable() &#123; @Override public void run() &#123; synchronized (mSessions) &#123; //【*3.1.6.1】将事务记录到 mSessionsFile 文件中！ writeSessionsLocked(); &#125; &#125; &#125;);&#125; 3.1.6.1 PackageInstallerS.writeSessionsLockedmSessionsFile 在 PackageInstallerService 构造器中有见过：/data/system/install_sessions.xml！！123456789101112131415161718192021222324252627private void writeSessionsLocked() &#123; if (LOGD) Slog.v(TAG, \"writeSessionsLocked()\"); FileOutputStream fos = null; try &#123; fos = mSessionsFile.startWrite(); XmlSerializer out = new FastXmlSerializer(); out.setOutput(fos, StandardCharsets.UTF_8.name()); out.startDocument(null, true); out.startTag(null, TAG_SESSIONS); //【1】写入 sessions 标签！ final int size = mSessions.size(); for (int i = 0; i &lt; size; i++) &#123; final PackageInstallerSession session = mSessions.valueAt(i); //【*3.1.6.2】写入所有的 Sessions！！ writeSessionLocked(out, session); &#125; out.endTag(null, TAG_SESSIONS); out.endDocument(); mSessionsFile.finishWrite(fos); &#125; catch (IOException e) &#123; if (fos != null) &#123; mSessionsFile.failWrite(fos); &#125; &#125;&#125; 3.1.6.2 PackageInstallerS.writeSessionLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void writeSessionLocked(XmlSerializer out, PackageInstallerSession session) throws IOException &#123; final SessionParams params = session.params; out.startTag(null, TAG_SESSION); // 写入 session 标签 writeIntAttribute(out, ATTR_SESSION_ID, session.sessionId); // 写入 sessionId 属性 writeIntAttribute(out, ATTR_USER_ID, session.userId); // 写入 userId 属性 writeStringAttribute(out, ATTR_INSTALLER_PACKAGE_NAME, // 写入 installerPackageName 属性 session.installerPackageName); writeIntAttribute(out, ATTR_INSTALLER_UID, session.installerUid); // 写入 installerUid 属性 writeLongAttribute(out, ATTR_CREATED_MILLIS, session.createdMillis); // 写入 createdMillis 属性 if (session.stageDir != null) &#123; writeStringAttribute(out, ATTR_SESSION_STAGE_DIR, // 写入 sessionStageDir 属性 session.stageDir.getAbsolutePath()); &#125; if (session.stageCid != null) &#123; writeStringAttribute(out, ATTR_SESSION_STAGE_CID, session.stageCid); // 写入 sessionStageCid 属性 &#125; writeBooleanAttribute(out, ATTR_PREPARED, session.isPrepared()); // 写入 prepared 属性 writeBooleanAttribute(out, ATTR_SEALED, session.isSealed()); // 写入 sealed 属性 writeIntAttribute(out, ATTR_MODE, params.mode); // 写入 mode 子标签 writeIntAttribute(out, ATTR_INSTALL_FLAGS, params.installFlags); // 写入 installFlags 属性 writeIntAttribute(out, ATTR_INSTALL_LOCATION, params.installLocation); // 写入 installLocation 属性 writeLongAttribute(out, ATTR_SIZE_BYTES, params.sizeBytes); // 写入 sizeBytes 属性 writeStringAttribute(out, ATTR_APP_PACKAGE_NAME, params.appPackageName); // 写入 appPackageName 属性 writeStringAttribute(out, ATTR_APP_LABEL, params.appLabel); // 写入 appLabel 属性 writeUriAttribute(out, ATTR_ORIGINATING_URI, params.originatingUri); // 写入 originatingUri 属性 writeIntAttribute(out, ATTR_ORIGINATING_UID, params.originatingUid); // 写入 originatingUid 属性 writeUriAttribute(out, ATTR_REFERRER_URI, params.referrerUri); // 写入 referrerUri 属性 writeStringAttribute(out, ATTR_ABI_OVERRIDE, params.abiOverride); // 写入 abiOverride 属性 writeStringAttribute(out, ATTR_VOLUME_UUID, params.volumeUuid); // 写入 volumeUuid 属性 // Persist app icon if changed since last written final File appIconFile = buildAppIconFile(session.sessionId); if (params.appIcon == null &amp;&amp; appIconFile.exists()) &#123; appIconFile.delete(); &#125; else if (params.appIcon != null &amp;&amp; appIconFile.lastModified() != params.appIconLastModified) &#123; if (LOGD) Slog.w(TAG, \"Writing changed icon \" + appIconFile); FileOutputStream os = null; try &#123; os = new FileOutputStream(appIconFile); params.appIcon.compress(CompressFormat.PNG, 90, os); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Failed to write icon \" + appIconFile + \": \" + e.getMessage()); &#125; finally &#123; IoUtils.closeQuietly(os); &#125; params.appIconLastModified = appIconFile.lastModified(); &#125; //【*3.1.6.3】将要在安装时授予的运行时权限集合写入到持久化文件中！ writeGrantedRuntimePermissions(out, params.grantedRuntimePermissions); out.endTag(null, TAG_SESSION);&#125; 3.1.6.3 PackageInstallerS.writeGrantedRuntimePermissions12345678910private static void writeGrantedRuntimePermissions(XmlSerializer out, String[] grantedRuntimePermissions) throws IOException &#123; if (grantedRuntimePermissions != null) &#123; for (String permission : grantedRuntimePermissions) &#123; out.startTag(null, TAG_GRANTED_RUNTIME_PERMISSION); // 写入 granted-runtime-permission 子标签 writeStringAttribute(out, ATTR_NAME, permission); // 写入 name 属性！ out.endTag(null, TAG_GRANTED_RUNTIME_PERMISSION); &#125; &#125;&#125; 3.2 PackageInstallerS.openSession - 获得事务openSession 方法可以获得 id 对应的 PackageInstallerSession！ 123456789@Overridepublic IPackageInstallerSession openSession(int sessionId) &#123; try &#123; //【*3.2.1】调用另外一个方法！ return openSessionInternal(sessionId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; 3.2.1 PackageInstallerS.openSessionInternal1234567891011private IPackageInstallerSession openSessionInternal(int sessionId) throws IOException &#123; synchronized (mSessions) &#123; final PackageInstallerSession session = mSessions.get(sessionId); //【*3.2.2】判断 uid 是否被允许获得该事务！ if (session == null || !isCallingUidOwner(session)) &#123; throw new SecurityException(\"Caller has no access to session \" + sessionId); &#125; session.open(); return session; &#125;&#125; 3.2.2 PackageInstallerS.isCallingUidOwner12345678910private boolean isCallingUidOwner(PackageInstallerSession session) &#123; final int callingUid = Binder.getCallingUid(); if (callingUid == Process.ROOT_UID) &#123; //【1】要么是 root 用户！ return true; &#125; else &#123; //【2】要么调用者的 uid 必须是事务的创建者 uid！ return (session != null) &amp;&amp; (callingUid == session.installerUid); &#125;&#125; 3.3 PackageInstallerS.getSessionInfo - 获得事务getSessionInfo 方法也是获得 id 对应的 Session 实例，但是封装的结果不同！ 12345678@Overridepublic SessionInfo getSessionInfo(int sessionId) &#123; synchronized (mSessions) &#123; final PackageInstallerSession session = mSessions.get(sessionId); //【*3.3.1】调用 PackageInstallerSession 的 generateInfo 方法！ return session != null ? session.generateInfo() : null; &#125;&#125; 3.3.1 PackageInstallerSession.generateInfoPackageInstallerSession 会返回一个 SessionInfo 对象！用于保存 Session 的一些细节信息！ 12345678910111213141516171819public SessionInfo generateInfo() &#123; final SessionInfo info = new SessionInfo(); synchronized (mLock) &#123; info.sessionId = sessionId; info.installerPackageName = installerPackageName; info.resolvedBaseCodePath = (mResolvedBaseFile != null) ? mResolvedBaseFile.getAbsolutePath() : null; info.progress = mProgress; info.sealed = mSealed; info.active = mActiveCount.get() &gt; 0; info.mode = params.mode; info.sizeBytes = params.sizeBytes; info.appPackageName = params.appPackageName; info.appIcon = params.appIcon; info.appLabel = params.appLabel; &#125; return info;&#125; 3.3.2 new PackageInstaller.SessionInfoSessionInfo 定义在 PackageInstaller.java 中，用于保存 Session 的信息，这里我们简单的分析下！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static class SessionInfo implements Parcelable &#123; /** &#123;@hide&#125; */ public int sessionId; /** &#123;@hide&#125; */ public String installerPackageName; /** &#123;@hide&#125; */ public String resolvedBaseCodePath; /** &#123;@hide&#125; */ public float progress; /** &#123;@hide&#125; */ public boolean sealed; /** &#123;@hide&#125; */ public boolean active; /** &#123;@hide&#125; */ public int mode; /** &#123;@hide&#125; */ public long sizeBytes; /** &#123;@hide&#125; */ public String appPackageName; /** &#123;@hide&#125; */ public Bitmap appIcon; /** &#123;@hide&#125; */ public CharSequence appLabel; /** &#123;@hide&#125; */ public SessionInfo() &#123; &#125; /** &#123;@hide&#125; */ public SessionInfo(Parcel source) &#123; sessionId = source.readInt(); installerPackageName = source.readString(); resolvedBaseCodePath = source.readString(); progress = source.readFloat(); sealed = source.readInt() != 0; active = source.readInt() != 0; mode = source.readInt(); sizeBytes = source.readLong(); appPackageName = source.readString(); appIcon = source.readParcelable(null); appLabel = source.readString(); &#125; ... ... ...&#125; 4 PackageInstallerSession4.1 openWrite这里的 name 传入的是 base.apk 123456789@Overridepublic ParcelFileDescriptor openWrite(String name, long offsetBytes, long lengthBytes) &#123; try &#123; //【*4.1.1】继续调用 openWriteInternal 方法处理； return openWriteInternal(name, offsetBytes, lengthBytes); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; 4.1.1 openWriteInternal继续来看，这里的参数 name 传入的是 “base.apk” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private ParcelFileDescriptor openWriteInternal(String name, long offsetBytes, long lengthBytes) throws IOException &#123; final FileBridge bridge; synchronized (mLock) &#123; assertPreparedAndNotSealed(\"openWrite\"); bridge = new FileBridge(); mBridges.add(bridge); &#125; try &#123; if (!FileUtils.isValidExtFilename(name)) &#123; throw new IllegalArgumentException(\"Invalid name: \" + name); &#125; final File target; final long identity = Binder.clearCallingIdentity(); try &#123; //【1】创建 /data/app/vmdl[sessionId].tmp/base.apk 对应的文件对象！ target = new File(resolveStageDir(), name); &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; //【2】返回其文件描述符； final FileDescriptor targetFd = Libcore.os.open(target.getAbsolutePath(), O_CREAT | O_WRONLY, 0644); Os.chmod(target.getAbsolutePath(), 0644); //【3】如果指定了大小，那么这里会做一次空间回收！ if (lengthBytes &gt; 0) &#123; final StructStat stat = Libcore.os.fstat(targetFd); final long deltaBytes = lengthBytes - stat.st_size; //【3.1】回收空间； if (stageDir != null &amp;&amp; deltaBytes &gt; 0) &#123; mPm.freeStorage(params.volumeUuid, deltaBytes); &#125; Libcore.os.posix_fallocate(targetFd, 0, lengthBytes); &#125; if (offsetBytes &gt; 0) &#123; Libcore.os.lseek(targetFd, offsetBytes, OsConstants.SEEK_SET); &#125; //【4】使用 FileBridge 封装文件描述符！ bridge.setTargetFile(targetFd); bridge.start(); return new ParcelFileDescriptor(bridge.getClientSocket()); &#125; catch (ErrnoException e) &#123; throw e.rethrowAsIOException(); &#125;&#125; 整个方法很简单，不多说了！ 4.2 commit - 提交事务核心入口在上面我们分析到，会进入 PackageInstallerSession.commit 提交事务。下面我们继续来分析！ 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void commit(IntentSender statusReceiver) &#123; Preconditions.checkNotNull(statusReceiver); final boolean wasSealed; synchronized (mLock) &#123; wasSealed = mSealed; if (!mSealed) &#123; // 校验所有的写操作都已经完成了，正常情况下，是肯定完成了的！ for (FileBridge bridge : mBridges) &#123; if (!bridge.isClosed()) &#123; throw new SecurityException(\"Files still open\"); &#125; &#125; mSealed = true; &#125; //【1】由于此时文件已经拷贝完成，这里更新进度为完成！ mClientProgress = 1f; //【*4.2.3.5】通知结果！ computeProgressLocked(true); &#125; if (!wasSealed) &#123; // Persist the fact that we've sealed ourselves to prevent // mutations of any hard links we create. We do this without holding // the session lock, since otherwise it's a lock inversion. mCallback.onSessionSealedBlocking(this); &#125; //【2】活跃计数 +1，表示该 Session 处于活跃状态； mActiveCount.incrementAndGet(); //【*4.2.1】创建了一个 PackageInstallObserverAdapter 实例！ // 会将前面创建的 IntentSender 实例，作为参数传入！ final PackageInstallObserverAdapter adapter = new PackageInstallObserverAdapter(mContext, statusReceiver, sessionId, mIsInstallerDeviceOwner, userId); //【*4.2.2】发送 MSG_COMMIT 消息 mHandler.obtainMessage(MSG_COMMIT, adapter.getBinder()).sendToTarget();&#125; mActiveCount 加 1，表示该事务处于活跃状态，直到安装完成！ 这里的 PackageInstallObserverAdapter.getBinder() 返回是一个服务端 Stub 桩对象！ 整个流程很清晰，我们继续看： 4.2.1 new PackageInstallObserverAdapterPackageInstallObserverAdapter 定义在 PackageInstallService 中： 123456789101112131415static class PackageInstallObserverAdapter extends PackageInstallObserver &#123; private final Context mContext; // 系统进程的上下文 private final IntentSender mTarget; // 前面创建的 IntentSender 实例 private final int mSessionId; // 事务的 id！ private final boolean mShowNotification; // 是否显示通知，取决于安装者是否是设备用户！ private final int mUserId; public PackageInstallObserverAdapter(Context context, IntentSender target, int sessionId, boolean showNotification, int userId) &#123; mContext = context; mTarget = target; mSessionId = sessionId; mShowNotification = showNotification; mUserId = userId; &#125; PackageInstallObserverAdapter 继承了 PackageInstallObserver： 12345678910111213141516171819202122232425public class PackageInstallObserver &#123; //【1】服务端桩对象！ private final IPackageInstallObserver2.Stub mBinder = new IPackageInstallObserver2.Stub() &#123; @Override public void onUserActionRequired(Intent intent) &#123; //【1.1】调用子类的 onUserActionRequired 方法！ PackageInstallObserver.this.onUserActionRequired(intent); &#125; @Override public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) &#123; //【1.2】调用子类的 onPackageInstalled 方法！ PackageInstallObserver.this.onPackageInstalled(basePackageName, returnCode, msg, extras); &#125; &#125;; /** &#123;@hide&#125; */ public IPackageInstallObserver2 getBinder() &#123; //【2】用于返回服务端桩对象！ return mBinder; &#125; ... ... ...&#125; PackageInstallObserverAdapter 继承了 PackageInstallObserver，并覆写了以下两个方法： 12onUserActionRequiredonPackageInstalled 4.2.1.1 PackageInstallObserverAdapter.onUserActionRequired覆写 onUserActionRequired，当安装过程需要用户参与授权时，会回调该接口，此时会中断安装，事务从 active 变为 idle 状态！ 123456789101112131415@Overridepublic void onUserActionRequired(Intent intent) &#123; final Intent fillIn = new Intent(); //【1】事务 id！ fillIn.putExtra(PackageInstaller.EXTRA_SESSION_ID, mSessionId); //【2】当前的状态：PackageInstaller.STATUS_PENDING_USER_ACTION！ fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_PENDING_USER_ACTION); fillIn.putExtra(Intent.EXTRA_INTENT, intent); // 额外的 intent try &#123; //【*2.9.4.1】发送 intent，其实，这里我们知道，该 intent 会发送到前面的 LocalIntentReceiver! mTarget.sendIntent(mContext, 0, fillIn, null, null); &#125; catch (SendIntentException ignored) &#123; &#125;&#125; 关于这个额外的 Intent，我们后面会看到！ 4.1.1.2 PackageInstallObserverAdapter.onPackageInstalled覆写 onPackageInstalled，当安装完成后，会回调该接口！ 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) &#123; //【1】当安装成功，并且需要弹出通知时，会在这里显示通知！ if (PackageManager.INSTALL_SUCCEEDED == returnCode &amp;&amp; mShowNotification) &#123; boolean update = (extras != null) &amp;&amp; extras.getBoolean(Intent.EXTRA_REPLACING); Notification notification = buildSuccessNotification(mContext, mContext.getResources() .getString(update ? R.string.package_updated_device_owner : R.string.package_installed_device_owner), basePackageName, mUserId); if (notification != null) &#123; NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE); notificationManager.notify(basePackageName, 0, notification); &#125; &#125; //【2】创建一个 intent，保存了安装结果等信息！ final Intent fillIn = new Intent(); fillIn.putExtra(PackageInstaller.EXTRA_PACKAGE_NAME, basePackageName); fillIn.putExtra(PackageInstaller.EXTRA_SESSION_ID, mSessionId); fillIn.putExtra(PackageInstaller.EXTRA_STATUS, PackageManager.installStatusToPublicStatus(returnCode)); fillIn.putExtra(PackageInstaller.EXTRA_STATUS_MESSAGE, PackageManager.installStatusToString(returnCode, msg)); fillIn.putExtra(PackageInstaller.EXTRA_LEGACY_STATUS, returnCode); if (extras != null) &#123; final String existing = extras.getString( PackageManager.EXTRA_FAILURE_EXISTING_PACKAGE); if (!TextUtils.isEmpty(existing)) &#123; fillIn.putExtra(PackageInstaller.EXTRA_OTHER_PACKAGE_NAME, existing); &#125; &#125; try &#123; //【*2.9.4.1】发送 intent，其实，这里我们知道，该 intent 会发送到前面的 LocalIntentReceiver mTarget.sendIntent(mContext, 0, fillIn, null, null); &#125; catch (SendIntentException ignored) &#123; &#125;&#125; 我们继续分析！ 4.2.2 send MSG_COMMIT代码片段如下： 12//【*4.2.2.1】发送 MSG_COMMIT 消息mHandler.obtainMessage(MSG_COMMIT, adapter.getBinder()).sendToTarget(); mHandler 的初始化是在 PackageInstallerSession 的构造器中： 1234567891011public PackageInstallerSession(PackageInstallerService.InternalCallback callback, Context context, PackageManagerService pm, Looper looper, int sessionId, int userId, String installerPackageName, int installerUid, SessionParams params, long createdMillis, File stageDir, String stageCid, boolean prepared, boolean sealed) &#123; mCallback = callback; mContext = context; mPm = pm; //【*4.2.1】handler 会处理该消息，我们看到，其传入了一个 mHandlerCallback 回调！ mHandler = new Handler(looper, mHandlerCallback); ... ... ...&#125; 如果我们直接发送 MSG_COMMIT 消息，回调 mHandlerCallback 会立刻触发： 4.2.2.1 Handler.Callback.handleMessage[MSG_COMMIT]12345678910111213141516171819202122232425262728293031private final Handler.Callback mHandlerCallback = new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; //【1】获得要安装的应用的信息，如果是第一次安装的话，那么二者返回的均为 null！ final PackageInfo pkgInfo = mPm.getPackageInfo( params.appPackageName, PackageManager.GET_SIGNATURES /*flags*/, userId); final ApplicationInfo appInfo = mPm.getApplicationInfo( params.appPackageName, 0, userId); synchronized (mLock) &#123; if (msg.obj != null) &#123; //【2】获得前面 PackageInstallObserverAdapter 内部的 PackageInstallObserver2 桩对象！ // 保存到了 mRemoteObserver 中！ mRemoteObserver = (IPackageInstallObserver2) msg.obj; &#125; try &#123; //【*4.2.3】调用 commitLocked 继续处理！ commitLocked(pkgInfo, appInfo); &#125; catch (PackageManagerException e) &#123; final String completeMsg = ExceptionUtils.getCompleteMessage(e); Slog.e(TAG, \"Commit of session \" + sessionId + \" failed: \" + completeMsg); destroyInternal(); dispatchSessionFinished(e.error, completeMsg, null); &#125; return true; &#125; &#125;&#125;; PackageInstallerSession 内部有一个 mRemoteObserver 成员变量，后面我们会见到： 12@GuardedBy(\"mLock\")private IPackageInstallObserver2 mRemoteObserver; 接下来，进入了 commitLocked 方法！ 4.2.3 commitLocked继续来看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125private void commitLocked(PackageInfo pkgInfo, ApplicationInfo appInfo) throws PackageManagerException &#123; if (mDestroyed) &#123; throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, \"Session destroyed\"); &#125; if (!mSealed) &#123; throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, \"Session not sealed\"); &#125; try &#123; //【*4.2.3.1】解析安装地址，即前文APK文件copy后的目的地址 resolveStageDir(); &#125; catch (IOException e) &#123; throw new PackageManagerException(INSTALL_FAILED_CONTAINER_ERROR, \"Failed to resolve stage location\", e); &#125; //【*4.2.3.2】校验安装有效性！ validateInstallLocked(pkgInfo, appInfo); Preconditions.checkNotNull(mPackageName); // 非 null 校验！ Preconditions.checkNotNull(mSignatures); Preconditions.checkNotNull(mResolvedBaseFile); //【1】mPermissionsAccepted 为 true，那么用户就可以静默安装了，如果为 false，那么就需要用户确认权限！！ if (!mPermissionsAccepted) &#123; //【1.1】这里会创建一个 intent， action 为 PackageInstaller.ACTION_CONFIRM_PERMISSIONS // 目标应用是 PackageInstaller，这里会先进入 packageinstaller 中确认权限信息！ final Intent intent = new Intent(PackageInstaller.ACTION_CONFIRM_PERMISSIONS); intent.setPackage(mContext.getPackageManager().getPermissionControllerPackageName()); intent.putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId); // 事务 id 也要从传递过去！ try &#123; //【*4.2.1.1】回调了 PackageInstallObserverAdapter 的 onUserActionRequired 接口 // 将 intent 传递过去！ mRemoteObserver.onUserActionRequired(intent); &#125; catch (RemoteException ignored) &#123; &#125; //【*4.2.3.3】关闭该事务，使其从 active 变为 idle 状态！！ close(); // 停止安装，等待用户确认权限，用户在 PackageInstaller 点击安装，安装会继续！！ return; &#125; //【2】安装到外置时，计算最终安装大小！ if (stageCid != null) &#123; //【*4.2.3.4】计算大小 final long finalSize = calculateInstalledSize(); resizeContainer(stageCid, finalSize); &#125; //【3】如果安装方式是继承已存在的 apk，那我们就要尝试基于已有的安装进行安装，这个一般用于安装和卸载 split apk！ if (params.mode == SessionParams.MODE_INHERIT_EXISTING) &#123; try &#123; final List&lt;File&gt; fromFiles = mResolvedInheritedFiles; final File toDir = resolveStageDir(); // 这是我们本次安装的目录 if (LOGD) Slog.d(TAG, \"Inherited files: \" + mResolvedInheritedFiles); if (!mResolvedInheritedFiles.isEmpty() &amp;&amp; mInheritedFilesBase == null) &#123; throw new IllegalStateException(\"mInheritedFilesBase == null\"); &#125; //【3.1】如果可以直接建立 link 的话，不行的话，就 copy！ if (isLinkPossible(fromFiles, toDir)) &#123; if (!mResolvedInstructionSets.isEmpty()) &#123; final File oatDir = new File(toDir, \"oat\"); createOatDirs(mResolvedInstructionSets, oatDir); &#125; linkFiles(fromFiles, toDir, mInheritedFilesBase); &#125; else &#123; //【3.2】执行拷贝，其实是将已经存在的目录的 apk，oat 文件拷贝到了这个目录！ // 对于要 remove 的文件，则会跳过拷贝！ copyFiles(fromFiles, toDir); &#125; &#125; catch (IOException e) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Failed to inherit existing install\", e); &#125; &#125; //【4】更新进度！ mInternalProgress = 0.5f; //【*4.2.3.5】通知结果！ computeProgressLocked(true); //【*4.2.3.6】提取 lib 库文件到目录中！ extractNativeLibraries(mResolvedStageDir, params.abiOverride); // 如果安装到外置，释放 Container if (stageCid != null) &#123; finalizeAndFixContainer(stageCid); &#125; //【5】创建一个本地的安装观察者，监听安装结果！ final IPackageInstallObserver2 localObserver = new IPackageInstallObserver2.Stub() &#123; @Override public void onUserActionRequired(Intent intent) &#123; throw new IllegalStateException(); &#125; @Override public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) &#123; //【*5.8.2.1】删除目录文件； destroyInternal(); //【*5.8.2.2】处理回调，通知监听者！ dispatchSessionFinished(returnCode, msg, extras); &#125; &#125;; //【6】处理要安装的目标设别用户 final UserHandle user; if ((params.installFlags &amp; PackageManager.INSTALL_ALL_USERS) != 0) &#123; user = UserHandle.ALL; &#125; else &#123; user = new UserHandle(userId); &#125; mRelinquished = true; //【×5.1】然后继续安装！ mPm.installStage(mPackageName, stageDir, stageCid, localObserver, params, installerPackageName, installerUid, user, mCertificates);&#125; 继续分析： 4.2.3.1 resolveStageDir123456789101112131415161718private File resolveStageDir() throws IOException &#123; synchronized (mLock) &#123; //【1】将之前保存的目录 stageDir 值赋给 mResolvedStageDir 并返回！ if (mResolvedStageDir == null) &#123; if (stageDir != null) &#123; mResolvedStageDir = stageDir; &#125; else &#123; final String path = PackageHelper.getSdDir(stageCid); if (path != null) &#123; mResolvedStageDir = new File(path); &#125; else &#123; throw new IOException(\"Failed to resolve path to container \" + stageCid); &#125; &#125; &#125; return mResolvedStageDir; &#125;&#125; 逻辑很简单，不多说了！ 4.2.3.2 validateInstallLocked校验安装有效性，这里的 mResolvedStageDir 就是前面的 /data/app/vmdl[sessionId].tmp 目录！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178private void validateInstallLocked(PackageInfo pkgInfo, ApplicationInfo appInfo) throws PackageManagerException &#123; mPackageName = null; mVersionCode = -1; mSignatures = null; mResolvedBaseFile = null; mResolvedStagedFiles.clear(); mResolvedInheritedFiles.clear(); //【1】返回 /data/app/vmdl[sessionId].tmp 目录下所有的 .removed 文件！ // 去除后缀，将前缀名保存到 removeSplitList！ final File[] removedFiles = mResolvedStageDir.listFiles(sRemovedFilter); final List&lt;String&gt; removeSplitList = new ArrayList&lt;&gt;(); if (!ArrayUtils.isEmpty(removedFiles)) &#123; for (File removedFile : removedFiles) &#123; final String fileName = removedFile.getName(); final String splitName = fileName.substring( 0, fileName.length() - REMOVE_SPLIT_MARKER_EXTENSION.length()); removeSplitList.add(splitName); &#125; &#125; //【2】返回 /data/app/vmdl[sessionId].tmp 目录下所有的非 .removed 文件！ // 并判断是否正常，如果该目录下没有任何 apk 和 .removed 文件，那么抛出异常！！ final File[] addedFiles = mResolvedStageDir.listFiles(sAddedFilter); if (ArrayUtils.isEmpty(addedFiles) &amp;&amp; removeSplitList.size() == 0) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"No packages staged\"); &#125; //【3】遍历该目录下的非 .removed 文件，解析其中的 apk 文件，也就是我们之前 copy 到这里的目标文件！ // 卸载和安装 split 都会进入这里！ final ArraySet&lt;String&gt; stagedSplits = new ArraySet&lt;&gt;(); for (File addedFile : addedFiles) &#123; final ApkLite apk; try &#123; //【3.1】解析要安装的 apk，具体的流程这里就不分析了！ apk = PackageParser.parseApkLite( addedFile, PackageParser.PARSE_COLLECT_CERTIFICATES); &#125; catch (PackageParserException e) &#123; throw PackageManagerException.from(e); &#125; //【3.2】将其添加到 stagedSplits 中，注意 base.apk 的 apk.splitName 为 null！ if (!stagedSplits.add(apk.splitName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Split \" + apk.splitName + \" was defined multiple times\"); &#125; //【3.3】将第一个被解析 apk 的包名，版本号，签名，证书保存下载，这个目录下的其他 apk // 的这几项要和其保持一致！ if (mPackageName == null) &#123; mPackageName = apk.packageName; mVersionCode = apk.versionCode; &#125; if (mSignatures == null) &#123; mSignatures = apk.signatures; mCertificates = apk.certificates; &#125; //【*4.3.2.1】校验 apk 关联性！ assertApkConsistent(String.valueOf(addedFile), apk); //【3.4】设置 apk 文件的目标名称！ final String targetName; if (apk.splitName == null) &#123; targetName = \"base.apk\"; // 一般情况下，我们只装 base apk！ &#125; else &#123; targetName = \"split_\" + apk.splitName + \".apk\"; // 对于 split apk 名称是这样的！！ &#125; if (!FileUtils.isValidExtFilename(targetName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Invalid filename: \" + targetName); &#125; //【3.5】当 addedFile 命名不标准的话，会改名; final File targetFile = new File(mResolvedStageDir, targetName); if (!addedFile.equals(targetFile)) &#123; addedFile.renameTo(targetFile); &#125; //【3.6】找到了 base apk，将其保存到 mResolvedBaseFile，同时将其添加到 mResolvedStagedFiles 中！ if (apk.splitName == null) &#123; mResolvedBaseFile = targetFile; &#125; mResolvedStagedFiles.add(targetFile); &#125; //【4】处理 .removed 文件（卸载 split apk，才会进入这里） if (removeSplitList.size() &gt; 0) &#123; //【4.1】找不到 split apk，抛出异常！ for (String splitName : removeSplitList) &#123; if (!ArrayUtils.contains(pkgInfo.splitNames, splitName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Split not found: \" + splitName); &#125; &#125; // 再次获得要安装的应用的包名，版本号，签名； if (mPackageName == null) &#123; mPackageName = pkgInfo.packageName; mVersionCode = pkgInfo.versionCode; &#125; if (mSignatures == null) &#123; mSignatures = pkgInfo.signatures; &#125; &#125; //【5】处理安装模式！ if (params.mode == SessionParams.MODE_FULL_INSTALL) &#123; //【5.1】全量安装必须要有 base.apk； if (!stagedSplits.contains(null)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Full install must include a base package\"); &#125; &#125; else &#123; //【5.2】部分安装必须基于现有的安装（卸载和安装 split apk 也会进入这里）！ if (appInfo == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Missing existing base package for \" + mPackageName); &#125; //【5.3】获得已存在的 apk 安装信息，这里会解析主 apk 的安装信息！ final PackageLite existing; final ApkLite existingBase; try &#123; existing = PackageParser.parsePackageLite(new File(appInfo.getCodePath()), 0); existingBase = PackageParser.parseApkLite(new File(appInfo.getBaseCodePath()), PackageParser.PARSE_COLLECT_CERTIFICATES); &#125; catch (PackageParserException e) &#123; throw PackageManagerException.from(e); &#125; //【*4.3.2.1】再次校验要本次要安装的 apk 和已存在的 apk 是有关联，包括包名，签名，版本号！ assertApkConsistent(\"Existing base\", existingBase); //【5.4】继承已有的 base apk，如果没有指定安装的 apk！！ if (mResolvedBaseFile == null) &#123; mResolvedBaseFile = new File(appInfo.getBaseCodePath()); mResolvedInheritedFiles.add(mResolvedBaseFile); &#125; //【5.5】继承已有的 split apk，要继承的 split apk 不能是在 removeSplitList 列表中！！ if (!ArrayUtils.isEmpty(existing.splitNames)) &#123; for (int i = 0; i &lt; existing.splitNames.length; i++) &#123; final String splitName = existing.splitNames[i]; final File splitFile = new File(existing.splitCodePaths[i]); final boolean splitRemoved = removeSplitList.contains(splitName); if (!stagedSplits.contains(splitName) &amp;&amp; !splitRemoved) &#123; mResolvedInheritedFiles.add(splitFile); &#125; &#125; &#125; //【5.6】继承已有的 oat 相关文件！！ final File packageInstallDir = (new File(appInfo.getBaseCodePath())).getParentFile(); mInheritedFilesBase = packageInstallDir; final File oatDir = new File(packageInstallDir, \"oat\"); if (oatDir.exists()) &#123; final File[] archSubdirs = oatDir.listFiles(); if (archSubdirs != null &amp;&amp; archSubdirs.length &gt; 0) &#123; final String[] instructionSets = InstructionSets.getAllDexCodeInstructionSets(); for (File archSubDir : archSubdirs) &#123; // Skip any directory that isn't an ISA subdir. if (!ArrayUtils.contains(instructionSets, archSubDir.getName())) &#123; continue; &#125; // 将要继承的 oat 目录文件名添加到 mResolvedInstructionSets！ mResolvedInstructionSets.add(archSubDir.getName()); List&lt;File&gt; oatFiles = Arrays.asList(archSubDir.listFiles()); if (!oatFiles.isEmpty()) &#123; // 将要继承的 odex 相关文件添加到 mResolvedInheritedFiles！ mResolvedInheritedFiles.addAll(oatFiles); &#125; &#125; &#125; &#125; &#125;&#125; 总结下： 1、返回 /data/app/vmdl[sessionId].tmp 目录下所有的 .removed 文件，去除后缀，将前缀名保存到 removeSplitList；2、/data/app/vmdl[sessionId].tmp 目录下必须要有 apk 文件或者 .removed 文件；3、遍历该目录下的非 .removed 文件，对其 packagename versionCode 和签名做关联校验；4、stagedSplits 用于保存该目录下的所有 apk 的 splitName，base apk 的 splitName 为 null；5、mResolvedBaseFile 用于保存 base apk；6、mResolvedStagedFiles 用于保存目录下所有的 apk； 7、removeSplitList 大于 0，说明有要移除的 split apk，前提是主 apk 要有 split apk！ 8、对于 MODE_FULL_INSTALL，全量安装，必须要有 base apk！9、对于 MODE_INHERIT_EXISTING，继承安装，会再次解析主 apk，收集那些不在 removeSplitList 列表中的 splitApk 路径到 mResolvedInheritedFiles 中； 4.2.3.2.1 assertApkConsistent校验 apk 的一致性，ApkLite apk 为扫描到的文件！ 12345678910111213141516171819202122232425private void assertApkConsistent(String tag, ApkLite apk) throws PackageManagerException &#123; //【1】扫描到的 apk 的包名必须和该目录下第一个被扫描到的 apk 包名保持一致！ if (!mPackageName.equals(apk.packageName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, tag + \" package \" + apk.packageName + \" inconsistent with \" + mPackageName); &#125; //【2】如果是要继承已安装的 apk，那么包名要一样！ if (params.appPackageName != null &amp;&amp; !params.appPackageName.equals(apk.packageName)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, tag + \" specified package \" + params.appPackageName + \" inconsistent with \" + apk.packageName); &#125; //【3】扫描到的 apk 的版本号必须和该目录下第一个被扫描到的 apk 版本号保持一致！ if (mVersionCode != apk.versionCode) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, tag + \" version code \" + apk.versionCode + \" inconsistent with \" + mVersionCode); &#125; //【4】扫描到的 apk 的签名必须和该目录下第一个被扫描到的 apk 签名保持一致！ if (!Signature.areExactMatch(mSignatures, apk.signatures)) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, tag + \" signatures are inconsistent\"); &#125;&#125; 流程很简单，不多说了！ 4.2.3.3 closeclose 方法很简单，将事务的 mActiveCount 引用计数自减 1，同时回调 12345678@Overridepublic void close() &#123; //【1】引用计数减去 1； if (mActiveCount.decrementAndGet() == 0) &#123; //【*3.1.4.2】反馈事务状态！ mCallback.onSessionActiveChanged(this, false); &#125;&#125; 4.2.3.4 calculateInstalledSize用于计算最终的安装大小！ 123456789101112131415161718192021222324252627282930313233343536private long calculateInstalledSize() throws PackageManagerException &#123; Preconditions.checkNotNull(mResolvedBaseFile); final ApkLite baseApk; try &#123; //【1】解析要安装的 apk 的数据信息！ baseApk = PackageParser.parseApkLite(mResolvedBaseFile, 0); &#125; catch (PackageParserException e) &#123; throw PackageManagerException.from(e); &#125; //【2】获得其 split apk 的文件路径！ final List&lt;String&gt; splitPaths = new ArrayList&lt;&gt;(); for (File file : mResolvedStagedFiles) &#123; if (mResolvedBaseFile.equals(file)) continue; splitPaths.add(file.getAbsolutePath()); &#125; //【3】获得其要继承的 apk 的文件路径！ for (File file : mResolvedInheritedFiles) &#123; if (mResolvedBaseFile.equals(file)) continue; splitPaths.add(file.getAbsolutePath()); &#125; //【4】创建一个 PackageLite 对象！ final PackageLite pkg = new PackageLite(null, baseApk, null, splitPaths.toArray(new String[splitPaths.size()]), null); final boolean isForwardLocked = (params.installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0; try &#123; //【*4.2.3.4.1】调用 PackageHelper 计算空间大小！ return PackageHelper.calculateInstalledSize(pkg, isForwardLocked, params.abiOverride); &#125; catch (IOException e) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Failed to calculate install size\", e); &#125;&#125; 我们去 PackageHelper.calculateInstalledSize 方法中去看看： 4.2.3.4.1 calculateInstalledSize123456789101112131415161718192021222324252627282930public static long calculateInstalledSize(PackageLite pkg, boolean isForwardLocked, String abiOverride) throws IOException &#123; NativeLibraryHelper.Handle handle = null; try &#123; handle = NativeLibraryHelper.Handle.create(pkg); return calculateInstalledSize(pkg, handle, isForwardLocked, abiOverride); &#125; finally &#123; IoUtils.closeQuietly(handle); &#125;&#125;public static long calculateInstalledSize(PackageLite pkg, NativeLibraryHelper.Handle handle, boolean isForwardLocked, String abiOverride) throws IOException &#123; long sizeBytes = 0; //【1】包括 apk 集合其他的一些资源！ for (String codePath : pkg.getAllCodePaths()) &#123; final File codeFile = new File(codePath); sizeBytes += codeFile.length(); //【2】如果是 forward lock 模式，还要加入一些公共资源！ if (isForwardLocked) &#123; sizeBytes += PackageHelper.extractPublicFiles(codeFile, null); &#125; &#125; //【3】加入 native code 的大小！ sizeBytes += NativeLibraryHelper.sumNativeBinariesWithOverride(handle, abiOverride); //【4】返回最终大小！ return sizeBytes;&#125; 这里就分析到这里！ 4.2.3.5 computeProgressLocked1234567891011private void computeProgressLocked(boolean forcePublish) &#123; mProgress = MathUtils.constrain(mClientProgress * 0.8f, 0f, 0.8f) + MathUtils.constrain(mInternalProgress * 0.2f, 0f, 0.2f); // Only publish when meaningful change if (forcePublish || Math.abs(mProgress - mReportedProgress) &gt;= 0.01) &#123; mReportedProgress = mProgress; //【3.1.4.1】调用 InternalCallback 回调！ mCallback.onSessionProgressChanged(this, mProgress); &#125;&#125; 4.2.3.6 extractNativeLibraries提取本地的 lib 库文件！ 1234567891011121314151617181920212223private static void extractNativeLibraries(File packageDir, String abiOverride) throws PackageManagerException &#123; //【1】libDir 指向 /data/app/vmdl[id].tmp/lib 目录，这里是删除目录下存在的 lib 库文件！ final File libDir = new File(packageDir, NativeLibraryHelper.LIB_DIR_NAME); NativeLibraryHelper.removeNativeBinariesFromDirLI(libDir, true); NativeLibraryHelper.Handle handle = null; try &#123; //【2】创建 lib 子目录，并将应用程序中的 lib 库拷贝到该目录下！ handle = NativeLibraryHelper.Handle.create(packageDir); final int res = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libDir, abiOverride); if (res != PackageManager.INSTALL_SUCCEEDED) &#123; throw new PackageManagerException(res, \"Failed to extract native libraries, res=\" + res); &#125; &#125; catch (IOException e) &#123; throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, \"Failed to extract native libraries\", e); &#125; finally &#123; IoUtils.closeQuietly(handle); &#125;&#125; 对于 lib 的提取，这里涉及到了 NativeLibraryHelper，我们先不过多关注其实现！ 5 PackageManagerService5.1 PackageManagerService.installStage接下来，进入 PackageManagerService 阶段。 这里的 IPackageInstallObserver2 observer 是前面创建的本次 localObserver： 1234567891011121314151617181920212223242526272829303132333435363738void installStage(String packageName, File stagedDir, String stagedCid, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, Certificate[][] certificates) &#123; if (DEBUG_EPHEMERAL) &#123; if ((sessionParams.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) &#123; Slog.d(TAG, \"Ephemeral install of \" + packageName); &#125; &#125; //【5.1.1】创建一个 VerificationInfo 对象，用于校验 final VerificationInfo verificationInfo = new VerificationInfo( sessionParams.originatingUri, sessionParams.referrerUri, sessionParams.originatingUid, installerUid); //【5.1.2】创建了一个 OriginInfo 对象！ final OriginInfo origin; if (stagedDir != null) &#123; origin = OriginInfo.fromStagedFile(stagedDir); &#125; else &#123; origin = OriginInfo.fromStagedContainer(stagedCid); &#125; //【1】创建了一个 INIT_COPY 消息！ final Message msg = mHandler.obtainMessage(INIT_COPY); //【5.1.3】创建一个 InstallParams 安装参数对象！ final InstallParams params = new InstallParams(origin, null, observer, sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid, verificationInfo, user, sessionParams.abiOverride, sessionParams.grantedRuntimePermissions, certificates); params.setTraceMethod(\"installStage\").setTraceCookie(System.identityHashCode(params)); msg.obj = params; Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installStage\", System.identityHashCode(msg.obj)); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\", System.identityHashCode(msg.obj)); //【5.2】发送 INIT_COPY 消息！ mHandler.sendMessage(msg); &#125; 这里的 mHandler 是在 PackageManagerService 的构造器中创建的： 1234mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);mHandlerThread.start();mHandler = new PackageHandler(mHandlerThread.getLooper()); 是一个 PackageHandler 实例，其绑定了一个子线程 ServiceThread！ 5.1.1 new VerificationInfoVerificationInfo 类定义在 PackageManagerService 中，用于信息校验： 12345678910111213141516171819202122static class VerificationInfo &#123; /** A constant used to indicate that a uid value is not present. */ public static final int NO_UID = -1; /** URI referencing where the package was downloaded from. */ final Uri originatingUri; /** HTTP referrer URI associated with the originatingURI. */ final Uri referrer; /** UID of the application that the install request originated from. */ final int originatingUid; final int installerUid; // 安装者应用的 uid！ VerificationInfo(Uri originatingUri, Uri referrer, int originatingUid, int installerUid) &#123; this.originatingUri = originatingUri; this.referrer = referrer; this.originatingUid = originatingUid; this.installerUid = installerUid; &#125;&#125; 5.1.2 new OriginInfo这里创建了一个 OriginInfo 实例，封装安装目录相关信息！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static class OriginInfo &#123; final File file; // 安装到内置存储，不为 null final String cid; // 安装到内置存储，为 null final boolean staged; final boolean existing; final String resolvedPath; final File resolvedFile; static OriginInfo fromNothing() &#123; return new OriginInfo(null, null, false, false); &#125; static OriginInfo fromUntrustedFile(File file) &#123; return new OriginInfo(file, null, false, false); &#125; static OriginInfo fromExistingFile(File file) &#123; return new OriginInfo(file, null, false, true); &#125; static OriginInfo fromStagedFile(File file) &#123; //【1】安装到内置存储会调用 return new OriginInfo(file, null, true, false); &#125; static OriginInfo fromStagedContainer(String cid) &#123; //【2】安装到外置存储会调用 return new OriginInfo(null, cid, true, false); &#125; private OriginInfo(File file, String cid, boolean staged, boolean existing) &#123; this.file = file; // 内置时为：/data/app/vmdl[sessionId].tmp this.cid = cid; this.staged = staged; // 安装到内置存储时为 true。 this.existing = existing; // 安装到内置存储时为 false。 if (cid != null) &#123; resolvedPath = PackageHelper.getSdDir(cid); resolvedFile = new File(resolvedPath); &#125; else if (file != null) &#123; resolvedPath = file.getAbsolutePath(); resolvedFile = file; &#125; else &#123; resolvedPath = null; resolvedFile = null; &#125; &#125;&#125; 这里我们先关注安装到内置存储中的逻辑！ 5.1.3 new PMS.InstallParamsInstallParams 类定义在 PackageManagerService 中，封装了安装参数： 1234567891011121314151617181920212223242526272829303132class InstallParams extends HandlerParams &#123; final OriginInfo origin; final MoveInfo move; // move package 才会传入，安装时为 null！ final IPackageInstallObserver2 observer; // 本地传观察者； int installFlags; final String installerPackageName; final String volumeUuid; private InstallArgs mArgs; private int mRet; final String packageAbiOverride; final String[] grantedRuntimePermissions; // 安装时授予的运行时权限列表； final VerificationInfo verificationInfo; final Certificate[][] certificates; InstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, Certificate[][] certificates) &#123; super(user); this.origin = origin; this.move = move; this.observer = observer; this.installFlags = installFlags; this.installerPackageName = installerPackageName; this.volumeUuid = volumeUuid; this.verificationInfo = verificationInfo; this.packageAbiOverride = packageAbiOverride; this.grantedRuntimePermissions = grantedPermissions; this.certificates = certificates; &#125; ... ... ... &#125; InstallParams 继承了 HandlerParams！ 这里涉及到一个 MoveInfo move，在 movePackageInternal 也就是移动 package 时才会调用，这里是安装，我们先不关注！ 5.2 PackageHandler.doHandleMessage[INIT_COPY]PackageHandler 会在子线程中处理 INIT_COPY 消息： 1234567891011121314151617181920212223242526272829303132333435363738case INIT_COPY: &#123; //【1】取出 InstallParams！ HandlerParams params = (HandlerParams) msg.obj; // mPendingInstalls 中会保存所有正在等待的安装！ int idx = mPendingInstalls.size(); if (DEBUG_INSTALL) Slog.i(TAG, \"init_copy idx=\" + idx + \": \" + params); //【2】mBound 用来判断是否已经绑定到了 DefaultContainerService，该服务用于安装！ if (!mBound) &#123; Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"bindingMCS\", System.identityHashCode(mHandler)); //【5.2.1】尝试去 bind 服务，bind 成功后，mBound 置为 true！ if (!connectToService()) &#123; Slog.e(TAG, \"Failed to bind to media container service\"); //【5.2.2】如果不能 bind 成功，那就触发 HandlerParams 的 serviceError 方法！ params.serviceError(); Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"bindingMCS\", System.identityHashCode(mHandler)); if (params.traceMethod != null) &#123; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod, params.traceCookie); &#125; return; &#125; else &#123; //【3】将本次的安装参数添加到等待集合中！！ mPendingInstalls.add(idx, params); &#125; &#125; else &#123; //【4】如果之前已经 bind 了，那就直接将安装参数添加到等待集合中！！ mPendingInstalls.add(idx, params); //【5.3】如果是第一次添加，发送 MCS_BOUND 消息！ if (idx == 0) &#123; mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; break;&#125; 这里逻辑很清晰了，我们继续看！ 5.2.1 PackageHandler.connectToService123456789101112131415private boolean connectToService() &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, \"Trying to bind to\" + \" DefaultContainerService\"); Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT); Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); //【1】开始 bind 服务，传入了 mDefContainerConn 对象！ if (mContext.bindServiceAsUser(service, mDefContainerConn, Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); mBound = true; return true; &#125; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); return false;&#125; 这里 bind 的服务是 DefaultContainerService！123static final ComponentName DEFAULT_CONTAINER_COMPONENT = new ComponentName( DEFAULT_CONTAINER_PACKAGE, \"com.android.defcontainer.DefaultContainerService\"); PackageManagerService 内部持有一个 DefaultContainerConnection 实例！ 123456789101112131415161718final private DefaultContainerConnection mDefContainerConn = new DefaultContainerConnection();class DefaultContainerConnection implements ServiceConnection &#123; public void onServiceConnected(ComponentName name, IBinder service) &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, \"onServiceConnected\"); //【1】获得 DefaultContainerConnection 代理对象！ IMediaContainerService imcs = IMediaContainerService.Stub.asInterface(service); //【5.3】发送 MCS_BOUND 消息！ mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs)); &#125; public void onServiceDisconnected(ComponentName name) &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, \"onServiceDisconnected\"); &#125;&#125; 最后会发送 MCS_BOUND 消息给 PackageHandler 对象！ 5.2.2 InstallParams.serviceErrorserviceError 方法是从 HandlerParams 中继承到的： 1234567final void serviceError() &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"serviceError\"); //【5.4.2】安装异常，保存结果 handleServiceError(); //【5.4.4】处理结果！ handleReturnCode();&#125; handleServiceError 方法和 handleReturnCode 方法的最终实现也是在 InstallParams 中！ 5.3 PackageHandler.doHandleMessage[MCS_BOUND] - 绑定服务继续来看下 PackageHandler 对 MCS_BOUND 的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071case MCS_BOUND: &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_bound\"); //【1】这里的 msg.obj 是前面 bind 获得的代理对象，将其保存到 mContainerService 中！ if (msg.obj != null) &#123; mContainerService = (IMediaContainerService) msg.obj; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"bindingMCS\", System.identityHashCode(mHandler)); &#125; //【2】异常处理，如果 mContainerService 为 null，且 mBound 为 ture，那么这种情况是异常！ if (mContainerService == null) &#123; if (!mBound) &#123; Slog.e(TAG, \"Cannot bind to media container service\"); //【2.1】遍历所有的 HandlerParams 安装参数，回调 serviceError！ for (HandlerParams params : mPendingInstalls) &#123; params.serviceError(); Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\", System.identityHashCode(params)); if (params.traceMethod != null) &#123; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod, params.traceCookie); &#125; return; &#125; //【2.2】清空 mPendingInstalls 集合！ mPendingInstalls.clear(); &#125; else &#123; Slog.w(TAG, \"Waiting to connect to media container service\"); &#125; &#125; else if (mPendingInstalls.size() &gt; 0) &#123; //【3】正常情况下，bind 是有效的，那么会进入这里！ HandlerParams params = mPendingInstalls.get(0); if (params != null) &#123; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\", System.identityHashCode(params)); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"startCopy\"); //【5.4】调用了 HandlerParams 的 startCopy 方法！ if (params.startCopy()) &#123; // We are done... look for more work or to // go idle. if (DEBUG_SD_INSTALL) Log.i(TAG, \"Checking for more work or unbind...\"); //【3.1】本次安装完成，删除本次处理的安装参数！ if (mPendingInstalls.size() &gt; 0) &#123; mPendingInstalls.remove(0); &#125; if (mPendingInstalls.size() == 0) &#123; //【3.2】如果所有的安装参数都处理玩了，unbind 服务！ // 这里的 unbind 延迟了 10s if (mBound) &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, \"Posting delayed MCS_UNBIND\"); removeMessages(MCS_UNBIND); Message ubmsg = obtainMessage(MCS_UNBIND); sendMessageDelayed(ubmsg, 10000); &#125; &#125; else &#123; //【3.3】在安装队列中有其他的安装项，我们发送 MCS_BOUND 消息继续处理！ if (DEBUG_SD_INSTALL) Log.i(TAG, \"Posting MCS_BOUND for next work\"); mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; &#125; else &#123; // Should never happen ideally. Slog.w(TAG, \"Empty queue\"); &#125; break;&#125; 5.4 InstallParams.startCopyInstallParams 继承了 HandlerParams： 1234567891011121314151617181920212223242526272829final boolean startCopy() &#123; boolean res; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this); //【1】如果重试次数大于 4 ，那么就放弃本次安装！ if (++mRetries &gt; MAX_RETRIES) &#123; Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\"); //【5.4.1】发送 MCS_GIVE_UP 消息！ mHandler.sendEmptyMessage(MCS_GIVE_UP); //【5.4.2】处理失败结果 handleServiceError(); return false; &#125; else &#123; //【5.5】继续安装！ handleStartCopy(); res = true; &#125; &#125; catch (RemoteException e) &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\"); //【5.4.3】发送 MCS_RECONNECT 消息！ mHandler.sendEmptyMessage(MCS_RECONNECT); res = false; &#125; //【5.4.4】处理返回码！ handleReturnCode(); return res;&#125; 这里定义了安装尝试次数：1private static final int MAX_RETRIES = 4; 5.4.1 PackageHandler.doHandleMessage[MCS_GIVE_UP] - 放弃安装重试次数大于 4 ，那么就放弃本次安装！ 12345678case MCS_GIVE_UP: &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_giveup too many retries\"); //【1】移除这个安装参数。 HandlerParams params = mPendingInstalls.remove(0); Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\", System.identityHashCode(params)); break;&#125; 5.4.2 InstallParams.handleServiceError处理本次安装失败的结果： 123456@Overridevoid handleServiceError() &#123; //【5.2.3】创建安装参数 InstallArgs！ mArgs = createInstallArgs(this); mRet = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;&#125; 这里的 createInstallArgs 方法我们后面再分析！ 5.4.3 PackageHandler.doHandleMessage[MCS_RECONNECT] - 重连服务MCS_RECONNECT 消息会尝试重连服务！ 12345678910111213141516171819202122case MCS_RECONNECT: &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"mcs_reconnect\"); if (mPendingInstalls.size() &gt; 0) &#123; //【1】如果 mBound 为 true，先尝试断开连接！ if (mBound) &#123; disconnectService(); &#125; //【2】开始重新连接服务！ if (!connectToService()) &#123; Slog.e(TAG, \"Failed to bind to media container service\"); for (HandlerParams params : mPendingInstalls) &#123; //【5.2.2】返回安装异常！ params.serviceError(); Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"queueInstall\", System.identityHashCode(params)); &#125; //【3】清空 mPendingInstalls 集合！ mPendingInstalls.clear(); &#125; &#125; break;&#125; 流程很简单，不多说了！ 5.4.4 InstallParams.handleReturnCode当 mArgs 为 null 的时候，此时该 package 正在被校验，所以需要等到校验成功后才能安装，所以不会进入这里！ 12345678@Overridevoid handleReturnCode() &#123; //【1】如果 mArgs 这里为 null，可能是不需要校验！ if (mArgs != null) &#123; //【5.7】继续安装！ processPendingInstall(mArgs, mRet); &#125;&#125; 我们继续看！ 5.5 InstallParams.handleStartCopy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256public void handleStartCopy() throws RemoteException &#123; //【1】保存安装结果，默认为成功！ int ret = PackageManager.INSTALL_SUCCEEDED; //【2】我们知道 origin 中存储了安装目录相关的信息！ if (origin.staged) &#123; if (origin.file != null) &#123; //【2.1】安装到内置存储中！ installFlags |= PackageManager.INSTALL_INTERNAL; installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL; &#125; else if (origin.cid != null) &#123; //【2.2】这里是安装到外置存储中的逻辑！ installFlags |= PackageManager.INSTALL_EXTERNAL; installFlags &amp;= ~PackageManager.INSTALL_INTERNAL; &#125; else &#123; throw new IllegalStateException(\"Invalid stage location\"); &#125; &#125; //【3】判断安装位置！ final boolean onSd = (installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0; final boolean onInt = (installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0; final boolean ephemeral = (installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0; PackageInfoLite pkgLite = null; //【4】判断安装位置是否满足条件！ if (onInt &amp;&amp; onSd) &#123; //【4.1】不能同时设置安装在 sd 和内置中！ Slog.w(TAG, \"Conflicting flags specified for installing on both internal and external\"); ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else if (onSd &amp;&amp; ephemeral) &#123; Slog.w(TAG, \"Conflicting flags specified for installing ephemeral on external\"); //【4.2】不能设置短暂安装在 sd 中！ ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else &#123; //【5.5.1】利用 ContainerService 获取 PackageInfoLite，同时判断空间是否合适！ pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride); if (DEBUG_EPHEMERAL &amp;&amp; ephemeral) &#123; Slog.v(TAG, \"pkgLite for install: \" + pkgLite); &#125; //【4.3】空间不足，尝试释放空尽！ if (!origin.staged &amp;&amp; pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) &#123; // TODO: focus freeing disk space on the target device final StorageManager storage = StorageManager.from(mContext); final long lowThreshold = storage.getStorageLowBytes( Environment.getDataDirectory()); final long sizeBytes = mContainerService.calculateInstalledSize( origin.resolvedPath, isForwardLocked(), packageAbiOverride); try &#123; //【4.4】通过 installd 释放存储！ mInstaller.freeCache(null, sizeBytes + lowThreshold); //【5.5.1】再次利用 ContainerService 获取 PackageInfoLite，同时判断空间是否合适！ pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride); &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Failed to free cache\", e); &#125; //【4.5】依然无法安装，设置结果为 RECOMMEND_FAILED_INSUFFICIENT_STORAGE！ if (pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INVALID_URI) &#123; pkgLite.recommendedInstallLocation = PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE; &#125; &#125; &#125; //【5】处理前面的空间判断后的结果！ if (ret == PackageManager.INSTALL_SUCCEEDED) &#123; int loc = pkgLite.recommendedInstallLocation; if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) &#123; ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else if (loc == PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS) &#123; ret = PackageManager.INSTALL_FAILED_ALREADY_EXISTS; &#125; else if (loc == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) &#123; ret = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE; &#125; else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_APK) &#123; ret = PackageManager.INSTALL_FAILED_INVALID_APK; &#125; else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_URI) &#123; ret = PackageManager.INSTALL_FAILED_INVALID_URI; &#125; else if (loc == PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE) &#123; ret = PackageManager.INSTALL_FAILED_MEDIA_UNAVAILABLE; &#125; else &#123; //【5.5.2】调用 installLocationPolicy 方法，针对于降级安装和替换安装做处理！ loc = installLocationPolicy(pkgLite); if (loc == PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE) &#123; // 处理无法降级的结果！ ret = PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE; &#125; else if (!onSd &amp;&amp; !onInt) &#123; // 如果 flags 没有指定内置还是外置，那么由 installLocationPolicy 的返回值指定！ if (loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) &#123; installFlags |= PackageManager.INSTALL_EXTERNAL; // 外置 installFlags &amp;= ~PackageManager.INSTALL_INTERNAL; &#125; else if (loc == PackageHelper.RECOMMEND_INSTALL_EPHEMERAL) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.v(TAG, \"...setting INSTALL_EPHEMERAL install flag\"); &#125; installFlags |= PackageManager.INSTALL_EPHEMERAL; // 内置并且是短暂安装！ installFlags &amp;= ~(PackageManager.INSTALL_EXTERNAL |PackageManager.INSTALL_INTERNAL); &#125; else &#123; installFlags |= PackageManager.INSTALL_INTERNAL; // 内置 installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL; &#125; &#125; &#125; &#125; //【5.5.3】创建一个 InstallArgs 对象，和 InstallParams 相互引用！ final InstallArgs args = createInstallArgs(this); mArgs = args; if (ret == PackageManager.INSTALL_SUCCEEDED) &#123; // TODO: http://b/22976637 //【6】如果该应用是安装给 all users 的，那么需要校验应用！ UserHandle verifierUser = getUser(); if (verifierUser == UserHandle.ALL) &#123; verifierUser = UserHandle.SYSTEM; &#125; //【7】尝试找到系统中安装的 pacakge 校验器，如果可以找到，那就要做校验啦！ //【7.1】获得校验器的 uid！ final int requiredUid = mRequiredVerifierPackage == null ? -1 : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, verifierUser.getIdentifier()); //【7.1】如果是安装到内置存储（existing 为 true），并且系统中有校验器，并且系统打开了校验功能，那么就尝试校验！ //【5.5.4】通过 isVerificationEnabled 判断是否打开校验功能！ if (!origin.existing &amp;&amp; requiredUid != -1 &amp;&amp; isVerificationEnabled(verifierUser.getIdentifier(), installFlags)) &#123; //【7.1.1】准备发送校验广播 final Intent verification = new Intent( Intent.ACTION_PACKAGE_NEEDS_VERIFICATION); verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)), PACKAGE_MIME_TYPE); // 设置 DataAndType 属性，包含了 apk 路径对应的 uri verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 增加了临时的权限授予！ //【7.1.2】查询校验器！ final List&lt;ResolveInfo&gt; receivers = queryIntentReceiversInternal(verification, PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier()); if (DEBUG_VERIFY) &#123; Slog.d(TAG, \"Found \" + receivers.size() + \" verifiers for intent \" + verification.toString() + \" with \" + pkgLite.verifiers.length + \" optional verifiers\"); &#125; final int verificationId = mPendingVerificationToken++; // 计算本次校验的唯一标识 token verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId); verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE, installerPackageName); // 安装器（packageInstaller） verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS, installFlags); // 本次安装的 installFlags verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME, pkgLite.packageName); // 要校验的应用 verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE, pkgLite.versionCode); // 版本号 if (verificationInfo != null) &#123; // 如果指定了校验信息，将其写入 intent！ if (verificationInfo.originatingUri != null) &#123; verification.putExtra(Intent.EXTRA_ORIGINATING_URI, verificationInfo.originatingUri); &#125; if (verificationInfo.referrer != null) &#123; verification.putExtra(Intent.EXTRA_REFERRER, verificationInfo.referrer); &#125; if (verificationInfo.originatingUid &gt;= 0) &#123; verification.putExtra(Intent.EXTRA_ORIGINATING_UID, verificationInfo.originatingUid); &#125; if (verificationInfo.installerUid &gt;= 0) &#123; verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID, verificationInfo.installerUid); &#125; &#125; //【5.5.5】创建一个 PackageVerificationState 对象，用于保存应用校验状态，同时将创建的 // installArgs 作为参数传入，并加入 mPendingVerification 集合中！！ final PackageVerificationState verificationState = new PackageVerificationState( requiredUid, args); mPendingVerification.append(verificationId, verificationState); //【7.1.3】如果应用指定了校验者，那么我们要尝试先用指定的校验器校验！ final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite, receivers, verificationState); if (sufficientVerifiers != null) &#123; final int N = sufficientVerifiers.size(); if (N == 0) &#123; Slog.i(TAG, \"Additional verifiers required, but none installed.\"); ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; &#125; else &#123; for (int i = 0; i &lt; N; i++) &#123; final ComponentName verifierComponent = sufficientVerifiers.get(i); // 使用前面创建的 verification 意图，再创建一个 intent！ // 指定组件为应用指定的校验器，并发送广播！ final Intent sufficientIntent = new Intent(verification); sufficientIntent.setComponent(verifierComponent); mContext.sendBroadcastAsUser(sufficientIntent, verifierUser); &#125; &#125; &#125; //【7.1.4】找到和 mRequiredVerifierPackage（系统指定的默认校验器）匹配的接收者！ final ComponentName requiredVerifierComponent = matchComponentForVerifier( mRequiredVerifierPackage, receivers); if (ret == PackageManager.INSTALL_SUCCEEDED &amp;&amp; mRequiredVerifierPackage != null) &#123; Trace.asyncTraceBegin( TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId); //【7.1.5】指定目标应用为 mRequiredVerifierPackage 的内部组件！ // 发送 verification 意图！ verification.setComponent(requiredVerifierComponent); mContext.sendOrderedBroadcastAsUser(verification, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; //【7.1.6】当 mRequiredVerifierPackage 接收到广播后，会回调 // 该 BroadcastReceiver 的 onReceive 方法！ //【5.6】此时校验完成，这里会发送 CHECK_PENDING_VERIFICATION 给 PackageHandler // 携带校验标识符！ final Message msg = mHandler .obtainMessage(CHECK_PENDING_VERIFICATION); msg.arg1 = verificationId; mHandler.sendMessageDelayed(msg, getVerificationTimeout()); &#125; &#125;, null, 0, null, null); /* * We don't want the copy to proceed until verification * succeeds, so null out this field. */ mArgs = null; &#125; &#125; else &#123; //【5.7】没有合适的校验器，那么会调用 InstallArgs 的 copyApk 方法！ ret = args.copyApk(mContainerService, true); &#125; &#125; mRet = ret;&#125; 直接可以看到，最终 5.5.1 DefaultContainerService.getMinimalPackageInfogetMinimalPackageInfo 方法会解析 apk，返回 apk 的解析信息，同时判断空间状态！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Overridepublic PackageInfoLite getMinimalPackageInfo(String packagePath, int flags, String abiOverride) &#123; final Context context = DefaultContainerService.this; final boolean isForwardLocked = (flags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0; //【5.5.1.1】创建了一个 PackageInfoLite 实例！ PackageInfoLite ret = new PackageInfoLite(); if (packagePath == null) &#123; Slog.i(TAG, \"Invalid package file \" + packagePath); ret.recommendedInstallLocation = PackageHelper.RECOMMEND_FAILED_INVALID_APK; // 该 apk 无效 return ret; &#125; final File packageFile = new File(packagePath); final PackageParser.PackageLite pkg; final long sizeBytes; try &#123; //【2】解析 apk，获得其 PackageLite 对象，并计算安装所需空间！ pkg = PackageParser.parsePackageLite(packageFile, 0); sizeBytes = PackageHelper.calculateInstalledSize(pkg, isForwardLocked, abiOverride); &#125; catch (PackageParserException | IOException e) &#123; Slog.w(TAG, \"Failed to parse package at \" + packagePath + \": \" + e); if (!packageFile.exists()) &#123; ret.recommendedInstallLocation = PackageHelper.RECOMMEND_FAILED_INVALID_URI; // 该 apk 无效 &#125; else &#123; ret.recommendedInstallLocation = PackageHelper.RECOMMEND_FAILED_INVALID_APK; // 该 apk 无效 &#125; return ret; &#125; //【3】将解析到的参数保存到 PackageInfoLite 中！ ret.packageName = pkg.packageName; ret.splitNames = pkg.splitNames; ret.versionCode = pkg.versionCode; ret.baseRevisionCode = pkg.baseRevisionCode; ret.splitRevisionCodes = pkg.splitRevisionCodes; ret.installLocation = pkg.installLocation; ret.verifiers = pkg.verifiers; //【5.5.1.2】解析安装位置状态信息！ ret.recommendedInstallLocation = PackageHelper.resolveInstallLocation(context, pkg.packageName, pkg.installLocation, sizeBytes, flags); ret.multiArch = pkg.multiArch; //【4】返回该 PackageInfoLite 实例！ return ret;&#125; 5.5.1.1 new PackageInfoLitePackageInfoLite 用来保存解析到的 apk 的一些信息！ 12345678910111213141516171819202122public class PackageInfoLite implements Parcelable &#123; public String packageName; // 应用包名； public String[] splitNames; // split apk 的名字 public int versionCode; // 版本号 public int baseRevisionCode; public int[] splitRevisionCodes; /** * The android:multiArch flag from the package manifest. If set, * we will extract all native libraries for the given app, not just those * from the preferred ABI. */ public boolean multiArch; public int recommendedInstallLocation; public int installLocation; public VerifierInfo[] verifiers; public PackageInfoLite() &#123; &#125; ... ... ...&#125; 这里的 recommendedInstallLocation 可以取下面四个值： 1234PackageHelper.RECOMMEND_INSTALL_INTERNAL // 内置PackageHelper.RECOMMEND_INSTALL_EXTERNAL // 外置PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE // 存储异常PackageHelper.RECOMMEND_FAILED_INVALID_APK // apk解析异常 5.5.1.2 PackageHelper.resolveInstallLocationresolveInstallLocation 方法用于计算一个合适的安装位置给 apk！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public static int resolveInstallLocation(Context context, String packageName, int installLocation, long sizeBytes, int installFlags) &#123; //【1】如果该应用已经安装了，那么我们获得上一次安装后的信息！！ ApplicationInfo existingInfo = null; try &#123; existingInfo = context.getPackageManager().getApplicationInfo(packageName, PackageManager.GET_UNINSTALLED_PACKAGES); &#125; catch (NameNotFoundException ignored) &#123; &#125; final int prefer; final boolean checkBoth; boolean ephemeral = false; //【2】根据安装参数 installFlags，来选择合适的安装位置，按照优先级依次解析！ if ((installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) &#123; //【2.1】如果指定了 PackageManager.INSTALL_EPHEMERAL，优先内置！ prefer = RECOMMEND_INSTALL_INTERNAL; ephemeral = true; // 表示短暂安装！ checkBoth = false; &#125; else if ((installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; //【2.2】如果指定了 PackageManager.INSTALL_INTERNAL，优先内置！ prefer = RECOMMEND_INSTALL_INTERNAL; checkBoth = false; &#125; else if ((installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0) &#123; //【2.3】如果指定了 PackageManager.INSTALL_EXTERNAL，优先外置！ prefer = RECOMMEND_INSTALL_EXTERNAL; checkBoth = false; &#125; else if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) &#123; //【2.4】如果指定了 PackageManager.INSTALL_LOCATION_INTERNAL_ONLY，优先内置！ prefer = RECOMMEND_INSTALL_INTERNAL; checkBoth = false; &#125; else if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) &#123; //【2.5】如果指定了 PackageManager.INSTALL_LOCATION_PREFER_EXTERNAL，优先外置！ prefer = RECOMMEND_INSTALL_EXTERNAL; checkBoth = true; &#125; else if (installLocation == PackageInfo.INSTALL_LOCATION_AUTO) &#123; //【2.6】如果指定了 PackageManager.INSTALL_LOCATION_AUTO，那么我们自动调整！ if (existingInfo != null) &#123; //【2.6.1】如果之前已经安装过该应用，那么就和之前安装的位置保持一致！ if ((existingInfo.flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) &#123; prefer = RECOMMEND_INSTALL_EXTERNAL; &#125; else &#123; prefer = RECOMMEND_INSTALL_INTERNAL; &#125; &#125; else &#123; //【2.6.2】否则，自动安装到内置！ prefer = RECOMMEND_INSTALL_INTERNAL; &#125; checkBoth = true; &#125; else &#123; //【2.7】其他情况，默认是内置！ prefer = RECOMMEND_INSTALL_INTERNAL; checkBoth = false; &#125; //【3】再次校验内置和外置是否合适！ boolean fitsOnInternal = false; if (checkBoth || prefer == RECOMMEND_INSTALL_INTERNAL) &#123; fitsOnInternal = fitsOnInternal(context, sizeBytes); &#125; boolean fitsOnExternal = false; if (checkBoth || prefer == RECOMMEND_INSTALL_EXTERNAL) &#123; fitsOnExternal = fitsOnExternal(context, sizeBytes); &#125; //【4】最后，返回合适的安装位置！ if (prefer == RECOMMEND_INSTALL_INTERNAL) &#123; //【4.1】如果优先安装到内置，且内置存储是合适的，根据是否是 ephemeral 返回不同的值！ if (fitsOnInternal) &#123; return (ephemeral) ? PackageHelper.RECOMMEND_INSTALL_EPHEMERAL : PackageHelper.RECOMMEND_INSTALL_INTERNAL; &#125; &#125; else if (prefer == RECOMMEND_INSTALL_EXTERNAL) &#123; //【4.2】如果优先安装到外置，且外置存储是合适的，返回结果！ if (fitsOnExternal) &#123; return PackageHelper.RECOMMEND_INSTALL_EXTERNAL; &#125; &#125; //【4.3】其他情况！ if (checkBoth) &#123; if (fitsOnInternal) &#123; return PackageHelper.RECOMMEND_INSTALL_INTERNAL; &#125; else if (fitsOnExternal) &#123; return PackageHelper.RECOMMEND_INSTALL_EXTERNAL; &#125; &#125; //【5】异常情况，返回 PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE！ return PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;&#125; 整个过程很简单，不多说了！ 5.5.2 PackageManagerS.installLocationPolicyPackageInfoLite pkgLite 保存了本次要安装的应用的信息！ installLocationPolicy 方法会对降级安装和替换安装做一个校验和判断！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private int installLocationPolicy(PackageInfoLite pkgLite) &#123; String packageName = pkgLite.packageName; int installLocation = pkgLite.installLocation; boolean onSd = (installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0; synchronized (mPackages) &#123; //【1】如果该应用已经安装过的话，那就获得上次安装后的解析信息！ PackageParser.Package installedPkg = mPackages.get(packageName); // 下面这段代码主要是处理卸载但是保留了数据的情况，比如 adb uninstall -k！ PackageParser.Package dataOwnerPkg = installedPkg; if (dataOwnerPkg == null) &#123; PackageSetting ps = mSettings.mPackages.get(packageName); if (ps != null) &#123; dataOwnerPkg = ps.pkg; &#125; &#125; //【2】如果 dataOwnerPkg 不为 nulkl，说明之前已经安装了！ if (dataOwnerPkg != null) &#123; //【2.1】如果安装标志位设置了 INSTALL_ALLOW_DOWNGRADE，表示允许降级安装！ final boolean downgradeRequested = (installFlags &amp; PackageManager.INSTALL_ALLOW_DOWNGRADE) != 0; //【2.2】判断应用是否允许 debug！ final boolean packageDebuggable = (dataOwnerPkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; //【2.3】如果要能够降级安装，必须满足 2 个条件：1、安装标志位设置了 allow downgrade // 2、系统允许 debug 或者该应用可以 debug！ final boolean downgradePermitted = (downgradeRequested) &amp;&amp; ((Build.IS_DEBUGGABLE) || (packageDebuggable)); if (!downgradePermitted) &#123; try &#123; //【5.5.2.1】如果，安装不允许降级，那就需要做检查！ checkDowngrade(dataOwnerPkg, pkgLite); &#125; catch (PackageManagerException e) &#123; Slog.w(TAG, \"Downgrade detected: \" + e.getMessage()); return PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE; &#125; &#125; &#125; //【3】接着处理覆盖安装的情况，即相同包名的应用已经存在！ if (installedPkg != null) &#123; //【3.1】覆盖安装的情况，必须携带 PackageManager.INSTALL_REPLACE_EXISTING 安装标志位！ if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) &#123; if ((installedPkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; //【3.1.1】对于系统应用，不能覆盖安装到 sd 卡上！ if (onSd) &#123; Slog.w(TAG, \"Cannot install update to system app on sdcard\"); return PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION; &#125; return PackageHelper.RECOMMEND_INSTALL_INTERNAL; &#125; else &#123; //【3.1.2】对于非系统应用，如果是安装到 sdcard，直接返回对应值！ if (onSd) &#123; return PackageHelper.RECOMMEND_INSTALL_EXTERNAL; &#125; //【3.1.2】对于非系统应用，如果只安装到内置，直接返回对应值！ if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) &#123; return PackageHelper.RECOMMEND_INSTALL_INTERNAL; &#125; else if (installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) &#123; //【3.1.3】对于非系统应用，如果优先安装到外置，那么安装位置由 // pkgLite.recommendedInstallLocation 决定！ &#125; else &#123; //【3.1.4】对于非系统应用，其他情况进入这里！ if (isExternal(installedPkg)) &#123; return PackageHelper.RECOMMEND_INSTALL_EXTERNAL; &#125; return PackageHelper.RECOMMEND_INSTALL_INTERNAL; &#125; &#125; &#125; else &#123; //【3.2】异常情况 return PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS; &#125; &#125; &#125; //【4】如果上面的条件都不满足，并且指定了在 sdcard，那么就返回 RECOMMEND_INSTALL_EXTERNAL； if (onSd) &#123; return PackageHelper.RECOMMEND_INSTALL_EXTERNAL; &#125; //【5】其他情况，均由 pkgLite.recommendedInstallLocation 决定！ return pkgLite.recommendedInstallLocation;&#125; 5.5.3 PackageManagerS.createInstallArgs其实就是针对不同的安装方式，创建不同的 InstallArgs！ 123456789101112private InstallArgs createInstallArgs(InstallParams params) &#123; if (params.move != null) &#123; //【1】如果是 move package，那么会创建 MoveInstallArgs 实例！ return new MoveInstallArgs(params); &#125; else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) &#123; //【2】对于安装到外置存储，或者 forward locked 安装，会创建 AsecInstallArgs 实例！ return new AsecInstallArgs(params); &#125; else &#123; //【5.5.3.1】对于一般安装，创建 FileInstallArgs 实例！ return new FileInstallArgs(params); &#125;&#125; 这里我们先关注一般情况，即创建 FileInstallArgs 实例的情况！ 5.5.3.1 new FileInstallArgs - 要安装的 apk12345678910111213141516171819202122232425262728293031323334class FileInstallArgs extends InstallArgs &#123; private File codeFile; private File resourceFile; // Example topology: // /data/app/com.example/base.apk // /data/app/com.example/split_foo.apk // /data/app/com.example/lib/arm/libfoo.so // /data/app/com.example/lib/arm64/libfoo.so // /data/app/com.example/dalvik/arm/base.apk@classes.dex //【1】安装一个新的 apk！ FileInstallArgs(InstallParams params) &#123; super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null /*instructionSets*/, params.packageAbiOverride, params.grantedRuntimePermissions, params.traceMethod, params.traceCookie, params.certificates); //【1.1】这里校验了下是否是 Forward Locked 的！ if (isFwdLocked()) &#123; throw new IllegalArgumentException(\"Forward locking only supported in ASEC\"); &#125; &#125; //【2】用于描述已存在的一个安装！ FileInstallArgs(String codePath, String resourcePath, String[] instructionSets) &#123; super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, 0, null /*certificates*/); this.codeFile = (codePath != null) ? new File(codePath) : null; this.resourceFile = (resourcePath != null) ? new File(resourcePath) : null; &#125; ... ... ...&#125; 我们看到 FileInstallArgs 有两个构造器！ 一参数构造器用于创建安装过程中的 InstallArgs！ 三参数构造器，用于描述一个已存在的安装，主要用于清除旧的安装，或者作为移动应用的时候的源数据，我们在 pms 开机初始化的过程中就已经看到过了！ 当然，这里我们重点关注安装过程！ 5.5.4 PackageManagerService.isVerificationEnabledisVerificationEnabled 用于校验系统是否打开了校验功能！ 12345678910111213141516171819202122232425262728293031323334353637383940private boolean isVerificationEnabled(int userId, int installFlags) &#123; if (!DEFAULT_VERIFY_ENABLE) &#123;//【1】如果默认没有打开校验，false！ return false; &#125; //【2】如果是 INSTALL_EPHEMERAL 方式的安装，不校验，false！ if ((installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.d(TAG, \"INSTALL_EPHEMERAL so skipping verification\"); &#125; return false; &#125; //【3】判断该用户下是否允许校验应用！ boolean ensureVerifyAppsEnabled = isUserRestricted(userId, UserManager.ENSURE_VERIFY_APPS); //【4】如果安装指定了 INSTALL_FROM_ADB，进入这里！ if ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0) &#123; //【4.1】test harness environment 不校验！ if (ActivityManager.isRunningInTestHarness()) &#123; return false; &#125; //【4.2】如果同时该用户下能校验应用，返回 true！ if (ensureVerifyAppsEnabled) &#123; return true; &#125; //【4.3】对于 adb install，如果系统属性 PACKAGE_VERIFIER_INCLUDE_ADB 为 0 ，那就不用校验！ if (android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_INCLUDE_ADB, 1) == 0) &#123; return false; &#125; &#125; //【5】如果该用户下能校验应用，返回 true！ if (ensureVerifyAppsEnabled) &#123; return true; &#125; //【6】判断系统属性 PACKAGE_VERIFIER_ENABLE 如果为 0，那就不用校验！ return android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_ENABLE, 1) == 1;&#125; 就不多说了！ 5.5.5 new PackageVerificationStatePackageVerificationState 用于保存被安装的应用的校验状态信息： 12345678910111213141516class PackageVerificationState &#123; private final InstallArgs mArgs; // InstallArgs 实例 private final SparseBooleanArray mSufficientVerifierUids; private final int mRequiredVerifierUid; // 校验者的 uid！ private boolean mSufficientVerificationComplete; private boolean mSufficientVerificationPassed; private boolean mRequiredVerificationComplete; private boolean mRequiredVerificationPassed; private boolean mExtendedTimeout; public PackageVerificationState(int requiredVerifierUid, InstallArgs args) &#123; mRequiredVerifierUid = requiredVerifierUid; mArgs = args; mSufficientVerifierUids = new SparseBooleanArray(); mExtendedTimeout = false; // 表示是否超时！ &#125; 不多说了！ 5.6 PackageHandler.doHandleMessage[CHECK_PENDING_VERIFICATION] - 校验完成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950case CHECK_PENDING_VERIFICATION: &#123; //【1】获得校验唯一标识！ final int verificationId = msg.arg1; //【2】获得本次校验的 PackageVerificationState 实例！ final PackageVerificationState state = mPendingVerification.get(verificationId); if ((state != null) &amp;&amp; !state.timeoutExtended()) &#123; //【3】获得 InstallArgs 实例！ final InstallArgs args = state.getInstallArgs(); final Uri originUri = Uri.fromFile(args.origin.resolvedFile); Slog.i(TAG, \"Verification timed out for \" + originUri); //【4】从 mPendingVerification 中移除校验状态对象！ mPendingVerification.remove(verificationId); int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; //【5】处理校验结果！ if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) &#123; //【5.1】校验成功 Slog.i(TAG, \"Continuing with installation of \" + originUri); state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT); //【5.6.1】发送 Intent.ACTION_PACKAGE_VERIFIED 广播 broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser()); try &#123; //【5.6.2】校验成功后，调用 installArgs.copyApk 继续处理！ ret = args.copyApk(mContainerService, true); &#125; catch (RemoteException e) &#123; Slog.e(TAG, \"Could not contact the ContainerService\"); &#125; &#125; else &#123; //【5.6.1】校验失败，发送 Intent.ACTION_PACKAGE_VERIFIED 广播 broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser()); &#125; Trace.asyncTraceEnd( TRACE_TAG_PACKAGE_MANAGER, \"verification\", verificationId); //【5.7】继续安装！ processPendingInstall(args, ret); // 安装过程结束，发送 MCS_UNBIND 消息！ mHandler.sendEmptyMessage(MCS_UNBIND); &#125; break;&#125; 这里我们通过 getDefaultVerificationResponse 方法返回校验结果：12345private int getDefaultVerificationResponse() &#123; return android.provider.Settings.Global.getInt(mContext.getContentResolver(), android.provider.Settings.Global.PACKAGE_VERIFIER_DEFAULT_RESPONSE, DEFAULT_VERIFICATION_RESPONSE);&#125; 默认返回的是 PackageManager.VERIFICATION_ALLOW，比如在校验超时的情况下！ 5.6.1 PackageManagerS.broadcastPackageVerified1234567891011private void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) &#123; final Intent intent = new Intent(Intent.ACTION_PACKAGE_VERIFIED); intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId); intent.putExtra(PackageManager.EXTRA_VERIFICATION_RESULT, verificationCode); mContext.sendBroadcastAsUser(intent, user, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT);&#125; 5.6.2 FileInstallArgs.(do)copyApk12345678int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"copyApk\"); try &#123; return doCopyApk(imcs, temp); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; copyApk 调用了 doCopyApk 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private int doCopyApk(IMediaContainerService imcs, boolean temp) throws RemoteException &#123; //【1】如果 origin.staged 为 true，那么说明应用已经 copy 到目标目录了， // 那就直接返回 PackageManager.INSTALL_SUCCEEDED！ if (origin.staged) &#123; if (DEBUG_INSTALL) Slog.d(TAG, origin.file + \" already staged; skipping copy\"); //【1.1】设置 FileInstallArgs 的 codeFile 属性！ codeFile = origin.file; resourceFile = origin.file; return PackageManager.INSTALL_SUCCEEDED; &#125; //【2】如果 origin.staged 为 false，说明应用没有拷贝到目标目录！ try &#123; final boolean isEphemeral = (installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0; //【5.6.2.1】获得要拷贝的目标目录！ final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid, isEphemeral); codeFile = tempDir; resourceFile = tempDir; &#125; catch (IOException e) &#123; Slog.w(TAG, \"Failed to create copy file: \" + e); return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE; &#125; //【3】回调接口！ final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() &#123; @Override public ParcelFileDescriptor open(String name, int mode) throws RemoteException &#123; if (!FileUtils.isValidExtFilename(name)) &#123; throw new IllegalArgumentException(\"Invalid filename: \" + name); &#125; try &#123; //【3.1】访问 codeFile 目录下的 name 文件，设置权限，并返回其文件描述符！ final File file = new File(codeFile, name); final FileDescriptor fd = Os.open(file.getAbsolutePath(), O_RDWR | O_CREAT, 0644); Os.chmod(file.getAbsolutePath(), 0644); return new ParcelFileDescriptor(fd); &#125; catch (ErrnoException e) &#123; throw new RemoteException(\"Failed to open: \" + e.getMessage()); &#125; &#125; &#125;; int ret = PackageManager.INSTALL_SUCCEEDED; //【5.6.2.2】将应用程序拷贝到目标目录！ ret = imcs.copyPackage(origin.file.getAbsolutePath(), target); if (ret != PackageManager.INSTALL_SUCCEEDED) &#123; Slog.e(TAG, \"Failed to copy package\"); return ret; &#125; //【4】解压本地 lib 库文件！ final File libraryRoot = new File(codeFile, LIB_DIR_NAME); NativeLibraryHelper.Handle handle = null; try &#123; handle = NativeLibraryHelper.Handle.create(codeFile); ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, abiOverride); &#125; catch (IOException e) &#123; Slog.e(TAG, \"Copying native libraries failed\", e); ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR; &#125; finally &#123; IoUtils.closeQuietly(handle); &#125; return ret;&#125; 根据前面创建 OriginInfo 时知道： 12345if (stagedDir != null) &#123; origin = OriginInfo.fromStagedFile(stagedDir);&#125; else &#123; origin = OriginInfo.fromStagedContainer(stagedCid);&#125; 通过 adb 安装时，安装到内置存储，会调用 OriginInfo.fromStagedFile 方法，此时 OriginInfo.staged 为 true，安装到外置存储时， OriginInfo.staged 也会为 true。 这是因为在进行 adb install 过程中时，我们通过 Session，已经拷贝到目标目录了：/data/app/vml[sessionId].tmp/，所以这里 doCopyApk 无需在继续进行下去！！ 对于其他的安装方式，OriginInfo.staged 为 false 的，那么会进入 doCopyApk 的下一步！ 5.6.2.1 PackageInstallerService.allocateStageDirLegacy1234567891011121314151617@Deprecatedpublic File allocateStageDirLegacy(String volumeUuid, boolean isEphemeral) throws IOException &#123; synchronized (mSessions) &#123; try &#123; //【3.1.2】分配一个 sessionId，保存到 mLegacySessions 中！ final int sessionId = allocateSessionIdLocked(); mLegacySessions.put(sessionId, true); //【3.1.2】创建目标目录！ final File stageDir = buildStageDir(volumeUuid, sessionId, isEphemeral); //【2】创建目录，设置权限！ prepareStageDir(stageDir); return stageDir; &#125; catch (IllegalStateException e) &#123; throw new IOException(e); &#125; &#125;&#125; 这里，前面分析过，这里就不多说了！ 5.6.2.2 DefaultContainerService.copyPackage(Inner)123456789101112131415161718@Overridepublic int copyPackage(String packagePath, IParcelFileDescriptorFactory target) &#123; if (packagePath == null || target == null) &#123; return PackageManager.INSTALL_FAILED_INVALID_URI; &#125; PackageLite pkg = null; try &#123; final File packageFile = new File(packagePath); //【1】解析应用！ pkg = PackageParser.parsePackageLite(packageFile, 0); //【2】继续处理 copyPackageInner return copyPackageInner(pkg, target); &#125; catch (PackageParserException | IOException | RemoteException e) &#123; Slog.w(TAG, \"Failed to copy package at \" + packagePath + \": \" + e); return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE; &#125;&#125; 这里继续调用了 copyPackageInner 方法123456789101112private int copyPackageInner(PackageLite pkg, IParcelFileDescriptorFactory target) throws IOException, RemoteException &#123; //【1】对 base apk 和 split apk 分别执行 copy！ copyFile(pkg.baseCodePath, target, \"base.apk\"); if (!ArrayUtils.isEmpty(pkg.splitNames)) &#123; for (int i = 0; i &lt; pkg.splitNames.length; i++) &#123; copyFile(pkg.splitCodePaths[i], target, \"split_\" + pkg.splitNames[i] + \".apk\"); &#125; &#125; return PackageManager.INSTALL_SUCCEEDED;&#125; 最终，调用了 copyFile 执行 copy！ 123456789101112131415private void copyFile(String sourcePath, IParcelFileDescriptorFactory target, String targetName) throws IOException, RemoteException &#123; Slog.d(TAG, \"Copying \" + sourcePath + \" to \" + targetName); InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(sourcePath); out = new ParcelFileDescriptor.AutoCloseOutputStream( target.open(targetName, ParcelFileDescriptor.MODE_READ_WRITE)); Streams.copy(in, out); &#125; finally &#123; IoUtils.closeQuietly(out); IoUtils.closeQuietly(in); &#125;&#125; 到这里就结束了！ 5.7 PackageManagerS.processPendingInstallprocessPendingInstall 用于继续安装： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123; // Queue up an async operation since the package installation may take a little while. mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); //【5.7.1】创建 PackageInstalledInfo 实例，封装安装结果！ PackageInstalledInfo res = new PackageInstalledInfo(); res.setReturnCode(currentStatus); // 保存当前的返回码 res.uid = -1; res.pkg = null; res.removedInfo = null; //【1】如果返回码为 PackageManager.INSTALL_SUCCEEDED！ if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; //【×5.7.2】安装前处理； args.doPreInstall(res.returnCode); synchronized (mInstallLock) &#123; //【×5.7.3】执行安装！ installPackageTracedLI(args, res); &#125; //【×5.7.4】安装后处理； args.doPostInstall(res.returnCode, res.uid); &#125; //【2】判断是否执行备份，要备份必须满足 3 个条件！ // 1、安装正常；2、本次安装并不是更新操作！3、应用允许备份 final boolean update = res.removedInfo != null &amp;&amp; res.removedInfo.removedPackage != null; final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags; boolean doRestore = !update &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0); //【3】计算本次安装的 token int token; if (mNextInstallToken &lt; 0) mNextInstallToken = 1; token = mNextInstallToken++; //【*5.7.5】创建一个 PostInstallData 对象，并将其加入 mRunningInstalls 中！ PostInstallData data = new PostInstallData(args, res); mRunningInstalls.put(token, data); if (DEBUG_INSTALL) Log.v(TAG, \"+ starting restore round-trip \" + token); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123; //【4】如果安装成功，并且需要备份，那就获得 BackupManager 执行备份！ IBackupManager bm = IBackupManager.Stub.asInterface( ServiceManager.getService(Context.BACKUP_SERVICE)); if (bm != null) &#123; if (DEBUG_INSTALL) Log.v(TAG, \"token \" + token + \" to BM for possible restore\"); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"restore\", token); try &#123; // TODO: http://b/22388012 if (bm.isBackupServiceActive(UserHandle.USER_SYSTEM)) &#123; bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token); &#125; else &#123; doRestore = false; &#125; &#125; catch (RemoteException e) &#123; // can't happen; the backup manager is local &#125; catch (Exception e) &#123; Slog.e(TAG, \"Exception trying to enqueue restore\", e); doRestore = false; &#125; &#125; else &#123; Slog.e(TAG, \"Backup Manager not found!\"); doRestore = false; &#125; &#125; //【5】如果备份失败或者不需要备份，那就进入这个阶段！ if (!doRestore) &#123; // No restore possible, or the Backup Manager was mysteriously not // available -- just fire the post-install work request directly. if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, \"postInstall\", token); Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); mHandler.sendMessage(msg); &#125; &#125; &#125;);&#125; 5.7.1 new PackageInstalledInfoPackageInstalledInfo 用于保存该应用的安装结果信息！ 123456789101112131415161718static class PackageInstalledInfo &#123; String name; int uid; int[] origUsers; // 该 pacakge 之前安装后所属的 user int[] newUsers; // 该 pacakge 现在安装后所属的 user PackageParser.Package pkg; int returnCode; // 返回码 String returnMsg; //【7.7.1.1】用于封装要移除的 apk 的信息！ PackageRemovedInfo removedInfo; ArrayMap&lt;String, PackageInstalledInfo&gt; addedChildPackages; // split apk 的安装结果信息！ ... ... ... // In some error cases we want to convey more info back to the observer String origPackage; String origPermission;&#125; 我们先看到这里！ 5.7.1.1 new PackageRemovedInfo封装要移除的 apk 的信息： 12345678910111213141516class PackageRemovedInfo &#123; String removedPackage; int uid = -1; int removedAppId = -1; int[] origUsers; int[] removedUsers = null; boolean isRemovedPackageSystemUpdate = false; boolean isUpdate; boolean dataRemoved; boolean removedForAllUsers; //【1】InstallArgs 用于清除 apk 的相关数据，后面会看到！ InstallArgs args = null; ArrayMap&lt;String, PackageRemovedInfo&gt; removedChildPackages; ArrayMap&lt;String, PackageInstalledInfo&gt; appearedChildPackages; ... ... ...&#125; 5.7.2 FileInstallArgs.doPreInstall安装前执行清理操作，正常情况不会触发！12345678int doPreInstall(int status) &#123; //【1】如果安装前的状态不是 PackageManager.INSTALL_SUCCEEDED if (status != PackageManager.INSTALL_SUCCEEDED) &#123; //【5.7.2.1】执行清理操作！ cleanUp(); &#125; return status;&#125; 5.7.2.1 FileInstallArgs.cleanUp(ResourcesLI)清理操作！12345678910111213private boolean cleanUp() &#123; if (codeFile == null || !codeFile.exists()) &#123; return false; &#125; //【1】删除目标目录下的所有文件！ removeCodePathLI(codeFile); if (resourceFile != null &amp;&amp; !FileUtils.contains(codeFile, resourceFile)) &#123; resourceFile.delete(); &#125; return true;&#125; 可以看到，最后调用了 removeCodePathLI 方法！1234567891011void removeCodePathLI(File codePath) &#123; if (codePath.isDirectory()) &#123; try &#123; mInstaller.rmPackageDir(codePath.getAbsolutePath()); &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Failed to remove code path\", e); &#125; &#125; else &#123; codePath.delete(); &#125;&#125; 5.7.3 PackageManagerS.installPackageTracedLI - 核心安装入口123456789private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) &#123; try &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installPackage\"); //【1】调用了 installPackageLI 方法！ installPackageLI(args, res); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 这里调用了 installPackageLI 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369private void installPackageLI(InstallArgs args, PackageInstalledInfo res) &#123; //【1】获得安装时传入的参数和标志位！！ final int installFlags = args.installFlags; final String installerPackageName = args.installerPackageName; final String volumeUuid = args.volumeUuid; final File tmpPackageFile = new File(args.getCodePath()); final boolean forwardLocked = ((installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0); final boolean onExternal = (((installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null)); final boolean ephemeral = ((installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0); final boolean forceSdk = ((installFlags &amp; PackageManager.INSTALL_FORCE_SDK) != 0); boolean replace = false; //【2】重新设置扫描参数 int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE; if (args.move != null) &#123; //【2.1】如果 args.move 不为 null，表示正在移动一个 app，我们会对其进行一个初始化的扫描 // 增加 SCAN_INITIAL 位！ scanFlags |= SCAN_INITIAL; &#125; if ((installFlags &amp; PackageManager.INSTALL_DONT_KILL_APP) != 0) &#123; //【2.2】如果安装参数指定了 INSTALL_DONT_KILL_APP，那么增加 SCAN_DONT_KILL_APP 位！ scanFlags |= SCAN_DONT_KILL_APP; &#125; //【3】更新结果码！ res.setReturnCode(PackageManager.INSTALL_SUCCEEDED); if (DEBUG_INSTALL) Slog.d(TAG, \"installPackageLI: path=\" + tmpPackageFile); //【4】检查 ephemeral 是否和 forwardLocked/onExternal 共存，共存则报错！ if (ephemeral &amp;&amp; (forwardLocked || onExternal)) &#123; Slog.i(TAG, \"Incompatible ephemeral install; fwdLocked=\" + forwardLocked + \" external=\" + onExternal); res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID); return; &#125; //【5】设置解析参数 parseFlags final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (ephemeral ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0); //【6】创建解析对象！ PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setDisplayMetrics(mMetrics); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\"); final PackageParser.Package pkg; try &#123; //【*5.7.3.1】解析 apk，获得其对应的 Package 对象！ pkg = pp.parsePackage(tmpPackageFile, parseFlags); &#125; catch (PackageParserException e) &#123; res.setError(\"Failed parse during installPackageLI\", e); return; &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; //【7】如果该应用有子包的话，那么对于每个子包，也会创建安装结果对象！！ if (pkg.childPackages != null) &#123; synchronized (mPackages) &#123; final int childCount = pkg.childPackages.size(); for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); //【*5.7.1】针对子包，创建 PackageInstalledInfo 对象! // 设置返回码，子包包名！ PackageInstalledInfo childRes = new PackageInstalledInfo(); childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED); childRes.pkg = childPkg; childRes.name = childPkg.packageName; //【7.1】获得子包的源 user! PackageSetting childPs = mSettings.peekPackageLPr(childPkg.packageName); if (childPs != null) &#123; childRes.origUsers = childPs.queryInstalledUsers( sUserManager.getUserIds(), true); &#125; //【7.2】如果子包之前被扫描到了（安装过），创建 PackageRemovedInfo 对象！ if ((mPackages.containsKey(childPkg.packageName))) &#123; childRes.removedInfo = new PackageRemovedInfo(); childRes.removedInfo.removedPackage = childPkg.packageName; &#125; if (res.addedChildPackages == null) &#123; res.addedChildPackages = new ArrayMap&lt;&gt;(); &#125; //【7.3】将子包的安装结果对象保存到 base apk 的信息中！ res.addedChildPackages.put(childPkg.packageName, childRes); &#125; &#125; &#125; // 如果应用没有指定 abi，我们通过安装参数指定！ if (TextUtils.isEmpty(pkg.cpuAbiOverride)) &#123; pkg.cpuAbiOverride = args.abiOverride; &#125; // 如果应用指定了 ApplicationInfo.FLAG_TEST_ONLY，那么安装参数也需要指定这个参数！ String pkgName = res.name = pkg.packageName; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) &#123; if ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == 0) &#123; res.setError(INSTALL_FAILED_TEST_ONLY, \"installPackageLI\"); return; &#125; &#125; try &#123; //【8】收集证书信息！ if (args.certificates != null) &#123; try &#123; PackageParser.populateCertificates(pkg, args.certificates); &#125; catch (PackageParserException e) &#123; PackageParser.collectCertificates(pkg, parseFlags); &#125; &#125; else &#123; PackageParser.collectCertificates(pkg, parseFlags); &#125; &#125; catch (PackageParserException e) &#123; res.setError(\"Failed collect during installPackageLI\", e); return; &#125; // Get rid of all references to package scan path via parser. pp = null; String oldCodePath = null; boolean systemApp = false; synchronized (mPackages) &#123; //【9】如果安装参数指定了 INSTALL_REPLACE_EXISTING，那么我们要尝试判断是否存在已安装的应用！ // 如果存在，那就要 replace！ if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) &#123; String oldName = mSettings.mRenamedPackages.get(pkgName); // 判断该应用是否重命名过！ if (pkg.mOriginalPackages != null &amp;&amp; pkg.mOriginalPackages.contains(oldName) &amp;&amp; mPackages.containsKey(oldName)) &#123; //【9.1】如果有源包（系统应用才会有），要命名为源包，replace 为 true！ pkg.setPackageName(oldName); pkgName = pkg.packageName; replace = true; if (DEBUG_INSTALL) Slog.d(TAG, \"Replacing existing renamed package: oldName=\" + oldName + \" pkgName=\" + pkgName); &#125; else if (mPackages.containsKey(pkgName)) &#123; //【9.2】如果没有源包（系统应用才会有），但是已经有相同包名的应用存在，replace 为 true！ replace = true; if (DEBUG_INSTALL) Slog.d(TAG, \"Replace existing pacakge: \" + pkgName); &#125; //【9.2】对于子包，只能通过父包更新，这里不处理子包的 replace！ if (pkg.parentPackage != null) &#123; res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, \"Package \" + pkg.packageName + \" is child of package \" + pkg.parentPackage.parentPackage + \". Child packages \" + \"can be updated only through the parent package.\"); return; &#125; //【9.3】如果需要替换已存在的 apk，那么需要做 sdk 的校验！ // 如果旧应用支持运行时，不允许新的应用不支持运行时！ if (replace) &#123; PackageParser.Package oldPackage = mPackages.get(pkgName); final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion; final int newTargetSdk = pkg.applicationInfo.targetSdkVersion; if (oldTargetSdk &gt; Build.VERSION_CODES.LOLLIPOP_MR1 &amp;&amp; newTargetSdk &lt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE, \"Package \" + pkg.packageName + \" new target SDK \" + newTargetSdk + \" doesn't support runtime permissions but the old\" + \" target SDK \" + oldTargetSdk + \" does.\"); return; &#125; //【9.4】如果旧包也是子包，也不安装！ if (oldPackage.parentPackage != null) &#123; res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, \"Package \" + pkg.packageName + \" is child of package \" + oldPackage.parentPackage + \". Child packages \" + \"can be updated only through the parent package.\"); return; &#125; &#125; &#125; //【10】获得上一次的安装数据！ PackageSetting ps = mSettings.mPackages.get(pkgName); if (ps != null) &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"Existing package: \" + ps); //【10.1】如果安装过旧版本，那就要校验签名！ //【×5.3.7.2】shouldCheckUpgradeKeySetLP 用于判断是否检查签名更新； if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) &#123; //【×5.3.7.3】checkUpgradeKeySetLP 用于检查签名更新； if (!checkUpgradeKeySetLP(ps, pkg)) &#123; res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" upgrade keys do not match the \" + \"previously installed version\"); return; &#125; &#125; else &#123; try &#123; //【×5.3.7.4】校验签名，如果签名不相等，那就禁止安装！ verifySignaturesLP(ps, pkg); &#125; catch (PackageManagerException e) &#123; res.setError(e.error, e.getMessage()); return; &#125; &#125; //【10.2】获得旧的 apk 的路径，判断旧应用是否是系统应用！ oldCodePath = mSettings.mPackages.get(pkgName).codePathString; if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null) &#123; systemApp = (ps.pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0; &#125; res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true); &#125; //【11】检查权限是否被重新定义，如果重新定义，那就要校验权限！ int N = pkg.permissions.size(); for (int i = N-1; i &gt;= 0; i--) &#123; //【11.1】获得该应用定义的权限 PackageParser.Permission perm = pkg.permissions.get(i); //【11.2】尝试从系统中获得该权限已有的信息！ BasePermission bp = mSettings.mPermissions.get(perm.info.name); if (bp != null) &#123; //【11.3】如果该权限已经被定义过了，那就要校验下签名！ final boolean sigsOk; if (bp.sourcePackage.equals(pkg.packageName) &amp;&amp; (bp.packageSetting instanceof PackageSetting) &amp;&amp; (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting, scanFlags))) &#123; //【11.3.1】检查签名更新！ sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg); &#125; else &#123; //【11.3.2】如果不检查签名更新，那就直接比较签名！ sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; &#125; //【11.4】如果签名发生了变化！ if (!sigsOk) &#123; if (!bp.sourcePackage.equals(\"android\")) &#123; //【11.4.1】如果权限的定义者不是系统，那么不允许重新定义，同时不允许继续安装！ res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, \"Package \" + pkg.packageName + \" attempting to redeclare permission \" + perm.info.name + \" already owned by \" + bp.sourcePackage); res.origPermission = perm.info.name; res.origPackage = bp.sourcePackage; return; &#125; else &#123; //【11.4.2】如果权限的定义不是系统，那么允许安装，但是会忽视掉新的定义！ Slog.w(TAG, \"Package \" + pkg.packageName + \" attempting to redeclare system permission \" + perm.info.name + \"; ignoring new declaration\"); pkg.permissions.remove(i); &#125; &#125; &#125; &#125; &#125; //【12】如果覆盖更新的是系统应用，要针对安装位置做判断！ // 新的 apk 不能是 onExternal / ephemeral！ if (systemApp) &#123; if (onExternal) &#123; res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, \"Cannot install updates to system apps on sdcard\"); return; &#125; else if (ephemeral) &#123; res.setError(INSTALL_FAILED_EPHEMERAL_INVALID, \"Cannot update a system app with an ephemeral app\"); return; &#125; &#125; //【13】根据安装参数做不同的处理！ if (args.move != null) &#123; //【13.1】如果是 move package，进入这里！ scanFlags |= SCAN_NO_DEX; // 设置以下标签，无需做 odex，我们需要已有的移动过去即可！ scanFlags |= SCAN_MOVE; synchronized (mPackages) &#123; final PackageSetting ps = mSettings.mPackages.get(pkgName); if (ps == null) &#123; res.setError(INSTALL_FAILED_INTERNAL_ERROR, \"Missing settings for moved package \" + pkgName); &#125; //【13.1.1】对于 abi，和移动前的保持一致！ pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString; pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString; &#125; &#125; else if (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) &#123; //【13.2】如果不是 forward lock 模式安装且没有安装到外置存储上，进入这里！ scanFlags |= SCAN_NO_DEX; // 扫描参数设置 SCAN_NO_DEX，意味着后面不做 odex，因为这里会做！ try &#123; String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride); derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, true /* extract libs */); &#125; catch (PackageManagerException pme) &#123; Slog.e(TAG, \"Error deriving application ABI\", pme); res.setError(INSTALL_FAILED_INTERNAL_ERROR, \"Error deriving application ABI\"); return; &#125; //【13.2.1】更新共享库文件！！ synchronized (mPackages) &#123; try &#123; updateSharedLibrariesLPw(pkg, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"updateSharedLibrariesLPw failed: \" + e.getMessage()); &#125; &#125; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"dexopt\"); //【13.2.2】执行 odex 优化 mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null /* instructionSets */, false /* checkProfiles */, getCompilerFilterForReason(REASON_INSTALL), getOrCreateCompilerPackageStats(pkg)); Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); //【13.2.3】将该应用从 odex fail list 中删除！ BackgroundDexOptService.notifyPackageChanged(pkg.packageName); &#125; //【×5.7.3.5】重命名文件目录，此时文件目录由 /data/app/tmpl[SessionId].tmp 变为 /data/app/packageName-X！ // 如果 X 存在，那么会 X + 1; if (!args.doRename(res.returnCode, pkg, oldCodePath)) &#123; res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Failed rename\"); return; &#125; //【*5.7.3.6】开始 intentFilter 校验！ startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg); //【*5.7.3.7】冻结应用！ try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, \"installPackageLI\")) &#123; if (replace) &#123; //【*6】如果是覆盖安装，进入这里！ replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res); &#125; else &#123; //【*7】如果是全新安装，进入这里！ installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res); &#125; &#125; //【14】为本次安装的 apk 更新目标用户信息！ synchronized (mPackages) &#123; final PackageSetting ps = mSettings.mPackages.get(pkgName); if (ps != null) &#123; res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true); &#125; final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName); PackageSetting childPs = mSettings.peekPackageLPr(childPkg.packageName); if (childPs != null) &#123; childRes.newUsers = childPs.queryInstalledUsers( sUserManager.getUserIds(), true); &#125; &#125; &#125;&#125; 5.7.3.1 PackageParser.parsePackagePackageParser.parsePackage 其实我们在 PMS 启动扫描的过程中已经分析过了，这里我们重点关注其对 installFlags 的处理！ 5.7.3.2 shouldCheckUpgradeKeySetLP判断是否应该检查签名更新： 12345678910111213141516171819202122232425private boolean shouldCheckUpgradeKeySetLP(PackageSetting oldPs, int scanFlags) &#123; //【1】以下情况无需检查签名更新： // 1、本次是全新安装；2、扫描设置了 SCAN_INITIAL(move pkg)；3、本次是覆盖安装，但是应用是 sharedUser 的！ // 4、应用不使用 upgradeKeySets！ if (oldPs == null || (scanFlags &amp; SCAN_INITIAL) != 0 || oldPs.sharedUser != null || !oldPs.keySetData.isUsingUpgradeKeySets()) &#123; return false; &#125; //【2】如果应用是覆盖安装，且不是 move pkg，且不是共享 uid 的，且使用 upgradeKeySets，那么就要检查 // upgradeKeySets 有效性，只有有效的 upgradeKeySets 才能检查更新！ KeySetManagerService ksms = mSettings.mKeySetManagerService; long[] upgradeKeySets = oldPs.keySetData.getUpgradeKeySets(); for (int i = 0; i &lt; upgradeKeySets.length; i++) &#123; //【2.1】判断 upgradeKeySets 是否有效！ if (!ksms.isIdValidKeySetId(upgradeKeySets[i])) &#123; Slog.wtf(TAG, \"Package \" + (oldPs.name != null ? oldPs.name : \"&lt;null&gt;\") + \" contains upgrade-key-set reference to unknown key-set: \" + upgradeKeySets[i] + \" reverting to signatures check.\"); return false; &#125; &#125; return true;&#125; 先分析到这里！ 5.7.3.3 checkUpgradeKeySetLP进行签名更新检查：123456789101112private boolean checkUpgradeKeySetLP(PackageSetting oldPS, PackageParser.Package newPkg) &#123; //【1】检查 key set 更新，更新有效的前提是新的 apk 持有的 keyset 至少包含旧应用的 keyset！ long[] upgradeKeySets = oldPS.keySetData.getUpgradeKeySets(); KeySetManagerService ksms = mSettings.mKeySetManagerService; for (int i = 0; i &lt; upgradeKeySets.length; i++) &#123; Set&lt;PublicKey&gt; upgradeSet = ksms.getPublicKeysFromKeySetLPr(upgradeKeySets[i]); if (upgradeSet != null &amp;&amp; newPkg.mSigningKeys.containsAll(upgradeSet)) &#123; return true; &#125; &#125; return false;&#125; 5.7.3.4 verifySignaturesLP校验签名： 123456789101112131415161718192021222324252627282930313233343536373839404142private void verifySignaturesLP(PackageSetting pkgSetting, PackageParser.Package pkg) throws PackageManagerException &#123; if (pkgSetting.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match boolean match = compareSignatures(pkgSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; if (!match) &#123; match = compareSignaturesCompat(pkgSetting.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; match = compareSignaturesRecover(pkgSetting.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" signatures do not match the \" + \"previously installed version; ignoring!\"); &#125; &#125; // Check for shared user signatures if (pkgSetting.sharedUser != null &amp;&amp; pkgSetting.sharedUser.signatures.mSignatures != null) &#123; // Already existing package. Make sure signatures match boolean match = compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; if (!match) &#123; match = compareSignaturesCompat(pkgSetting.sharedUser.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; match = compareSignaturesRecover(pkgSetting.sharedUser.signatures, pkg) == PackageManager.SIGNATURE_MATCH; &#125; if (!match) &#123; throw new PackageManagerException(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE, \"Package \" + pkg.packageName + \" has no signatures that match those in shared user \" + pkgSetting.sharedUser.name + \"; ignoring!\"); &#125; &#125;&#125; 5.7.3.5 FileInstallArgs.doRename - 重命名临时目录doRename 重命名文件！之前我们的临时目录为 /data/app/tmpl[SessionId].tmp，这里会将其重命名为 /data/app/packageName-X！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) &#123; if (status != PackageManager.INSTALL_SUCCEEDED) &#123; cleanUp(); return false; &#125; //【1】获得改名前的临时目录 targetDir 就是 /data/app/tmpl[SessionId].tmp！ final File targetDir = codeFile.getParentFile(); final File beforeCodeFile = codeFile; //【5.7.3.5.1】获得改名后的目录：/data/app/packageName-X，策略取决为 getNextCodePath！ final File afterCodeFile = getNextCodePath(targetDir, pkg.packageName); if (DEBUG_INSTALL) Slog.d(TAG, \"Renaming \" + beforeCodeFile + \" to \" + afterCodeFile); try &#123; Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath()); &#125; catch (ErrnoException e) &#123; Slog.w(TAG, \"Failed to rename\", e); return false; &#125; //【2】恢复默认的安全上下文！ if (!SELinux.restoreconRecursive(afterCodeFile)) &#123; Slog.w(TAG, \"Failed to restorecon\"); return false; &#125; //【3】更新 FileInstallArgs 的目录为最终目录！ codeFile = afterCodeFile; resourceFile = afterCodeFile; //【4】更新扫描到的应用的 Package 中的目录数据！ // 以及 Application 中的数据！ pkg.setCodePath(afterCodeFile.getAbsolutePath()); pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath)); pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths)); pkg.setApplicationVolumeUuid(pkg.volumeUuid); pkg.setApplicationInfoCodePath(pkg.codePath); pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath); pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths); pkg.setApplicationInfoResourcePath(pkg.codePath); pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath); pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths); return true;&#125; 流程很简单，不多说了！ 5.7.3.5.1 getNextCodePathgetNextCodePath 方法用于获得最终的目录！ 1234567891011private File getNextCodePath(File targetDir, String packageName) &#123; int suffix = 1; File result; do &#123; //【1】最终目录为 /data/app/packageName-X(X=1,2,3...) // suffix 从 1 开始，如果 suffix 已存在，那就 +1; result = new File(targetDir, packageName + \"-\" + suffix); suffix++; &#125; while (result.exists()); return result;&#125; 逻辑很简单，不多说了！ 5.7.3.7 freezePackageForInstall - 冻结应用该方法用于冻结应用： 1234public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) &#123; return freezePackageForInstall(packageName, UserHandle.USER_ALL, installFlags, killReason);&#125; 继续来看：12345678910public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) &#123; if ((installFlags &amp; PackageManager.INSTALL_DONT_KILL_APP) != 0) &#123; //【1】如果指定了卸载时不 kill app，就用默认的参数（卸载时才会进入） return new PackageFreezer(); &#125; else &#123; //【2】默认是需要 kill app 的，调用 freezePackage！ return freezePackage(packageName, userId, killReason); &#125;&#125; 继续调用 freezePackage 方法：1234public PackageFreezer freezePackage(String packageName, int userId, String killReason) &#123; //【×5.7.3.7.1】创建了一个 PackageFreezer 实例！ return new PackageFreezer(packageName, userId, killReason);&#125; 5.7.3.7.1 new PackageFreezer如果不杀进程，那就只创建一个 PackageFreezer 实例，并返回，不做任何事情！ 123456public PackageFreezer() &#123; mPackageName = null; mChildren = null; mWeFroze = false; mCloseGuard.open(\"close\");&#125; 如果要 kill app，那么会创建 PackageFreezer（父包和子包），并且会杀掉进程！ 1234567891011121314151617181920212223242526public PackageFreezer(String packageName, int userId, String killReason) &#123; synchronized (mPackages) &#123; mPackageName = packageName; mWeFroze = mFrozenPackages.add(mPackageName); final PackageSetting ps = mSettings.mPackages.get(mPackageName); if (ps != null) &#123; //【1】杀掉父包的进程! killApplication(ps.name, ps.appId, userId, killReason); &#125; final PackageParser.Package p = mPackages.get(packageName); if (p != null &amp;&amp; p.childPackages != null) &#123; final int N = p.childPackages.size(); mChildren = new PackageFreezer[N]; for (int i = 0; i &lt; N; i++) &#123; //【2】为子包创建 PackageFreezer，并杀掉子包的进程！ mChildren[i] = new PackageFreezer(p.childPackages.get(i).packageName, userId, killReason); &#125; &#125; else &#123; mChildren = null; &#125; &#125; mCloseGuard.open(\"close\");&#125; 这里就不多说了！！ 5.7.4 FileInstallArgs.doPostInstall清理操作，正常情况不会触发！ 12345678int doPostInstall(int status, int uid) &#123; //【1】如果安装前的状态不是 PackageManager.INSTALL_SUCCEEDED if (status != PackageManager.INSTALL_SUCCEEDED) &#123; //【5.7.2.1】执行清理操作！ cleanUp(); &#125; return status;&#125; 5.7.5 new PostInstallData又创建了一个 PostInstallData 对象，对 PackageInstalledInfo 做了再次封装： 123456789static class PostInstallData &#123; public InstallArgs args; public PackageInstalledInfo res; PostInstallData(InstallArgs _a, PackageInstalledInfo _r) &#123; args = _a; res = _r; &#125;&#125; 继续来看！! 5.8 PackageHandler.doHandleMessage[POST_INSTALL] - 安装收尾PackageHandler 会处理 POST_INSTALL 消息，此时已经处于安装收尾阶段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case POST_INSTALL: &#123; if (DEBUG_INSTALL) Log.v(TAG, \"Handling post-install for \" + msg.arg1); //【1】我们在安装开始前，会用 PostInstallData 封装安装结果，并保存到 mRunningInstalls 中！ // 在安装结束后，会处理本次的安装结果！ PostInstallData data = mRunningInstalls.get(msg.arg1); final boolean didRestore = (msg.arg2 != 0); mRunningInstalls.delete(msg.arg1); // 删除掉！ if (data != null) &#123; InstallArgs args = data.args; PackageInstalledInfo parentRes = data.res; //【2】本次安装是否授予运行时权限！ final boolean grantPermissions = (args.installFlags &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0; //【2】本次安装是否 kill app！ final boolean killApp = (args.installFlags &amp; PackageManager.INSTALL_DONT_KILL_APP) == 0; final String[] grantedPermissions = args.installGrantPermissions; //【×5.8.1】调用 handlePackagePostInstall 继续处理收尾工作！ handlePackagePostInstall(parentRes, grantPermissions, killApp, grantedPermissions, didRestore, args.installerPackageName, args.observer); //【3】处理子包！ final int childCount = (parentRes.addedChildPackages != null) ? parentRes.addedChildPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageInstalledInfo childRes = parentRes.addedChildPackages.valueAt(i); //【×5.8.1】调用 handlePackagePostInstall 继续处理收尾工作！ handlePackagePostInstall(childRes, grantPermissions, killApp, grantedPermissions, false, args.installerPackageName, args.observer); &#125; if (args.traceMethod != null) &#123; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, args.traceMethod, args.traceCookie); &#125; &#125; else &#123; Slog.e(TAG, \"Bogus post-install token \" + msg.arg1); &#125; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, \"postInstall\", msg.arg1);&#125; break; 继续处理！ 5.8.1 PackageManagerS.handlePackagePostInstall处理安装收尾工作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155private void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, String[] grantedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) &#123; //【1】当安装结果为 success 后，会进入后续的处理！ if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; //【1.1】如果是 move pacakge，那么发送 removed 广播！ if (res.removedInfo != null) &#123; res.removedInfo.sendPackageRemovedBroadcasts(killApp); &#125; //【1.2】如果安装时指定了授予运行时权限，并且应用的目标 sdk 支持运行时权限，那就授予运行时权限！ if (grantPermissions &amp;&amp; res.pkg.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.M) &#123; grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions); &#125; //【1.3】判断安装方式，是更新安装，还是全新安装！ // 我们知道，如果 res.removedInfo 不为 null 的话，一定是覆盖更新！ final boolean update = res.removedInfo != null &amp;&amp; res.removedInfo.removedPackage != null; //【1.4】如果被 disable 的特权应用之前没有子包，这是第一次有子包，那么我们会授予新的子包 // 运行时权限，如果旧的特权应用之前已经授予！ if (res.pkg.parentPackage != null) &#123; synchronized (mPackages) &#123; grantRuntimePermissionsGrantedToDisabledPrivSysPackageParentLPw(res.pkg); &#125; &#125; synchronized (mPackages) &#123; mEphemeralApplicationRegistry.onPackageInstalledLPw(res.pkg); &#125; final String packageName = res.pkg.applicationInfo.packageName; Bundle extras = new Bundle(1); extras.putInt(Intent.EXTRA_UID, res.uid); //【1.5】决定在那些 user 下是第一次安装，那些用户下是覆盖更新！ int[] firstUsers = EMPTY_INT_ARRAY; int[] updateUsers = EMPTY_INT_ARRAY; if (res.origUsers == null || res.origUsers.length == 0) &#123; firstUsers = res.newUsers; &#125; else &#123; // res.newUsers 表示本次安装新增加的目标 user！ // res.origUsers 标志之前安装的目标 user！ for (int newUser : res.newUsers) &#123; boolean isNew = true; for (int origUser : res.origUsers) &#123; if (origUser == newUser) &#123; isNew = false; break; &#125; &#125; if (isNew) &#123; firstUsers = ArrayUtils.appendInt(firstUsers, newUser); &#125; else &#123; updateUsers = ArrayUtils.appendInt(updateUsers, newUser); &#125; &#125; &#125; //【1.5】发送 ADD 和 REPLACE 广播，如果不是 Ephemeral app！ if (!isEphemeral(res.pkg)) &#123; mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(res.pkg.baseCodePath); //【1.5.1】给第一次安装的用户发送 ACTION_PACKAGE_ADDED 广播，不带 EXTRA_REPLACING 属性！ sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, 0 /*flags*/, null /*targetPackage*/, null /*finishedReceiver*/, firstUsers); //【1.5.2】给覆盖更新的用户发送 ACTION_PACKAGE_ADDED 广播，带 EXTRA_REPLACING 属性！ if (update) &#123; extras.putBoolean(Intent.EXTRA_REPLACING, true); &#125; sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, extras, 0 /*flags*/, null /*targetPackage*/, null /*finishedReceiver*/, updateUsers); //【1.5.3】给覆盖更新的用户发送 ACTION_PACKAGE_REPLACED / ACTION_MY_PACKAGE_REPLACED 广播！ if (update) &#123; sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, extras, 0 /*flags*/, null /*targetPackage*/, null /*finishedReceiver*/, updateUsers); sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null /*package*/, null /*extras*/, 0 /*flags*/, packageName /*targetPackage*/, null /*finishedReceiver*/, updateUsers); &#125; else if (launchedForRestore &amp;&amp; !isSystemApp(res.pkg)) &#123; //【1.5.4】如果是第一次安装，同时我们要做一个恢复操作，并且 apk 不是系统应用 // 那么我们会发送 ACTION_PACKAGE_FIRST_LAUNCH 广播！ if (DEBUG_BACKUP) &#123; Slog.i(TAG, \"Post-restore of \" + packageName + \" sending FIRST_LAUNCH in \" + Arrays.toString(firstUsers)); &#125; sendFirstLaunchBroadcast(packageName, installerPackage, firstUsers); &#125; //【1.5.5】如果该 apk 处于 forward locked 或者处于外置存储中，那么会给所有的用户发送 // 资源变化的广播！ if (res.pkg.isForwardLocked() || isExternal(res.pkg)) &#123; if (DEBUG_INSTALL) &#123; Slog.i(TAG, \"upgrading pkg \" + res.pkg + \" is ASEC-hosted -&gt; AVAILABLE\"); &#125; final int[] uidArray = new int[]&#123;res.pkg.applicationInfo.uid&#125;; ArrayList&lt;String&gt; pkgList = new ArrayList&lt;&gt;(1); pkgList.add(packageName); sendResourcesChangedBroadcast(true, true, pkgList, uidArray, null); &#125; &#125; //【1.6】针对 firstUsers 做一些权限恢复和默认浏览器设置！ if (firstUsers != null &amp;&amp; firstUsers.length &gt; 0) &#123; synchronized (mPackages) &#123; for (int userId : firstUsers) &#123; //【1.6.1】默认浏览器设置！！ if (packageIsBrowser(packageName, userId)) &#123; mSettings.setDefaultBrowserPackageNameLPw(null, userId); &#125; //【1.6.2】处理那些正在等待或者需要恢复的运行时权限授予！ mSettings.applyPendingPermissionGrantsLPw(packageName, userId); &#125; &#125; &#125; EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings()); // 触发 GC 回收资源！ Runtime.getRuntime().gc(); //【5.8.1.1】移除掉更新后的旧 apk！ if (res.removedInfo != null &amp;&amp; res.removedInfo.args != null) &#123; synchronized (mInstallLock) &#123; res.removedInfo.args.doPostDeleteLI(true); &#125; &#125; &#125; //【*5.8.2】通知观察者安装的结果，这里的 installObserver 是我们之前创建的 localObsever！！ if (installObserver != null) &#123; try &#123; Bundle extras = extrasForInstallResult(res); installObserver.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extras); &#125; catch (RemoteException e) &#123; Slog.i(TAG, \"Observer no longer exists.\"); &#125; &#125;&#125; 我们看到，这里涉及到了几个重要的广播： Intent.ACTION_PACKAGE_ADDED：当有应用程序第一次安装时，会发送该广播给对应的 firstUsers！ 携带数据：Intent.EXTRA_UID，值为 apk uid； Intent.ACTION_PACKAGE_REPLACED：当有应用程序被覆盖安装时，会发送该广播给对应的 updateUsers！ 携带数据：Intent.EXTRA_UID， 携带数据：Intent.EXTRA_REPLACING，置为 true； Intent.ACTION_MY_PACKAGE_REPLACED：当有应用程序被覆盖安装时，会发送该广播给对应的 updateUsers 下被更新的 pkg！ 携带数据：packageName，被更新的应用包； 5.8.1.1 FileInstallArgs.doPostDeleteLI - 删除被更新的旧 apk继续来看： 12345boolean doPostDeleteLI(boolean delete) &#123; //【*5.8.1.2】清楚 apk 文件 和 dex 文件！ cleanUpResourcesLI(); return true;&#125; 继续分析： 5.8.1.2 FileInstallArgs.cleanUpResourcesLI继续分析： 12345678910111213141516void cleanUpResourcesLI() &#123; List&lt;String&gt; allCodePaths = Collections.EMPTY_LIST; if (codeFile != null &amp;&amp; codeFile.exists()) &#123; try &#123; //【1】收集 apk path！ final PackageLite pkg = PackageParser.parsePackageLite(codeFile, 0); allCodePaths = pkg.getAllCodePaths(); &#125; catch (PackageParserException e) &#123; // Ignored; we tried our best &#125; &#125; //【2】清除 apk！ cleanUp(); //【3】清除 dex files！ removeDexFiles(allCodePaths, instructionSets);&#125; 这里就不再过多分析！ 5.8.2 IPackageInstallObserver2.onPackageInstalled这里的 installObserver 是我们在 4.3 PackageInstallerSession.commitLocked 中创建的另一个 Observer： 123456789101112131415//【1】创建一个本地的安装观察者，监听安装结果！final IPackageInstallObserver2 localObserver = new IPackageInstallObserver2.Stub() &#123; @Override public void onUserActionRequired(Intent intent) &#123; throw new IllegalStateException(); &#125; @Override public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) &#123; //【×5.8.2.1】关闭文件桥，删除文件拷贝！ destroyInternal(); //【×5.8.2.2】处理回调，通知监听者！ dispatchSessionFinished(returnCode, msg, extras); &#125;&#125;; 5.8.2.1 PackageInstallerSession.destroyInternal关闭文件桥，删除文件拷贝： 123456789101112131415161718192021private void destroyInternal() &#123; synchronized (mLock) &#123; mSealed = true; mDestroyed = true; //【1】关闭之前打开的文件桥对象！ for (FileBridge bridge : mBridges) &#123; bridge.forceClose(); &#125; &#125; if (stageDir != null) &#123; try &#123; //【2】删除之前的文件拷贝目录！ mPm.mInstaller.rmPackageDir(stageDir.getAbsolutePath()); &#125; catch (InstallerException ignored) &#123; &#125; &#125; if (stageCid != null) &#123; PackageHelper.destroySdDir(stageCid); &#125;&#125; 5.8.2.2 PackageInstallerSession.dispatchSessionFinished处理回调，通知监听者！ 123456789101112131415private void dispatchSessionFinished(int returnCode, String msg, Bundle extras) &#123; mFinalStatus = returnCode; mFinalMessage = msg; //【*4.1.2】触发 mRemoteObserver 回调！ if (mRemoteObserver != null) &#123; try &#123; mRemoteObserver.onPackageInstalled(mPackageName, returnCode, msg, extras); &#125; catch (RemoteException ignored) &#123; &#125; &#125; final boolean success = (returnCode == PackageManager.INSTALL_SUCCEEDED); //【*5.8.2.2.2】回调触发！！ mCallback.onSessionFinished(this, success);&#125; 在前面 4.1 commit 事务的时候，我们创建了一个 PackageInstallObserverAdapter，并将其保存到了 PackageInstallerSession.mRemoteObserver 中，这里首先会触发 mRemoteObserver 的回调！ 在 3.1.4.1 new InternalCallback 的时候，我们在创建 PackageInstallerSession 时，传入了一个回调对象 InternalCallback： 1private final InternalCallback mInternalCallback = new InternalCallback(); InternalCallback 类定义在 PackageInstallerService 中，该对象的引用会被保存到 PackageInstallerSession.mCallback 变量中！ 5.8.2.2.2 InternalCallback.onSessionFinished这里我们重点关于 onSessionFinished 方法： 1234567891011121314151617181920212223public void onSessionFinished(final PackageInstallerSession session, boolean success) &#123; //【×5.8.2.2.2.1】注册者回调！ mCallbacks.notifySessionFinished(session.sessionId, session.userId, success); mInstallHandler.post(new Runnable() &#123; @Override public void run() &#123; synchronized (mSessions) &#123; //【1】从 PackageInstallerService 中的 mSessions 移除了该 Session； mSessions.remove(session.sessionId); //【2】将该 Sesssion 添加到历史中； mHistoricalSessions.put(session.sessionId, session); final File appIconFile = buildAppIconFile(session.sessionId); if (appIconFile.exists()) &#123; appIconFile.delete(); &#125; //【×3.1.6.1】持久化事务记录文件！ writeSessionsLocked(); &#125; &#125; &#125;);&#125; 我们看到，在 InternalCallback 中又回调了另外一个 Callback mCallbacks，它也是 PackageInstallerService 的内部类： 5.8.2.2.2.1 Callback.notifySessionFinished前面我们分析过，Callback 本质上就是一个 Handler，这里就是向其所在的线程发送消息：123public void notifySessionFinished(int sessionId, int userId, boolean success) &#123; obtainMessage(MSG_SESSION_FINISHED, sessionId, userId, success).sendToTarget();&#125; 在 3.1.4.2 Callbacks.notifySessionXXXX 中，我们分析过，最终其实是很将安装的结果分发给了注册在 Callback 中的所有远程回调： 12private final RemoteCallbackList&lt;IPackageInstallerCallback&gt; mCallbacks = new RemoteCallbackList&lt;&gt;(); 这里就不多说了！ 6 PackageManagerS.replacePackageLIF - 覆盖安装6.1 参数分析这里我们来回顾下传入的参数：final int policyFlags 就是我们之前的解析参数 parseFlags 1234567// 默认情况下： mDefParseFlags = 0 final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (ephemeral ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0); 同时，对于扫描标志位 scanFlags，会做如下处理：1234567891011121314151617181920212223//【2】设置扫描参数int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;if (args.move != null) &#123; //【2.1】如果 args.move 不为 null，表示正在移动一个 app，我们会对其进行一个初始化的扫描 // 增加 SCAN_INITIAL 位！ scanFlags |= SCAN_INITIAL;&#125;if ((installFlags &amp; PackageManager.INSTALL_DONT_KILL_APP) != 0) &#123; //【2.2】如果安装参数指定了 INSTALL_DONT_KILL_APP，那么增加 SCAN_DONT_KILL_APP 位！ scanFlags |= SCAN_DONT_KILL_APP;&#125;... ...//【13】根据安装参数做不同的处理！if (args.move != null) &#123; //【13.1】如果是 move package，进入这里！ scanFlags |= SCAN_NO_DEX; // 设置以下标签，无需做 odex，我们需要已有的移动过去即可！ scanFlags |= SCAN_MOVE; ... ... ...&#125; else if (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) &#123; //【13.2】如果不是 forward lock 模式安装且没有安装到外置存储上，进入这里！ scanFlags |= SCAN_NO_DEX; // 扫描参数设置 SCAN_NO_DEX，意味着后面不做 odex，因为这里会做！ ... ... ...&#125; 上面，我们省略掉了不重要的代码段！ 6.2 方法分析下面继续分析核心方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156private void replacePackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res) &#123; final boolean isEphemeral = (policyFlags &amp; PackageParser.PARSE_IS_EPHEMERAL) != 0; // 是否是 ephemeral final PackageParser.Package oldPackage; final String pkgName = pkg.packageName; final int[] allUsers; final int[] installedUsers; synchronized(mPackages) &#123; //【1】获得旧应用的 Package 对象！ oldPackage = mPackages.get(pkgName); if (DEBUG_INSTALL) Slog.d(TAG, \"replacePackageLI: new=\" + pkg + \", old=\" + oldPackage); // don't allow upgrade to target a release SDK from a pre-release SDK final boolean oldTargetsPreRelease = oldPackage.applicationInfo.targetSdkVersion == android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; final boolean newTargetsPreRelease = pkg.applicationInfo.targetSdkVersion == android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; //【2】如果安装设置了 PackageParser.PARSE_FORCE_SDK，那就要校验下 sdk！ if (oldTargetsPreRelease &amp;&amp; !newTargetsPreRelease &amp;&amp; ((policyFlags &amp; PackageParser.PARSE_FORCE_SDK) == 0)) &#123; Slog.w(TAG, \"Can't install package targeting released sdk\"); res.setReturnCode(PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE); return; &#125; //【3】如果之前安装是 no ephemeral，现在是 ephemeral，那么不能安装！ final boolean oldIsEphemeral = oldPackage.applicationInfo.isEphemeralApp(); if (isEphemeral &amp;&amp; !oldIsEphemeral) &#123; Slog.w(TAG, \"Can't replace app with ephemeral: \" + pkgName); res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID); return; &#125; //【4】校验签名，不匹配，不能安装！ final PackageSetting ps = mSettings.mPackages.get(pkgName); if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) &#123; if (!checkUpgradeKeySetLP(ps, pkg)) &#123; res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"New package not signed by keys specified by upgrade-keysets: \" + pkgName); return; &#125; &#125; else &#123; if (compareSignatures(oldPackage.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"New package has a different signature: \" + pkgName); return; &#125; &#125; //【5】如果旧的应用是 sys app，并且需要强制 hash 校验，那就会在这里校验 hash！ if (oldPackage.restrictUpdateHash != null &amp;&amp; oldPackage.isSystemApp()) &#123; byte[] digestBytes = null; try &#123; final MessageDigest digest = MessageDigest.getInstance(\"SHA-512\"); updateDigest(digest, new File(pkg.baseCodePath)); if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) &#123; for (String path : pkg.splitCodePaths) &#123; updateDigest(digest, new File(path)); &#125; &#125; digestBytes = digest.digest(); &#125; catch (NoSuchAlgorithmException | IOException e) &#123; res.setError(INSTALL_FAILED_INVALID_APK, \"Could not compute hash: \" + pkgName); return; &#125; if (!Arrays.equals(oldPackage.restrictUpdateHash, digestBytes)) &#123; res.setError(INSTALL_FAILED_INVALID_APK, \"New package fails restrict-update check: \" + pkgName); return; &#125; // retain upgrade restriction pkg.restrictUpdateHash = oldPackage.restrictUpdateHash; &#125; //【6】检查 shareUserId 是否变化！ String invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, pkg); if (invalidPackageName != null) &#123; res.setError(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE, \"Package \" + invalidPackageName + \" tried to change user \" + oldPackage.mSharedUserId); return; &#125; //【7】获得系统中所有的 user，已经上一次安装的目标 user！ allUsers = sUserManager.getUserIds(); installedUsers = ps.queryInstalledUsers(allUsers, true); &#125; //【×5.7.1.1】针对与 replace 的情况，会创建一个 PackageRemovedInfo，封装被 replace 的 app 的信息！ // 如果有子包的话，也会做相同的事情！ res.removedInfo = new PackageRemovedInfo(); res.removedInfo.uid = oldPackage.applicationInfo.uid; res.removedInfo.removedPackage = oldPackage.packageName; res.removedInfo.isUpdate = true; // 表示要更新 package！！ res.removedInfo.origUsers = installedUsers; final int childCount = (oldPackage.childPackages != null) ? oldPackage.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; boolean childPackageUpdated = false; PackageParser.Package childPkg = oldPackage.childPackages.get(i); if (res.addedChildPackages != null) &#123; PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName); if (childRes != null) &#123; childRes.removedInfo.uid = childPkg.applicationInfo.uid; childRes.removedInfo.removedPackage = childPkg.packageName; childRes.removedInfo.isUpdate = true; childPackageUpdated = true; &#125; &#125; if (!childPackageUpdated) &#123; PackageRemovedInfo childRemovedRes = new PackageRemovedInfo(); childRemovedRes.removedPackage = childPkg.packageName; childRemovedRes.isUpdate = false; childRemovedRes.dataRemoved = true; synchronized (mPackages) &#123; PackageSetting childPs = mSettings.peekPackageLPr(childPkg.packageName); if (childPs != null) &#123; childRemovedRes.origUsers = childPs.queryInstalledUsers(allUsers, true); &#125; &#125; if (res.removedInfo.removedChildPackages == null) &#123; res.removedInfo.removedChildPackages = new ArrayMap&lt;&gt;(); &#125; res.removedInfo.removedChildPackages.put(childPkg.packageName, childRemovedRes); &#125; &#125; //【9】判断下旧应用是系统应用，还是非系统应用，然后做不同的处理！ boolean sysPkg = (isSystemApp(oldPackage)); if (sysPkg) &#123; //【9.1】如果是系统应用，再判断是是否是系统特权应用！ final boolean privileged = (oldPackage.applicationInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0; //【9.2】对于系统应用会增加如下的解析 flags! final int systemPolicyFlags = policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0); //【×6.2.1】处理系统应用的 replace！ replaceSystemPackageLIF(oldPackage, pkg, systemPolicyFlags, scanFlags, user, allUsers, installerPackageName, res); &#125; else &#123; //【×6.2.2】处理下非系统应用的 replace！ replaceNonSystemPackageLIF(oldPackage, pkg, policyFlags, scanFlags, user, allUsers, installerPackageName, res); &#125;&#125; 对于判断是否是系统应用，调用了如下的接口： 123private static boolean isSystemApp(PackageParser.Package pkg) &#123; return (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0;&#125; 6.2.1 replaceSystemPackageLIF - 覆盖安装系统应用这里我们来回顾下传入的参数：final int policyFlags 就是我们之前的解析参数 parseFlags 123456789101112//【1】默认情况下： mDefParseFlags = 0 final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (ephemeral ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0); //【2】针对系统应用额外增加如下的标志 final int systemPolicyFlags = policyFlags | PackageParser.PARSE_IS_SYSTEM | (privileged ? PackageParser.PARSE_IS_PRIVILEGED : 0); 同时，对于扫描标志位 scanFlags，和上面保持一致，下面我们来分析下更新 sys app 的流程！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129private void replaceSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res) &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"replaceSystemPackageLI: new=\" + pkg + \", old=\" + deletedPackage); final boolean disabledSystem; //【*6.2.1.1】移除掉已安装的 sys app 的数据，包括解析到的四大组件； removePackageLI(deletedPackage, true); synchronized (mPackages) &#123; //【*6.2.1.2】disable 掉系统应用； disabledSystem = disableSystemPackageLPw(deletedPackage, pkg); &#125; //【1】根据 disabledSystem 的值做不同处理！ if (!disabledSystem) &#123; //【1.1】如果 disabledSystem 为 false，说明我们之前已经更新过 sys app 了，其已经被 disable 过了 // 我们现在更新的是位于 data 分区的那个 app，所以要删除掉那个旧的 data app！ //【*6.2.1.3】这里会根据要删除 data 分区的 apk 的数据，创建一个 InstallArgs，用于执行删除操作！ res.removedInfo.args = createInstallArgsForExisting(0, deletedPackage.applicationInfo.getCodePath(), deletedPackage.applicationInfo.getResourcePath(), getAppDexInstructionSets(deletedPackage.applicationInfo)); &#125; else &#123; //【1.2】此时无需删除 app，所以设置为 null res.removedInfo.args = null; &#125; //【*6.2.1.4】清楚掉新安装的应用 code_cache 目录下的文件数据； clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); //【*6.2.1.5】清楚掉旧的 app 的 profile 相关数据； clearAppProfilesLIF(deletedPackage, UserHandle.USER_ALL); res.setReturnCode(PackageManager.INSTALL_SUCCEEDED); //【2】给本次扫描的新 app 设置 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标志位！ pkg.setApplicationInfoFlags(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP, ApplicationInfo.FLAG_UPDATED_SYSTEM_APP); PackageParser.Package newPackage = null; try &#123; //【3】再次扫描 apk 文件！！ newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, 0, user); //【4】更新新 apk 的安装时间和最新更新时间（包括子包的）； PackageSetting deletedPkgSetting = (PackageSetting) deletedPackage.mExtras; setInstallAndUpdateTime(newPackage, deletedPkgSetting.firstInstallTime, System.currentTimeMillis()); //【5】处理安装成功的情况！ if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; final int deletedChildCount = (deletedPackage.childPackages != null) ? deletedPackage.childPackages.size() : 0; final int newChildCount = (newPackage.childPackages != null) ? newPackage.childPackages.size() : 0; //【5.1】比较旧的应用和新安装的应用的子包！ for (int i = 0; i &lt; deletedChildCount; i++) &#123; PackageParser.Package deletedChildPkg = deletedPackage.childPackages.get(i); boolean childPackageDeleted = true; for (int j = 0; j &lt; newChildCount; j++) &#123; PackageParser.Package newChildPkg = newPackage.childPackages.get(j); if (deletedChildPkg.packageName.equals(newChildPkg.packageName)) &#123; childPackageDeleted = false; break; &#125; &#125; //【5.1.1】如果旧的应用的子包被删除了，那会移除旧的应用子包遗留下的数据！ if (childPackageDeleted) &#123; PackageSetting ps = mSettings.getDisabledSystemPkgLPr( deletedChildPkg.packageName); if (ps != null &amp;&amp; res.removedInfo.removedChildPackages != null) &#123; PackageRemovedInfo removedChildRes = res.removedInfo .removedChildPackages.get(deletedChildPkg.packageName); // 移除数据！ removePackageDataLIF(ps, allUsers, removedChildRes, 0, false); removedChildRes.removedForAllUsers = mPackages.get(ps.name) == null; &#125; &#125; &#125; //【*7.2.1】更新数据； updateSettingsLI(newPackage, installerPackageName, allUsers, res, user); //【*7.2.2】准备数据目录，即 data/data/packageName 的目录； prepareAppDataAfterInstallLIF(newPackage); &#125; &#125; catch (PackageManagerException e) &#123; res.setReturnCode(INSTALL_FAILED_INTERNAL_ERROR); res.setError(\"Package couldn't be installed in \" + pkg.codePath, e); &#125; //【3】处理安装失败的情况！ if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) &#123; if (newPackage != null) &#123; //【*6.2.1.6】移除新解析的 apk 的数据 removeInstalledPackageLI(newPackage, true); &#125; try &#123; //【3.1】重新扫描旧的 apk（注意如果之前 system apk 已经被更新过了，那么这里 // 恢复的是处于 data 的那个新的 apk）！ scanPackageTracedLI(deletedPackage, policyFlags, SCAN_UPDATE_SIGNATURE, 0, user); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"Failed to restore original package: \" + e.getMessage()); &#125; synchronized (mPackages) &#123; if (disabledSystem) &#123; //【*6.2.1.7】如果本次是第一次更新（即 disable 了 sys app），那么我们要 enable sys app！ enableSystemPackageLPw(deletedPackage); &#125; //【3.2】更新升级包的安装信息，就是 PackageInstaller！ setInstallerPackageNameLPw(deletedPackage, installerPackageName); //【3.3】更新权限信息，关于权限的相关逻辑，这里不再分析，但是能推测到更新权限的原因！ updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL); //【3.4】持久化数据！ mSettings.writeLPr(); &#125; Slog.i(TAG, \"Successfully restored package : \" + deletedPackage.packageName + \" after failed upgrade\"); &#125;&#125; 这里就不多说了！！ 6.2.1.1 removePackageLI移除旧的 apk 的数据信息： 123456789101112131415161718private void removePackageLI (PackageParser.Package pkg, boolean chatty) &#123; //【1】处理父包！ PackageSetting ps = (PackageSetting) pkg.mExtras; if (ps != null) &#123; //【1.1】移除父包的 Settings 对象的 Settings 数据！ removePackageLI(ps, chatty); &#125; //【2】处理子包！ final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); ps = (PackageSetting) childPkg.mExtras; if (ps != null) &#123; //【2.1】移除子包的 Settings 对象的 Settings 数据！ removePackageLI(ps, chatty); &#125; &#125;&#125; 调用了另外一个 removePackageLI 方法！12345678910111213141516void removePackageLI(PackageSetting ps, boolean chatty) &#123; if (DEBUG_INSTALL) &#123; if (chatty) Log.d(TAG, \"Removing package \" + ps.name); &#125; synchronized (mPackages) &#123; //【1】将应用对应的 PackageSettings 对象删除掉！ mPackages.remove(ps.name); final PackageParser.Package pkg = ps.pkg; if (pkg != null) &#123; //【×6.2.1.1.1】移除四大组件数据！ cleanPackageDataStructuresLILPw(pkg, chatty); &#125; &#125;&#125; 6.2.1.1.1 cleanPackageDataStructuresLILPw用于删除 apk 的四大组件和共享库数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) &#123; //【1】移除 provider！ int N = pkg.providers.size(); StringBuilder r = null; int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); mProviders.removeProvider(p); if (p.info.authority == null) &#123; //【1.1】表示系统之前已经有相同 authority 的 provider，那么这个应用的 provider 是不会注册的！ // 对于没有注册的 provider 不处理！ continue; &#125; String names[] = p.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; if (mProvidersByAuthority.get(names[j]) == p) &#123; mProvidersByAuthority.remove(names[j]); if (DEBUG_REMOVE) &#123; if (chatty) Log.d(TAG, \"Unregistered content provider: \" + names[j] + \", className = \" + p.info.name + \", isSyncable = \" + p.info.isSyncable); &#125; &#125; &#125; if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Providers: \" + r); &#125; //【2】移除 service！ N = pkg.services.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Service s = pkg.services.get(i); mServices.removeService(s); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(s.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Services: \" + r); &#125; //【3】移除 receiver！ N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); mReceivers.removeActivity(a, \"receiver\"); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Receivers: \" + r); &#125; //【4】移除 activity！ N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); mActivities.removeActivity(a, \"activity\"); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Activities: \" + r); &#125; //【5】移除定义的 permission，设置了 appop 标志为的权限，从 mAppOpPermissionPackages 也要移除！ N = pkg.permissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Permission p = pkg.permissions.get(i); BasePermission bp = mSettings.mPermissions.get(p.info.name); if (bp == null) &#123; bp = mSettings.mPermissionTrees.get(p.info.name); &#125; if (bp != null &amp;&amp; bp.perm == p) &#123; bp.perm = null; if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if ((p.info.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; ArraySet&lt;String&gt; appOpPkgs = mAppOpPermissionPackages.get(p.info.name); if (appOpPkgs != null) &#123; appOpPkgs.remove(pkg.packageName); &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Permissions: \" + r); &#125; //【6】移除请求的 permission，设置了 appop 标志为的权限，从 mAppOpPermissionPackages 也要移除！！ N = pkg.requestedPermissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; String perm = pkg.requestedPermissions.get(i); BasePermission bp = mSettings.mPermissions.get(perm); if (bp != null &amp;&amp; (bp.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; ArraySet&lt;String&gt; appOpPkgs = mAppOpPermissionPackages.get(perm); if (appOpPkgs != null) &#123; appOpPkgs.remove(pkg.packageName); if (appOpPkgs.isEmpty()) &#123; mAppOpPermissionPackages.remove(perm); &#125; &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Permissions: \" + r); &#125; //【7】移除请求的 instrumentation！ N = pkg.instrumentation.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Instrumentation a = pkg.instrumentation.get(i); mInstrumentation.remove(a.getComponentName()); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Instrumentation: \" + r); &#125; //【8】移除 SharedLibraries！ r = null; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0) &#123; // Only system apps can hold shared libraries. if (pkg.libraryNames != null) &#123; for (i=0; i&lt;pkg.libraryNames.size(); i++) &#123; String name = pkg.libraryNames.get(i); SharedLibraryEntry cur = mSharedLibraries.get(name); if (cur != null &amp;&amp; cur.apk != null &amp;&amp; cur.apk.equals(pkg.packageName)) &#123; mSharedLibraries.remove(name); if (DEBUG_REMOVE &amp;&amp; chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(name); &#125; &#125; &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_REMOVE) Log.d(TAG, \" Libraries: \" + r); &#125;&#125; 该阶段的逻辑比较简单，不多说了！ 6.2.1.2 disableSystemPackageLPwdisable 掉系统应用 1234567891011121314private boolean disableSystemPackageLPw(PackageParser.Package oldPkg, PackageParser.Package newPkg) &#123; //【6.2.1.2.1】disable 掉父包，父包是要通过 replace 方式！ boolean disabled = mSettings.disableSystemPackageLPw(oldPkg.packageName, true); // Disable the child packages final int childCount = (oldPkg.childPackages != null) ? oldPkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = oldPkg.childPackages.get(i); final boolean replace = newPkg.hasChildPackage(childPkg.packageName); //【6.2.1.2.1】disable 掉子包，如果新包也有子包，那就通过 replace 方式！ disabled |= mSettings.disableSystemPackageLPw(childPkg.packageName, replace); &#125; return disabled;&#125; 这里调用了 Settings 的 disableSystemPackageLPw 方法！ 6.2.1.2.1 Settings.disableSystemPackageLPw我们继续分析： 12345678910111213141516171819202122232425262728293031boolean disableSystemPackageLPw(String name, boolean replaced) &#123; final PackageSetting p = mPackages.get(name); //【1】异常判断，如果没安装，disable 个屁！ if(p == null) &#123; Log.w(PackageManagerService.TAG, \"Package \" + name + \" is not an installed package\"); return false; &#125; //【2】尝试从 mDisabledSysPackages 列表中获得 PackageSetting！ final PackageSetting dp = mDisabledSysPackages.get(name); //【3】判断 disable 的条件是否满足： // 1、之前没有 disable；2、是系统应用；3、没有更新过！ if (dp == null &amp;&amp; p.pkg != null &amp;&amp; p.pkg.isSystemApp() &amp;&amp; !p.pkg.isUpdatedSystemApp()) &#123; //【3.1】设置 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标志位，表示更新过的 sys app！ if((p.pkg != null) &amp;&amp; (p.pkg.applicationInfo != null)) &#123; p.pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; //【3.2】将其旧应用的 PackageSetting 添加到 mDisabledSysPackages 中！ mDisabledSysPackages.put(name, p); //【3.4】判断是否是 replace，显然，对于 base apk 是需要 replace 的，对于 child apk， // 需要看新安装的应用是否有相应的子包！ if (replaced) &#123; PackageSetting newp = new PackageSetting(p); // copy 一份旧数据 //【3.5】用 copy 后的数据替换之前的数据！ replacePackageLPw(name, newp); &#125; return true; &#125; return false;&#125; 可以看到，对于系统应用来说，只有第一次覆盖更新时，会 disable 掉 sys 下的那个 app；如果多次覆盖安装，后续的不会再 disable！ 下面是替换的具体操作！ 1234567891011121314private void replacePackageLPw(String name, PackageSetting newp) &#123; //【1】获得之前数据，然后根据 uid 的不同做不同的处理！ final PackageSetting p = mPackages.get(name); if (p != null) &#123; if (p.sharedUser != null) &#123; p.sharedUser.removePackage(p); p.sharedUser.addPackage(newp); &#125; else &#123; replaceUserIdLPw(p.appId, newp); &#125; &#125; //【2】更新 mPackages 中的数据！ mPackages.put(name, newp);&#125; 旧的数据，此时是在 mDisabledSysPackages 中！ 6.2.1.3 createInstallArgsForExisting - 要删除的被更新 apk这里是针对已存在的应用创建一个 InstallArgs 12345678910111213141516171819202122232425private InstallArgs createInstallArgsForExisting(int installFlags, String codePath, String resourcePath, String[] instructionSets) &#123; final boolean isInAsec; if (installOnExternalAsec(installFlags)) &#123; //【1】如果是安装到外置的，那就创建 AsecInstallArgs！ isInAsec = true; &#125; else if (installForwardLocked(installFlags) &amp;&amp; !codePath.startsWith(mDrmAppPrivateInstallDir.getAbsolutePath())) &#123; //【2】对于 forward lock 安装，如果目录是 drm app pri // 那就创建 AsecInstallArgs！ isInAsec = true; &#125; else &#123; isInAsec = false; &#125; if (isInAsec) &#123; //【3】创建 AsecInstallArgs 安装参数 return new AsecInstallArgs(codePath, instructionSets, installOnExternalAsec(installFlags), installForwardLocked(installFlags)); &#125; else &#123; //【5.5.3.1】一般情况下，会创建 FileInstallArgs，这里通过 FileInstallArgs 的另一构造器 // 创建了实例，描述一个已经存在的 app！ return new FileInstallArgs(codePath, resourcePath, instructionSets); &#125;&#125; 这里又回到了 5.5.3.1 的 FileInstallArgs 的相关创建！ 6.2.1.4 clearAppDataLIF清楚 app 的数据： 12345678910111213private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【1】处理父包！ clearAppDataLeafLIF(pkg, userId, flags); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【2】调用另外一个方法处理子包！ clearAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 继续看：123456789101112131415private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; final PackageSetting ps; synchronized (mPackages) &#123; ps = mSettings.mPackages.get(pkg.packageName); &#125; for (int realUserId : resolveUserIds(userId)) &#123; final long ceDataInode = (ps != null) ? ps.getCeDataInode(realUserId) : 0; try &#123; mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ceDataInode); &#125; catch (InstallerException e) &#123; Slog.w(TAG, String.valueOf(e)); &#125; &#125;&#125; 6.2.1.5 clearAppProfilesLIF清楚 app 的 profiles 数据： 123456789101112131415161718private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【×6.2.1.5.1】清除父包的 profile 数据！ clearAppProfilesLeafLIF(pkg); // We don't remove the base foreign use marker when clearing profiles because // we will rename it when the app is updated. Unlike the actual profile contents, // the foreign use marker is good across installs. destroyAppReferenceProfileLeafLIF(pkg, userId, false /* removeBaseMarker */); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【×6.2.1.5.1】清除子包的！ clearAppProfilesLeafLIF(pkg.childPackages.get(i)); &#125;&#125; 6.2.1.5.1 clearAppProfilesLeafLIF最终调用了这个方法，清楚 profile 数据：1234567private void clearAppProfilesLeafLIF(PackageParser.Package pkg) &#123; try &#123; mInstaller.clearAppProfiles(pkg.packageName); &#125; catch (InstallerException e) &#123; Slog.w(TAG, String.valueOf(e)); &#125;&#125; 6.2.1.6 removeInstalledPackageLI移除被扫描到的新的 apk 的数据： 123456789101112131415161718192021222324void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) &#123; if (DEBUG_INSTALL) &#123; if (chatty) Log.d(TAG, \"Removing package \" + pkg.applicationInfo.packageName); &#125; // writer synchronized (mPackages) &#123; //【1】移除父包! mPackages.remove(pkg.applicationInfo.packageName); //【*6.2.1.1.1】移除父包的数据结构！ cleanPackageDataStructuresLILPw(pkg, chatty); // Remove the child packages final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【2】移除子包! PackageParser.Package childPkg = pkg.childPackages.get(i); mPackages.remove(childPkg.applicationInfo.packageName); //【*6.2.1.1.1】移除子包的数据结构！ cleanPackageDataStructuresLILPw(childPkg, chatty); &#125; &#125;&#125; 6.2.1.7 enableSystemPackageLPw恢复系统应用 1234567891011private void enableSystemPackageLPw(PackageParser.Package pkg) &#123; //【1】恢复父包！ mSettings.enableSystemPackageLPw(pkg.packageName); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); //【*6.2.1.7.1】恢复子包！ mSettings.enableSystemPackageLPw(childPkg.packageName); &#125;&#125; 6.2.1.7.1 Settings.enableSystemPackageLPw最终会调用 Settings 的 enableSystemPackageLPw 方法 enable package： 123456789101112131415161718192021PackageSetting enableSystemPackageLPw(String name) &#123; //【1】判断该 sys package 是否被 disable 了； PackageSetting p = mDisabledSysPackages.get(name); if(p == null) &#123; Log.w(PackageManagerService.TAG, \"Package \" + name + \" is not disabled\"); return null; &#125; //【2】取消 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标志位！ if((p.pkg != null) &amp;&amp; (p.pkg.applicationInfo != null)) &#123; p.pkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; //【3】重新为该 system 创建一个 PackageSetting 对象，并添加到相应的集合中！ PackageSetting ret = addPackageLPw(name, p.realName, p.codePath, p.resourcePath, p.legacyNativeLibraryPathString, p.primaryCpuAbiString, p.secondaryCpuAbiString, p.cpuAbiOverrideString, p.appId, p.versionCode, p.pkgFlags, p.pkgPrivateFlags, p.parentPackageName, p.childPackageNames); //【4】从 mDisabledSysPackages 中删除！ mDisabledSysPackages.remove(name); return ret;&#125; 关于 addPackageLPw 的逻辑这里就不在分析了！ 6.2.2 replaceNonSystemPackageLIF - 覆盖安装三方应用 -&gt; 接入 8关于 replaceNonSystemPackageLIF 的逻辑，由于 markdown 不支持 6 级以上的标题，所以移动到第 8 节，单独分析!! 7 PackageManagerS.installNewPackageLIF - 全新安装7.1 参数分析这里我们来回顾下传入的参数：final int policyFlags 就是我们之前的解析参数 parseFlags 1234567//【1】默认情况下： mDefParseFlags = 0 final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0) | (ephemeral ? PackageParser.PARSE_IS_EPHEMERAL : 0) | (forceSdk ? PackageParser.PARSE_FORCE_SDK : 0); 同时，对于扫描标志位 scanFlags，会做如下处理：1234567891011121314151617181920212223//【2】设置扫描参数int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;if (args.move != null) &#123; //【2.1】如果 args.move 不为 null，表示正在移动一个 app，我们会对其进行一个初始化的扫描 // 增加 SCAN_INITIAL 位！ scanFlags |= SCAN_INITIAL;&#125;if ((installFlags &amp; PackageManager.INSTALL_DONT_KILL_APP) != 0) &#123; //【2.2】如果安装参数指定了 INSTALL_DONT_KILL_APP，那么增加 SCAN_DONT_KILL_APP 位！ scanFlags |= SCAN_DONT_KILL_APP;&#125;... ... ...//【13】根据安装参数做不同的处理！if (args.move != null) &#123; //【13.1】如果是 move package，进入这里！ scanFlags |= SCAN_NO_DEX; // 设置以下标签，无需做 odex，我们需要已有的移动过去即可！ scanFlags |= SCAN_MOVE; ... ... ...&#125; else if (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) &#123; //【13.2】如果不是 forward lock 模式安装且没有安装到外置存储上，进入这里！ scanFlags |= SCAN_NO_DEX; // 扫描参数设置 SCAN_NO_DEX，意味着后面不做 odex，因为这里会做！ ... ... ...&#125; 上面我们省略掉了不重要的代码段！ 7.2 方法解析下面继续分析核心方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void installNewPackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"installNewPackage\"); // Remember this for later, in case we need to rollback this install String pkgName = pkg.packageName; if (DEBUG_INSTALL) Slog.d(TAG, \"installNewPackageLI: \" + pkg); synchronized(mPackages) &#123; //【1】如果已经有一个同名的应用安装了，并且其被改为的旧的名字，那么这种情况不能用该接口安装， // 需要使用 replace 接口来更新！ if (mSettings.mRenamedPackages.containsKey(pkgName)) &#123; res.setError(INSTALL_FAILED_ALREADY_EXISTS, \"Attempt to re-install \" + pkgName + \" without first uninstalling package running as \" + mSettings.mRenamedPackages.get(pkgName)); return; &#125; //【2】如果 PMS.mPackages 中已经扫描到同名的应用，这种情况不能用该接口安装，需要通过 replace 接口！ if (mPackages.containsKey(pkgName)) &#123; // Don't allow installation over an existing package with the same name. res.setError(INSTALL_FAILED_ALREADY_EXISTS, \"Attempt to re-install \" + pkgName + \" without first uninstalling.\"); return; &#125; &#125; try &#123; //【3】核心方法，扫描 apk，这里和 PMS 开机的时候一样！ PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, System.currentTimeMillis(), user); //【*7.2.1】更新 Settings 中对应的 PackageSettings 集合！ updateSettingsLI(newPackage, installerPackageName, null, res, user); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; //【*7.2.2】安装成功，准备数据目录！ prepareAppDataAfterInstallLIF(newPackage); &#125; else &#123; //【*8.1】安装失败，删除 apk，但是保存之前就存在的数据！ deletePackageLIF(pkgName, UserHandle.ALL, false, null, PackageManager.DELETE_KEEP_DATA, res.removedInfo, true, null); &#125; &#125; catch (PackageManagerException e) &#123; res.setError(\"Package couldn't be installed in \" + pkg.codePath, e); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);&#125; 继续分析： 7.2.1 updateSettingsLI12345678910111213141516private void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user) &#123; //【×7.2.1.1】更新父包！ updateSettingsInternalLI(newPackage, installerPackageName, allUsers, res.origUsers, res, user); //【1】对子包也做相同的处理； final int childCount = (newPackage.childPackages != null) ? newPackage.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPackage = newPackage.childPackages.get(i); PackageInstalledInfo childRes = res.addedChildPackages.get(childPackage.packageName); //【×7.2.1.1】更新子包！ updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user); &#125;&#125; 继续来看： 7.2.1.1 updateSettingsInternalLI此时，apk 已经扫描了，在扫描的最后阶段，也会创建对应的 PackageSettings 对象，这里会根据安装结果，更新数据！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private void updateSettingsInternalLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\"); String pkgName = newPackage.packageName; synchronized (mPackages) &#123; //【1】如果应用已经安装了，更新安装状态 INCOMPLETE，并调用 writeLPr 方法更新本地文件！ // writeLPr 方法在 PMS 开机的时候后有分析过，这里不多说了！ mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_INCOMPLETE); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"writeSettings\"); mSettings.writeLPr(); Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; if (DEBUG_INSTALL) Slog.d(TAG, \"New package installed in \" + newPackage.codePath); synchronized (mPackages) &#123; //【2】更新权限信息，移除无效的权限和权限树，更新的 flags 设置了 UPDATE_PERMISSIONS_REPLACE_PKG， // 表示只更新自身；如果其有定义权限，还会增加 UPDATE_PERMISSIONS_ALL！ // 关于 updatePermissionsLPw 我们在 PMS 启动时分析过！ updatePermissionsLPw(newPackage.packageName, newPackage, UPDATE_PERMISSIONS_REPLACE_PKG | (newPackage.permissions.size() &gt; 0 ? UPDATE_PERMISSIONS_ALL : 0)); //【3】对于系统应用，我们默认其为可用状态！ PackageSetting ps = mSettings.mPackages.get(pkgName); final int userId = user.getIdentifier(); if (ps != null) &#123; if (isSystemApp(newPackage)) &#123; if (DEBUG_INSTALL) &#123; Slog.d(TAG, \"Implicitly enabling system package on upgrade: \" + pkgName); &#125; //【3.1】设置在请求的 userId 下，该应用可用！ if (res.origUsers != null) &#123; for (int origUserId : res.origUsers) &#123; if (userId == UserHandle.USER_ALL || userId == origUserId) &#123; ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, origUserId, installerPackageName); &#125; &#125; &#125; //【3.2】设置只有在指定要安装的目标 user 下，安装状态为 true！ if (allUsers != null &amp;&amp; installedForUsers != null) &#123; for (int currentUserId : allUsers) &#123; final boolean installed = ArrayUtils.contains( installedForUsers, currentUserId); if (DEBUG_INSTALL) &#123; Slog.d(TAG, \" user \" + currentUserId + \" =&gt; \" + installed); &#125; ps.setInstalled(installed, currentUserId); &#125; &#125; &#125; //【3.3】如果安装目标用户不是 UserHandle.USER_ALL，设置其在该 userId 下为已安装状态并且可用！ if (userId != UserHandle.USER_ALL) &#123; ps.setInstalled(true, userId); ps.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, userId, installerPackageName); &#125; &#125; //【4】修改安装结果对象中的属性！ res.name = pkgName; res.uid = newPackage.applicationInfo.uid; res.pkg = newPackage; //【5】更新 Settings 中该 PackageSetting 的安装状态！ mSettings.setInstallStatus(pkgName, PackageSettingBase.PKG_INSTALL_COMPLETE); mSettings.setInstallerPackageName(pkgName, installerPackageName); res.setReturnCode(PackageManager.INSTALL_SUCCEEDED); //【6】并调用 writeLPr 方法更新本地文件！ Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"writeSettings\"); mSettings.writeLPr(); Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);&#125; 7.2.2 prepareAppDataAfterInstallLIF准备数据目录！ 1234567891011121314151617181920212223242526private void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) &#123; final PackageSetting ps; synchronized (mPackages) &#123; //【1】保存 Kernel Map 数据！ ps = mSettings.mPackages.get(pkg.packageName); mSettings.writeKernelMappingLPr(ps); &#125; final UserManager um = mContext.getSystemService(UserManager.class); UserManagerInternal umInternal = getUserManagerInternal(); for (UserInfo user : um.getUsers()) &#123; final int flags; if (umInternal.isUserUnlockingOrUnlocked(user.id)) &#123; flags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE; &#125; else if (umInternal.isUserRunning(user.id)) &#123; flags = StorageManager.FLAG_STORAGE_DE; &#125; else &#123; continue; &#125; //【2】如果在该 user 下是安装状态，那就在该设备用户下准备数据目录！ if (ps.getInstalled(user.id)) &#123; //【7.2.2.1】准备数据目录！ prepareAppDataLIF(pkg, user.id, flags); &#125; &#125;&#125; 暂时分析到这里！ 7.2.2.1 prepareAppDataLIF12345678910111213private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【×7.2.2】准备父包的数据目录 prepareAppDataLeafLIF(pkg, userId, flags); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【×7.2.2.2】准备子包的数据目录 prepareAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 7.2.2.2 prepareAppDataLeafLIF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (DEBUG_APP_DATA) &#123; Slog.v(TAG, \"prepareAppData for \" + pkg.packageName + \" u\" + userId + \" 0x\" + Integer.toHexString(flags)); &#125; final String volumeUuid = pkg.volumeUuid; final String packageName = pkg.packageName; final ApplicationInfo app = pkg.applicationInfo; final int appId = UserHandle.getAppId(app.uid); Preconditions.checkNotNull(app.seinfo); try &#123; //【1】通过 installd 来准备数据目录！ mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seinfo, app.targetSdkVersion); &#125; catch (InstallerException e) &#123; //【2】如果是系统应用，第一次准备失败后，还会在尝试一次！ if (app.isSystemApp()) &#123; logCriticalInfo(Log.ERROR, \"Failed to create app data for \" + packageName + \", but trying to recover: \" + e); //【2.1】先删除之前创建的脏目录！ destroyAppDataLeafLIF(pkg, userId, flags); try &#123; //【2.2】再次创建数据目录； mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seinfo, app.targetSdkVersion); logCriticalInfo(Log.DEBUG, \"Recovery succeeded!\"); &#125; catch (InstallerException e2) &#123; logCriticalInfo(Log.DEBUG, \"Recovery failed!\"); &#125; &#125; else &#123; Slog.e(TAG, \"Failed to create app data for \" + packageName + \": \" + e); &#125; &#125; if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; try &#123; // CE storage is unlocked right now, so read out the inode and // remember for use later when it's locked // TODO: mark this structure as dirty so we persist it! final long ceDataInode = mInstaller.getAppDataInode(volumeUuid, packageName, userId, StorageManager.FLAG_STORAGE_CE); synchronized (mPackages) &#123; final PackageSetting ps = mSettings.mPackages.get(packageName); if (ps != null) &#123; ps.setCeDataInode(ceDataInode, userId); &#125; &#125; &#125; catch (InstallerException e) &#123; Slog.e(TAG, \"Failed to find inode for \" + packageName + \": \" + e); &#125; &#125; prepareAppDataContentsLeafLIF(pkg, userId, flags);&#125; 8 PackageManagerS.replaceNonSystemPackageLIF - 接 6.2.2这里我们分析下覆盖安装三方应用的流程，对于扫描标志位 scanFlags，和上面保持一致： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153private void replaceNonSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res) &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"replaceNonSystemPackageLI: new=\" + pkg + \", old=\" + deletedPackage); String pkgName = deletedPackage.packageName; // 获得包名！ boolean deletedPkg = true; boolean addedPkg = false; boolean updatedSettings = false; final boolean killApp = (scanFlags &amp; SCAN_DONT_KILL_APP) == 0; //【1】设置删除 flags，会保留用户数据！ final int deleteFlags = PackageManager.DELETE_KEEP_DATA | (killApp ? 0 : PackageManager.DELETE_DONT_KILL_APP); final long origUpdateTime = (pkg.mExtras != null) ? ((PackageSetting)pkg.mExtras).lastUpdateTime : 0; //【*8.1】删除在 data 分区的旧 apk 数据，res.removedInfo 用于表示要移除的 apk！！ // 删除失败会进入 if 分支！ if (!deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, pkg)) &#123; res.setError(INSTALL_FAILED_REPLACE_COULDNT_DELETE, \"replaceNonSystemPackageLI\"); deletedPkg = false; &#125; else &#123; //【2】删除成功后，要判断下被删除的 apk 是否安装在 External 位置或者其是否是 forward lock 的 // 如果是，那么我们要发送资源变化的广播通知其他进程！！ if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) &#123; if (DEBUG_INSTALL) &#123; Slog.i(TAG, \"upgrading pkg \" + deletedPackage + \" is ASEC-hosted -&gt; UNAVAILABLE\"); &#125; final int[] uidArray = new int[] &#123; deletedPackage.applicationInfo.uid &#125;; final ArrayList&lt;String&gt; pkgList = new ArrayList&lt;String&gt;(1); pkgList.add(deletedPackage.applicationInfo.packageName); sendResourcesChangedBroadcast(false, true, pkgList, uidArray, null); &#125; //【*6.2.1.4】清楚 code cache 数据！ clearAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); //【*6.2.1.5】清楚要被删除的应用的 profile 数据，这个和 odex 优化相关！ clearAppProfilesLIF(deletedPackage, UserHandle.USER_ALL); try &#123; //【3】扫描新的 apk 应用！ final PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_TIME, System.currentTimeMillis(), user); //【4】更新系统中的数据结构； updateSettingsLI(newPackage, installerPackageName, allUsers, res, user); //【5】记录保存被删除的旧 apk 的 code path，包括父包和子包！ PackageSetting ps = mSettings.mPackages.get(pkgName); if (!killApp) &#123; if (ps.oldCodePaths == null) &#123; ps.oldCodePaths = new ArraySet&lt;&gt;(); &#125; Collections.addAll(ps.oldCodePaths, deletedPackage.baseCodePath); if (deletedPackage.splitCodePaths != null) &#123; Collections.addAll(ps.oldCodePaths, deletedPackage.splitCodePaths); &#125; &#125; else &#123; ps.oldCodePaths = null; &#125; if (ps.childPackageNames != null) &#123; for (int i = ps.childPackageNames.size() - 1; i &gt;= 0; --i) &#123; final String childPkgName = ps.childPackageNames.get(i); final PackageSetting childPs = mSettings.mPackages.get(childPkgName); childPs.oldCodePaths = ps.oldCodePaths; &#125; &#125; //【*7.2.2】准备 app 数据目录； prepareAppDataAfterInstallLIF(newPackage); // 表示安装应用成功！ addedPkg = true; &#125; catch (PackageManagerException e) &#123; res.setError(\"Package couldn't be installed in \" + pkg.codePath, e); &#125; &#125; //【6】如果前面的处理没有问题，进入 if 分支！！ if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"Install failed, rolling pack: \" + pkgName); //【*8.1】如果安装不成功，但是我们已经扫描了新的 apk 那么这里会删除其遗留的数据！ if (addedPkg) &#123; deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, res.removedInfo, true, null); &#125; //【6.1】如果新 apk 安装失败了，并且执行了清理旧的 apk 的数据，那么这里会 reinstall 旧 apk！ if (deletedPkg) &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"Install failed, reinstalling: \" + deletedPackage); File restoreFile = new File(deletedPackage.codePath); //【6.1.1】设置解析参数 flags！ boolean oldExternal = isExternal(deletedPackage); int oldParseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | (deletedPackage.isForwardLocked() ? PackageParser.PARSE_FORWARD_LOCK : 0) | (oldExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0); int oldScanFlags = SCAN_UPDATE_SIGNATURE | SCAN_UPDATE_TIME; try &#123; //【6.1.2】重新解析和扫描旧的 apk！ scanPackageTracedLI(restoreFile, oldParseFlags, oldScanFlags, origUpdateTime, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"Failed to restore package : \" + pkgName + \" after failed upgrade: \" + e.getMessage()); return; &#125; synchronized (mPackages) &#123; //【6.1.3】设置 installer name！ setInstallerPackageNameLPw(deletedPackage, installerPackageName); //【6.1.4】更新被恢复的旧 apk 的权限信息！ updatePermissionsLPw(deletedPackage, UPDATE_PERMISSIONS_ALL); //【6.1.5】持久化内存中的应用数据！ mSettings.writeLPr(); &#125; Slog.i(TAG, \"Successfully restored package : \" + pkgName + \" after failed upgrade\"); &#125; &#125; else &#123; //【7】新 apk 覆盖安装成功了，进入 else！ synchronized (mPackages) &#123; PackageSetting ps = mSettings.peekPackageLPr(pkg.packageName); if (ps != null) &#123; //【7.1】更新要从那些 user 下移除！ res.removedInfo.removedForAllUsers = mPackages.get(ps.name) == null; if (res.removedInfo.removedChildPackages != null) &#123; final int childCount = res.removedInfo.removedChildPackages.size(); for (int i = childCount - 1; i &gt;= 0; i--) &#123; String childPackageName = res.removedInfo.removedChildPackages.keyAt(i); if (res.addedChildPackages.containsKey(childPackageName)) &#123; res.removedInfo.removedChildPackages.removeAt(i); &#125; else &#123; PackageRemovedInfo childInfo = res.removedInfo .removedChildPackages.valueAt(i); childInfo.removedForAllUsers = mPackages.get( childInfo.removedPackage) == null; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 不多说了！ 8.1 deletePackageLIF删除 apk，参数 PackageParser.Package replacingPackage 表示用于 replace 的 package： deletePackageLIF 中的逻辑很多涉及到了 delete package 的逻辑，和 install package 并没有太大关系，我们在后面的 delete package 中会继续分析！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) &#123; if (packageName == null) &#123; Slog.w(TAG, \"Attempt to delete null packageName.\"); return false; &#125; if (DEBUG_REMOVE) Slog.d(TAG, \"deletePackageLI: \" + packageName + \" user \" + user); PackageSetting ps; synchronized (mPackages) &#123; //【1】获得要删除的 apk 的 PackageSetting 数据！ ps = mSettings.mPackages.get(packageName); if (ps == null) &#123; Slog.w(TAG, \"Package named '\" + packageName + \"' doesn't exist.\"); return false; &#125; //【2】处理子包的数据： // 如果是子包，并且（其不是系统应用，或者 deleteFlags 设置了 DELETE_SYSTEM_APP 标志）！ // 那么我们会清除该子包的使用状态，同时设置在设备用户下处于未安装状态！ if (ps.parentPackageName != null &amp;&amp; (!isSystemApp(ps) || (flags &amp; PackageManager.DELETE_SYSTEM_APP) != 0)) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Uninstalled child package:\" + packageName + \" for user:\" + ((user == null) ? UserHandle.USER_ALL : user)); &#125; //【2.1】判断下要在那些 user 下删除该子包 apk 的状态信息！ final int removedUserId = (user != null) ? user.getIdentifier() : UserHandle.USER_ALL; //【*8.1.1】清除掉 userId 下的子包 apk 的使用信息！！ if (!clearPackageStateForUserLIF(ps, removedUserId, outInfo)) &#123; return false; &#125; //【*8.1.2】更新子包 apk 在该 user 下为未安装状态！ markPackageUninstalledForUserLPw(ps, user); //【2.2】更新应用偏好设置！ scheduleWritePackageRestrictionsLocked(user); return true; &#125; &#125; //【3】如果只是删除在指定 user 下的安装信息，那么我们会设置其在该 user 下为未安装的状态，同时删除其数据！ // 如果 deleteFlags 设置了 DELETE_SYSTEM_APP 标志位，表示删除的是系统应用； if (((!isSystemApp(ps) || (flags &amp; PackageManager.DELETE_SYSTEM_APP) != 0) &amp;&amp; user != null &amp;&amp; user.getIdentifier() != UserHandle.USER_ALL)) &#123; //【*8.1.2】更新子包 apk 在该 user 下为未安装状态！ markPackageUninstalledForUserLPw(ps, user); if (!isSystemApp(ps)) &#123; //【3.1】对于非系统应用的情况，先判断下是否需要保留不卸载！ boolean keepUninstalledPackage = shouldKeepUninstalledPackageLPr(packageName); //【3.2】如果该 package 在其他用户下有安装；或者其需要保留不卸载！ // 那么我们只需要清楚在当前指定的用户 user 下的数据并设置其为未安装状态； if (ps.isAnyInstalled(sUserManager.getUserIds()) || keepUninstalledPackage) &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Still installed by other users\"); //【*8.1.1】清除掉当前指定的用户 user 下的 apk 的使用信息！！ if (!clearPackageStateForUserLIF(ps, user.getIdentifier(), outInfo)) &#123; return false; &#125; //【3.3】更新应用偏好设置，然后返回！ scheduleWritePackageRestrictionsLocked(user); return true; &#125; else &#123; //【3.4】这里说明其没有在其他 user 下安装，同时也不需要保留，那么后面会执行删除操作 // 这里会将在当前指定的用户 user 下的安装状态设置为 installed，这样卸载广播能正确发出！ if (DEBUG_REMOVE) Slog.d(TAG, \"Not installed by other users, full delete\"); ps.setInstalled(true, user.getIdentifier()); &#125; &#125; else &#123; //【3.5】对于系统应用的情况，这里只会清楚当前指定用户下的数据，然后返回！ if (DEBUG_REMOVE) Slog.d(TAG, \"Deleting system app\"); //【*8.1.1】清除掉当前指定的用户 user 下的 apk 的使用信息！！ if (!clearPackageStateForUserLIF(ps, user.getIdentifier(), outInfo)) &#123; return false; &#125; //【3.6】更新应用偏好设置，然后返回！ scheduleWritePackageRestrictionsLocked(user); return true; &#125; &#125; //【4】这里按照逻辑，只有系统 apk 才能进入，因为只有系统 apk 才有子包！ // 这里是处理每个子包的移除信息，包括子包名，子包所在 user！ if (ps.childPackageNames != null &amp;&amp; outInfo != null) &#123; synchronized (mPackages) &#123; final int childCount = ps.childPackageNames.size(); outInfo.removedChildPackages = new ArrayMap&lt;&gt;(childCount); for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = ps.childPackageNames.get(i); PackageRemovedInfo childInfo = new PackageRemovedInfo(); childInfo.removedPackage = childPackageName; //【4.1】添加到父包的 removedChildPackages 集合中！ outInfo.removedChildPackages.put(childPackageName, childInfo); PackageSetting childPs = mSettings.peekPackageLPr(childPackageName); if (childPs != null) &#123; childInfo.origUsers = childPs.queryInstalledUsers(allUserHandles, true); &#125; &#125; &#125; &#125; boolean ret = false; if (isSystemApp(ps)) &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Removing system package: \" + ps.name); //【×8.1.3】删除系统 apk，如果系统 apk 之前被覆盖更新了，那么我们会删除新的 apk // 回滚到 system 分区的旧 apk！！ ret = deleteSystemPackageLIF(ps.pkg, ps, allUserHandles, flags, outInfo, writeSettings); &#125; else &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Removing non-system package: \" + ps.name); //【×8.1.4】删除非系统的 apk！ ret = deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles, outInfo, writeSettings, replacingPackage); &#125; //【5】记录下，我们是否从所有的用户 user 下删除了该 package! if (outInfo != null) &#123; //【5.1】更新父包和子包的 removedForAllUsers 属性！ outInfo.removedForAllUsers = mPackages.get(ps.name) == null; if (outInfo.removedChildPackages != null) &#123; synchronized (mPackages) &#123; final int childCount = outInfo.removedChildPackages.size(); for (int i = 0; i &lt; childCount; i++) &#123; PackageRemovedInfo childInfo = outInfo.removedChildPackages.valueAt(i); if (childInfo != null) &#123; childInfo.removedForAllUsers = mPackages.get( childInfo.removedPackage) == null; &#125; &#125; &#125; &#125; //【5.2】我们卸载的是一个系统 apk 的更新包，那么可能有些子包在 system 分区的旧 apk 中声明了 // 但是在新的 data 更新 apk 中没有申明，这里会处理这种情况！！ if (isSystemApp(ps)) &#123; synchronized (mPackages) &#123; PackageSetting updatedPs = mSettings.peekPackageLPr(ps.name); final int childCount = (updatedPs.childPackageNames != null) ? updatedPs.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = updatedPs.childPackageNames.get(i); if (outInfo.removedChildPackages == null || outInfo.removedChildPackages.indexOfKey(childPackageName) &lt; 0) &#123; PackageSetting childPs = mSettings.peekPackageLPr(childPackageName); if (childPs == null) &#123; continue; &#125; PackageInstalledInfo installRes = new PackageInstalledInfo(); installRes.name = childPackageName; installRes.newUsers = childPs.queryInstalledUsers(allUserHandles, true); installRes.pkg = mPackages.get(childPackageName); installRes.uid = childPs.pkg.applicationInfo.uid; if (outInfo.appearedChildPackages == null) &#123; outInfo.appearedChildPackages = new ArrayMap&lt;&gt;(); &#125; //【5.3】将这些子包保存到 outInfo.appearedChildPackages 中！ outInfo.appearedChildPackages.put(childPackageName, installRes); &#125; &#125; &#125; &#125; &#125; return ret;&#125; 先看到这里！ 8.1.1 clearPackageStateForUserLIF清楚指定 user 下的应用数据，这里涉及到的清理操作很多，由于篇幅，这里先不细讲，等到卸载应用时在深入分析！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private boolean clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo) &#123; final PackageParser.Package pkg; synchronized (mPackages) &#123; //【1】获得旧 apk 的扫描信息！ pkg = mPackages.get(ps.name); &#125; //【2】判断要删除那些 user 下的状态数据！ final int[] userIds = (userId == UserHandle.USER_ALL) ? sUserManager.getUserIds() : new int[] &#123;userId&#125;; for (int nextUserId : userIds) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Updating package:\" + ps.name + \" install state for user:\" + nextUserId); &#125; //【×8.1.1.1】删除掉旧 apk 的使用状态本地记录文件！ destroyAppDataLIF(pkg, userId, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); //【×8.1.1.2】删除 profile 相关信息！！ destroyAppProfilesLIF(pkg, userId); //【4】移除 key store！！ removeKeystoreDataIfNeeded(nextUserId, ps.appId); //【×8.1.1.3】执行 package clean 操作！！ schedulePackageCleaning(ps.name, nextUserId, false); synchronized (mPackages) &#123; //【5】清楚默认应用设置! if (clearPackagePreferredActivitiesLPw(ps.name, nextUserId)) &#123; //【5.1】更新偏好设置！ scheduleWritePackageRestrictionsLocked(nextUserId); &#125; //【6】更新运行时权限信息！ resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId); &#125; &#125; if (outInfo != null) &#123; outInfo.removedPackage = ps.name; outInfo.removedAppId = ps.appId; outInfo.removedUsers = userIds; &#125; return true;&#125; 关于以下的内容，会在卸载 app 和权限相关文章中分析，这里由于篇幅原因（markdown 只支持 6 级标题），就先不深入分析了！ 12345678//【3】删除 profile 相关信息！！destroyAppProfilesLIF(pkg, userId);//【4】移除 key store！！removeKeystoreDataIfNeeded(nextUserId, ps.appId);//【5】清楚默认应用设置clearPackagePreferredActivitiesLPw();//【6】更新运行时权限信息！resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId); 这里就不再多说了！！ 8.1.1.1 destroyAppDataLIF -&gt;[Leaf]12345678910111213private void destroyAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【1】删除父包的数据！！ destroyAppDataLeafLIF(pkg, userId, flags); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; //【2】删除子包的数据！ destroyAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 继续看：123456789101112131415161718private void destroyAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; final PackageSetting ps; synchronized (mPackages) &#123; //【1】获得该应用的安装信息 PackageSetting ！ ps = mSettings.mPackages.get(pkg.packageName); &#125; for (int realUserId : resolveUserIds(userId)) &#123; //【2】获得要删除的状态信息目录： final long ceDataInode = (ps != null) ? ps.getCeDataInode(realUserId) : 0; try &#123; //【3】调用了 Installd 删除指定目录！ mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ceDataInode); &#125; catch (InstallerException e) &#123; Slog.w(TAG, String.valueOf(e)); &#125; &#125;&#125; 这里使用了 PackageSetting.getCeDataInode 方法： 8.1.1.1.1 PackageSetting.getCeDataInode123long getCeDataInode(int userId) &#123; return readUserState(userId).ceDataInode;&#125; 该方法返回的是 PackageUserState.ceDataInode 的值！ 8.1.1.3 schedulePackageCleaning12345678910111213void schedulePackageCleaning(String packageName, int userId, boolean andCode) &#123; //【*8.1.1.3.1】这里会发送一个 START_CLEANING_PACKAGE 的消息给 PackageHandler ！ final Message msg = mHandler.obtainMessage(START_CLEANING_PACKAGE, userId, andCode ? 1 : 0, packageName); if (mSystemReady) &#123; msg.sendToTarget(); &#125; else &#123; if (mPostSystemReadyMessages == null) &#123; mPostSystemReadyMessages = new ArrayList&lt;&gt;(); &#125; mPostSystemReadyMessages.add(msg); &#125;&#125; 8.1.1.3.1 Packagehandler.doHandleMessage[START_CLEANING_PACKAGE]12345678910111213141516171819202122case START_CLEANING_PACKAGE: &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); final String packageName = (String)msg.obj; final int userId = msg.arg1; final boolean andCode = msg.arg2 != 0; synchronized (mPackages) &#123; if (userId == UserHandle.USER_ALL) &#123; int[] users = sUserManager.getUserIds(); for (int user : users) &#123; //【1】将 package 加入到 Settings 内部的 mPackagesToBeCleaned 集合中！ mSettings.addPackageToCleanLPw( new PackageCleanItem(user, packageName, andCode)); &#125; &#125; else &#123; mSettings.addPackageToCleanLPw( new PackageCleanItem(userId, packageName, andCode)); &#125; &#125; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //【*8.1.1.3.2】 startCleaningPackages();&#125; break; 8.1.1.3.2 startCleaningPackages执行扩展存储清理操作： 123456789101112131415161718192021222324void startCleaningPackages() &#123; // reader if (!isExternalMediaAvailable()) &#123; return; &#125; synchronized (mPackages) &#123; if (mSettings.mPackagesToBeCleaned.isEmpty()) &#123; return; &#125; &#125; //【1】发送 action PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE！ Intent intent = new Intent(PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE); //【2】目标组件服务：DefaultContainerService intent.setComponent(DEFAULT_CONTAINER_COMPONENT); IActivityManager am = ActivityManagerNative.getDefault(); if (am != null) &#123; try &#123; //【2.1】启动服务！ am.startService(null, intent, null, mContext.getOpPackageName(), UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; &#125; &#125;&#125; 进入 DefaultContainerService.onHandleIntent 方法： 12345678910111213141516171819@Overrideprotected void onHandleIntent(Intent intent) &#123; if (PackageManager.ACTION_CLEAN_EXTERNAL_STORAGE.equals(intent.getAction())) &#123; final IPackageManager pm = IPackageManager.Stub.asInterface( ServiceManager.getService(\"package\")); PackageCleanItem item = null; try &#123; while ((item = pm.nextPackageToClean(item)) != null) &#123; final UserEnvironment userEnv = new UserEnvironment(item.userId); eraseFiles(userEnv.buildExternalStorageAppDataDirs(item.packageName)); eraseFiles(userEnv.buildExternalStorageAppMediaDirs(item.packageName)); if (item.andCode) &#123; eraseFiles(userEnv.buildExternalStorageAppObbDirs(item.packageName)); &#125; &#125; &#125; catch (RemoteException e) &#123; &#125; &#125;&#125; 这里的逻辑就不多说了！ 8.1.2 markPackageUninstalledForUserLPw更新每个用户下的 package 的用户状态： 123456789101112131415private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) &#123; final int[] userIds = (user == null || user.getIdentifier() == UserHandle.USER_ALL) ? sUserManager.getUserIds() : new int[] &#123;user.getIdentifier()&#125;; for (int nextUserId : userIds) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Marking package:\" + ps.name + \" uninstalled for user:\" + nextUserId); &#125; //【1】调用了 PackageSettings 的 setUserState 接口！ ps.setUserState(nextUserId, 0, COMPONENT_ENABLED_STATE_DEFAULT, false /*installed*/, true /*stopped*/, true /*notLaunched*/, false /*hidden*/, false /*suspended*/, null, null, null, false /*blockUninstall*/, ps.readUserState(nextUserId).domainVerificationStatus, 0); &#125;&#125; 8.1.3 deleteSystemPackageLIF关于 flags 的设置： 123//【1】设置删除 flags，会保留用户数据！final int deleteFlags = PackageManager.DELETE_KEEP_DATA | (killApp ? 0 : PackageManager.DELETE_DONT_KILL_APP); 删除 system 更新 apk，PackageRemovedInfo outInfo 用于封装移除的相关信息！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private boolean deleteSystemPackageLIF(PackageParser.Package deletedPkg, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) &#123; if (deletedPs.parentPackageName != null) &#123; Slog.w(TAG, \"Attempt to delete child system package \" + deletedPkg.packageName); return false; &#125; final boolean applyUserRestrictions = (allUserHandles != null) &amp;&amp; (outInfo.origUsers != null); final PackageSetting disabledPs; synchronized (mPackages) &#123; //【1】尝试获得被更新的 system apk 数据！ disabledPs = mSettings.getDisabledSystemPkgLPr(deletedPs.name); &#125; if (DEBUG_REMOVE) Slog.d(TAG, \"deleteSystemPackageLI: newPs=\" + deletedPkg.packageName + \" disabledPs=\" + disabledPs); //【2】如果没有更新，那就不能删除，对于系统 apk，我们只能删除覆盖更新在 data 分区的！ if (disabledPs == null) &#123; Slog.w(TAG, \"Attempt to delete unknown system package \"+ deletedPkg.packageName); return false; &#125; else if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Deleting system pkg from data partition\"); &#125; if (DEBUG_REMOVE) &#123; if (applyUserRestrictions) &#123; Slog.d(TAG, \"Remembering install states:\"); for (int userId : allUserHandles) &#123; final boolean finstalled = ArrayUtils.contains(outInfo.origUsers, userId); Slog.d(TAG, \" u=\" + userId + \" inst=\" + finstalled); &#125; &#125; &#125; //【3】设置父包和子包的 isRemovedPackageSystemUpdate 为 true！ outInfo.isRemovedPackageSystemUpdate = true; if (outInfo.removedChildPackages != null) &#123; final int childCount = (deletedPs.childPackageNames != null) ? deletedPs.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = deletedPs.childPackageNames.get(i); if (disabledPs.childPackageNames != null &amp;&amp; disabledPs.childPackageNames .contains(childPackageName)) &#123; PackageRemovedInfo childInfo = outInfo.removedChildPackages.get( childPackageName); if (childInfo != null) &#123; childInfo.isRemovedPackageSystemUpdate = true; &#125; &#125; &#125; &#125; //【4】判读 version code，如果出现降级，那么就不能保留数据！ if (disabledPs.versionCode &lt; deletedPs.versionCode) &#123; flags &amp;= ~PackageManager.DELETE_KEEP_DATA; &#125; else &#123; flags |= PackageManager.DELETE_KEEP_DATA; &#125; //【×8.1.4】执行删除 data 分区新 apk，删除失败就结束操作！ boolean ret = deleteInstalledPackageLIF(deletedPs, true, flags, allUserHandles, outInfo, writeSettings, disabledPs.pkg); if (!ret) &#123; return false; &#125; //【5】恢复 system 分区的旧 apk 的数据，同时删除更新的 apk 的 native libs synchronized (mPackages) &#123; enableSystemPackageLPw(disabledPs.pkg); removeNativeBinariesLI(deletedPs); &#125; //【6】设置扫描 flags！ if (DEBUG_REMOVE) Slog.d(TAG, \"Re-installing system package: \" + disabledPs); int parseFlags = mDefParseFlags | PackageParser.PARSE_MUST_BE_APK | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; if (locationIsPrivileged(disabledPs.codePath)) &#123; parseFlags |= PackageParser.PARSE_IS_PRIVILEGED; &#125; final PackageParser.Package newPkg; try &#123; //【7】扫描旧的 system apk！ newPkg = scanPackageTracedLI(disabledPs.codePath, parseFlags, SCAN_NO_PATHS, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.w(TAG, \"Failed to restore system package:\" + deletedPkg.packageName + \": \" + e.getMessage()); return false; &#125; try &#123; //【8】更新 shared libs 给重新安装的 system apk！ updateSharedLibrariesLPw(newPkg, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"updateAllSharedLibrariesLPw failed: \" + e.getMessage()); &#125; //【*7.2.2】准备 app 数据目录； prepareAppDataAfterInstallLIF(newPkg); //【9】更新 pms 数据！ synchronized (mPackages) &#123; PackageSetting ps = mSettings.mPackages.get(newPkg.packageName); //【9.1】从被删除的 data 分区 apk 那里继承最新的权限信息！ ps.getPermissionsState().copyFrom(deletedPs.getPermissionsState()); //【9.2】更新系统中所有应用的权限信息！ updatePermissionsLPw(newPkg.packageName, newPkg, UPDATE_PERMISSIONS_ALL | UPDATE_PERMISSIONS_REPLACE_PKG); if (applyUserRestrictions) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Propagating install state across reinstall\"); &#125; for (int userId : allUserHandles) &#123; final boolean installed = ArrayUtils.contains(outInfo.origUsers, userId); if (DEBUG_REMOVE) &#123; Slog.d(TAG, \" user \" + userId + \" =&gt; \" + installed); &#125; ps.setInstalled(installed, userId); //【9.3】持久化运行时权限； mSettings.writeRuntimePermissionsForUserLPr(userId, false); &#125; //【9.4】持久化应用偏好设置！ mSettings.writeAllUsersPackageRestrictionsLPr(); &#125; //【9.5】持久化最新的所有应用数据！ if (writeSettings) &#123; mSettings.writeLPr(); &#125; &#125; return true;&#125; 这里就不在多说了！ 8.1.4 deleteInstalledPackageLIF关于 flags 的设置： 123//【1】设置删除 flags，会保留用户数据！final int deleteFlags = PackageManager.DELETE_KEEP_DATA | (killApp ? 0 : PackageManager.DELETE_DONT_KILL_APP); 删除 data 分区的 apk： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private boolean deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) &#123; synchronized (mPackages) &#123; if (outInfo != null) &#123; outInfo.uid = ps.appId; &#125; if (outInfo != null &amp;&amp; outInfo.removedChildPackages != null) &#123; final int childCount = (ps.childPackageNames != null) ? ps.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = ps.childPackageNames.get(i); PackageSetting childPs = mSettings.mPackages.get(childPackageName); if (childPs == null) &#123; return false; &#125; PackageRemovedInfo childInfo = outInfo.removedChildPackages.get( childPackageName); if (childInfo != null) &#123; childInfo.uid = childPs.appId; &#125; &#125; &#125; &#125; //【×8.1.4.1】移除 package 的数据！ removePackageDataLIF(ps, allUserHandles, outInfo, flags, writeSettings); //【1】如果有子包，也会移除子包的数据！ final int childCount = (ps.childPackageNames != null) ? ps.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageSetting childPs; synchronized (mPackages) &#123; childPs = mSettings.peekPackageLPr(ps.childPackageNames.get(i)); &#125; if (childPs != null) &#123; PackageRemovedInfo childOutInfo = (outInfo != null &amp;&amp; outInfo.removedChildPackages != null) ? outInfo.removedChildPackages.get(childPs.name) : null; final int deleteFlags = (flags &amp; DELETE_KEEP_DATA) != 0 &amp;&amp; (replacingPackage != null &amp;&amp; !replacingPackage.hasChildPackage(childPs.name)) ? flags &amp; ~DELETE_KEEP_DATA : flags; //【×8.1.4.1】移除 package 的数据！ removePackageDataLIF(childPs, allUserHandles, childOutInfo, deleteFlags, writeSettings); &#125; &#125; //【2】对于被删除的父包，会创建一个 InstallArgs，用于删除 apk 和资源！ if (ps.parentPackageName == null) &#123; if (deleteCodeAndResources &amp;&amp; (outInfo != null)) &#123; //【×6.2.1.3】根据一个存在的 package 创建一个 InstallArgs 中！ outInfo.args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps)); if (DEBUG_SD_INSTALL) Slog.i(TAG, \"args=\" + outInfo.args); &#125; &#125; return true;&#125; 不多说了！ 8.1.4.1 removePackageDataLIF删除 package 的数据！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114private void removePackageDataLIF(PackageSetting ps, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) &#123; String packageName = ps.name; if (DEBUG_REMOVE) Slog.d(TAG, \"removePackageDataLI: \" + ps); final PackageParser.Package deletedPkg; final PackageSetting deletedPs; synchronized (mPackages) &#123; //【1】获得要被删除的 apk 的 PackageSetting 和 PackageParser.Package 对象！ deletedPkg = mPackages.get(packageName); deletedPs = mSettings.mPackages.get(packageName); if (outInfo != null) &#123; outInfo.removedPackage = packageName; outInfo.removedUsers = deletedPs != null ? deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true) : null; &#125; &#125; //【×8.1.4.1】第一部移除，扫描和四大组件信息！ removePackageLI(ps, (flags &amp; REMOVE_CHATTY) != 0); //【2】如果 flags 没有设置 DELETE_KEEP_DATA，那么会清楚 apk 的数据，显然这里由于设置了，那么就不会清楚！ if ((flags &amp; PackageManager.DELETE_KEEP_DATA) == 0) &#123; final PackageParser.Package resolvedPkg; if (deletedPkg != null) &#123; resolvedPkg = deletedPkg; &#125; else &#123; resolvedPkg = new PackageParser.Package(ps.name); resolvedPkg.setVolumeUuid(ps.volumeUuid); &#125; //【×8.1.1.1】删除 apk 的 data 数据！！ destroyAppDataLIF(resolvedPkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); //【×8.1.1.2】删除 apk 的 profiles 数据！！ destroyAppProfilesLIF(resolvedPkg, UserHandle.USER_ALL); if (outInfo != null) &#123; outInfo.dataRemoved = true; &#125; //【×8.1.1.3】执行 package 清除！！ schedulePackageCleaning(packageName, UserHandle.USER_ALL, true); &#125; //【3】进一步处理！ synchronized (mPackages) &#123; if (deletedPs != null) &#123; //【3.1】如果 flags 没有设置 DELETE_KEEP_DATA 标志位，那么执行其他的清楚操作！ if ((flags &amp; PackageManager.DELETE_KEEP_DATA) == 0) &#123; //【3.1.1】清楚 intentfilter verify 和 默认浏览器的设置数据！ clearIntentFilterVerificationsLPw(deletedPs.name, UserHandle.USER_ALL); clearDefaultBrowserIfNeeded(packageName); if (outInfo != null) &#123; mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName); outInfo.removedAppId = mSettings.removePackageLPw(packageName); &#125; //【3.1.2】更新权限信息！ updatePermissionsLPw(deletedPs.name, null, 0); //【3.1.3】如果该应用是共享 shared user 的，进入这里！ if (deletedPs.sharedUser != null) &#123; for (int userId : UserManagerService.getInstance().getUserIds()) &#123; //【3.1.3.1】更新该共享 shared uid 的权限，该 package 被移除掉，会导致和该 // 应用相关连的权限的变化，从而导致共享 shared uid 的 gids 发生变化！ final int userIdToKill = mSettings.updateSharedUserPermsLPw(deletedPs, userId); if (userIdToKill == UserHandle.USER_ALL || userIdToKill &gt;= UserHandle.USER_SYSTEM) &#123; //【3.1.3.1】如果共享 shared uid 的 gids 发生变化，杀掉该 uid 下的 // 所有的 app 进程！ mHandler.post(new Runnable() &#123; @Override public void run() &#123; killApplication(deletedPs.name, deletedPs.appId, KILL_APP_REASON_GIDS_CHANGED); &#125; &#125;); break; &#125; &#125; &#125; //【3.1.4】清除默认应用的数据； clearPackagePreferredActivitiesLPw(deletedPs.name, UserHandle.USER_ALL); &#125; //【3.4】更新下在每个 user 下的安装状态！ if (allUserHandles != null &amp;&amp; outInfo != null &amp;&amp; outInfo.origUsers != null) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Propagating install state across downgrade\"); &#125; for (int userId : allUserHandles) &#123; final boolean installed = ArrayUtils.contains(outInfo.origUsers, userId); if (DEBUG_REMOVE) &#123; Slog.d(TAG, \" user \" + userId + \" =&gt; \" + installed); &#125; ps.setInstalled(installed, userId); &#125; &#125; &#125; //【3.5】持久化 Settings！！ if (writeSettings) &#123; mSettings.writeLPr(); &#125; &#125; if (outInfo != null) &#123; //【4】移除 key-store！ removeKeystoreDataIfNeeded(UserHandle.USER_ALL, outInfo.removedAppId); &#125;&#125; 不多说了！！ 8.1.4.1.1 removePackageLI移除 PackageSetting 对应的扫描数据： 123456789101112131415void removePackageLI(PackageSetting ps, boolean chatty) &#123; if (DEBUG_INSTALL) &#123; if (chatty) Log.d(TAG, \"Removing package \" + ps.name); &#125; synchronized (mPackages) &#123; //【1】移除扫描信息！ mPackages.remove(ps.name); final PackageParser.Package pkg = ps.pkg; if (pkg != null) &#123; //【×6.2.1.6.1】移除四大组件，共享库解析对象！ cleanPackageDataStructuresLILPw(pkg, chatty); &#125; &#125;&#125; 这个就不多说了！！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 6 篇 - PMS_READY 阶段","slug":"PMS6-PMS_READY","date":"2018-04-27T16:00:00.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/04/28/PMS6-PMS_READY/","link":"","permalink":"https://coolqi.top/2018/04/28/PMS6-PMS_READY/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现，本文是作者原创，转载请说明出处！ 0 综述最后我们会进入 PMS 初始化的最后阶段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 ... ... ... ...// 第五阶段 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis()); //【1】获得 PMS 需要一些包名，比如 PackageInstaller，IntentFilterVerifier 等等！ if (!mOnlyCore) &#123; mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr(); mRequiredInstallerPackage = getRequiredInstallerLPr(); mRequiredUninstallerPackage = getRequiredUninstallerLPr(); mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr(); mIntentFilterVerifier = new IntentVerifierProxy(mContext, mIntentFilterVerifierComponent); mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES); mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SHARED); &#125; else &#123; mRequiredVerifierPackage = null; mRequiredInstallerPackage = null; mRequiredUninstallerPackage = null; mIntentFilterVerifierComponent = null; mIntentFilterVerifier = null; mServicesSystemSharedLibraryPackageName = null; mSharedSystemSharedLibraryPackageName = null; &#125; //【2】建立 PackageInstallerService 服务对象，用于 package 的安装！ mInstallerService = new PackageInstallerService(context, this); final ComponentName ephemeralResolverComponent = getEphemeralResolverLPr(); final ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr(); // both the installer and resolver must be present to enable ephemeral if (ephemeralInstallerComponent != null &amp;&amp; ephemeralResolverComponent != null) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.i(TAG, \"Ephemeral activated; resolver: \" + ephemeralResolverComponent + \" installer:\" + ephemeralInstallerComponent); &#125; mEphemeralResolverComponent = ephemeralResolverComponent; mEphemeralInstallerComponent = ephemeralInstallerComponent; setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent); mEphemeralResolverConnection = new EphemeralResolverConnection(mContext, mEphemeralResolverComponent); &#125; else &#123; if (DEBUG_EPHEMERAL) &#123; final String missingComponent = (ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? \"resolver and installer\" : \"resolver\" : \"installer\"; Slog.i(TAG, \"Ephemeral deactivated; missing \" + missingComponent); &#125; mEphemeralResolverComponent = null; mEphemeralInstallerComponent = null; mEphemeralResolverConnection = null; &#125; mEphemeralApplicationRegistry = new EphemeralApplicationRegistry(this); &#125; // synchronized (mPackages) &#125; // synchronized (mInstallLock) // 执行 GC 操作，回收系统资源！ Runtime.getRuntime().gc(); // The initial scanning above does many calls into installd while // holding the mPackages lock, but we're mostly interested in yelling // once we have a booted system. mInstaller.setWarnIfHeld(mPackages); //【3】将自身加入本地服务管理中，方便系统自身访问！ LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); &#125; 这个阶段逻辑很简单，我们不多分析！ 1 获得一些 PMS 会用到的应用的包名1.1 PackageMS.getRequiredButNotReallyRequiredVerifierLPr123456789101112131415private @Nullable String getRequiredButNotReallyRequiredVerifierLPr() &#123; // android.intent.action.PACKAGE_NEEDS_VERIFICATION final Intent intent = new Intent(Intent.ACTION_PACKAGE_NEEDS_VERIFICATION); final List&lt;ResolveInfo&gt; matches = queryIntentReceiversInternal(intent, PACKAGE_MIME_TYPE, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM); if (matches.size() == 1) &#123; return matches.get(0).getComponentInfo().packageName; &#125; else if (matches.size() == 0) &#123; Log.e(TAG, \"There should probably be a verifier, but, none were found\"); return null; &#125; throw new RuntimeException(\"There must be exactly one verifier; found \" + matches);&#125; 1.2 PackageMS.getRequiredInstallerLPr获得 packageInstaller 的包名！123456789101112131415161718private @NonNull String getRequiredInstallerLPr() &#123; final Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setDataAndType(Uri.fromFile(new File(\"foo.apk\")), PACKAGE_MIME_TYPE); final List&lt;ResolveInfo&gt; matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM); if (matches.size() == 1) &#123; ResolveInfo resolveInfo = matches.get(0); if (!resolveInfo.activityInfo.applicationInfo.isPrivilegedApp()) &#123; throw new RuntimeException(\"The installer must be a privileged app\"); &#125; return matches.get(0).getComponentInfo().packageName; &#125; else &#123; throw new RuntimeException(\"There must be exactly one installer; found \" + matches); &#125;&#125; 1.3 PackageMS.getRequiredUninstallerLPr123456789101112131415private @NonNull String getRequiredUninstallerLPr() &#123; final Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setData(Uri.fromParts(PACKAGE_SCHEME, \"foo.bar\", null)); final ResolveInfo resolveInfo = resolveIntent(intent, null, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM); if (resolveInfo == null || mResolveActivity.name.equals(resolveInfo.getComponentInfo().name)) &#123; throw new RuntimeException(\"There must be exactly one uninstaller; found \" + resolveInfo); &#125; return resolveInfo.getComponentInfo().packageName;&#125; 1.4 PackageMS.getIntentFilterVerifierComponentNameLPr123456789101112131415161718192021222324252627private @NonNull ComponentName getIntentFilterVerifierComponentNameLPr() &#123; final Intent intent = new Intent(Intent.ACTION_INTENT_FILTER_NEEDS_VERIFICATION); final List&lt;ResolveInfo&gt; matches = queryIntentReceiversInternal(intent, PACKAGE_MIME_TYPE, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM); ResolveInfo best = null; final int N = matches.size(); for (int i = 0; i &lt; N; i++) &#123; final ResolveInfo cur = matches.get(i); final String packageName = cur.getComponentInfo().packageName; if (checkPermission(android.Manifest.permission.INTENT_FILTER_VERIFICATION_AGENT, packageName, UserHandle.USER_SYSTEM) != PackageManager.PERMISSION_GRANTED) &#123; continue; &#125; if (best == null || cur.priority &gt; best.priority) &#123; best = cur; &#125; &#125; if (best != null) &#123; return best.getComponentInfo().getComponentName(); &#125; else &#123; throw new RuntimeException(\"There must be at least one intent filter verifier\"); &#125;&#125; 1.5 PackageMS.getRequiredSharedLibraryLPr123456789101112131415161718192021/** * This is a library that contains components apps can invoke. For * example, a services for apps to bind to, or standard chooser UI, * etc. This library is versioned and backwards compatible. Clients * should check its version via &#123;@link android.ext.services.Version * #getVersionCode()&#125; and avoid calling APIs added in later versions. * * @hide */public static final String SYSTEM_SHARED_LIBRARY_SERVICES = \"android.ext.services\";/** * This is a library that contains components apps can dynamically * load. For example, new widgets, helper classes, etc. This library * is versioned and backwards compatible. Clients should check its * version via &#123;@link android.ext.shared.Version#getVersionCode()&#125; * and avoid calling APIs added in later versions. * * @hide */public static final String SYSTEM_SHARED_LIBRARY_SHARED = \"android.ext.shared\"; 123456789101112131415 mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES); mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SHARED);``` ```java private @NonNull String getRequiredSharedLibraryLPr(String libraryName) &#123; synchronized (mPackages) &#123; SharedLibraryEntry libraryEntry = mSharedLibraries.get(libraryName); if (libraryEntry == null) &#123; throw new IllegalStateException(\"Missing required shared library:\" + libraryName); &#125; return libraryEntry.apk; &#125; &#125; 2 new PackageInstallerService - 创建安装服务对象创建 PackageInstallerService 服务对象，用于应用的安装，关于安装，这个我们先不关注！ 12345678910111213141516171819202122232425262728293031323334353637383940public PackageInstallerService(Context context, PackageManagerService pm) &#123; mContext = context; mPm = pm; // pms 的应用！ mInstallThread = new HandlerThread(TAG); // 一个线程，用于处理 install 操作！ mInstallThread.start(); mInstallHandler = new Handler(mInstallThread.getLooper()); // 该线程的 Handler！ //【2.1】创建了一个 Callbacks 回调对象，用于处理事务的变化，通知需要监听事务变化的远程对象！ mCallbacks = new Callbacks(mInstallThread.getLooper()); // 用于保存安装事务项的文件对象！ mSessionsFile = new AtomicFile( new File(Environment.getDataSystemDirectory(), \"install_sessions.xml\")); mSessionsDir = new File(Environment.getDataSystemDirectory(), \"install_sessions\"); mSessionsDir.mkdirs(); synchronized (mSessions) &#123; //【2.2】读取安装事务！ readSessionsLocked(); reconcileStagesLocked(StorageManager.UUID_PRIVATE_INTERNAL, false /*isEphemeral*/); reconcileStagesLocked(StorageManager.UUID_PRIVATE_INTERNAL, true /*isEphemeral*/); final ArraySet&lt;File&gt; unclaimedIcons = newArraySet( mSessionsDir.listFiles()); // Ignore stages and icons claimed by active sessions for (int i = 0; i &lt; mSessions.size(); i++) &#123; final PackageInstallerSession session = mSessions.valueAt(i); unclaimedIcons.remove(buildAppIconFile(session.sessionId)); &#125; // Clean up orphaned icons for (File icon : unclaimedIcons) &#123; Slog.w(TAG, \"Deleting orphan icon \" + icon); icon.delete(); &#125; &#125;&#125; 在 PackageInstallerService 有如下的集合，来保存安装事务！1234567891011// 所有的事务，有效和无效的@GuardedBy(\"mSessions\")private final SparseBooleanArray mAllocatedSessions = new SparseBooleanArray();// 用于保存那些有效的安装事务！@GuardedBy(\"mSessions\")private final SparseArray&lt;PackageInstallerSession&gt; mSessions = new SparseArray&lt;&gt;();// 用于保存那些无效的历史事务！@GuardedBy(\"mSessions\")private final SparseArray&lt;PackageInstallerSession&gt; mHistoricalSessions = new SparseArray&lt;&gt;(); 在创建 PackageInstallerService 的时候会调用 readSessionsLocked 读取重启之前的所有安装事务！ 2.1 new CallbackCallback 本质上也是一个 Handler 对象，其 Looper 对象来自 mInstallThread.getLooper()，用于处理耗时操作： 12345private static class Callbacks extends Handler &#123; public Callbacks(Looper looper) &#123; super(looper); &#125;&#125; Callback 用于处理和 session 相关的消息：12345private static final int MSG_SESSION_CREATED = 1;private static final int MSG_SESSION_BADGING_CHANGED = 2;private static final int MSG_SESSION_ACTIVE_CHANGED = 3;private static final int MSG_SESSION_PROGRESS_CHANGED = 4;private static final int MSG_SESSION_FINISHED = 5; 本质上讲，Callback 只是这些消息的中转站，它会将消息发送给注册到其内部的远程回调接口： 12private final RemoteCallbackList&lt;IPackageInstallerCallback&gt; mCallbacks = new RemoteCallbackList&lt;&gt;(); CallBack 内部提供了注册相关的接口： 1234567public void register(IPackageInstallerCallback callback, int userId) &#123; mCallbacks.register(callback, new UserHandle(userId));&#125;public void unregister(IPackageInstallerCallback callback) &#123; mCallbacks.unregister(callback);&#125; 我们来看下，其实如何处理回调的，当有 Session 发生变化后，下面的接口会被触发调用！12345678910111213141516171819private void notifySessionCreated(int sessionId, int userId) &#123; obtainMessage(MSG_SESSION_CREATED, sessionId, userId).sendToTarget();&#125;private void notifySessionBadgingChanged(int sessionId, int userId) &#123; obtainMessage(MSG_SESSION_BADGING_CHANGED, sessionId, userId).sendToTarget();&#125;private void notifySessionActiveChanged(int sessionId, int userId, boolean active) &#123; obtainMessage(MSG_SESSION_ACTIVE_CHANGED, sessionId, userId, active).sendToTarget();&#125;private void notifySessionProgressChanged(int sessionId, int userId, float progress) &#123; obtainMessage(MSG_SESSION_PROGRESS_CHANGED, sessionId, userId, progress).sendToTarget();&#125;public void notifySessionFinished(int sessionId, int userId, boolean success) &#123; obtainMessage(MSG_SESSION_FINISHED, sessionId, userId, success).sendToTarget();&#125; 这些接口会发送消息，处理仍然是在 CallBack 中： 123456789101112131415161718@Overridepublic void handleMessage(Message msg) &#123; final int userId = msg.arg2; final int n = mCallbacks.beginBroadcast(); for (int i = 0; i &lt; n; i++) &#123; final IPackageInstallerCallback callback = mCallbacks.getBroadcastItem(i); final UserHandle user = (UserHandle) mCallbacks.getBroadcastCookie(i); // TODO: dispatch notifications for slave profiles if (userId == user.getIdentifier()) &#123; try &#123; // 调用 invokeCallback 分发 session 变化的消息！ invokeCallback(callback, msg); &#125; catch (RemoteException ignored) &#123; &#125; &#125; &#125; mCallbacks.finishBroadcast();&#125; invokeCallback 方法将 session 变化的消息会转发给所有注册到其内部的远程回调接口！123456789101112131415161718192021private void invokeCallback(IPackageInstallerCallback callback, Message msg) throws RemoteException &#123; final int sessionId = msg.arg1; switch (msg.what) &#123; case MSG_SESSION_CREATED: callback.onSessionCreated(sessionId); break; case MSG_SESSION_BADGING_CHANGED: callback.onSessionBadgingChanged(sessionId); break; case MSG_SESSION_ACTIVE_CHANGED: callback.onSessionActiveChanged(sessionId, (boolean) msg.obj); break; case MSG_SESSION_PROGRESS_CHANGED: callback.onSessionProgressChanged(sessionId, (float) msg.obj); break; case MSG_SESSION_FINISHED: callback.onSessionFinished(sessionId, (boolean) msg.obj); break; &#125;&#125; 2.2 PackageInstallerService.readSessionsLocked[0]readSessionsLocked 用来读取事务！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void readSessionsLocked() &#123; if (LOGD) Slog.v(TAG, \"readSessionsLocked()\"); mSessions.clear(); FileInputStream fis = null; try &#123; fis = mSessionsFile.openRead(); final XmlPullParser in = Xml.newPullParser(); in.setInput(fis, StandardCharsets.UTF_8.name()); int type; while ((type = in.next()) != END_DOCUMENT) &#123; if (type == START_TAG) &#123; final String tag = in.getName(); if (TAG_SESSION.equals(tag)) &#123; // session 标签，用户封装指定的安装事务！ //【2.2】读取安装事务，返回 PackageInstallerSession 对象！ final PackageInstallerSession session = readSessionLocked(in); // 计算事务的有效性！ final long age = System.currentTimeMillis() - session.createdMillis; final boolean valid; // 如果大于 MAX_AGE_MILLIS 3 天，那就是无效的，否则是有效的！ if (age &gt;= MAX_AGE_MILLIS) &#123; Slog.w(TAG, \"Abandoning old session first created at \" + session.createdMillis); valid = false; &#125; else &#123; valid = true; &#125; if (valid) &#123; // 有效的事务 mSessions.put(session.sessionId, session); &#125; else &#123; // 无效的事务，用于 debug，比如 dumpsys 等等！ mHistoricalSessions.put(session.sessionId, session); &#125; // 所有的事务！ mAllocatedSessions.put(session.sessionId, true); &#125; &#125; &#125; &#125; catch (FileNotFoundException e) &#123; // Missing sessions are okay, probably first boot &#125; catch (IOException | XmlPullParserException e) &#123; Slog.wtf(TAG, \"Failed reading install sessions\", e); &#125; finally &#123; IoUtils.closeQuietly(fis); &#125;&#125; 判断一个事务是否有效的依据是，其实是否是在 3 天时间间隔之前创建的！1private static final long MAX_AGE_MILLIS = 3 * DateUtils.DAY_IN_MILLIS; 2.2.1 PackageInstallerService.readSessionsLocked[1]我们看下解析单个事务的具体过程！ 12345678910111213141516171819202122232425262728293031323334353637383940414243private PackageInstallerSession readSessionLocked(XmlPullParser in) throws IOException, XmlPullParserException &#123; final int sessionId = readIntAttribute(in, ATTR_SESSION_ID); // sessionId 属性 final int userId = readIntAttribute(in, ATTR_USER_ID); // userId 属性 final String installerPackageName = readStringAttribute(in, ATTR_INSTALLER_PACKAGE_NAME); // installerPackageName 属性 final int installerUid = readIntAttribute(in, ATTR_INSTALLER_UID, mPm.getPackageUid( installerPackageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, userId)); // installerUid 属性 final long createdMillis = readLongAttribute(in, ATTR_CREATED_MILLIS); // createdMillis 属性 final String stageDirRaw = readStringAttribute(in, ATTR_SESSION_STAGE_DIR); // sessionStageDir 属性 final File stageDir = (stageDirRaw != null) ? new File(stageDirRaw) : null; final String stageCid = readStringAttribute(in, ATTR_SESSION_STAGE_CID); // sessionStageCid 属性 final boolean prepared = readBooleanAttribute(in, ATTR_PREPARED, true); // prepared 属性 final boolean sealed = readBooleanAttribute(in, ATTR_SEALED); // sealed 属性 //【2.2.1】创建了一个 SessionParams 对象，封装事务详细参数 final SessionParams params = new SessionParams( SessionParams.MODE_INVALID); params.mode = readIntAttribute(in, ATTR_MODE); // mode 属性 params.installFlags = readIntAttribute(in, ATTR_INSTALL_FLAGS); // installFlags 属性 params.installLocation = readIntAttribute(in, ATTR_INSTALL_LOCATION); // installLocation 属性 params.sizeBytes = readLongAttribute(in, ATTR_SIZE_BYTES); // sizeBytes 属性 params.appPackageName = readStringAttribute(in, ATTR_APP_PACKAGE_NAME); // appPackageName 属性 params.appIcon = readBitmapAttribute(in, ATTR_APP_ICON); // appIcon 属性 params.appLabel = readStringAttribute(in, ATTR_APP_LABEL); // appLabel 属性 params.originatingUri = readUriAttribute(in, ATTR_ORIGINATING_URI); // originatingUri 属性 params.originatingUid = readIntAttribute(in, ATTR_ORIGINATING_UID, SessionParams.UID_UNKNOWN); // originatingUid 属性 params.referrerUri = readUriAttribute(in, ATTR_REFERRER_URI); // referrerUri 属性 params.abiOverride = readStringAttribute(in, ATTR_ABI_OVERRIDE); // abiOverride 属性 params.volumeUuid = readStringAttribute(in, ATTR_VOLUME_UUID); // volumeUuid 属性 //【2.2.2】读取授予的运行时权限！ params.grantedRuntimePermissions = readGrantedRuntimePermissions(in); final File appIconFile = buildAppIconFile(sessionId); if (appIconFile.exists()) &#123; params.appIcon = BitmapFactory.decodeFile(appIconFile.getAbsolutePath()); params.appIconLastModified = appIconFile.lastModified(); &#125; //【2.2.3】创建事务对象 PackageInstallerSession！ return new PackageInstallerSession(mInternalCallback, mContext, mPm, mInstallThread.getLooper(), sessionId, userId, installerPackageName, installerUid, params, createdMillis, stageDir, stageCid, prepared, sealed);&#125; 方法步骤： 解析 xml； 创建事务对象 PackageInstallerSession； 2.2.1.1 new SessionParams123public SessionParams(int mode) &#123; this.mode = mode;&#125; 创建了一个 SessionParams，用于封装事务参数！ 2.2.1.2 PackageInstallerService.readGrantedRuntimePermissionsreadGrantedRuntimePermissions 方法会读取授予的运行时权限！1234567891011121314151617181920212223242526272829private static String[] readGrantedRuntimePermissions(XmlPullParser in) throws IOException, XmlPullParserException &#123; List&lt;String&gt; permissions = null; final int outerDepth = in.getDepth(); int type; while ((type = in.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || in.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (TAG_GRANTED_RUNTIME_PERMISSION.equals(in.getName())) &#123; // 读取 granted-runtime-permission 子标签！ String permission = readStringAttribute(in, ATTR_NAME); // 读取 name 属性，即运行时权限名 if (permissions == null) &#123; permissions = new ArrayList&lt;&gt;(); &#125; // 将权限名保存到 permissions，并返回！！ permissions.add(permission); &#125; &#125; if (permissions == null) &#123; return null; &#125; String[] permissionsArray = new String[permissions.size()]; permissions.toArray(permissionsArray); return permissionsArray;&#125; 方法很简单，这就不多说了！ 2.2.1.3 new PackageInstallerSession创建一个 PackageInstallerSession，参数来自前面的解析！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public PackageInstallerSession(PackageInstallerService.InternalCallback callback, Context context, PackageManagerService pm, Looper looper, int sessionId, int userId, String installerPackageName, int installerUid, SessionParams params, long createdMillis, File stageDir, String stageCid, boolean prepared, boolean sealed) &#123; mCallback = callback; // InternalCallback 对象，用于监听和相应 session 的变化！！ mContext = context; mPm = pm; mHandler = new Handler(looper, mHandlerCallback); this.sessionId = sessionId; this.userId = userId; this.installerPackageName = installerPackageName; this.installerUid = installerUid; this.params = params; this.createdMillis = createdMillis; this.stageDir = stageDir; this.stageCid = stageCid; if ((stageDir == null) == (stageCid == null)) &#123; throw new IllegalArgumentException( \"Exactly one of stageDir or stageCid stage must be set\"); &#125; mPrepared = prepared; mSealed = sealed; // Device owners are allowed to silently install packages, so the permission check is // waived if the installer is the device owner. DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService( Context.DEVICE_POLICY_SERVICE); final boolean isPermissionGranted = (mPm.checkUidPermission(android.Manifest.permission.INSTALL_PACKAGES, installerUid) == PackageManager.PERMISSION_GRANTED); final boolean isInstallerRoot = (installerUid == Process.ROOT_UID); // 安装者是否是 root 级别！ final boolean forcePermissionPrompt = (params.installFlags &amp; PackageManager.INSTALL_FORCE_PERMISSION_PROMPT) != 0; mIsInstallerDeviceOwner = (dpm != null) &amp;&amp; dpm.isDeviceOwnerAppOnCallingUser( installerPackageName); if ((isPermissionGranted || isInstallerRoot || mIsInstallerDeviceOwner) &amp;&amp; !forcePermissionPrompt) &#123; mPermissionsAccepted = true; &#125; else &#123; mPermissionsAccepted = false; &#125; final long identity = Binder.clearCallingIdentity(); try &#123; final int uid = mPm.getPackageUid(PackageManagerService.DEFAULT_CONTAINER_PACKAGE, PackageManager.MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM); defaultContainerGid = UserHandle.getSharedAppGid(uid); &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125;&#125; 在创建 PackageInstallerSession 的时候，我们传入了一个 mInternalCallback，他是 PackageInstallerService 的成员变量： 1private final InternalCallback mInternalCallback = new InternalCallback(); 这个接口用于监听和相应 Sessions 的变化，当 Sessions 发生变化后，会通过该接口，将相应的消息抓发给 Callback，Callback 会将消息再次转发给远程回调接口！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class InternalCallback &#123; public void onSessionBadgingChanged(PackageInstallerSession session) &#123; mCallbacks.notifySessionBadgingChanged(session.sessionId, session.userId); writeSessionsAsync(); &#125; public void onSessionActiveChanged(PackageInstallerSession session, boolean active) &#123; mCallbacks.notifySessionActiveChanged(session.sessionId, session.userId, active); &#125; // 安装事务的进度发生变化！ public void onSessionProgressChanged(PackageInstallerSession session, float progress) &#123; mCallbacks.notifySessionProgressChanged(session.sessionId, session.userId, progress); &#125; // 处理事务完成的消息！ public void onSessionFinished(final PackageInstallerSession session, boolean success) &#123; mCallbacks.notifySessionFinished(session.sessionId, session.userId, success); mInstallHandler.post(new Runnable() &#123; @Override public void run() &#123; synchronized (mSessions) &#123; // 将已经完成的消息移除 mSessions，加入到 mHistoricalSessions 中！ mSessions.remove(session.sessionId); mHistoricalSessions.put(session.sessionId, session); final File appIconFile = buildAppIconFile(session.sessionId); if (appIconFile.exists()) &#123; appIconFile.delete(); &#125; writeSessionsLocked(); // 更新 sessions 变化到本地文件中！ &#125; &#125; &#125;); &#125; public void onSessionPrepared(PackageInstallerSession session) &#123; // We prepared the destination to write into; we want to persist // this, but it's not critical enough to block for. writeSessionsAsync(); // 将 sessions 数据写到本地文件中！ &#125; public void onSessionSealedBlocking(PackageInstallerSession session) &#123; // It's very important that we block until we've recorded the // session as being sealed, since we never want to allow mutation // after sealing. synchronized (mSessions) &#123; writeSessionsLocked(); &#125; &#125;&#125; 关于 Session，我们想讲这么多，在分析安装的过程中，我们在深入分析，我们只需要知道，每一个安装任务都会封装成一个 Session 即可！ 3 new PackageManagerInternalImpl - 系统进程内部调用在 pms 的构造器结尾，调用了 LocalServices，将一个 PackageManagerInternalImpl 对象注册到本地服务管理中，这种方式用于系统进程内部服务间的通信，因为不需要使用 Binder 线程，所以效率更高！ 12//【3】将自身加入本地服务管理中，方便系统自身访问！LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); LocalServices 内部保存着一个静态的 ArrayMap 来保存所有注册到其内部的服务： 12private static final ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects = new ArrayMap&lt;Class&lt;?&gt;, Object&gt;(); 通过其内部的 addService 方法，将系统服务添加进来！12345678public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123; synchronized (sLocalServiceObjects) &#123; if (sLocalServiceObjects.containsKey(type)) &#123; throw new IllegalStateException(\"Overriding service registration\"); &#125; sLocalServiceObjects.put(type, service); &#125;&#125; PackageManagerInternalImpl 对象继承了 PackageManagerInternal 并实现了其抽象方法，其内部有多个方案来供其他服务访问 PMS： 3.1 注册系统服务 provider后续会有其他的系统服务启动，他们会把自身的 provider 注册进入 PMS，后续 PMS 会授予他们权限！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private class PackageManagerInternalImpl extends PackageManagerInternal &#123; // 创建 LocationManagerService 时会调用该方法，LocationManagerService 会创建一个 PackagesProvider 对象！ // 用于封装其 provider name！ @Override public void setLocationPackagesProvider(PackagesProvider provider) &#123; synchronized (mPackages) &#123; // 保存到 DefaultPermissionGrantPolicy.mLocationPackagesProvider 变量中！ mDefaultPermissionPolicy.setLocationPackagesProviderLPw(provider); &#125; &#125; // 创建 VoiceInteractionManagerService 时会调用该方法！ @Override public void setVoiceInteractionPackagesProvider(PackagesProvider provider) &#123; synchronized (mPackages) &#123; // 保存到 DefaultPermissionGrantPolicy.mVoiceInteractionPackagesProvider 变量中！ mDefaultPermissionPolicy.setVoiceInteractionPackagesProviderLPw(provider); &#125; &#125; // 创建 TelecomLoaderService 时会调用该方法，TelecomLoaderService 创建时, // 会调用 registerDefaultAppProviders，该方法会触发注册 provider！ @Override public void setSmsAppPackagesProvider(PackagesProvider provider) &#123; synchronized (mPackages) &#123; // 保存到 DefaultPermissionGrantPolicy.mSmsAppPackagesProvider 变量中！ mDefaultPermissionPolicy.setSmsAppPackagesProviderLPw(provider); &#125; &#125; // 创建 TelecomLoaderService 时会调用该方法，同上！ @Override public void setDialerAppPackagesProvider(PackagesProvider provider) &#123; synchronized (mPackages) &#123; // 保存到 DefaultPermissionGrantPolicy.mDialerAppPackagesProvider 变量中！ mDefaultPermissionPolicy.setDialerAppPackagesProviderLPw(provider); &#125; &#125; // 创建 TelecomLoaderService 时会调用该方法，同上！ @Override public void setSimCallManagerPackagesProvider(PackagesProvider provider) &#123; synchronized (mPackages) &#123; // 保存到 DefaultPermissionGrantPolicy.mSimCallManagerPackagesProvider 变量中！ mDefaultPermissionPolicy.setSimCallManagerPackagesProviderLPw(provider); &#125; &#125; // 创建 ContentService 时会调用该方法，注册 provider！ @Override public void setSyncAdapterPackagesprovider(SyncAdapterPackagesProvider provider) &#123; synchronized (mPackages) &#123; // 保存到 DefaultPermissionGrantPolicy.mSyncAdapterPackagesProvider 变量中！ mDefaultPermissionPolicy.setSyncAdapterPackagesProviderLPw(provider); &#125; &#125; ... ... ... ...&#125; 上面的内容，后面会遇到！ 3.2 授予默认权限接口123456789101112131415161718192021222324252627282930private class PackageManagerInternalImpl extends PackageManagerInternal &#123; ... ... ... ... @Override public void grantDefaultPermissionsToDefaultSmsApp(String packageName, int userId) &#123; synchronized (mPackages) &#123; mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSmsAppLPr( packageName, userId); &#125; &#125; @Override public void grantDefaultPermissionsToDefaultDialerApp(String packageName, int userId) &#123; synchronized (mPackages) &#123; mSettings.setDefaultDialerPackageNameLPw(packageName, userId); mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultDialerAppLPr( packageName, userId); &#125; &#125; @Override public void grantDefaultPermissionsToDefaultSimCallManager(String packageName, int userId) &#123; synchronized (mPackages) &#123; mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSimCallManagerLPr( packageName, userId); &#125; &#125; ... ... ... ...&#125; 以上方法都是在 TelecomLoaderService 服务中调用的！ 4 PackageMS.updatePackagesIfNeeded - 执行 Odex 优化在 SystemServer.startOtherServices 中，会调用 updatePackagesIfNeeded 更新 package！ 123456789if (!mOnlyCore) &#123; Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"UpdatePackagesIfNeeded\"); try &#123; mPackageManagerService.updatePackagesIfNeeded(); &#125; catch (Throwable e) &#123; reportWtf(\"update packages\", e); &#125; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);&#125; 我们去看看 updatePackagesIfNeeded 方法，该方法的主要作用是对应用进行 Odex 优化！1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void updatePackagesIfNeeded() &#123; enforceSystemOrRoot(\"Only the system can request package update\"); //【1】是否是通过 OTA 升级的！ boolean causeUpgrade = isUpgrade(); //【2】是否是第一次启动，包括出场第一次开机，factory reset，如果是从 Android N 升级上来的，也看作是第一次启动！ boolean causeFirstBoot = isFirstBoot() || mIsPreNUpgrade; // We need to re-extract after a pruned cache, as AoT-ed files will be out of date. boolean causePrunedCache = VMRuntime.didPruneDalvikCache(); //【1】如果不是上面几种情况，不处理！ if (!causeUpgrade &amp;&amp; !causeFirstBoot &amp;&amp; !causePrunedCache) &#123; return; &#125; //【4.1】获得要执行 odex 优化的 package！ List&lt;PackageParser.Package&gt; pkgs; synchronized (mPackages) &#123; pkgs = PackageManagerServiceUtils.getPackagesForDexopt(mPackages.values(), this); &#125; final long startTime = System.nanoTime(); //【4.2】执行 odex 优化！ final int[] stats = performDexOptUpgrade(pkgs, mIsPreNUpgrade /* showDialog */, getCompilerFilterForReason(causeFirstBoot ? REASON_FIRST_BOOT : REASON_BOOT)); final int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime); //【4】记录执行结果！ MetricsLogger.histogram(mContext, \"opt_dialog_num_dexopted\", stats[0]); MetricsLogger.histogram(mContext, \"opt_dialog_num_skipped\", stats[1]); MetricsLogger.histogram(mContext, \"opt_dialog_num_failed\", stats[2]); MetricsLogger.histogram(mContext, \"opt_dialog_num_total\", getOptimizablePackages().size()); MetricsLogger.histogram(mContext, \"opt_dialog_time_s\", elapsedTimeSeconds);&#125; 整个过程就是收集所有的 Pacakge，然后执行 Odex 优化！ 可以看到，只有 4.1 PackageManagerServiceUtils.getPackagesForDexoptgetPackagesForDexopt 会对系统中所有扫描到的 package 进行排序！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public static List&lt;PackageParser.Package&gt; getPackagesForDexopt( Collection&lt;PackageParser.Package&gt; packages, PackageManagerService packageManagerService) &#123; //【1】result 用于保存排序后的所有结果，remainingPkgs 用于保存没有排序的 package // sortTemp 用于缓存排序的结果！ ArrayList&lt;PackageParser.Package&gt; remainingPkgs = new ArrayList&lt;&gt;(packages); // 初始化 remainingPkgs！ LinkedList&lt;PackageParser.Package&gt; result = new LinkedList&lt;&gt;(); ArrayList&lt;PackageParser.Package&gt; sortTemp = new ArrayList&lt;&gt;(remainingPkgs.size()); //【4.1.1】调用 applyPackageFilter 设置优先级，然后排序！ //【4.1.1.1】开始第一阶段排序，收集那些 pkg.coreApp 为 true 的应用，进行排序，然后添加到 result 中！ applyPackageFilter((pkg) -&gt; pkg.coreApp, result, remainingPkgs, sortTemp, packageManagerService); //【4.1.1.2】开始第二个阶段排序，条件是是否监听 ACTION_PRE_BOOT_COMPLETED 这个广播！ // 手机监听该广播的 package，进行排序，结果添加到 result 中！ Intent intent = new Intent(Intent.ACTION_PRE_BOOT_COMPLETED); final ArraySet&lt;String&gt; pkgNames = getPackageNamesForIntent(intent, UserHandle.USER_SYSTEM); applyPackageFilter((pkg) -&gt; pkgNames.contains(pkg.packageName), result, remainingPkgs, sortTemp, packageManagerService); //【4.1.1.3】开始第三个阶段排序，条件是 package 是否被其他应用加载或使用，排序后结果添加到 result 中！ applyPackageFilter((pkg) -&gt; PackageDexOptimizer.isUsedByOtherApps(pkg), result, remainingPkgs, sortTemp, packageManagerService); //【2】处理剩余的仍然没有被处理的 Package！ Predicate&lt;PackageParser.Package&gt; remainingPredicate; if (!remainingPkgs.isEmpty() &amp;&amp; packageManagerService.isHistoricalPackageUsageAvailable()) &#123; if (DEBUG_DEXOPT) &#123; Log.i(TAG, \"Looking at historical package use\"); &#125; //【1】对剩余的 package 进行比较，找到最新使用时间最晚的那个 package！ PackageParser.Package lastUsed = Collections.max(remainingPkgs, (pkg1, pkg2) -&gt; Long.compare(pkg1.getLatestForegroundPackageUseTimeInMills(), pkg2.getLatestForegroundPackageUseTimeInMills())); if (DEBUG_DEXOPT) &#123; Log.i(TAG, \"Taking package \" + lastUsed.packageName + \" as reference in time use\"); &#125; long estimatedPreviousSystemUseTime = lastUsed.getLatestForegroundPackageUseTimeInMills(); //【2】确定过滤器 if (estimatedPreviousSystemUseTime != 0) &#123; //【2.1】剩余 package 的排序条件为：该应用最新使用时间距离安装超过了 7 天！ final long cutoffTime = estimatedPreviousSystemUseTime - SEVEN_DAYS_IN_MILLISECONDS; remainingPredicate = (pkg) -&gt; pkg.getLatestForegroundPackageUseTimeInMills() &gt;= cutoffTime; &#125; else &#123; //【2.2】剩余 package 的排序条件为 true，即：不过滤，处理剩下的所有 package！ remainingPredicate = (pkg) -&gt; true; &#125; // 先对剩余的 package 进行一次时间排序，目的是使用！ sortPackagesByUsageDate(remainingPkgs, packageManagerService); &#125; else &#123; //【2.3】剩余 package 的排序条件为 true，即：不过滤，处理剩下的所有 package remainingPredicate = (pkg) -&gt; true; &#125; //【4.1.1.4】最后一次排序，处理剩余的仍然没有被处理的 Package，满足上面条件的 package！！ applyPackageFilter(remainingPredicate, result, remainingPkgs, sortTemp, packageManagerService); if (DEBUG_DEXOPT) &#123; Log.i(TAG, \"Packages to be dexopted: \" + packagesToString(result)); Log.i(TAG, \"Packages skipped from dexopt: \" + packagesToString(remainingPkgs)); &#125; //【3】返回需要做 Odex 的排序过的 Package！ return result;&#125; 对于 getPackagesForDexopt 方法的分析就到这里！ 4.1.1 PackageManagerServiceUtils.applyPackageFilterapplyPackageFilter 方法通过传入的过滤条件，收集满足条件的 package，对其进行排序！123456789101112131415161718192021222324252627282930313233private static void applyPackageFilter(Predicate&lt;PackageParser.Package&gt; filter, Collection&lt;PackageParser.Package&gt; result, Collection&lt;PackageParser.Package&gt; packages, @NonNull List&lt;PackageParser.Package&gt; sortTemp, PackageManagerService packageManagerService) &#123; //【1】收集那些满足 filter 设定的条件的 package，添加到 sortTemp！ for (PackageParser.Package pkg : packages) &#123; if (filter.test(pkg)) &#123; sortTemp.add(pkg); &#125; &#125; //【4.1.1.1】对 sortTemp 中的 package 进行排序！ sortPackagesByUsageDate(sortTemp, packageManagerService); //【2】从 packages （就是 remainingPkgs）中移除 sortTemp 包含的 pacakge！ packages.removeAll(sortTemp); //【3】将 sortTemp 中排好序的所有 package，添加到 result 中！ for (PackageParser.Package pkg : sortTemp) &#123; result.add(pkg); //【3.1】找到和该 pkg 共享非系统库文件的 package，也添加到 result 中！ // 同时从 packages （就是 remainingPkgs）中也移除这部分 package！ Collection&lt;PackageParser.Package&gt; deps = packageManagerService.findSharedNonSystemLibraries(pkg); if (!deps.isEmpty()) &#123; deps.removeAll(result); result.addAll(deps); packages.removeAll(deps); &#125; &#125; sortTemp.clear();&#125; 过程很简单不多说了！ 4.1.1.1 PackageManagerServiceUtils.sortPackagesByUsageDate该方法的作用是对 package 列表进行排序！12345678910public static void sortPackagesByUsageDate(List&lt;PackageParser.Package&gt; pkgs, PackageManagerService packageManagerService) &#123; if (!packageManagerService.isHistoricalPackageUsageAvailable()) &#123; return; &#125; //【1】排序依据是：package 在前台使用是时间！ Collections.sort(pkgs, (pkg1, pkg2) -&gt; Long.compare(pkg2.getLatestForegroundPackageUseTimeInMills(), pkg1.getLatestForegroundPackageUseTimeInMills()));&#125; 4.2 PackageMS.performDexOptUpgradeperformDexOptUpgrade 用于执行 Odex 优化操作！ 对于参数 showDialog：传入的是 mIsPreNUpgrade，表示是否是从 N 升级上来的！ 对于参数 compilerFilter：传入的是 getCompilerFilterForReason(causeFirstBoot ? REASON_FIRST_BOOT : REASON_BOOT)!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private int[] performDexOptUpgrade(List&lt;PackageParser.Package&gt; pkgs, boolean showDialog, String compilerFilter) &#123; int numberOfPackagesVisited = 0; int numberOfPackagesOptimized = 0; int numberOfPackagesSkipped = 0; int numberOfPackagesFailed = 0; final int numberOfPackagesToDexopt = pkgs.size(); //【All】遍历所有要执行 Odex 的所有 Package！ for (PackageParser.Package pkg : pkgs) &#123; numberOfPackagesVisited++; //【1】跳过那些不能做 Odex 优化的 Package！ if (!PackageDexOptimizer.canOptimizePackage(pkg)) &#123; if (DEBUG_DEXOPT) &#123; Log.i(TAG, \"Skipping update of of non-optimizable app \" + pkg.packageName); &#125; numberOfPackagesSkipped++; continue; &#125; if (DEBUG_DEXOPT) &#123; Log.i(TAG, \"Updating app \" + numberOfPackagesVisited + \" of \" + numberOfPackagesToDexopt + \": \" + pkg.packageName); &#125; //【2】在做 Odex 优化的时候，是否显示界面进行提示！ if (showDialog) &#123; try &#123; ActivityManagerNative.getDefault().showBootMessage( mContext.getResources().getString(R.string.android_upgrading_apk, numberOfPackagesVisited, numberOfPackagesToDexopt), true); &#125; catch (RemoteException e) &#123; &#125; synchronized (mPackages) &#123; mDexOptDialogShown = true; &#125; &#125; // If the OTA updates a system app which was previously preopted to a non-preopted state // the app might end up being verified at runtime. That's because by default the apps // are verify-profile but for preopted apps there's no profile. // Do a hacky check to ensure that if we have no profiles (a reasonable indication // that before the OTA the app was preopted) the app gets compiled with a non-profile // filter (by default interpret-only). // Note that at this stage unused apps are already filtered. //【3】设置执行 Odex 优化的时候的 compilerFilter 类型！ if (isSystemApp(pkg) &amp;&amp; DexFile.isProfileGuidedCompilerFilter(compilerFilter) &amp;&amp; !Environment.getReferenceProfile(pkg.packageName).exists()) &#123; compilerFilter = getNonProfileGuidedCompilerFilter(compilerFilter); &#125; // checkProfiles is false to avoid merging profiles during boot which // might interfere with background compilation (b/28612421). // Unfortunately this will also means that \"pm.dexopt.boot=speed-profile\" will // behave differently than \"pm.dexopt.bg-dexopt=speed-profile\" but that's a // trade-off worth doing to save boot time work. //【4.2.2】执行 Odex int dexOptStatus = performDexOptTraced(pkg.packageName, false /* checkProfiles */, compilerFilter, false /* force */); switch (dexOptStatus) &#123; case PackageDexOptimizer.DEX_OPT_PERFORMED: numberOfPackagesOptimized++; break; case PackageDexOptimizer.DEX_OPT_SKIPPED: numberOfPackagesSkipped++; break; case PackageDexOptimizer.DEX_OPT_FAILED: numberOfPackagesFailed++; break; default: Log.e(TAG, \"Unexpected dexopt return code \" + dexOptStatus); break; &#125; &#125; return new int[] &#123; numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed &#125;;&#125; 4.2.1 PackageManagerServiceCompilerMapping.getCompilerFilterForReason这里调用了 getCompilerFilterForReason，根据执行的原因选择合适的 compileFilter：1234public static String getCompilerFilterForReason(int reason) &#123; //【4.2.1.1】通过 reason 来获得 compileFilter return getAndCheckValidity(reason);&#125; 如果是 first boot，则为 REASON_FIRST_BOOT，否则为 REASON_BOOT！ 12345678910// Compilation reasons.public static final int REASON_FIRST_BOOT = 0;public static final int REASON_BOOT = 1;public static final int REASON_INSTALL = 2;public static final int REASON_BACKGROUND_DEXOPT = 3;public static final int REASON_AB_OTA = 4;public static final int REASON_NON_SYSTEM_LIBRARY = 5;public static final int REASON_SHARED_APK = 6;public static final int REASON_FORCED_DEXOPT = 7;public static final int REASON_CORE_APP = 8; 对于 reason 的取值如上，其实通过名字，很容易就能看到，每种 reason 的使用类型！ 4.2.1.1 PackageManagerServiceCompilerMapping.getAndCheckValidity检查 reason 对应的有效性！ 123456789101112131415161718192021222324private static String getAndCheckValidity(int reason) &#123; //【1】校验 reason 对应的 compileFilter 是否有效！ String sysPropValue = SystemProperties.get(getSystemPropertyName(reason)); if (sysPropValue == null || sysPropValue.isEmpty() || !DexFile.isValidCompilerFilter(sysPropValue)) &#123; //【1.1】这里会通过 DexFile.isValidCompilerFilter 校验！ throw new IllegalStateException(\"Value \\\"\" + sysPropValue +\"\\\" not valid \" + \"(reason \" + REASON_STRINGS[reason] + \")\"); &#125; //【2】如果 reason 是 REASON_SHARED_APK 和 REASON_FORCED_DEXOPT，还要校验下其是否映射到一个 // profile-guided filter！ switch (reason) &#123; case PackageManagerService.REASON_SHARED_APK: case PackageManagerService.REASON_FORCED_DEXOPT: if (DexFile.isProfileGuidedCompilerFilter(sysPropValue)) &#123; throw new IllegalStateException(\"\\\"\" + sysPropValue + \"\\\" is profile-guided, \" + \"but not allowed for \" + REASON_STRINGS[reason]); &#125; break; &#125; //【3】返回我们需要的 compileFilter！ return sysPropValue;&#125; 每一个有效的 reason 都会对应一个系统属性名，PackageManagerServiceCompilerMapping 内置了如下的系统属性名关键字：1234static final String REASON_STRINGS[] = &#123; \"first-boot\", \"boot\", \"install\", \"bg-dexopt\", \"ab-ota\", \"nsys-library\", \"shared-apk\", \"forced-dexopt\", \"core-app\"&#125;; 如果是 REASON_FIRST_BOOT，对应的关键字就是 “first-boot”，其他的以此类推！1234567private static String getSystemPropertyName(int reason) &#123; if (reason &lt; 0 || reason &gt;= REASON_STRINGS.length) &#123; throw new IllegalArgumentException(\"reason \" + reason + \" invalid\"); &#125; return \"pm.dexopt.\" + REASON_STRINGS[reason];&#125; 然后，我们就可以获得系统属性名了，格式为：pm.dexopt.REASON_STRINGS[reason]，比如对于 REASON_FIRST_BOOT，对应的系统属性名为 ：pm.dexopt.first-boot！ 然后我们通过该系统属性名，获得对应的属性 compileFilter！ 4.2.2 PackageMS.performDexOptTraced执行 Odex 优化操作！ 1234567891011private int performDexOptTraced(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"dexopt\"); try &#123; //【4.2.2.1】执行 Odex 优化！ return performDexOptInternal(packageName, checkProfiles, targetCompilerFilter, force); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 继续调用 performDexOptTraced 方法！ 4.2.2.1 PackageMS.performDexOptTraced12345678910111213141516171819202122232425private int performDexOptInternal(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force) &#123; PackageParser.Package p; synchronized (mPackages) &#123; //【1】获得 package 对应的数据对象 PackageParser.Package！ // 找不到，返回 PackageDexOptimizer.DEX_OPT_FAILED！ p = mPackages.get(packageName); if (p == null) &#123; // Package could not be found. Report failure. return PackageDexOptimizer.DEX_OPT_FAILED; &#125; mPackageUsage.maybeWriteAsync(mPackages); mCompilerStats.maybeWriteAsync(); &#125; long callingId = Binder.clearCallingIdentity(); try &#123; synchronized (mInstallLock) &#123; //【4.2.2.2】调用 performDexOptInternalWithDependenciesLI 继续执行！ return performDexOptInternalWithDependenciesLI(p, checkProfiles, targetCompilerFilter, force); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125;&#125; 继续调用 performDexOptInternalWithDependenciesLI 4.2.2.2 PackageMS.performDexOptInternalWithDependenciesLI根据前面的参数传递：checkProfiles 的值为 false；force 的值为 false：1234567891011121314151617181920212223242526private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, boolean checkProfiles, String targetCompilerFilter, boolean force) &#123; //【1】根据参数 force 的值，选择不同的 PackageDexOptimizer，绝大多数情况下，选择的是 // PackageDexOptimizer！ PackageDexOptimizer pdo = force ? new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(mPackageDexOptimizer) : mPackageDexOptimizer; //【2】先对该 package 所依赖的共享库所属 pacakge 进行 Odex 优化！ Collection&lt;PackageParser.Package&gt; deps = findSharedNonSystemLibraries(p); final String[] instructionSets = getAppDexInstructionSets(p.applicationInfo); if (!deps.isEmpty()) &#123; for (PackageParser.Package depPackage : deps) &#123; // TODO: Analyze and investigate if we (should) profile libraries. // Currently this will do a full compilation of the library by default. pdo.performDexOpt(depPackage, null /* sharedLibraries */, instructionSets, false /* checkProfiles */, getCompilerFilterForReason(REASON_NON_SYSTEM_LIBRARY), getOrCreateCompilerPackageStats(depPackage)); &#125; &#125; //【4.2.2.3】对该 package 进行 Odex 优化！ return pdo.performDexOpt(p, p.usesLibraryFiles, instructionSets, checkProfiles, targetCompilerFilter, getOrCreateCompilerPackageStats(p));&#125; 如果 force 的值为 false，那么选择的是 mPackageDexOptimizer，mPackageDexOptimizer 我们都知道，在 PackageManagerService 的初始化的时候，会创建对应的 PackageDexOptimizer 对象！ 绝大数情况，force 都是 false；为 true 的情况很少使用，主要用于 cmd test！ 当然，最终调用了：1PackageDexOptimizer.performDexOpt performDexOpt 方法进行 Odex 优化！ 4.2.2.3 PackageDexOptimizer.performDexOpt123456789101112131415161718192021int performDexOpt(PackageParser.Package pkg, String[] sharedLibraries, String[] instructionSets, boolean checkProfiles, String targetCompilationFilter, CompilerStats.PackageStats packageStats) &#123; synchronized (mInstallLock) &#123; //【1】申请 WakeLock！ final boolean useLock = mSystemReady; if (useLock) &#123; mDexoptWakeLock.setWorkSource(new WorkSource(pkg.applicationInfo.uid)); mDexoptWakeLock.acquire(); &#125; try &#123; //【4.2.2.3.1】调用 performDexOptLI 执行 Odex 优化！ return performDexOptLI(pkg, sharedLibraries, instructionSets, checkProfiles, targetCompilationFilter, packageStats); &#125; finally &#123; if (useLock) &#123; mDexoptWakeLock.release(); &#125; &#125; &#125;&#125; 4.2.2.3.1 PackageDexOptimizer.performDexOptLIperformDexOptLI 是执行 Odex 的重要方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142private int performDexOptLI(PackageParser.Package pkg, String[] sharedLibraries, String[] targetInstructionSets, boolean checkProfiles, String targetCompilerFilter, CompilerStats.PackageStats packageStats) &#123; final String[] instructionSets = targetInstructionSets != null ? targetInstructionSets : getAppDexInstructionSets(pkg.applicationInfo); //【1】如果该 package 没有 ApplicationInfo.FLAG_HAS_CODE 该标志， // 就不能执行 Odex 优化，返回 DEX_OPT_SKIPPED！ if (!canOptimizePackage(pkg)) &#123; return DEX_OPT_SKIPPED; &#125; //【2】获得该应用的 apk 文件所在路径！ final List&lt;String&gt; paths = pkg.getAllCodePathsExcludingResourceOnly(); final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid); //【3】如果该应用被其他的应用使用，不能用 profile-guided boolean isProfileGuidedFilter = DexFile.isProfileGuidedCompilerFilter(targetCompilerFilter); if (isProfileGuidedFilter &amp;&amp; isUsedByOtherApps(pkg)) &#123; checkProfiles = false; targetCompilerFilter = getNonProfileGuidedCompilerFilter(targetCompilerFilter); if (DexFile.isProfileGuidedCompilerFilter(targetCompilerFilter)) &#123; throw new IllegalStateException(targetCompilerFilter); &#125; isProfileGuidedFilter = false; &#125; // If we're asked to take profile updates into account, check now. boolean newProfile = false; if (checkProfiles &amp;&amp; isProfileGuidedFilter) &#123; // Merge profiles, see if we need to do anything. try &#123; newProfile = mInstaller.mergeProfiles(sharedGid, pkg.packageName); &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Failed to merge profiles\", e); &#125; &#125; final boolean vmSafeMode = (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_VM_SAFE_MODE) != 0; final boolean debuggable = (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; boolean performedDexOpt = false; boolean successfulDexOpt = true; //【5】处理所有指令集下的 Odex 优化！ final String[] dexCodeInstructionSets = getDexCodeInstructionSets(instructionSets); for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (String path : paths) &#123; int dexoptNeeded; try &#123; //【5.1】判断是否有必要做 Odex 优化，结果保存到 dexoptNeeded！ dexoptNeeded = DexFile.getDexOptNeeded(path, dexCodeInstructionSet, targetCompilerFilter, newProfile); &#125; catch (IOException ioe) &#123; Slog.w(TAG, \"IOException reading apk: \" + path, ioe); return DEX_OPT_FAILED; &#125; dexoptNeeded = adjustDexoptNeeded(dexoptNeeded); // 返回自身！ if (PackageManagerService.DEBUG_DEXOPT) &#123; Log.i(TAG, \"DexoptNeeded for \" + path + \"@\" + targetCompilerFilter + \" is \" + dexoptNeeded); &#125; final String dexoptType; String oatDir = null; //【5.2】处理 dexoptNeeded 结果！ switch (dexoptNeeded) &#123; case DexFile.NO_DEXOPT_NEEDED: // 如果是 NO_DEXOPT_NEEDED，不需要优化，跳过； continue; case DexFile.DEX2OAT_NEEDED: // 如果是 DEX2OAT_NEEDED，需要优化，类型为 dex2oat！ //【4.2.2.3.1.1】并创建 oat 目标目录！ dexoptType = \"dex2oat\"; oatDir = createOatDirIfSupported(pkg, dexCodeInstructionSet); break; case DexFile.PATCHOAT_NEEDED: // 如果是 PATCHOAT_NEEDED，需要优化，类型为 patchoat！ dexoptType = \"patchoat\"; break; case DexFile.SELF_PATCHOAT_NEEDED: // 如果是 SELF_PATCHOAT_NEEDED，需要优化，类型为 self patchoat！ dexoptType = \"self patchoat\"; break; default: throw new IllegalStateException(\"Invalid dexopt:\" + dexoptNeeded); &#125; String sharedLibrariesPath = null; if (sharedLibraries != null &amp;&amp; sharedLibraries.length != 0) &#123; StringBuilder sb = new StringBuilder(); for (String lib : sharedLibraries) &#123; if (sb.length() != 0) &#123; sb.append(\":\"); &#125; sb.append(lib); &#125; sharedLibrariesPath = sb.toString(); &#125; Log.i(TAG, \"Running dexopt (\" + dexoptType + \") on: \" + path + \" pkg=\" + pkg.applicationInfo.packageName + \" isa=\" + dexCodeInstructionSet + \" vmSafeMode=\" + vmSafeMode + \" debuggable=\" + debuggable + \" target-filter=\" + targetCompilerFilter + \" oatDir = \" + oatDir + \" sharedLibraries=\" + sharedLibrariesPath); // Profile guide compiled oat files should not be public. final boolean isPublic = !pkg.isForwardLocked() &amp;&amp; !isProfileGuidedFilter; final int profileFlag = isProfileGuidedFilter ? DEXOPT_PROFILE_GUIDED : 0; final int dexFlags = adjustDexoptFlags( ( isPublic ? DEXOPT_PUBLIC : 0) | (vmSafeMode ? DEXOPT_SAFEMODE : 0) | (debuggable ? DEXOPT_DEBUGGABLE : 0) | profileFlag | DEXOPT_BOOTCOMPLETE); try &#123; long startTime = System.currentTimeMillis(); //【5.3】执行 Odex 优化！ mInstaller.dexopt(path, sharedGid, pkg.packageName, dexCodeInstructionSet, dexoptNeeded, oatDir, dexFlags, targetCompilerFilter, pkg.volumeUuid, sharedLibrariesPath); performedDexOpt = true; if (packageStats != null) &#123; long endTime = System.currentTimeMillis(); packageStats.setCompileTime(path, (int)(endTime - startTime)); &#125; &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Failed to dexopt\", e); successfulDexOpt = false; // 如果有异常，successfulDexOpt 为 false！ &#125; &#125; &#125; //【6】处理 Odex 优化结果，如果 successfulDexOpt 为 true，说明执行 Odex 的过程中没有发生错误！ // 然后还要处理 performedDexOpt，如果为 true，表示 Odex 优化成功，返回 DEX_OPT_PERFORMED！ // 否则，直接返回 DEX_OPT_SKIPPED 表示无需 Odex 优化，直接跳过！ if (successfulDexOpt) &#123; return performedDexOpt ? DEX_OPT_PERFORMED : DEX_OPT_SKIPPED; &#125; else &#123; return DEX_OPT_FAILED; &#125;&#125; 整个流程很清晰，不多说！ 4.2.2.3.1.1 PackageDexOptimizer.createOatDirIfSupportedcreateOatDirIfSupported 方法用于创建 oat 目录！12345678910111213141516171819202122@Nullableprivate String createOatDirIfSupported(PackageParser.Package pkg, String dexInstructionSet) &#123; //【1】如果应用不能有 oat 文件，返回 null！ if (!pkg.canHaveOatDir()) &#123; return null; &#125; File codePath = new File(pkg.codePath); if (codePath.isDirectory()) &#123; //【2】创建 oat 目录！ File oatDir = getOatDir(codePath); try &#123; // 这里的 oatDir 为 /data/app/&lt;packageName&gt;/oat // 而 dexInstructionSet 为 arm/arm64 mInstaller.createOatDir(oatDir.getAbsolutePath(), dexInstructionSet); &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Failed to create oat dir\", e); return null; &#125; return oatDir.getAbsolutePath(); &#125; return null;&#125; PackageParser.Package.canHaveOatDir 方法用于判断该应用是否能够有 oat 目录！1234567public boolean canHaveOatDir() &#123; // 要能有 oat 目录，必须要满足 2 个条件； // 1、不是 system app，或者是被更新过的 system app； // 2、同时不能是 forward-locked app，并且不能被安装在 external 上! return (!isSystemApp() || isUpdatedSystemApp()) &amp;&amp; !isForwardLocked() &amp;&amp; !applicationInfo.isExternalAsec();&#125; 5 PackageMS.systemReady - 进入最终阶段在 SystemServer.startOtherServices 中，最后，会调用 systemReady 方法，进入 PackageManagerService 启动的最终阶段！123456Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;MakePackageManagerServiceReady&quot;);try &#123; mPackageManagerService.systemReady();&#125; catch (Throwable e) &#123; reportWtf(&quot;making Package Manager Service ready&quot;, e);&#125; 当系统准备完成后，会调用到 PackageManagerService 的 systemReady 方法！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120@Overridepublic void systemReady() &#123; mSystemReady = true; // Disable any carrier apps. We do this very early in boot to prevent the apps from being // disabled after already being started. CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), this, mContext.getContentResolver(), UserHandle.USER_SYSTEM); // Read the compatibilty setting when the system is ready. boolean compatibilityModeEnabled = android.provider.Settings.Global.getInt( mContext.getContentResolver(), android.provider.Settings.Global.COMPATIBILITY_MODE, 1) == 1; PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled); if (DEBUG_SETTINGS) &#123; Log.d(TAG, \"compatibility mode:\" + compatibilityModeEnabled); &#125; //【1】该集合表示需要默认授予运行时权限的 userId！ int[] grantPermissionsUserIds = EMPTY_INT_ARRAY; synchronized (mPackages) &#123; //【1】移除那些已经不存在的 preferred activity ArrayList&lt;PreferredActivity&gt; removed = new ArrayList&lt;PreferredActivity&gt;(); for (int i=0; i&lt;mSettings.mPreferredActivities.size(); i++) &#123; PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i); removed.clear(); for (PreferredActivity pa : pir.filterSet()) &#123; if (mActivities.mActivities.get(pa.mPref.mComponent) == null) &#123; removed.add(pa); &#125; &#125; // 移除这些不存在的 preferred activity 在系统中的关联！ if (removed.size() &gt; 0) &#123; for (int r=0; r&lt;removed.size(); r++) &#123; PreferredActivity pa = removed.get(r); Slog.w(TAG, \"Removing dangling preferred activity: \" + pa.mPref.mComponent); pir.removeFilter(pa); &#125; // 更新偏好设置！ mSettings.writePackageRestrictionsLPr( mSettings.mPreferredActivities.keyAt(i)); &#125; &#125; // 返回需要授予默认权限的 userId 集合！，其实就是访问 mDefaultPermissionsGranted 在指定的 userId 下的值 // 如果指定 userId 返回 false，表示发生了系统升级，那么我们会执行默认运行时权限授予！！ for (int userId : UserManagerService.getInstance().getUserIds()) &#123; if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) &#123; grantPermissionsUserIds = ArrayUtils.appendInt( grantPermissionsUserIds, userId); &#125; &#125; &#125; // 通知 userManager 系统准备完毕！ sUserManager.systemReady(); //【5.1】执行默认授予运行时权限的操作！ for (int userId : grantPermissionsUserIds) &#123; mDefaultPermissionPolicy.grantDefaultPermissions(userId); &#125; // 如果没有默认授予运行时权限给指定的 userId，那么我们会直接读取 default-permissions 目录中的文件 // 初始化 mGrantExceptions，和上面的过程类似，不关注！ if (grantPermissionsUserIds == EMPTY_INT_ARRAY) &#123; // 该方法会发送 MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS 消息给内部的 Handler // 然后会调用：readDefaultPermissionExceptionsLPw 方法！ mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions(); &#125; // 处理 mPostSystemReadyMessages 中的 START_CLEANING_PACKAGE 消息，这些消息是在 delete/remove package // 的时候添加进来的！！ if (mPostSystemReadyMessages != null) &#123; for (Message msg : mPostSystemReadyMessages) &#123; msg.sendToTarget(); &#125; mPostSystemReadyMessages = null; &#125; // 注册存储监听器，持续监听存储变化！ final StorageManager storage = mContext.getSystemService(StorageManager.class); storage.registerListener(mStorageListener); // 通知 PackageInstallerService 和 PackageDexOptimizer 系统准备完成！ // PackageDexOptimizer 是用于执行 odex 优化的，后续我们会看到！ mInstallerService.systemReady(); mPackageDexOptimizer.systemReady(); MountServiceInternal mountServiceInternal = LocalServices.getService( MountServiceInternal.class); mountServiceInternal.addExternalStoragePolicy( new MountServiceInternal.ExternalStorageMountPolicy() &#123; @Override public int getMountMode(int uid, String packageName) &#123; if (Process.isIsolated(uid)) &#123; return Zygote.MOUNT_EXTERNAL_NONE; &#125; if (checkUidPermission(WRITE_MEDIA_STORAGE, uid) == PERMISSION_GRANTED) &#123; return Zygote.MOUNT_EXTERNAL_DEFAULT; &#125; if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) &#123; return Zygote.MOUNT_EXTERNAL_DEFAULT; &#125; if (checkUidPermission(WRITE_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) &#123; return Zygote.MOUNT_EXTERNAL_READ; &#125; return Zygote.MOUNT_EXTERNAL_WRITE; &#125; @Override public boolean hasExternalStorage(int uid, String packageName) &#123; return true; &#125; &#125;); //【5.2】清楚哪些无效不用的用户和应用！ reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL); reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL);&#125; 5.1 DefaultPermissionGrantPolicy.grantDefaultPermissions - 默认运行时权限授予前面有讲过 DefaultPermissionGrantPolicy 用来处理默认授予系统应用相应的运行时权限的！12345678public void grantDefaultPermissions(int userId) &#123; //【5.1.1】默认授予系统组件和 pri app 相应的运行时权限！ grantPermissionsToSysComponentsAndPrivApps(userId); //【5.1.2】默认授予系统中的一些重要应用包相应的运行时权限！ grantDefaultSystemHandlerPermissions(userId); //【5.1.3】处理之前授予异常的情况！ grantDefaultPermissionExceptions(userId);&#125; 我们来一个一个分析！ 下面分析过程中，我们把 DefaultPermissionGrantPolicy 简称为 DPGrantPolicy 5.1.1 DPGrantPolicy.grantPermissionsToSysComponentsAndPrivApps授予系统组件和私有应用默认权限！ 12345678910111213141516171819202122232425262728private void grantPermissionsToSysComponentsAndPrivApps(int userId) &#123; Log.i(TAG, \"Granting permissions to platform components for user \" + userId); synchronized (mService.mPackages) &#123; for (PackageParser.Package pkg : mService.mPackages.values()) &#123; //【5.1.1.1/2】跳过那些非系统或者非私有应用，或者不支持运行时权限，或者没有请求运行时权限的应用 if (!isSysComponentOrPersistentPlatformSignedPrivAppLPr(pkg) || !doesPackageSupportRuntimePermissions(pkg) || pkg.requestedPermissions.isEmpty()) &#123; continue; &#125; Set&lt;String&gt; permissions = new ArraySet&lt;&gt;(); final int permissionCount = pkg.requestedPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; String permission = pkg.requestedPermissions.get(i); BasePermission bp = mService.mSettings.mPermissions.get(permission); // 如果是运行时权限的话，添加到集合中！ if (bp != null &amp;&amp; bp.isRuntime()) &#123; permissions.add(permission); &#125; &#125; //【5.1.1.3】默认授予运行时权限，不需要请求！！ if (!permissions.isEmpty()) &#123; grantRuntimePermissionsLPw(pkg, permissions, true, userId); &#125; &#125; &#125;&#125; 直接授予权限即可！ 5.1.1.1 DPGrantPolicy.isSysComponentOrPersistentPlatformSignedPrivAppLPr12345678910111213141516171819202122private boolean isSysComponentOrPersistentPlatformSignedPrivAppLPr(PackageParser.Package pkg) &#123; //【1】apk 的 uid 小于 FIRST_APPLICATION_UID，那么返回 true，不跳过！ if (UserHandle.getAppId(pkg.applicationInfo.uid) &lt; FIRST_APPLICATION_UID) &#123; return true; &#125; //【2】如果不是 privileged App，返回 false，会跳过！ if (!pkg.isPrivilegedApp()) &#123; return false; &#125; //【3】如果其没有 ApplicationInfo.FLAG_PERSISTENT 标志位，返回 false，会跳过！ PackageSetting sysPkg = mService.mSettings.getDisabledSystemPkgLPr(pkg.packageName); if (sysPkg != null &amp;&amp; sysPkg.pkg != null) &#123; if ((sysPkg.pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_PERSISTENT) == 0) &#123; return false; &#125; &#125; else if ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_PERSISTENT) == 0) &#123; return false; &#125; // 最后，匹配签名，如果应用是系统平台签名，返回 true，不跳过！ return PackageManagerService.compareSignatures(mService.mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;&#125; 上面的逻辑就不多说了！ 5.1.1.2 DPGrantPolicy.doesPackageSupportRuntimePermissions判断该 package 是否支持运行时权限！123private static boolean doesPackageSupportRuntimePermissions(PackageParser.Package pkg) &#123; return pkg.applicationInfo.targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1;&#125; 即：如果目标 sdk 大于 Android5.1，那就是支持，返回 true！ 5.1.2 DPGrantPolicy.grantDefaultSystemHandlerPermissions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411private void grantDefaultSystemHandlerPermissions(int userId) &#123; Log.i(TAG, \"Granting permissions to default platform handlers for user \" + userId); // 这些 PackagesProvider 就是其他服务通过 PackageManagerInternalImpl 注册到 pms 内部的！ final PackagesProvider locationPackagesProvider; final PackagesProvider voiceInteractionPackagesProvider; final PackagesProvider smsAppPackagesProvider; final PackagesProvider dialerAppPackagesProvider; final PackagesProvider simCallManagerPackagesProvider; final SyncAdapterPackagesProvider syncAdapterPackagesProvider; synchronized (mService.mPackages) &#123; locationPackagesProvider = mLocationPackagesProvider; voiceInteractionPackagesProvider = mVoiceInteractionPackagesProvider; smsAppPackagesProvider = mSmsAppPackagesProvider; dialerAppPackagesProvider = mDialerAppPackagesProvider; simCallManagerPackagesProvider = mSimCallManagerPackagesProvider; syncAdapterPackagesProvider = mSyncAdapterPackagesProvider; &#125; String[] voiceInteractPackageNames = (voiceInteractionPackagesProvider != null) ? voiceInteractionPackagesProvider.getPackages(userId) : null; String[] locationPackageNames = (locationPackagesProvider != null) ? locationPackagesProvider.getPackages(userId) : null; String[] smsAppPackageNames = (smsAppPackagesProvider != null) ? smsAppPackagesProvider.getPackages(userId) : null; String[] dialerAppPackageNames = (dialerAppPackagesProvider != null) ? dialerAppPackagesProvider.getPackages(userId) : null; String[] simCallManagerPackageNames = (simCallManagerPackagesProvider != null) ? simCallManagerPackagesProvider.getPackages(userId) : null; String[] contactsSyncAdapterPackages = (syncAdapterPackagesProvider != null) ? syncAdapterPackagesProvider.getPackages(ContactsContract.AUTHORITY, userId) : null; String[] calendarSyncAdapterPackages = (syncAdapterPackagesProvider != null) ? syncAdapterPackagesProvider.getPackages(CalendarContract.AUTHORITY, userId) : null; synchronized (mService.mPackages) &#123; //【2】默认授予 PackageInstaller STORAGE_PERMISSIONS 中的所有权限！ PackageParser.Package installerPackage = getSystemPackageLPr( mService.mRequiredInstallerPackage); if (installerPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(installerPackage)) &#123; grantRuntimePermissionsLPw(installerPackage, STORAGE_PERMISSIONS, true, userId); &#125; //【3】默认授予 PackageVerifier STORAGE_PERMISSIONS，PHONE_PERMISSIONS，SMS_PERMISSIONS 中的所有权限！ PackageParser.Package verifierPackage = getSystemPackageLPr( mService.mRequiredVerifierPackage); if (verifierPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(verifierPackage)) &#123; grantRuntimePermissionsLPw(verifierPackage, STORAGE_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(verifierPackage, PHONE_PERMISSIONS, false, userId); grantRuntimePermissionsLPw(verifierPackage, SMS_PERMISSIONS, false, userId); &#125; //【4】默认授予 SetupWizard PHONE_PERMISSIONS，CONTACTS_PERMISSIONS，LOCATION_PERMISSIONS // CAMERA_PERMISSIONS中的所有权限！ PackageParser.Package setupPackage = getSystemPackageLPr( mService.mSetupWizardPackage); if (setupPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(setupPackage)) &#123; grantRuntimePermissionsLPw(setupPackage, PHONE_PERMISSIONS, userId); grantRuntimePermissionsLPw(setupPackage, CONTACTS_PERMISSIONS, userId); grantRuntimePermissionsLPw(setupPackage, LOCATION_PERMISSIONS, userId); grantRuntimePermissionsLPw(setupPackage, CAMERA_PERMISSIONS, userId); &#125; //【5】默认授予 Camera CAMERA_PERMISSIONS，MICROPHONE_PERMISSIONS，STORAGE_PERMISSIONS 中的所有权限！ Intent cameraIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); PackageParser.Package cameraPackage = getDefaultSystemHandlerActivityPackageLPr( cameraIntent, userId); if (cameraPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(cameraPackage)) &#123; grantRuntimePermissionsLPw(cameraPackage, CAMERA_PERMISSIONS, userId); grantRuntimePermissionsLPw(cameraPackage, MICROPHONE_PERMISSIONS, userId); grantRuntimePermissionsLPw(cameraPackage, STORAGE_PERMISSIONS, userId); &#125; //【6】默认授予 Media provier STORAGE_PERMISSIONS 中的所有权限！ PackageParser.Package mediaStorePackage = getDefaultProviderAuthorityPackageLPr( MediaStore.AUTHORITY, userId); if (mediaStorePackage != null) &#123; grantRuntimePermissionsLPw(mediaStorePackage, STORAGE_PERMISSIONS, true, userId); &#125; //【7】默认授予 download provier STORAGE_PERMISSIONS 中的所有权限！ PackageParser.Package downloadsPackage = getDefaultProviderAuthorityPackageLPr( \"downloads\", userId); if (downloadsPackage != null) &#123; grantRuntimePermissionsLPw(downloadsPackage, STORAGE_PERMISSIONS, true, userId); &#125; //【8】默认授予 Downloads UI STORAGE_PERMISSIONS 中的所有权限！ Intent downloadsUiIntent = new Intent(DownloadManager.ACTION_VIEW_DOWNLOADS); PackageParser.Package downloadsUiPackage = getDefaultSystemHandlerActivityPackageLPr( downloadsUiIntent, userId); if (downloadsUiPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(downloadsUiPackage)) &#123; grantRuntimePermissionsLPw(downloadsUiPackage, STORAGE_PERMISSIONS, true, userId); &#125; //【9】默认授予 Storage provider STORAGE_PERMISSIONS 中的所有权限！ PackageParser.Package storagePackage = getDefaultProviderAuthorityPackageLPr( \"com.android.externalstorage.documents\", userId); if (storagePackage != null) &#123; grantRuntimePermissionsLPw(storagePackage, STORAGE_PERMISSIONS, true, userId); &#125; //【10】默认授予 CertInstaller STORAGE_PERMISSIONS 中的所有权限！ Intent certInstallerIntent = new Intent(Credentials.INSTALL_ACTION); PackageParser.Package certInstallerPackage = getDefaultSystemHandlerActivityPackageLPr( certInstallerIntent, userId); if (certInstallerPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(certInstallerPackage)) &#123; grantRuntimePermissionsLPw(certInstallerPackage, STORAGE_PERMISSIONS, true, userId); &#125; //【11】默认授予 dialer CONTACTS_PERMISSIONS，SMS_PERMISSIONS， // MICROPHONE_PERMISSIONS，CAMERA_PERMISSIONS中的所有权限！ if (dialerAppPackageNames == null) &#123; Intent dialerIntent = new Intent(Intent.ACTION_DIAL); PackageParser.Package dialerPackage = getDefaultSystemHandlerActivityPackageLPr( dialerIntent, userId); if (dialerPackage != null) &#123; grantDefaultPermissionsToDefaultSystemDialerAppLPr(dialerPackage, userId); &#125; &#125; else &#123; for (String dialerAppPackageName : dialerAppPackageNames) &#123; PackageParser.Package dialerPackage = getSystemPackageLPr(dialerAppPackageName); if (dialerPackage != null) &#123; grantDefaultPermissionsToDefaultSystemDialerAppLPr(dialerPackage, userId); &#125; &#125; &#125; //【12】默认授予 Sim call manager PHONE_PERMISSIONS，SMS_PERMISSIONS // MICROPHONE_PERMISSIONS，CAMERA_PERMISSIONS中的所有权限！ if (simCallManagerPackageNames != null) &#123; for (String simCallManagerPackageName : simCallManagerPackageNames) &#123; PackageParser.Package simCallManagerPackage = getSystemPackageLPr(simCallManagerPackageName); if (simCallManagerPackage != null) &#123; grantDefaultPermissionsToDefaultSimCallManagerLPr(simCallManagerPackage, userId); &#125; &#125; &#125; //【13】默认授予 SMS PHONE_PERMISSIONS，CONTACTS_PERMISSIONS，SMS_PERMISSIONS 中的所有权限！ if (smsAppPackageNames == null) &#123; Intent smsIntent = new Intent(Intent.ACTION_MAIN); smsIntent.addCategory(Intent.CATEGORY_APP_MESSAGING); PackageParser.Package smsPackage = getDefaultSystemHandlerActivityPackageLPr( smsIntent, userId); if (smsPackage != null) &#123; grantDefaultPermissionsToDefaultSystemSmsAppLPr(smsPackage, userId); &#125; &#125; else &#123; for (String smsPackageName : smsAppPackageNames) &#123; PackageParser.Package smsPackage = getSystemPackageLPr(smsPackageName); if (smsPackage != null) &#123; grantDefaultPermissionsToDefaultSystemSmsAppLPr(smsPackage, userId); &#125; &#125; &#125; //【14】默认授予 Cell Broadcast Receiver SMS_PERMISSIONS 中的所有权限！ Intent cbrIntent = new Intent(Intents.SMS_CB_RECEIVED_ACTION); PackageParser.Package cbrPackage = getDefaultSystemHandlerActivityPackageLPr(cbrIntent, userId); if (cbrPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(cbrPackage)) &#123; grantRuntimePermissionsLPw(cbrPackage, SMS_PERMISSIONS, userId); &#125; //【15】默认授予 Carrier Provisioning Service SMS_PERMISSIONS 中的所有权限！ Intent carrierProvIntent = new Intent(Intents.SMS_CARRIER_PROVISION_ACTION); PackageParser.Package carrierProvPackage = getDefaultSystemHandlerServicePackageLPr(carrierProvIntent, userId); if (carrierProvPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(carrierProvPackage)) &#123; grantRuntimePermissionsLPw(carrierProvPackage, SMS_PERMISSIONS, false, userId); &#125; //【15】默认授予 Calendar CALENDAR_PERMISSIONS 中的所有权限！ Intent calendarIntent = new Intent(Intent.ACTION_MAIN); calendarIntent.addCategory(Intent.CATEGORY_APP_CALENDAR); PackageParser.Package calendarPackage = getDefaultSystemHandlerActivityPackageLPr( calendarIntent, userId); if (calendarPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(calendarPackage)) &#123; grantRuntimePermissionsLPw(calendarPackage, CALENDAR_PERMISSIONS, userId); grantRuntimePermissionsLPw(calendarPackage, CONTACTS_PERMISSIONS, userId); &#125; //【16】默认授予 Calendar provider CONTACTS_PERMISSIONS，CALENDAR_PERMISSIONS， // STORAGE_PERMISSIONS 中的所有权限！ PackageParser.Package calendarProviderPackage = getDefaultProviderAuthorityPackageLPr( CalendarContract.AUTHORITY, userId); if (calendarProviderPackage != null) &#123; grantRuntimePermissionsLPw(calendarProviderPackage, CONTACTS_PERMISSIONS, userId); grantRuntimePermissionsLPw(calendarProviderPackage, CALENDAR_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(calendarProviderPackage, STORAGE_PERMISSIONS, userId); &#125; //【17】默认授予 Calendar provider sync adapters CALENDAR_PERMISSIONS 中的所有权限！ List&lt;PackageParser.Package&gt; calendarSyncAdapters = getHeadlessSyncAdapterPackagesLPr( calendarSyncAdapterPackages, userId); final int calendarSyncAdapterCount = calendarSyncAdapters.size(); for (int i = 0; i &lt; calendarSyncAdapterCount; i++) &#123; PackageParser.Package calendarSyncAdapter = calendarSyncAdapters.get(i); if (doesPackageSupportRuntimePermissions(calendarSyncAdapter)) &#123; grantRuntimePermissionsLPw(calendarSyncAdapter, CALENDAR_PERMISSIONS, userId); &#125; &#125; //【18】默认授予 Contacts CONTACTS_PERMISSIONS， PHONE_PERMISSIONS 中的所有权限！ Intent contactsIntent = new Intent(Intent.ACTION_MAIN); contactsIntent.addCategory(Intent.CATEGORY_APP_CONTACTS); PackageParser.Package contactsPackage = getDefaultSystemHandlerActivityPackageLPr( contactsIntent, userId); if (contactsPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(contactsPackage)) &#123; grantRuntimePermissionsLPw(contactsPackage, CONTACTS_PERMISSIONS, userId); grantRuntimePermissionsLPw(contactsPackage, PHONE_PERMISSIONS, userId); &#125; //【19】默认授予 Contacts provider sync adapters CONTACTS_PERMISSIONS 中的所有权限！ List&lt;PackageParser.Package&gt; contactsSyncAdapters = getHeadlessSyncAdapterPackagesLPr( contactsSyncAdapterPackages, userId); final int contactsSyncAdapterCount = contactsSyncAdapters.size(); for (int i = 0; i &lt; contactsSyncAdapterCount; i++) &#123; PackageParser.Package contactsSyncAdapter = contactsSyncAdapters.get(i); if (doesPackageSupportRuntimePermissions(contactsSyncAdapter)) &#123; grantRuntimePermissionsLPw(contactsSyncAdapter, CONTACTS_PERMISSIONS, userId); &#125; &#125; //【20】默认授予 Contacts provider CONTACTS_PERMISSIONS，PHONE_PERMISSIONS， // STORAGE_PERMISSIONS 中的所有权限！ PackageParser.Package contactsProviderPackage = getDefaultProviderAuthorityPackageLPr( ContactsContract.AUTHORITY, userId); if (contactsProviderPackage != null) &#123; grantRuntimePermissionsLPw(contactsProviderPackage, CONTACTS_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(contactsProviderPackage, PHONE_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(contactsProviderPackage, STORAGE_PERMISSIONS, userId); &#125; //【21】默认授予 Device provisioning CONTACTS_PERMISSIONS 中的所有权限！ Intent deviceProvisionIntent = new Intent( DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE); PackageParser.Package deviceProvisionPackage = getDefaultSystemHandlerActivityPackageLPr(deviceProvisionIntent, userId); if (deviceProvisionPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(deviceProvisionPackage)) &#123; grantRuntimePermissionsLPw(deviceProvisionPackage, CONTACTS_PERMISSIONS, userId); &#125; //【22】默认授予 Maps App LOCATION_PERMISSIONS 中的所有权限！ Intent mapsIntent = new Intent(Intent.ACTION_MAIN); mapsIntent.addCategory(Intent.CATEGORY_APP_MAPS); PackageParser.Package mapsPackage = getDefaultSystemHandlerActivityPackageLPr( mapsIntent, userId); if (mapsPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(mapsPackage)) &#123; grantRuntimePermissionsLPw(mapsPackage, LOCATION_PERMISSIONS, userId); &#125; //【23】默认授予 Gallery App STORAGE_PERMISSIONS 中的所有权限！ Intent galleryIntent = new Intent(Intent.ACTION_MAIN); galleryIntent.addCategory(Intent.CATEGORY_APP_GALLERY); PackageParser.Package galleryPackage = getDefaultSystemHandlerActivityPackageLPr( galleryIntent, userId); if (galleryPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(galleryPackage)) &#123; grantRuntimePermissionsLPw(galleryPackage, STORAGE_PERMISSIONS, userId); &#125; //【24】默认授予 Email App CONTACTS_PERMISSIONS，CALENDAR_PERMISSIONS 中的所有权限！ Intent emailIntent = new Intent(Intent.ACTION_MAIN); emailIntent.addCategory(Intent.CATEGORY_APP_EMAIL); PackageParser.Package emailPackage = getDefaultSystemHandlerActivityPackageLPr( emailIntent, userId); if (emailPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(emailPackage)) &#123; grantRuntimePermissionsLPw(emailPackage, CONTACTS_PERMISSIONS, userId); grantRuntimePermissionsLPw(emailPackage, CALENDAR_PERMISSIONS, userId); &#125; //【25】默认授予 Browser App LOCATION_PERMISSIONS 中的所有权限！ PackageParser.Package browserPackage = null; String defaultBrowserPackage = mService.getDefaultBrowserPackageName(userId); if (defaultBrowserPackage != null) &#123; browserPackage = getPackageLPr(defaultBrowserPackage); &#125; if (browserPackage == null) &#123; Intent browserIntent = new Intent(Intent.ACTION_MAIN); browserIntent.addCategory(Intent.CATEGORY_APP_BROWSER); browserPackage = getDefaultSystemHandlerActivityPackageLPr( browserIntent, userId); &#125; if (browserPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(browserPackage)) &#123; grantRuntimePermissionsLPw(browserPackage, LOCATION_PERMISSIONS, userId); &#125; //【26】默认授予 Voice interaction CONTACTS_PERMISSIONS，CALENDAR_PERMISSIONS，MICROPHONE_PERMISSIONS // PHONE_PERMISSIONS，SMS_PERMISSIONS，LOCATION_PERMISSIONS 中的所有权限！ if (voiceInteractPackageNames != null) &#123; for (String voiceInteractPackageName : voiceInteractPackageNames) &#123; PackageParser.Package voiceInteractPackage = getSystemPackageLPr( voiceInteractPackageName); if (voiceInteractPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(voiceInteractPackage)) &#123; grantRuntimePermissionsLPw(voiceInteractPackage, CONTACTS_PERMISSIONS, userId); grantRuntimePermissionsLPw(voiceInteractPackage, CALENDAR_PERMISSIONS, userId); grantRuntimePermissionsLPw(voiceInteractPackage, MICROPHONE_PERMISSIONS, userId); grantRuntimePermissionsLPw(voiceInteractPackage, PHONE_PERMISSIONS, userId); grantRuntimePermissionsLPw(voiceInteractPackage, SMS_PERMISSIONS, userId); grantRuntimePermissionsLPw(voiceInteractPackage, LOCATION_PERMISSIONS, userId); &#125; &#125; &#125; //【26】默认授予 Voice recognition MICROPHONE_PERMISSIONS 中的所有权限！ Intent voiceRecoIntent = new Intent(\"android.speech.RecognitionService\"); voiceRecoIntent.addCategory(Intent.CATEGORY_DEFAULT); PackageParser.Package voiceRecoPackage = getDefaultSystemHandlerServicePackageLPr( voiceRecoIntent, userId); if (voiceRecoPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(voiceRecoPackage)) &#123; grantRuntimePermissionsLPw(voiceRecoPackage, MICROPHONE_PERMISSIONS, userId); &#125; //【27】默认授予 Location CONTACTS_PERMISSIONS... 中的所有权限！ if (locationPackageNames != null) &#123; for (String packageName : locationPackageNames) &#123; PackageParser.Package locationPackage = getSystemPackageLPr(packageName); if (locationPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(locationPackage)) &#123; grantRuntimePermissionsLPw(locationPackage, CONTACTS_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, CALENDAR_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, MICROPHONE_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, PHONE_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, SMS_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, LOCATION_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(locationPackage, CAMERA_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, SENSORS_PERMISSIONS, userId); grantRuntimePermissionsLPw(locationPackage, STORAGE_PERMISSIONS, userId); &#125; &#125; &#125; //【28】默认授予 Music STORAGE_PERMISSIONS 中的所有权限！ Intent musicIntent = new Intent(Intent.ACTION_VIEW); musicIntent.addCategory(Intent.CATEGORY_DEFAULT); musicIntent.setDataAndType(Uri.fromFile(new File(\"foo.mp3\")), AUDIO_MIME_TYPE); PackageParser.Package musicPackage = getDefaultSystemHandlerActivityPackageLPr( musicIntent, userId); if (musicPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(musicPackage)) &#123; grantRuntimePermissionsLPw(musicPackage, STORAGE_PERMISSIONS, userId); &#125; // 这里是针对于 Android Wear 设备的，不关注！ if (mService.hasSystemFeature(PackageManager.FEATURE_WATCH, 0)) &#123; Intent homeIntent = new Intent(Intent.ACTION_MAIN); homeIntent.addCategory(Intent.CATEGORY_HOME_MAIN); PackageParser.Package wearHomePackage = getDefaultSystemHandlerActivityPackageLPr( homeIntent, userId); if (wearHomePackage != null &amp;&amp; doesPackageSupportRuntimePermissions(wearHomePackage)) &#123; grantRuntimePermissionsLPw(wearHomePackage, CONTACTS_PERMISSIONS, false, userId); grantRuntimePermissionsLPw(wearHomePackage, PHONE_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(wearHomePackage, MICROPHONE_PERMISSIONS, false, userId); grantRuntimePermissionsLPw(wearHomePackage, LOCATION_PERMISSIONS, false, userId); &#125; &#125; //【29】默认授予 Print Spooler LOCATION_PERMISSIONS 中的所有权限！ PackageParser.Package printSpoolerPackage = getSystemPackageLPr( PrintManager.PRINT_SPOOLER_PACKAGE_NAME); if (printSpoolerPackage != null &amp;&amp; doesPackageSupportRuntimePermissions(printSpoolerPackage)) &#123; grantRuntimePermissionsLPw(printSpoolerPackage, LOCATION_PERMISSIONS, true, userId); &#125; //【30】默认授予 EmergencyInfo CONTACTS_PERMISSIONS, PHONE_PERMISSIONS 中的所有权限！ Intent emergencyInfoIntent = new Intent(TelephonyManager.ACTION_EMERGENCY_ASSISTANCE); PackageParser.Package emergencyInfoPckg = getDefaultSystemHandlerActivityPackageLPr( emergencyInfoIntent, userId); if (emergencyInfoPckg != null &amp;&amp; doesPackageSupportRuntimePermissions(emergencyInfoPckg)) &#123; grantRuntimePermissionsLPw(emergencyInfoPckg, CONTACTS_PERMISSIONS, true, userId); grantRuntimePermissionsLPw(emergencyInfoPckg, PHONE_PERMISSIONS, true, userId); &#125; //【31】默认授予 NFC CONTACTS_PERMISSIONS, PHONE_PERMISSIONS 中的所有权限！ Intent nfcTagIntent = new Intent(Intent.ACTION_VIEW); nfcTagIntent.setType(\"vnd.android.cursor.item/ndef_msg\"); PackageParser.Package nfcTagPkg = getDefaultSystemHandlerActivityPackageLPr( nfcTagIntent, userId); if (nfcTagPkg != null &amp;&amp; doesPackageSupportRuntimePermissions(nfcTagPkg)) &#123; grantRuntimePermissionsLPw(nfcTagPkg, CONTACTS_PERMISSIONS, false, userId); grantRuntimePermissionsLPw(nfcTagPkg, PHONE_PERMISSIONS, false, userId); &#125; //【32】默认授予 Storage Manager STORAGE_PERMISSIONS 中的所有权限！ Intent storageManagerIntent = new Intent(StorageManager.ACTION_MANAGE_STORAGE); PackageParser.Package storageManagerPckg = getDefaultSystemHandlerActivityPackageLPr( storageManagerIntent, userId); if (storageManagerPckg != null &amp;&amp; doesPackageSupportRuntimePermissions(storageManagerPckg)) &#123; grantRuntimePermissionsLPw(storageManagerPckg, STORAGE_PERMISSIONS, true, userId); &#125; //【5.1.2.2】最后调用了 Settings.onDefaultRuntimePermissionsGrantedLPr 方法， // 再次保存运行时权限授予情况！！！ mService.mSettings.onDefaultRuntimePermissionsGrantedLPr(userId); &#125;&#125; 我们可以看到，这个阶段 DefaultPermissionGrantPolicy 默认授予了很多系统组件很多必须的运行时权限！ 涉及到的 DefaultPermissionGrantPolicy 内部方法也很多，但是最终都是调用了其内部的 grantRuntimePermissionsLPw 方法，该方法，我们签名有分析过！ 这里就不在跟踪了！ 5.1.2.1 权限集合DefaultPermissionGrantPolicy 内部有多个 Set 集合，保存了要默认授予给应用的运行时权限！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static final Set&lt;String&gt; PHONE_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; PHONE_PERMISSIONS.add(Manifest.permission.READ_PHONE_STATE); PHONE_PERMISSIONS.add(Manifest.permission.CALL_PHONE); PHONE_PERMISSIONS.add(Manifest.permission.READ_CALL_LOG); PHONE_PERMISSIONS.add(Manifest.permission.WRITE_CALL_LOG); PHONE_PERMISSIONS.add(Manifest.permission.ADD_VOICEMAIL); PHONE_PERMISSIONS.add(Manifest.permission.USE_SIP); PHONE_PERMISSIONS.add(Manifest.permission.PROCESS_OUTGOING_CALLS);&#125;private static final Set&lt;String&gt; CONTACTS_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; CONTACTS_PERMISSIONS.add(Manifest.permission.READ_CONTACTS); CONTACTS_PERMISSIONS.add(Manifest.permission.WRITE_CONTACTS); CONTACTS_PERMISSIONS.add(Manifest.permission.GET_ACCOUNTS);&#125;private static final Set&lt;String&gt; LOCATION_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; LOCATION_PERMISSIONS.add(Manifest.permission.ACCESS_FINE_LOCATION); LOCATION_PERMISSIONS.add(Manifest.permission.ACCESS_COARSE_LOCATION);&#125;private static final Set&lt;String&gt; CALENDAR_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; CALENDAR_PERMISSIONS.add(Manifest.permission.READ_CALENDAR); CALENDAR_PERMISSIONS.add(Manifest.permission.WRITE_CALENDAR);&#125;private static final Set&lt;String&gt; SMS_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; SMS_PERMISSIONS.add(Manifest.permission.SEND_SMS); SMS_PERMISSIONS.add(Manifest.permission.RECEIVE_SMS); SMS_PERMISSIONS.add(Manifest.permission.READ_SMS); SMS_PERMISSIONS.add(Manifest.permission.RECEIVE_WAP_PUSH); SMS_PERMISSIONS.add(Manifest.permission.RECEIVE_MMS); SMS_PERMISSIONS.add(Manifest.permission.READ_CELL_BROADCASTS);&#125;private static final Set&lt;String&gt; MICROPHONE_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; MICROPHONE_PERMISSIONS.add(Manifest.permission.RECORD_AUDIO);&#125;private static final Set&lt;String&gt; CAMERA_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; CAMERA_PERMISSIONS.add(Manifest.permission.CAMERA);&#125;private static final Set&lt;String&gt; SENSORS_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; SENSORS_PERMISSIONS.add(Manifest.permission.BODY_SENSORS);&#125;private static final Set&lt;String&gt; STORAGE_PERMISSIONS = new ArraySet&lt;&gt;();static &#123; STORAGE_PERMISSIONS.add(Manifest.permission.READ_EXTERNAL_STORAGE); STORAGE_PERMISSIONS.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);&#125; 这里只是简单的列举出来！ 5.1.2.2 Settings.onDefaultRuntimePermissionsGrantedLPr1234void onDefaultRuntimePermissionsGrantedLPr(int userId) &#123; mRuntimePermissionsPersistence .onDefaultRuntimePermissionsGrantedLPr(userId);&#125; 对于 RuntimePermissionsPersistence 我们前面有说过，这里会调用其 onDefaultRuntimePermissionsGrantedLPr 方法，重新保存一次运行时权限授予情况！ 代码就不在跟踪了！ 5.1.3 DPGrantPolicy.grantDefaultPermissionExceptionsgrantDefaultPermissionExceptions 用于处理那些授予异常的情况，系统会将授予异常的权限保存到一个文件中！ 12345678910111213141516171819202122232425262728293031private void grantDefaultPermissionExceptions(int userId) &#123; synchronized (mService.mPackages) &#123; mHandler.removeMessages(MSG_READ_DEFAULT_PERMISSION_EXCEPTIONS); //【5.1.3.1】通过本地文件读取默认运行时权限的授予！ if (mGrantExceptions == null) &#123; mGrantExceptions = readDefaultPermissionExceptionsLPw(); &#125; // mGrantExceptions 仅在第一次读取之前为空，然后它作为应为每个用户执行的默认授权的缓存。 // 如果有条目，则应用程序位于系统映像上并支持运行时权限。 Set&lt;String&gt; permissions = null; final int exceptionCount = mGrantExceptions.size(); for (int i = 0; i &lt; exceptionCount; i++) &#123; String packageName = mGrantExceptions.keyAt(i); PackageParser.Package pkg = getSystemPackageLPr(packageName); List&lt;DefaultPermissionGrant&gt; permissionGrants = mGrantExceptions.valueAt(i); final int permissionGrantCount = permissionGrants.size(); for (int j = 0; j &lt; permissionGrantCount; j++) &#123; DefaultPermissionGrant permissionGrant = permissionGrants.get(j); if (permissions == null) &#123; permissions = new ArraySet&lt;&gt;(); &#125; else &#123; permissions.clear(); &#125; permissions.add(permissionGrant.name); //【5.1.1.3】再次调用 grantRuntimePermissionsLPw 授予该运行时权限！ grantRuntimePermissionsLPw(pkg, permissions, false, permissionGrant.fixed, userId); &#125; &#125; &#125;&#125; 5.1.3.1 DPGrantPolicy.readDefaultPermissionExceptionsLPw1234567891011121314151617181920212223242526272829303132333435363738private @NonNull ArrayMap&lt;String, List&lt;DefaultPermissionGrant&gt;&gt; readDefaultPermissionExceptionsLPw() &#123; //【1】获得 /etc/default-permissions 文件目录对象！ File dir = new File(Environment.getRootDirectory(), \"etc/default-permissions\"); if (!dir.exists() || !dir.isDirectory() || !dir.canRead()) &#123; return new ArrayMap&lt;&gt;(0); &#125; File[] files = dir.listFiles(); if (files == null) &#123; return new ArrayMap&lt;&gt;(0); &#125; ArrayMap&lt;String, List&lt;DefaultPermissionGrant&gt;&gt; grantExceptions = new ArrayMap&lt;&gt;(); for (File file : files) &#123; if (!file.getPath().endsWith(\".xml\")) &#123; Slog.i(TAG, \"Non-xml file \" + file + \" in \" + dir + \" directory, ignoring\"); continue; &#125; if (!file.canRead()) &#123; Slog.w(TAG, \"Default permissions file \" + file + \" cannot be read\"); continue; &#125; try ( InputStream str = new BufferedInputStream(new FileInputStream(file)) ) &#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(str, null); //【5.1.3.1.1】parse 解析该目录下的每一个 xml 文件，将结果保存到 grantExceptions 中！ parse(parser, grantExceptions); &#125; catch (XmlPullParserException | IOException e) &#123; Slog.w(TAG, \"Error reading default permissions file \" + file, e); &#125; &#125; return grantExceptions;&#125; 5.1.3.1.1 DPGrantPolicy.parse1234567891011121314151617private void parse(XmlPullParser parser, Map&lt;String, List&lt;DefaultPermissionGrant&gt;&gt; outGrantExceptions) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (TAG_EXCEPTIONS.equals(parser.getName())) &#123; // 标签 exceptions //【5.1.3.1.2】parseExceptions 继续解析 parseExceptions(parser, outGrantExceptions); &#125; else &#123; Log.e(TAG, \"Unknown tag \" + parser.getName()); &#125; &#125;&#125; 5.1.3.1.2 DPGrantPolicy.parseExceptions1234567891011121314151617181920212223242526272829303132333435363738394041private void parseExceptions(XmlPullParser parser, Map&lt;String, List&lt;DefaultPermissionGrant&gt;&gt; outGrantExceptions) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (TAG_EXCEPTION.equals(parser.getName())) &#123; // exception 标签名； String packageName = parser.getAttributeValue(null, ATTR_PACKAGE); // package 属性名； List&lt;DefaultPermissionGrant&gt; packageExceptions = outGrantExceptions.get(packageName); if (packageExceptions == null) &#123; //【1】要处理的应用必须是 system app！ PackageParser.Package pkg = getSystemPackageLPr(packageName); if (pkg == null) &#123; Log.w(TAG, \"Unknown package:\" + packageName); XmlUtils.skipCurrentTag(parser); continue; &#125; //【2】必须支持运行时权限！ if (!doesPackageSupportRuntimePermissions(pkg)) &#123; Log.w(TAG, \"Skipping non supporting runtime permissions package:\" + packageName); XmlUtils.skipCurrentTag(parser); continue; &#125; //【3】创建一个 list，保存权限信息！ packageExceptions = new ArrayList&lt;&gt;(); outGrantExceptions.put(packageName, packageExceptions); &#125; //【5.1.3.1.3】调用 parsePermission 继续解析！ parsePermission(parser, packageExceptions); &#125; else &#123; Log.e(TAG, \"Unknown tag \" + parser.getName() + \"under &lt;exceptions&gt;\"); &#125; &#125;&#125; 5.1.3.1.3 DPGrantPolicy.parsePermission12345678910111213141516171819202122232425262728private void parsePermission(XmlPullParser parser, List&lt;DefaultPermissionGrant&gt; outPackageExceptions) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (TAG_PERMISSION.contains(parser.getName())) &#123; // permission 标签！ String name = parser.getAttributeValue(null, ATTR_NAME); // name 属性 if (name == null) &#123; Log.w(TAG, \"Mandatory name attribute missing for permission tag\"); XmlUtils.skipCurrentTag(parser); continue; &#125; final boolean fixed = XmlUtils.readBooleanAttribute(parser, ATTR_FIXED); // fixed 属性 //【5.1.3.1.4】封装为一个 DefaultPermissionGrant 对象！ DefaultPermissionGrant exception = new DefaultPermissionGrant(name, fixed); outPackageExceptions.add(exception); &#125; else &#123; Log.e(TAG, \"Unknown tag \" + parser.getName() + \"under &lt;exception&gt;\"); &#125; &#125;&#125; 5.1.3.1.4 new DefaultPermissionGrant123456789private static final class DefaultPermissionGrant &#123; final String name; final boolean fixed; public DefaultPermissionGrant(String name, boolean fixed) &#123; this.name = name; this.fixed = fixed; &#125;&#125; DefaultPermissionGrant 对象的属性简单，这里不多看了！ 5.1.4 DPGrantPolicy.grantRuntimePermissionsLPw - 默认授予核心方法默认授予运行时权限，调用的是内部的两个 grantRuntimePermissionsLPw 方法： 12345[1]private void grantRuntimePermissionsLPw(PackageParser.Package pkg, Set&lt;String&gt; permissions, boolean systemFixed, int userId) &#123;...&#125;[2]private void grantRuntimePermissionsLPw(PackageParser.Package pkg, Set&lt;String&gt; permissions, boolean systemFixed, boolean isDefaultPhoneOrSms, int userId) &#123;...&#125; 其中，方法一会调用方法二，这是参数 boolean systemFixed 设置的是 false！ 1234private void grantRuntimePermissionsLPw(PackageParser.Package pkg, Set&lt;String&gt; permissions, boolean systemFixed, int userId) &#123; grantRuntimePermissionsLPw(pkg, permissions, systemFixed, false, userId);&#125; 最后调用的是五参的同名方法：systemFixed 表示是否设置 system fix，isDefaultPhoneOrSms 表示是否是默认的 phone or sms app，permissions 为该 package 要被默认授予的运行时权限集合：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private void grantRuntimePermissionsLPw(PackageParser.Package pkg, Set&lt;String&gt; permissions, boolean systemFixed, boolean isDefaultPhoneOrSms, int userId) &#123; //【1】再次校验应用是否有请求权限！ if (pkg.requestedPermissions.isEmpty()) &#123; return; &#125; //【2】获得本次扫描的 system apk 的权限！ List&lt;String&gt; requestedPermissions = pkg.requestedPermissions; Set&lt;String&gt; grantablePermissions = null; //【3】如果是默认的 phone app 或者 sms app，如果其更新过，我们会默认授予更新过的 app 申明的权限 // 如果这是一个被更新过的其他类型的 system app，我们只会默认授予是那些 system 分区的被更新过得 app 申明过的权限！ if (!isDefaultPhoneOrSms &amp;&amp; pkg.isUpdatedSystemApp()) &#123; PackageSetting sysPs = mService.mSettings.getDisabledSystemPkgLPr(pkg.packageName); if (sysPs != null) &#123; if (sysPs.pkg.requestedPermissions.isEmpty()) &#123; return; &#125; if (!requestedPermissions.equals(sysPs.pkg.requestedPermissions)) &#123; // 表示本次扫描的 package 申明过的权限； grantablePermissions = new ArraySet&lt;&gt;(requestedPermissions); // 替换为被更新过的 system app 申明的权限！！ requestedPermissions = sysPs.pkg.requestedPermissions; &#125; &#125; &#125; //【4】遍历该 package 申明过的所有权限； final int grantablePermissionCount = requestedPermissions.size(); for (int i = 0; i &lt; grantablePermissionCount; i++) &#123; String permission = requestedPermissions.get(i); //【4.1】如果这是一个被更新过的 system app，跳过那些 data 分区新 app 没有声明的权限！ if (grantablePermissions != null &amp;&amp; !grantablePermissions.contains(permission)) &#123; continue; &#125; //【4.2】接下来，就是授予权限权限的过程了！ if (permissions.contains(permission)) &#123; //【5.1.1.3.1】获得权限的 flags； final int flags = mService.getPermissionFlags(permission, pkg.packageName, userId); // If any flags are set to the permission, then it is either set in // its current state by the system or device/profile owner or the user. // In all these cases we do not want to clobber the current state. // Unless the caller wants to override user choices. The override is // to make sure we can grant the needed permission to the default // sms and phone apps after the user chooses this in the UI. //【4.2.1】如果该权限的 flags 没有设置任何标志位，或者是默认的 phone app 或者 sms app 会进入 IF 分支！ if (flags == 0 || isDefaultPhoneOrSms) &#123; //【4.2.1.1】对于 isDefaultPhoneOrSms 我们会再判断下是否设置了 system fix 或者 policy fix 标志位! // 如果设置了，那么我们不会修改标志位！ final int fixedFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED | PackageManager.FLAG_PERMISSION_POLICY_FIXED; if ((flags &amp; fixedFlags) != 0) &#123; continue; &#125; //【4.2.1.2】这里调用了 PMS 的 grantRuntimePermission 方法，授予权限，不多说了！ mService.grantRuntimePermission(pkg.packageName, permission, userId); if (DEBUG) &#123; Log.i(TAG, \"Granted \" + (systemFixed ? \"fixed \" : \"not fixed \") + permission + \" to default handler \" + pkg.packageName); &#125; //【4.2.1.3】更新该运行时权限的 flags，先只设置 FLAG_PERMISSION_GRANTED_BY_DEFAULT 标志位 // 如果为 system fix，还会设置 FLAG_PERMISSION_SYSTEM_FIXED 位！ int newFlags = PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT; if (systemFixed) &#123; newFlags |= PackageManager.FLAG_PERMISSION_SYSTEM_FIXED; &#125; // 这里调用了 PMS 的 updatePermissionFlags 方法，更新权限的 flags 为 newFlags！ mService.updatePermissionFlags(permission, pkg.packageName, newFlags, newFlags, userId); &#125; //【4.2.2】如果权限被设置了 FLAG_PERMISSION_GRANTED_BY_DEFAULT 和 FLAG_PERMISSION_SYSTEM_FIXED 标志位 // 但是本次授予是 no system fix，那么我们就要去掉 system fix 标志位！ if ((flags &amp; PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0 &amp;&amp; (flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0 &amp;&amp; !systemFixed) &#123; if (DEBUG) &#123; Log.i(TAG, \"Granted not fixed \" + permission + \" to default handler \" + pkg.packageName); &#125; //【4.2.2.1】更新权限的 flags 去掉 system fix 标志位！ mService.updatePermissionFlags(permission, pkg.packageName, PackageManager.FLAG_PERMISSION_SYSTEM_FIXED, 0, userId); &#125; &#125; &#125;&#125; 该方法我们就分析到这里！ 5.1.4.1 PackageManagerS.getPermissionFlags该方法用于获得权限的 flags；12345678910111213141516171819202122232425262728293031@Overridepublic int getPermissionFlags(String name, String packageName, int userId) &#123; if (!sUserManager.exists(userId)) &#123; return 0; &#125; //【1】首先是校验是否具有相应的权限！ enforceGrantRevokeRuntimePermissionPermissions(\"getPermissionFlags\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, false /* checkShell */, \"getPermissionFlags\"); synchronized (mPackages) &#123; final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; return 0; &#125; final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; return 0; &#125; SettingBase sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; return 0; &#125; //【2】查询权限的 Flags！ PermissionsState permissionsState = sb.getPermissionsState(); return permissionsState.getPermissionFlags(name, userId); &#125;&#125; 5.1.4.1.1 PermissionsState.getPermissionFlags12345678910111213public int getPermissionFlags(String name, int userId) &#123; //【1】如果是运行时权限的话，那就返回运行时权限的 flags PermissionState installPermState = getInstallPermissionState(name); if (installPermState != null) &#123; return installPermState.getFlags(); &#125; //【2】如果是安装时权限的话，那就返回安装时权限的 flags PermissionState runtimePermState = getRuntimePermissionState(name, userId); if (runtimePermState != null) &#123; return runtimePermState.getFlags(); &#125; return 0;&#125; 下面是具体的获取运行时权限或者安装时权限的权限状态的方法，很简单，不多说了！12345678public PermissionState getInstallPermissionState(String name) &#123; return getPermissionState(name, UserHandle.USER_ALL);&#125;public PermissionState getRuntimePermissionState(String name, int userId) &#123; enforceValidUserId(userId); return getPermissionState(name, userId);&#125; 5.2 清除那些陈旧不用的用户和应用代码段如下：12reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL);reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL); 5.2.1 PackageManagerService.reconcileUsers该方法会检测清除不用的设备用户：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void reconcileUsers(String volumeUuid) &#123; final List&lt;File&gt; files = new ArrayList&lt;&gt;(); // 收集 /data/user_de 目录下的所有文件； Collections.addAll(files, FileUtils .listFilesOrEmpty(Environment.getDataUserDeDirectory(volumeUuid))); // 收集 /data/user 目录下的所有文件； Collections.addAll(files, FileUtils .listFilesOrEmpty(Environment.getDataUserCeDirectory(volumeUuid))); // 收集 /data/system_de 目录下的所有文件； Collections.addAll(files, FileUtils .listFilesOrEmpty(Environment.getDataSystemDeDirectory())); // 收集 /data/system 目录下的所有文件； Collections.addAll(files, FileUtils .listFilesOrEmpty(Environment.getDataSystemCeDirectory())); for (File file : files) &#123; if (!file.isDirectory()) continue; final int userId; final UserInfo info; try &#123; userId = Integer.parseInt(file.getName()); // 尝试获得设备用户对应的 UserInfo！ info = sUserManager.getUserInfo(userId); &#125; catch (NumberFormatException e) &#123; Slog.w(TAG, \"Invalid user directory \" + file); continue; &#125; // 判断用户是否无效！ boolean destroyUser = false; if (info == null) &#123; logCriticalInfo(Log.WARN, \"Destroying user directory \" + file + \" because no matching user was found\"); destroyUser = true; &#125; else if (!mOnlyCore) &#123; try &#123; UserManagerService.enforceSerialNumber(file, info.serialNumber); &#125; catch (IOException e) &#123; logCriticalInfo(Log.WARN, \"Destroying user directory \" + file + \" because we failed to enforce serial number: \" + e); destroyUser = true; &#125; &#125; //【5.2.1.1】如果设备用户无效了，清楚该用户的所有数据！ if (destroyUser) &#123; synchronized (mInstallLock) &#123; destroyUserDataLI(volumeUuid, userId, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); &#125; &#125; &#125;&#125; 第一步，收集了 /data/user_de，/data/user，/data/system_de 和 /data/system 目录下的文件，这些文件的名字，都是以 userId 开头的！ 5.2.1.1 PackageManagerService.destroyUserDataLI123456789101112131415161718192021222324private void destroyUserDataLI(String volumeUuid, int userId, int flags) &#123; final StorageManager storage = mContext.getSystemService(StorageManager.class); try &#123; //【1】通过 Installer 来删除该用户下的 app data, profile data, and media data mInstaller.destroyUserData(volumeUuid, userId, flags); //【2】删除 system data！ if (Objects.equals(volumeUuid, StorageManager.UUID_PRIVATE_INTERNAL)) &#123; if ((flags &amp; StorageManager.FLAG_STORAGE_DE) != 0) &#123; FileUtils.deleteContentsAndDir(Environment.getUserSystemDirectory(userId)); FileUtils.deleteContentsAndDir(Environment.getDataSystemDeDirectory(userId)); &#125; if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; FileUtils.deleteContentsAndDir(Environment.getDataSystemCeDirectory(userId)); &#125; &#125; //【3】取消挂载！ storage.destroyUserStorage(volumeUuid, userId, flags); &#125; catch (Exception e) &#123; logCriticalInfo(Log.WARN, \"Failed to destroy user \" + userId + \" on volume \" + volumeUuid + \": \" + e); &#125;&#125; 该函数的作用很简单，不多说了！ 5.2.2 PackageManagerService.reconcileApps清除那些在该用户下已经卸载的，无效的应用！ 12345678910111213141516171819202122232425262728private void reconcileApps(String volumeUuid) &#123; //【1】手机 /data/app 目录下的所有文件 final File[] files = FileUtils .listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid)); for (File file : files) &#123; final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; // Ignore entries which are not packages continue; &#125; try &#123; // 再次解析该 package，返回 PackageLite 对象！ final PackageLite pkg = PackageParser.parsePackageLite(file, PackageParser.PARSE_MUST_BE_APK); //【4.2.2.1】判断该 package 是否有效，无效会抛出一个异常！ assertPackageKnown(volumeUuid, pkg.packageName); &#125; catch (PackageParserException | PackageManagerException e) &#123; logCriticalInfo(Log.WARN, \"Destroying \" + file + \" due to: \" + e); synchronized (mInstallLock) &#123; //【4.2.2.2】package 无效，删除该 apk！ removeCodePathLI(file); &#125; &#125; &#125;&#125; 5.2.2.1 PackageManagerService.assertPackageKnown12345678910111213141516private void assertPackageKnown(String volumeUuid, String packageName) throws PackageManagerException &#123; synchronized (mPackages) &#123; //【1】如果重命名过了，转为以前的名字； packageName = normalizePackageNameLPr(packageName); final PackageSetting ps = mSettings.mPackages.get(packageName); //【2】如果系统中没有该 apk 的安装信息，或者其所处的 volume 异常，那么无效，抛出异常！ if (ps == null) &#123; throw new PackageManagerException(\"Package \" + packageName + \" is unknown\"); &#125; else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) &#123; throw new PackageManagerException( \"Package \" + packageName + \" found on unknown volume \" + volumeUuid + \"; expected volume \" + ps.volumeUuid); &#125; &#125;&#125; 该方法用于判断 package 是否有效！ 5.2.2.2 PackageManagerService.removeCodePathLI1234567891011void removeCodePathLI(File codePath) &#123; if (codePath.isDirectory()) &#123; try &#123; mInstaller.rmPackageDir(codePath.getAbsolutePath()); &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Failed to remove code path\", e); &#125; &#125; else &#123; codePath.delete(); &#125;&#125; 该方法删除指定的 apk 文件！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"Java 基础 - SPI 机制原理分析","slug":"Javabase-1-SPI","date":"2018-04-13T12:46:25.000Z","updated":"2019-09-21T10:25:25.872Z","comments":true,"path":"2018/04/13/Javabase-1-SPI/","link":"","permalink":"https://coolqi.top/2018/04/13/Javabase-1-SPI/","excerpt":"","text":"本篇文章简要总结和分析下 Java 的 SPI 机制的原理。 1 概述SPI，全称为 Sevice Provider Interface，是 JDK 内置的一种服务提供发现机制，用于框架扩展和代码替换，主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是解耦； Android 中的 dagger 依赖注入框架的内部就有 SPI 的应用！ 2 基本使用 首先要定义一个统一的服务接口： 123456package com.coolqi.myapplication;public class ICommonInterface &#123; void show(int name) &#123; &#125;&#125; 然后需要在应用的 classpath 目录下创建，META-INF/services/ 目录，同时创建一个以 ICommonInterface 服务接口命名的文件； 1META-INF/services/com.coolqi.myapplication.ICommonInterface 然后，在 com.coolqi.myapplication.ICommonInterface 文件中记录那些实现了这个借口的类！ 123com.coolqi.myapplication.CommonInterfaceAcom.coolqi.myapplication.CommonInterfaceBcom.coolqi.myapplication.CommonInterfaceC 最后我们要通过 JDK 的 ServiceLoader 来查询接口 12345678910111213package com.coolqi.myapplication;import java.util.ServiceLoader;public class CoolSPI &#123; public static void main(String[] args) &#123; ServiceLoader&lt;ICommonInterface&gt; serviceLoader = ServiceLoader.load(ICommonInterface.class); for (ICommonInterface helloSPI : serviceLoader) &#123; helloSPI.show(1); &#125; &#125;&#125; 上面就是 SPI 的基本使用方法； 3 ServiceLoader - 源码分析下面我们来看看 ServiceLoader 的源码（JDK 1.8）： 3.1 成员属性12345678910111213141516171819202122public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123; //【1】表示要创建的那个一个以 xxx 服务接口命名的文件所在的路径； private static final String PREFIX = \"META-INF/services/\"; //【2】用于保存要被加载的服务接口 private final Class&lt;S&gt; service; //【3】类加载器； private final ClassLoader loader; //【4】可以看到，在 Android 里面，这里关闭了 java security 机制； // The access control context taken when the ServiceLoader is created // Android-changed: do not use legacy security code. // private final AccessControlContext acc; //【4】缓存机制，保存加载起来的服务；key 是类的权限定名；value 是通过反射创建的实例； private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); //【4】查询迭代器，ServiceLoader 最终是通过 lookupIterator 来访问服务的； private LazyIterator lookupIterator; ServiceLoader 实现了 Iterable 接口，说明他具有迭代器的机制，对于迭代器，核心方法就是 Iterator 和 forEach 12public @NonNull Iterator&lt;@NullFromTypeParam T&gt; iterator();public default void forEach(@NonNull Consumer&lt;? super T&gt; action) &#123;...&#125; 对于 ServiceLoader，我们只能通过 foreach 语法糖来访问内部数据，而 foreach 是通过迭代器 Iterator，不断获取next元素，而这里的迭代器是由 LazyIterator lookupIterator 是实现的！ 3.2 load - 加载服务123456public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; //【1】获取线程的类加载器； ClassLoader cl = Thread.currentThread().getContextClassLoader(); //【2】调用另外一个方法： return ServiceLoader.load(service, cl);&#125; 这里调用了另外一个参数： 123456public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader)&#123; //【--&gt;3.3】创建 ServiceLoader 实例； return new ServiceLoader&lt;&gt;(service, loader); &#125; 3.3 new ServiceLoader创建 ServiceLoader 实例： 12345678910private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123; service = Objects.requireNonNull(svc, \"Service interface cannot be null\"); //【1】这里是对类加载器做了下验证； loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; // Android-changed: Do not use legacy security code. // On Android, System.getSecurityManager() is always null. // acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; //【--&gt;3.4】执行 reload 方法； reload();&#125; 3.4 reload清空了缓存，通知创建 LazyIterator 实例： 12345public void reload() &#123; providers.clear(); //【--&gt;4.1】创建了 LazyIterator 实例； lookupIterator = new LazyIterator(service, loader);&#125; 核心是创建 LazyIterator 实例！ 3.5 iterator - 核心方法ServiceLoader 实现了 iterator 方法： 12345678910111213141516171819202122232425262728public Iterator&lt;S&gt; iterator() &#123; //【1】这里返回了一个新的 Iterator&lt;S&gt; 匿名类实例！ return new Iterator&lt;S&gt;() &#123; //【--&gt;3.1】内部持有 ServiceLoader 的 LinkedHashMap&lt;String,S&gt; providers 的迭代器实例； // 因为 providers 中保存的是缓存，所有优先在缓存中获取； Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); //【2】是否有下一个元素？ public boolean hasNext() &#123; if (knownProviders.hasNext()) //【2.1】如果缓存中有，那就从缓存中获取，返回 true； return true; return lookupIterator.hasNext(); //【--&gt;4.2】如果缓存没有，那就通过 lookupIterator 判断； &#125; //【3】返回下一个元素； public S next() &#123; if (knownProviders.hasNext()) //【3.1】如果缓存中有，那就从缓存中获取； return knownProviders.next().getValue(); return lookupIterator.next(); //【--&gt;4.3】如果缓存没有，那就通过 lookupIterator 获取； &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125;;&#125; 其内部返回了一个新的 Iterator 实例，用遍历数据！ 可以看到先访问缓存，再访问 lookupIterator 实例； 4 LazyIterator懒加载机制的 Iterator，之所以是懒加载，是因为并不是在创建的时候加载文件的，而是在第一次加载的时候，在初始化的； 4.1 成员变量和构造器123456789private class LazyIterator implements Iterator&lt;S&gt;&#123; Class&lt;S&gt; service; // 所属的 service loader； ClassLoader loader; // 类加载器； Enumeration&lt;URL&gt; configs = null; // 用于保存要加载的文件的 url 路径； Iterator&lt;String&gt; pending = null; // 文件中的数据的迭代器； String nextName = null; // 用于继续下一个要加载的服务名称； 同时我们来看看构造器： 1234private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader;&#125; 不多说了； 4.2 hasNext判断是否有下一个元素 1234567891011121314public boolean hasNext() &#123; // Android-changed: do not use legacy security code /* if (acc == null) &#123; */ //【--&gt;4.2.1】调用下一个方法； return hasNextService(); /* &#125; else &#123; PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return hasNextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; */&#125; 继续看： 4.2.1 hasNextService是否有下一个元素： 12345678910111213141516171819202122232425262728293031private boolean hasNextService() &#123; //【1】如果 nextName 不为 null，说明有下一个元素；当然第一次肯定是 null‘ if (nextName != null) &#123; return true; &#125; //【2】加载 META-INF/services/ 目录下的那个接口文件，第一次会读取； // 返回的是 Enumeration&lt;URL&gt; 的枚举实例； if (configs == null) &#123; try &#123; String fullName = PREFIX + service.getName(); // 文件名； if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; catch (IOException x) &#123; fail(service, \"Error locating configuration files\", x); &#125; &#125; //【3】第一次 pending == null，那么就会按行读取文件的内容，保存到 pending 中； // pending 是一个迭代器； while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; pending = parse(service, configs.nextElement()); &#125; //【4】nextname 永远保存下一个要加载的类的全限定名； // 也就是 pending 的下一个元素； nextName = pending.next(); return true;&#125; 方法很简单，不多说了！ 4.3 next返回下一个元素！ 1234567891011121314public S next() &#123; // Android-changed: do not use legacy security code /* if (acc == null) &#123; */ //【--&gt;4.3.1】调用另外一个方法： return nextService(); /* &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; */&#125; 继续看： 4.3.1 nextService返回下一个服务： 12345678910111213141516171819202122232425262728293031323334353637383940private S nextService() &#123; //【--&gt;4.2.1】这里先判断了下是否有下一个元素； if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; //【1】启动类加载器，可以看到，loader 传入的是 ServiceLoader.loader； c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, // Android-changed: Let the ServiceConfigurationError have a cause. \"Provider \" + cn + \" not found\", x); // \"Provider \" + cn + \" not found\"); &#125; //【2】判断下是否满足类继承关系，就是说我们显示传入的接口/类，必须是其父类； if (!service.isAssignableFrom(c)) &#123; // Android-changed: Let the ServiceConfigurationError have a cause. ClassCastException cce = new ClassCastException( service.getCanonicalName() + \" is not assignable from \" + c.getCanonicalName()); fail(service, \"Provider \" + cn + \" not a subtype\", cce); // fail(service, // \"Provider \" + cn + \" not a subtype\"); &#125; try &#123; //【3】通过反射创建服务的实例，并将其转为父类的类型：也就是多态； S p = service.cast(c.newInstance()); //【4】将其加入缓存 providers 中； providers.put(cn, p); //【5】返回实例； return p; &#125; catch (Throwable x) &#123; fail(service, \"Provider \" + cn + \" could not be instantiated\", x); &#125; throw new Error(); // This cannot happen&#125; Class.cast 这里调用了 Class.cast 将子类实例的类型转为父类的： 12345public T cast(Object obj) &#123; if (obj != null &amp;&amp; !isInstance(obj)) throw new ClassCastException(cannotCastMsg(obj)); return (T) obj;&#125; 这里的 T 实际上就是我们上面的 com.coolqi.myapplication.ICommonInterface； 1234567public boolean isInstance(Object obj) &#123; if (obj == null) &#123; return false; &#125; //【1】判断了下当前类是否是对象的类的父类； return isAssignableFrom(obj.getClass());&#125; 5 总结","categories":[{"name":"Java","slug":"Java","permalink":"https://coolqi.top/categories/Java/"},{"name":"Java 基础","slug":"Java/Java-基础","permalink":"https://coolqi.top/categories/Java/Java-基础/"}],"tags":[{"name":"Java basement","slug":"Java-basement","permalink":"https://coolqi.top/tags/Java-basement/"}]},{"title":"ContentProvider篇  2 - ContentProvider 的启动","slug":"ContentProvider2-contentProviderStartProcess","date":"2018-04-13T12:46:25.000Z","updated":"2018-11-20T15:43:58.000Z","comments":true,"path":"2018/04/13/ContentProvider2-contentProviderStartProcess/","link":"","permalink":"https://coolqi.top/2018/04/13/ContentProvider2-contentProviderStartProcess/","excerpt":"","text":"[toc] 基于 Android 7.1.1，分析 ContentProvider 的架构和原理。 0 综述ContentProvider 是进程间通信的利器之一，充当数据存储和出具共享的中间者，其和核心是 Binder 和匿名共享内存！ 我们在访问一个 ContentProvider 的时候，一般情况下都会先拉起该 ContentProvider 所在的进程，然后对其的增删改查： 12ContentResolver cr = getContentResolver();Cursor cursor = cr.query(uri, null, null, null, null); 下面我们来分析下，其主要的流程： 1 ContextImpl1.1 getContentResolver1234@Overridepublic ContentResolver getContentResolver() &#123; return mContentResolver;&#125; 这里的 mContentResolver 是一个 ApplicationContentResolver 的实例： 1private final ApplicationContentResolver mContentResolver; 其创建是在 ContentImpl 初始化的时候： 12345678910private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread, @NonNull LoadedApk packageInfo, @Nullable String splitName, @Nullable IBinder activityToken, @Nullable UserHandle user, int flags, @Nullable ClassLoader classLoader) &#123; ... ... ... ...// 省略掉和 provider 无关的代码！ //【1.2】创建 ApplicationContentResolver 实例！ mContentResolver = new ApplicationContentResolver(this, mainThread, user);&#125; 1.2 new ApplicationContentResolver可以看到 ApplicationContentResolver 继承了 ContentResolver 123456789101112private static final class ApplicationContentResolver extends ContentResolver &#123; private final ActivityThread mMainThread; private final UserHandle mUser; public ApplicationContentResolver( Context context, ActivityThread mainThread, UserHandle user) &#123; super(context); mMainThread = Preconditions.checkNotNull(mainThread); mUser = Preconditions.checkNotNull(user); &#125; ... ... ...&#125; 同时，ApplicationContentResolver 继承了 ContentResolver 中和增删改查相关的接口： 1234public final @Nullable Cursor query(...) &#123;...&#125;public final int update(...) &#123;...&#125;public final @Nullable Uri insert(...) &#123;...&#125;... ... ... 下面，我们通过分析 query 接口，来了解下 ContentProvider 的启动流程！ 2 ContentResolver2.1 query - 查询下面我们来看下查询的调用！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal) &#123; //【1】检查 uri 是否为 null； Preconditions.checkNotNull(uri, \"uri\"); //【×3.1】获得 unstable Provider 对象！ IContentProvider unstableProvider = acquireUnstableProvider(uri); if (unstableProvider == null) &#123; return null; &#125; IContentProvider stableProvider = null; Cursor qCursor = null; try &#123; long startTime = SystemClock.uptimeMillis(); ICancellationSignal remoteCancellationSignal = null; if (cancellationSignal != null) &#123; cancellationSignal.throwIfCanceled(); remoteCancellationSignal = unstableProvider.createCancellationSignal(); cancellationSignal.setRemote(remoteCancellationSignal); &#125; try &#123; //【2】通过 unstable Provider 查询，并返回游标 Cursor！ qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal); &#125; catch (DeadObjectException e) &#123; //【3】如果 query 时远程进程死亡，我们会尝试恢复，但是恢复时，我们会获取 stable provider！ //【*3.2】处理 unstable Provider 进程死亡的清理操作！！ unstableProviderDied(unstableProvider); //【×3.3】获得 stable Provider 对象！ stableProvider = acquireProvider(uri); if (stableProvider == null) &#123; return null; &#125; //【4】通过 stable Provider 查询，并返回游标 Cursor！ qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal); &#125; if (qCursor == null) &#123; return null; &#125; //【5】强制执行 query 的操作，可能会失败抛出运行时异常！！ qCursor.getCount(); long durationMillis = SystemClock.uptimeMillis() - startTime; maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder); //【6】将查询结果 Cursor 封装成 CursorWrapperInner，并返回！！ // 可以看到，我们最后访问的其实是 CursorWrapperInner！！ final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri); final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider); stableProvider = null; qCursor = null; return wrapper; &#125; catch (RemoteException e) &#123; //【7】如果抛出运行时异常，ams 会杀掉该进程！ return null; &#125; finally &#123; if (qCursor != null) &#123; qCursor.close(); &#125; if (cancellationSignal != null) &#123; cancellationSignal.setRemote(null); &#125; if (unstableProvider != null) &#123; releaseUnstableProvider(unstableProvider); &#125; if (stableProvider != null) &#123; releaseProvider(stableProvider); &#125; &#125;&#125; 这里简单的说下，stable provider 和 unstable provider 的区别： 获取 stable provider 的进程会因为 provider 所在进程死亡而被杀死；而获取 unstable provider 的进程则不会出现这种情况； 具体的原因我们后面再分析！ 这个流程很简单，不多说了！！ 2.1.1 acquireUnstableProvider - 获取 unstable provider12345678910111213public final IContentProvider acquireUnstableProvider(Uri uri) &#123; //【1】如果 uri 的 scheme 不是 \"content\"，那就返回 null！ if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; return null; &#125; //【2】如果 uri 没有指定 authority，也返回 null； String auth = uri.getAuthority(); if (auth != null) &#123; //【×3.1】继续调用！ return acquireUnstableProvider(mContext, uri.getAuthority()); &#125; return null;&#125; 2.1.2 acquireProvider - 获取 stable provider12345678910111213public final IContentProvider acquireProvider(Uri uri) &#123; //【1】如果 uri 的 scheme 不是 \"content\"，那就返回 null！ if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; return null; &#125; //【2】如果 uri 没有指定 authority，也返回 null； final String auth = uri.getAuthority(); if (auth != null) &#123; //【×3.3】继续调用！ return acquireProvider(mContext, auth); &#125; return null;&#125; 3 ApplicationContentResolver3.1 acquireUnstableProvider - 获取 unstable provider获取 unstable provider 1234567@Overrideprotected IContentProvider acquireUnstableProvider(Context c, String auth) &#123; //【×4.1】进入 ActivityThread return mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false);&#125; 3.2 unstableProviderDied处理 unstable provider 所在进程死亡后的工作！ 12345@Overridepublic void unstableProviderDied(IContentProvider icp) &#123; //【×4.2】进入 ActivityThread mMainThread.handleUnstableProviderDied(icp.asBinder(), true);&#125; 3.3 acquireProvider - 获取 stable provider获取 stable provider 1234567@Overrideprotected IContentProvider acquireProvider(Context context, String auth) &#123; //【×4.1】进入 ActivityThread return mMainThread.acquireProvider(context, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), true);&#125; 可以看到 ApplicationContentResolver 最终都访问了 ActivityThread 中的逻辑！ 4 ActivityThread4.1 acquireProvider - 获取 provider无论是 unstable provider 还是 stable provider，最终都会调用 ActivityThread 的 acquireProvider 方法，参数传递： String auth：authority 属性； int userId：设备用户 id； boolean stable：provider 的类型； 123456789101112131415161718192021222324252627public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; //【×4.1.1】尝试查询一个已经存在的 provider，如果有，那就返回这个 provider！ final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; IActivityManager.ContentProviderHolder holder = null; try &#123; //【×5.1】如果没有已经存在的，那就需要通过 ams 来获取！ holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; if (holder == null) &#123; Slog.e(TAG, \"Failed to find provider info for \" + auth); return null; &#125; //【×6.4】增加引用计数，将 provider 封装为 ContentProviderHolder 然后返回！ holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); //【1】最后返回 holder.provider！ return holder.provider;&#125; 关于 holder 和 holder.provider 我们后面再分析！ 继续来看： 4.1.1 acquireExistingProvider尝试获得已经存在的一个 provider： 12345678910111213141516171819202122232425262728293031323334public final IContentProvider acquireExistingProvider( Context c, String auth, int userId, boolean stable) &#123; synchronized (mProviderMap) &#123; //【1】根据 authority 属性创建 ProviderKey 对象！ final ProviderKey key = new ProviderKey(auth, userId); //【2】尝试获得已经存在的 ProviderClientRecord 客户端对象！ final ProviderClientRecord pr = mProviderMap.get(key); if (pr == null) &#123; return null; &#125; //【3】判断 provdier 所在的进程是否死亡，这里的 provider 其实是一个 Transport 对象， // 目标进程的 provider 被拉起是会创建！ IContentProvider provider = pr.mProvider; IBinder jBinder = provider.asBinder(); if (!jBinder.isBinderAlive()) &#123; //【3.1】如果 provider 所在进程死亡了，那么就返回 null！ Log.i(TAG, \"Acquiring provider \" + auth + \" for user \" + userId + \": existing object's process dead\"); //【×4.1.1.1】处理进程死亡后，unstable providre 的引用计数！ handleUnstableProviderDiedLocked(jBinder, true); return null; &#125; //【4】如果可以找到已经存在的合适的 provider，那么就增加客户端的引用计数！ ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; //【×4.1.1.2】增加客户端的引用计数！ incProviderRefLocked(prc, stable); &#125; return provider; &#125;&#125; 主要逻辑如下： 尝试从 ActivityThread 的 mProviderMap 查询已存在相对应的 provider，若不存在，则返回 null； 如果 ActivityThread 存在该 provider ，但其所在的进程已经死亡，则调用 handleUnstableProviderDiedLocked 清理 provider 信息，并返回 null； 当 provider 记录存在，并且其进程仍然存活，则在 provider 引用计数不为空时继续增加引用计数。然后返回当前进程已经存在的 provider。 4.1.1.1 handleUnstableProviderDiedLocked如果 provdier 所在的进程已经死亡，那么我们会将该 provider 从引用它的进程中的相关结构体中移除！ boolean fromClient 是否是客户端移除的！ 12345678910111213141516171819202122232425262728final void handleUnstableProviderDiedLocked(IBinder provider, boolean fromClient) &#123; //【1】获得该进程对该 provider 的引用对象！ ProviderRefCount prc = mProviderRefCountMap.get(provider); if (prc != null) &#123; if (DEBUG_PROVIDER) Slog.v(TAG, \"Cleaning up dead provider \" + provider + \" \" + prc.holder.info.name); //【1.1】从引用计数 mProviderRefCountMap 中移除该 provider 的信息！ mProviderRefCountMap.remove(provider); for (int i = mProviderMap.size() - 1; i&gt;=0; i--) &#123; ProviderClientRecord pr = mProviderMap.valueAt(i); if (pr != null &amp;&amp; pr.mProvider.asBinder() == provider) &#123; Slog.i(TAG, \"Removing dead content provider:\" + pr.mProvider.toString()); //【1.2】从 mProviderMap 中移除该 provider 的信息！ mProviderMap.removeAt(i); &#125; &#125; if (fromClient) &#123; try &#123; //【5】通知 ams 该 provider 已经死亡！ ActivityManagerNative.getDefault().unstableProviderDied( prc.holder.connection); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125;&#125; 这里的逻辑就不多说了！ 4.1.1.2 incProviderRefLocked增加 provider 的引用计数， 参数 boolean stable 表示的是稳定引用，还是非稳定引用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private final void incProviderRefLocked(ProviderRefCount prc, boolean stable) &#123; //【1】stable 引用进入这里！ if (stable) &#123; prc.stableCount += 1; // 增加引用计数 if (prc.stableCount == 1) &#123; int unstableDelta; if (prc.removePending) &#123; // 如果此时我们正在移除 provider，那就取消移除！ unstableDelta = -1; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef: stable \" + \"snatched provider from the jaws of death\"); &#125; prc.removePending = false; //【1.1】移除 REMOVE_PROVIDER 消息！ mH.removeMessages(H.REMOVE_PROVIDER, prc); &#125; else &#123; unstableDelta = 0; &#125; try &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef Now stable - \" + prc.holder.info.name + \": unstableDelta=\" + unstableDelta); &#125; //【×7.2】通知 ams，增加框架层的引用信息！ ActivityManagerNative.getDefault().refContentProvider( prc.holder.connection, 1, unstableDelta); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; else &#123; //【2】no stable 引用进入这里； prc.unstableCount += 1; // 增加引用计数 if (prc.unstableCount == 1) &#123; if (prc.removePending) &#123; // 如果此时我们正在移除 provider，那就取消移除！ if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef: unstable \" + \"snatched provider from the jaws of death\"); &#125; //【2.1】移除 REMOVE_PROVIDER 消息！ prc.removePending = false; mH.removeMessages(H.REMOVE_PROVIDER, prc); &#125; else &#123; try &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef: Now unstable - \" + prc.holder.info.name); &#125; //【×7.2】通知 ams，增加框架层的引用信息！ ActivityManagerNative.getDefault().refContentProvider( prc.holder.connection, 0, 1); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; &#125;&#125; 可以看到，如果是第一次引用，那么会做一些额外的处理！ 4.2 handleUnstableProviderDied处理 unstable provider 死亡的清理操作，boolean fromClient 表示本次操作是否来自客户端进程，通过前面的参数传递 123456final void handleUnstableProviderDied(IBinder provider, boolean fromClient) &#123; synchronized (mProviderMap) &#123; //【×4.2.1】继续分析： handleUnstableProviderDiedLocked(provider, fromClient); &#125;&#125; 这里就不多说了，继续看！ 4.2.1 handleUnstableProviderDiedLocked根据参数，这里的 boolean fromClient 为 true，当该进程持有的 unstable provider 所在进程死亡后，123456789101112131415161718192021222324252627final void handleUnstableProviderDiedLocked(IBinder provider, boolean fromClient) &#123; //【1】尝试从当前进程的引用集合中获得该 provider 的引用计数对象，并移除！ ProviderRefCount prc = mProviderRefCountMap.get(provider); if (prc != null) &#123; if (DEBUG_PROVIDER) Slog.v(TAG, \"Cleaning up dead provider \" + provider + \" \" + prc.holder.info.name); mProviderRefCountMap.remove(provider); for (int i=mProviderMap.size()-1; i&gt;=0; i--) &#123; //【1.2】移除该进程持有的 provider 的 ProviderClientRecord 客户端对象！ ProviderClientRecord pr = mProviderMap.valueAt(i); if (pr != null &amp;&amp; pr.mProvider.asBinder() == provider) &#123; Slog.i(TAG, \"Removing dead content provider:\" + pr.mProvider.toString()); mProviderMap.removeAt(i); &#125; &#125; if (fromClient) &#123; try &#123; //【×7.4】通知 ams，客户端进程移除了该 provider 相关的引用计数和客户端实例！ ActivityManagerNative.getDefault().unstableProviderDied( prc.holder.connection); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125;&#125; 这里就不多说了！ 5 ActivityManagerService - 系统进程1当我们拉起了 Content provider 所在的进程，并且执行了一些初始化的操作后，就需要将创建的 provider 注册到系统进程中进行管理！ 5.1 getContentProvider[Impl]下面我们来看 ActivityManagerService 中的 getContentProvider 方法： 12345678910111213@Overridepublic final ContentProviderHolder getContentProvider( IApplicationThread caller, String name, int userId, boolean stable) &#123; enforceNotIsolatedCaller(\"getContentProvider\"); if (caller == null) &#123; String msg = \"null IApplicationThread when getting content provider \" + name; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; //【1】调用了另外一个 getContentProviderImpl 方法！ return getContentProviderImpl(caller, name, null, stable, userId);&#125; 继续来看，getContentProviderImpl 方法的逻辑很长， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) &#123; //【1】在 ams 中每一个的 provider 都是以 ContentProviderRecord 的形式保存的! ContentProviderRecord cpr; //【2】用于保存和 provider 的连接关系！ ContentProviderConnection conn = null; //【3】provider 的信息对象，在应用程序安装的时候会解析保存！ ProviderInfo cpi = null; synchronized(this) &#123; long startTime = SystemClock.uptimeMillis(); //【4】判断访问者进程 r 是否存在，如果不存在，那就抛出异常，并返回！ ProcessRecord r = null; if (caller != null) &#123; r = getRecordForAppLocked(caller); if (r == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when getting content provider \" + name); &#125; &#125; boolean checkCrossUser = true; checkTime(startTime, \"getContentProviderImpl: getProviderByName\"); //【5】判断该 provider 是否已经 publish 到该 userId 中了！ cpr = mProviderMap.getProviderByName(name, userId); // 如果在 userId 下并没有 publish，那么就判断下，该 provider 是否只是给 USER_SYSTEM 使用的 // 如果是，那么就要校验下是否是单例模式！ if (cpr == null &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123; cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM); if (cpr != null) &#123; cpi = cpr.info; //【5.1】如果该 provider 是给 USER_SYSTEM 使用的，那么只有该 provider 是单例模式，并且 // 本地调用对于单例是有效的，那么才可以使用该 provider！ //【×5.1.1.1】通过 isSingleton 判断是否是单例模式！ //【×5.1.1.2】通过 isValidSingletonCall 方法判断方法访问单例 pvodier if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) &#123; //【5.2】单例模式的 provider 运行在默认用户，所以 userId 被设置为了 USER_SYSTEM！ // 同时其他的用户可以访问！ userId = UserHandle.USER_SYSTEM; checkCrossUser = false; // 不用校验 user 了！ &#125; else &#123; cpr = null; // 不是单例模式，进入这里！ cpi = null; &#125; &#125; &#125; //【6】判断 provider 是否正在运行！ boolean providerRunning = cpr != null &amp;&amp; cpr.proc != null &amp;&amp; !cpr.proc.killed; //【7】如果 provider 正在运行，即： cpr 不为 null，同时其进程存在，那么就直接返回该 provider！ if (providerRunning) &#123; cpi = cpr.info; String msg; checkTime(startTime, \"getContentProviderImpl: before checkContentProviderPermission\"); //【×5.1.1.3】校验 provider 权限！ if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser)) != null) &#123; throw new SecurityException(msg); &#125; checkTime(startTime, \"getContentProviderImpl: after checkContentProviderPermission\"); //【×5.1.1.4】如果访问者进程存在，并且 provider 能够在访问者的进程中运行的话，进入这里！ // 该 provider 支持 multi process，或者 provider 和访问者属于同一进程，并且所属 userId 相同！ if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; //【×5.1.1.5】那么这里会通过 provider 在 ams 中的 ContentProviderRecord 实例，创建一个 // ContentProviderHolder 实例，同时设置 holder.connection 和 holder.provider 为 null； // 因为访问者会建立自己的本地 provider！ ContentProviderHolder holder = cpr.newHolder(null); holder.provider = null; return holder; &#125; final long origId = Binder.clearCallingIdentity(); checkTime(startTime, \"getContentProviderImpl: incProviderCountLocked\"); //【×5.1.1.6】增加 provider 引用计数，并返回连接对象 ContentProviderConnection！ conn = incProviderCountLocked(r, cpr, token, stable); if (conn != null &amp;&amp; (conn.stableCount+conn.unstableCount) == 1) &#123; //【8】如果是第一次连接，那么会判断下访问者进程的 adj，如果优先级是可感知进程，或者比可感知进程高 // 那么会调整 provider 所在进程在 lruProcess 中的位置！ if (cpr.proc != null &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123; checkTime(startTime, \"getContentProviderImpl: before updateLruProcess\"); updateLruProcessLocked(cpr.proc, false, null); checkTime(startTime, \"getContentProviderImpl: after updateLruProcess\"); &#125; &#125; checkTime(startTime, \"getContentProviderImpl: before updateOomAdj\"); //【9】调整 provider 所在进程的优先级！ final int verifiedAdj = cpr.proc.verifiedAdj; boolean success = updateOomAdjLocked(cpr.proc); //【10】异常校验，如果优先级调整结果是成功的，但是 provider 的进程 adj 校验不过，并且 provider // 的进程不处于 alive 状态，那么这属于异常情况！ if (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123; success = false; &#125; //【11】更新使用情况！ maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name); checkTime(startTime, \"getContentProviderImpl: after updateOomAdj\"); if (DEBUG_PROVIDER) Slog.i(TAG_PROVIDER, \"Adjust success: \" + success); //【12】如果 success 为 false，说明出现了异常，比如 provider 的进程被杀死了。 // 那么我们需要启动一个新的进程，并且确认 provider 进程的死亡不会杀掉我们的进程！ if (!success) &#123; Slog.i(TAG, \"Existing provider \" + cpr.name.flattenToShortString() + \" is crashing; detaching \" + r); //【×5.1.1.7】减少 provider 引用计数，因为前面尝试增加了！ // 并判断取消的引用是否是该进程对 provider 的最后引用！ boolean lastRef = decProviderCountLocked(conn, cpr, token, stable); checkTime(startTime, \"getContentProviderImpl: before appDied\"); //【12.1】这个是处理 provider 进程死亡后的相关工作，这里不关注！ appDiedLocked(cpr.proc); checkTime(startTime, \"getContentProviderImpl: after appDied\"); if (!lastRef) &#123; //【12.2】如果取消的引用不是该进程对 provider 的最后引用，返回一个 null！ return null; &#125; //【12.3】设置 providerRunning 为 false，conn 为 null，下面我们会继续处理！ providerRunning = false; conn = null; &#125; else &#123; cpr.proc.verifiedAdj = cpr.proc.setAdj; &#125; Binder.restoreCallingIdentity(origId); &#125; //【8】如果 provider 没有在运行，进入这里！！ if (!providerRunning) &#123; try &#123; checkTime(startTime, \"getContentProviderImpl: before resolveContentProvider\"); //【8.1】查询 provider 的信息； cpi = AppGlobals.getPackageManager(). resolveContentProvider(name, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId); checkTime(startTime, \"getContentProviderImpl: after resolveContentProvider\"); &#125; catch (RemoteException ex) &#123; &#125; if (cpi == null) &#123; return null; &#125; //【8.2】如果 provider 是单例模式，同时且满足访问单例的条件，那么我们才允许访问 provider！ //【×5.1.1.1】通过 isSingleton 判断是否是单例模式！ //【×5.1.1.2】通过 isValidSingletonCall 方法判断是否可以访问单例 provider！ boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid); if (singleton) &#123; // 如果是单例访问，那么 userId 为 USER_SYSTEM！ userId = UserHandle.USER_SYSTEM; &#125; //【8.2】获得 provider 在该 userId 下的 ApplicationInfo cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId); checkTime(startTime, \"getContentProviderImpl: got app info for user\"); String msg; checkTime(startTime, \"getContentProviderImpl: before checkContentProviderPermission\"); //【×5.1.1.3】检验访问者是否有权限访问 provider！ if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, !singleton)) != null) &#123; throw new SecurityException(msg); &#125; checkTime(startTime, \"getContentProviderImpl: after checkContentProviderPermission\"); //【8.3】如果该 provider 是运行在其他进程中的，但是系统进程没有启动完成， // 那么也无法启动 provider 所在进程，抛出异常！！ if (!mProcessesReady &amp;&amp; !cpi.processName.equals(\"system\")) &#123; throw new IllegalArgumentException( \"Attempt to launch content provider before system ready\"); &#125; //【8.4】确保 provider 所在的设备用户处于运行状态！ if (!mUserController.isUserRunningLocked(userId, 0)) &#123; Slog.w(TAG, \"Unable to launch app \" + cpi.applicationInfo.packageName + \"/\" + cpi.applicationInfo.uid + \" for provider \" + name + \": user \" + userId + \" is stopped\"); return null; &#125; //【8.5】封装 provider 的组件信息！ ComponentName comp = new ComponentName(cpi.packageName, cpi.name); checkTime(startTime, \"getContentProviderImpl: before getProviderByClass\"); //【×5.1.2.1】尝试通过组件名获得 provider 实例！ cpr = mProviderMap.getProviderByClass(comp, userId); checkTime(startTime, \"getContentProviderImpl: after getProviderByClass\"); final boolean firstClass = cpr == null; //【8.6】如果该 provider 并没有 publish 到系统中，说明这是第一次！ // 那么我们会创建一个 ContentProviderRecord 实例！ if (firstClass) &#123; final long ident = Binder.clearCallingIdentity(); //【8.6.1】如果运行任何组件前要重新确认权限，那么这里会拉起权限确认！ if (Build.PERMISSIONS_REVIEW_REQUIRED) &#123; if (!requestTargetProviderPermissionsReviewIfNeededLocked(cpi, r, userId)) &#123; return null; &#125; &#125; try &#123; checkTime(startTime, \"getContentProviderImpl: before getApplicationInfo\"); //【8.6.2】获得应用程序的 ApplicationInfo 实例！！ ApplicationInfo ai = AppGlobals.getPackageManager(). getApplicationInfo( cpi.applicationInfo.packageName, STOCK_PM_FLAGS, userId); checkTime(startTime, \"getContentProviderImpl: after getApplicationInfo\"); if (ai == null) &#123; Slog.w(TAG, \"No package info for content provider \" + cpi.name); return null; &#125; //【8.6.3】根据本次访问的 userId，动态调整 ApplicationInfo 的信息！ ai = getAppInfoForUser(ai, userId); //【×5.1.2.2】创建 provider 的 ContentProviderRecord 实例！！ cpr = new ContentProviderRecord(this, cpi, ai, comp, singleton); &#125; catch (RemoteException ex) &#123; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; checkTime(startTime, \"getContentProviderImpl: now have ContentProviderRecord\"); //【×5.1.1.4】如果访问者进程存在，并且 provider 能够在访问者的进程中运行的话，进入这里！ // 该 provider 支持 multi process，或者 provider 和访问者属于同一进程，并且所属 userId 相同！ if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; //【×5.1.1.5】那么这里会通过 provider 在 ams 中的 ContentProviderRecord 实例，创建一个 // ContentProviderHolder 实例，同时设置 holder.connection 和 holder.provider 为 null； //（holder.provider 在前面 new ContentProviderRecord 时就是 null 的） // 因为访问者会建立自己的本地 provider！！ return cpr.newHolder(null); &#125; if (DEBUG_PROVIDER) Slog.w(TAG_PROVIDER, \"LAUNCHING REMOTE PROVIDER (myuid \" + (r != null ? r.uid : null) + \" pruid \" + cpr.appInfo.uid + \"): \" + cpr.info.name + \" callers=\" + Debug.getCallers(6)); //【8.7】判断 provider 是否正在启动中，每一个正在启动的 provider 都会被加入到 // mLaunchingProviders 列表中！！！ final int N = mLaunchingProviders.size(); int i; for (i = 0; i &lt; N; i++) &#123; //【8.7.1】如果该 provider 正在启动，那么 i 不会超过 N！ if (mLaunchingProviders.get(i) == cpr) &#123; break; &#125; &#125; //【8.8】如果 provider 还没有启动，那么我们会先启动 orovider！ if (i &gt;= N) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; try &#123; checkTime(startTime, \"getContentProviderImpl: before set stopped state\"); //【8.8.1】provider 所属的 package 不能处于 stop 状态！ AppGlobals.getPackageManager().setPackageStoppedState( cpr.appInfo.packageName, false, userId); checkTime(startTime, \"getContentProviderImpl: after set stopped state\"); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + cpr.appInfo.packageName + \": \" + e); &#125; checkTime(startTime, \"getContentProviderImpl: looking for process record\"); //【8.8.2】获得 provider 所属的进程！ ProcessRecord proc = getProcessRecordLocked( cpi.processName, cpr.appInfo.uid, false); //【8.8.3】如果 provider 所属进程已经启动了，那我们就拉起该 provider！！ if (proc != null &amp;&amp; proc.thread != null &amp;&amp; !proc.killed) &#123; if (DEBUG_PROVIDER) Slog.d(TAG_PROVIDER, \"Installing in existing process \" + proc); if (!proc.pubProviders.containsKey(cpi.name)) &#123; checkTime(startTime, \"getContentProviderImpl: scheduling install\"); //【8.8.3.1】如果该 provider 不在该进程的 pubProviders，将其添加其中！ proc.pubProviders.put(cpi.name, cpr); try &#123; //【×6.1】进入 provider 所在进程，拉起 provider！ proc.thread.scheduleInstallProvider(cpi); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; else &#123; checkTime(startTime, \"getContentProviderImpl: before start process\"); //【8.8.4】如果该 provider 所在进程未启动，那么就启动所在进程！ proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, \"content provider\", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false); checkTime(startTime, \"getContentProviderImpl: after start process\"); if (proc == null) &#123; Slog.w(TAG, \"Unable to launch app \" + cpi.applicationInfo.packageName + \"/\" + cpi.applicationInfo.uid + \" for provider \" + name + \": process is bad\"); return null; &#125; &#125; //【8.8.4.1】设置 cpr.launchingApp 为 proc，表示正在等待该进程启动！ cpr.launchingApp = proc; //【8.8.4.2】将该 provider 加入到 mLaunchingProviders 中，表示其正在启动！ mLaunchingProviders.add(cpr); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125; checkTime(startTime, \"getContentProviderImpl: updating data structures\"); //【9】将 provider 加入的 mProviderMap 中！ if (firstClass) &#123; mProviderMap.putProviderByClass(comp, cpr); &#125; mProviderMap.putProviderByName(name, cpr); //【×5.1.1.6】增加 provider 引用计数，并返回连接对象 ContentProviderConnection！！ conn = incProviderCountLocked(r, cpr, token, stable); if (conn != null) &#123; conn.waiting = true; &#125; &#125; checkTime(startTime, \"getContentProviderImpl: done!\"); &#125; //【9】等待 provider publish 完成！ synchronized (cpr) &#123; //【9.1】当 cpr.provider 为 null 的时候，说明 provider 还没有 publish 完成，所以这里会持续等待！！ while (cpr.provider == null) &#123; if (cpr.launchingApp == null) &#123; //【9.3】 cpr.launchingApp 表示其正在等待启动的进程，如果为 null，说明无法启动 provider 所在 // 的进程，那么就返回 null！ Slog.w(TAG, \"Unable to launch app \" + cpi.applicationInfo.packageName + \"/\" + cpi.applicationInfo.uid + \" for provider \" + name + \": launching app became null\"); EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS, UserHandle.getUserId(cpi.applicationInfo.uid), cpi.applicationInfo.packageName, cpi.applicationInfo.uid, name); return null; &#125; try &#123; if (DEBUG_MU) Slog.v(TAG_MU, \"Waiting to start provider \" + cpr + \" launchingApp=\" + cpr.launchingApp); //【9.4】如果此时创建了连接对象，那么设置 conn.waiting 为 true，表示等待 provider 的 publish！！ if (conn != null) &#123; conn.waiting = true; &#125; cpr.wait(); // Binder 线程加入了该对象的等待队列中等待条件满足！ &#125; catch (InterruptedException ex) &#123; &#125; finally &#123; if (conn != null) &#123; conn.waiting = false; &#125; &#125; &#125; &#125; //【10】provider 启动完成了，返回一个 Holder 对象，此时我们已经创建了连接对象 conn！ // 同时 cpr.provider 也不为 null； return cpr != null ? cpr.newHolder(conn) : null;&#125; 在 ams 中有如下的集合： 123//【1】用于保存正在启动的 provider！final ArrayList&lt;ContentProviderRecord&gt; mLaunchingProviders = new ArrayList&lt;ContentProviderRecord&gt;(); 5.1.1 Provider 正在运行的情况5.1.1.1 isSingleton判断该 provider 时候是否是单例模式！123456789101112131415161718192021222324252627282930313233343536boolean isSingleton(String componentProcessName, ApplicationInfo aInfo, String className, int flags) &#123; boolean result = false; if (UserHandle.getAppId(aInfo.uid) &gt;= Process.FIRST_APPLICATION_UID) &#123; //【1】如果 provider 所属应用的 uid 大于等于 FIRST_APPLICATION_UID，那么其必须要设置 FLAG_SINGLE_USER // 标志位，同时也要被授予 INTERACT_ACROSS_USERS 权限才行！ if ((flags &amp; ServiceInfo.FLAG_SINGLE_USER) != 0) &#123; if (ActivityManager.checkUidPermission( INTERACT_ACROSS_USERS, aInfo.uid) != PackageManager.PERMISSION_GRANTED) &#123; ComponentName comp = new ComponentName(aInfo.packageName, className); String msg = \"Permission Denial: Component \" + comp.flattenToShortString() + \" requests FLAG_SINGLE_USER, but app does not hold \" + INTERACT_ACROSS_USERS; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; result = true; &#125; &#125; else if (\"system\".equals(componentProcessName)) &#123; //【2】如果 1 满足，那么 provider 所在进程必须是 system 进程！ result = true; &#125; else if ((flags &amp; ServiceInfo.FLAG_SINGLE_USER) != 0) &#123; //【3】如果 1 和 2 都不满足，那么必须是 Phone app 或者 persistent apps，才能提供单例 provider！ result = UserHandle.isSameApp(aInfo.uid, Process.PHONE_UID) || (aInfo.flags &amp; ApplicationInfo.FLAG_PERSISTENT) != 0; &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"isSingleton(\" + componentProcessName + \", \" + aInfo + \", \" + className + \", 0x\" + Integer.toHexString(flags) + \") = \" + result); return result;&#125; 属性： android:singleUser，取值为 true 或者 false，如果为 true，那么该 privider 将会是一个单例组件，系统中将有且只会存在一个单例组件运行在所有的设备用户下！ 判断一个 provider 是否是单例模式，要满足一下条件之一： 如果 provider 所属 appId 大于等于 FIRST_APPLICATION_UID，并且其 flags 设置了 FLAG_SINGLE_USER 位，同时其被授予了 INTERACT_ACROSS_USERS 权限； 如果条件 1 不满足，那么如果 provider 所属进程是 system 进程，那么其就是单例的！ 条件 1，2 都不满足，如果 provider 所属进程不是系统进程，同时其设置了 FLAG_SINGLE_USER 位，那么其所属应必须用是 phone app 或者是 persistent app，那么才是单例的！ 逻辑很简单，不多说了！ 5.1.1.2 isValidSingletonCall用于判断调用单例 provider 的操作是否有效： 12345678910boolean isValidSingletonCall(int callingUid, int componentUid) &#123; int componentAppId = UserHandle.getAppId(componentUid); //【1】对于单例模式，调用者和 provider 必须属于同一个应用，或者 provider 组件属于 system/phone // 或者 provider 组件有垮用户的权限！ return UserHandle.isSameApp(callingUid, componentUid) || componentAppId == Process.SYSTEM_UID || componentAppId == Process.PHONE_UID || ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL, componentUid) == PackageManager.PERMISSION_GRANTED;&#125; 判断是否可以访问单例 provider，至少要满足以下的条件之一： 单例的 provider 组件和调用者是同一个 app； 单例的 provider 是 system uid 或者 phone uid； 单例的 provider 所属应用有 INTERACT_ACROSS_USERS_FULL 的权限！ 不多说了！ 5.1.1.3 checkContentProviderPermissionLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private final String checkContentProviderPermissionLocked( ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) &#123; final int callingPid = (r != null) ? r.pid : Binder.getCallingPid(); final int callingUid = (r != null) ? r.uid : Binder.getCallingUid(); boolean checkedGrants = false; if (checkUser) &#123; // Looking for cross-user grants before enforcing the typical cross-users permissions int tmpTargetUserId = mUserController.unsafeConvertIncomingUserLocked(userId); if (tmpTargetUserId != UserHandle.getUserId(callingUid)) &#123; if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) &#123; return null; &#125; checkedGrants = true; &#125; userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, false, ALLOW_NON_FULL, \"checkContentProviderPermissionLocked \" + cpi.authority, null); if (userId != tmpTargetUserId) &#123; // When we actually went to determine the final targer user ID, this ended // up different than our initial check for the authority. This is because // they had asked for USER_CURRENT_OR_SELF and we ended up switching to // SELF. So we need to re-check the grants again. checkedGrants = false; &#125; &#125; if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; if (checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; PathPermission[] pps = cpi.pathPermissions; if (pps != null) &#123; int i = pps.length; while (i &gt; 0) &#123; i--; PathPermission pp = pps[i]; String pprperm = pp.getReadPermission(); if (pprperm != null &amp;&amp; checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; String ppwperm = pp.getWritePermission(); if (ppwperm != null &amp;&amp; checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; &#125; &#125; if (!checkedGrants &amp;&amp; checkAuthorityGrants(callingUid, cpi, userId, checkUser)) &#123; return null; &#125; String msg; if (!cpi.exported) &#123; msg = \"Permission Denial: opening provider \" + cpi.name + \" from \" + (r != null ? r : \"(null)\") + \" (pid=\" + callingPid + \", uid=\" + callingUid + \") that is not exported from uid \" + cpi.applicationInfo.uid; &#125; else &#123; msg = \"Permission Denial: opening provider \" + cpi.name + \" from \" + (r != null ? r : \"(null)\") + \" (pid=\" + callingPid + \", uid=\" + callingUid + \") requires \" + cpi.readPermission + \" or \" + cpi.writePermission; &#125; Slog.w(TAG, msg); return msg;&#125; 5.1.1.4 ContentProviderRecord.canRunHere判断该 provider 是否可以在指定的进程中运行：123456public boolean canRunHere(ProcessRecord app) &#123; //【1】provider 设置了 multiprocess 属性，或者 provider 的进程是该进程 // 并且该 provider 所属 userId 和该进程所属应用程序的 userId 一样（相同用户下）！ return (info.multiprocess || info.processName.equals(app.processName)) &amp;&amp; uid == app.info.uid;&#125; 不多说了！ 5.1.1.5 ContentProviderRecord.newHolder根据系统中已经 publish 的 provider，创建一个 ContentProviderHolder 对象！ 1234567public ContentProviderHolder newHolder(ContentProviderConnection conn) &#123; ContentProviderHolder holder = new ContentProviderHolder(info); holder.provider = provider; holder.noReleaseNeeded = noReleaseNeeded; holder.connection = conn; return holder;&#125; 关于 ContentProviderHolder，我们后面会分析！ 5.1.1.6 incProviderCountLocked增加 provider 的引用计数，参数 r 是访问 provider 的进程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ContentProviderConnection incProviderCountLocked(ProcessRecord r, final ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) &#123; //【1】判断下访问者进程是否存在！ if (r != null) &#123; for (int i = 0; i &lt; r.conProviders.size(); i++) &#123; //【1.1】如果进程存在（当然是存在的），那就依次遍历其持有的 provider connection 对象！ // 找到该进程持有的对该 provider 的连接对象！ ContentProviderConnection conn = r.conProviders.get(i); if (conn.provider == cpr) &#123; if (DEBUG_PROVIDER) Slog.v(TAG_PROVIDER, \"Adding provider requested by \" + r.processName + \" from process \" + cpr.info.processName + \": \" + cpr.name.flattenToShortString() + \" scnt=\" + conn.stableCount + \" uscnt=\" + conn.unstableCount); //【1.2】如果是访问的是 stable provider，增加 stable count！ if (stable) &#123; conn.stableCount++; conn.numStableIncs++; &#125; else &#123; //【1.3】如果是访问的是 unstable provider，增加 unstable count！ conn.unstableCount++; conn.numUnstableIncs++; &#125; //【1.4】返回该 connection 对象！ return conn; &#125; &#125; //【*5.1.1.6.1】如果找不到，说明是第一次访问该 provider，那就先创建 // 一个 ContentProviderConnection 对象！！ ContentProviderConnection conn = new ContentProviderConnection(cpr, r); //【1.5】增加引用计数！ if (stable) &#123; conn.stableCount = 1; conn.numStableIncs = 1; &#125; else &#123; conn.unstableCount = 1; conn.numUnstableIncs = 1; &#125; //【1.6】将其添加到 ContentProviderRecord.connections 集合中； cpr.connections.add(conn); //【1.7】将其添加到 ProcessRecord.conProviders 集合中； r.conProviders.add(conn); startAssociationLocked(r.uid, r.processName, r.curProcState, cpr.uid, cpr.name, cpr.info.processName); // 用于记录进程间的关联性的，这里先不关注！ //【1.8】返回该新建的连接对象！ return conn; &#125; cpr.addExternalProcessHandleLocked(externalProcessToken); return null;&#125; 不多说了！ 5.1.1.6.1 new ContentProviderConnection创建连接对象，本质上是一个 Binder 对象：1234567891011121314151617181920public final class ContentProviderConnection extends Binder &#123; public final ContentProviderRecord provider; // provider 对象； public final ProcessRecord client; // 连接到该 provider 的进程； public final long createTime; public int stableCount; // stable provider 的引用计数； public int unstableCount; // unstable provider 的引用计数； public boolean waiting; // 是否正在等待 provider publish，被锁保护！ public boolean dead; // provider 是否死亡！ public int numStableIncs; // 用于调试！ public int numUnstableIncs; public ContentProviderConnection(ContentProviderRecord _provider, ProcessRecord _client) &#123; provider = _provider; client = _client; createTime = SystemClock.elapsedRealtime(); &#125; ... ... ...&#125; 数据结构都很简答，不多说了！！ 5.1.1.7 decProviderCountLocked减少 provider 的引用计数，参数 conn 是该 provider 的连接对象： 12345678910111213141516171819202122232425262728293031323334353637383940boolean decProviderCountLocked(ContentProviderConnection conn, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) &#123; if (conn != null) &#123; //【1】获得该连接对象链接的 provider 对爱 ContentProviderRecord！ cpr = conn.provider; if (DEBUG_PROVIDER) Slog.v(TAG_PROVIDER, \"Removing provider requested by \" + conn.client.processName + \" from process \" + cpr.info.processName + \": \" + cpr.name.flattenToShortString() + \" scnt=\" + conn.stableCount + \" uscnt=\" + conn.unstableCount); //【2】减少该连接对象的相应引用计数！ if (stable) &#123; conn.stableCount--; &#125; else &#123; conn.unstableCount--; &#125; //【3】判断是否是该 provider 的最后一个引用，即本次减少引用后，该连接对象的 stable count // 和 unstable count 都是 0。 if (conn.stableCount == 0 &amp;&amp; conn.unstableCount == 0) &#123; //【3.1】ContentProviderRecord.connections 移除该连接对象； cpr.connections.remove(conn); //【3.2】从该连接对象的所属进程中移除自身！ conn.client.conProviders.remove(conn); if (conn.client.setProcState &lt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; // The client is more important than last activity -- note the time this // is happening, so we keep the old provider process around a bit as last // activity to avoid thrashing it. if (cpr.proc != null) &#123; cpr.proc.lastProviderTime = SystemClock.uptimeMillis(); &#125; &#125; stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid, cpr.name); //【3.3】返回 true，说明取消的是最后一个引用！ return true; &#125; return false; &#125; cpr.removeExternalProcessHandleLocked(externalProcessToken); return false;&#125; 不多说了！ 5.1.2 Provider 没在运行的情况5.1.2.1 ProviderMap在 ams 有一个这样的数据结构： 1ProviderMap mProviderMap = new ProviderMap(this); 用来记录系统中所有 publish 的 provider： 123456789101112131415161718192021222324public final class ProviderMap &#123; private static final String TAG = \"ProviderMap\"; private static final boolean DBG = false; private final ActivityManagerService mAm; //【1】单例 provdier 集合，key 为 authority，value 为 ContentProviderRecord 实例！ private final HashMap&lt;String, ContentProviderRecord&gt; mSingletonByName = new HashMap&lt;String, ContentProviderRecord&gt;(); private final HashMap&lt;ComponentName, ContentProviderRecord&gt; mSingletonByClass = new HashMap&lt;ComponentName, ContentProviderRecord&gt;(); //【2】非单例 provdier 集合，key 为 userId，value 是 authority 和 ContentProviderRecord 的映射！ private final SparseArray&lt;HashMap&lt;String, ContentProviderRecord&gt;&gt; mProvidersByNamePerUser = new SparseArray&lt;HashMap&lt;String, ContentProviderRecord&gt;&gt;(); private final SparseArray&lt;HashMap&lt;ComponentName, ContentProviderRecord&gt;&gt; mProvidersByClassPerUser = new SparseArray&lt;HashMap&lt;ComponentName, ContentProviderRecord&gt;&gt;(); ProviderMap(ActivityManagerService am) &#123; mAm = am; &#125; ... ... ...&#125; 这里就不多说了！ 同时也提供了如下的 get set 接口： 5.1.2.2.1 ProviderMap.get 5.1.2.2 new ContentProviderRecord创建一个 ContentProviderRecord 实例，用于在系统进程中描述一个 provider！ 1234567891011121314151617181920212223242526272829303132333435363738final class ContentProviderRecord &#123; final ActivityManagerService service; // ams 实力 public final ProviderInfo info; // provider 的信息对象； final int uid; // 所属应用的 uid； final ApplicationInfo appInfo; // 所属应用程序的信息； final ComponentName name; // provider 对应的组件名实例； final boolean singleton; // 是否是单例模式； public IContentProvider provider; public boolean noReleaseNeeded; //【1】所有连接到该 provider 的进程的连接对象！ final ArrayList&lt;ContentProviderConnection&gt; connections = new ArrayList&lt;ContentProviderConnection&gt;(); //final HashSet&lt;ProcessRecord&gt; clients = new HashSet&lt;ProcessRecord&gt;(); // Handles for non-framework processes supported by this provider HashMap&lt;IBinder, ExternalProcessHandle&gt; externalProcessTokenToHandle; // Count for external process for which we have no handles. int externalProcessNoHandleCount; ProcessRecord proc; //【2】所在进程 ProcessRecord launchingApp; //【3】等待启动的进程！ String stringName; String shortStringName; public ContentProviderRecord(ActivityManagerService _service, ProviderInfo _info, ApplicationInfo ai, ComponentName _name, boolean _singleton) &#123; service = _service; info = _info; uid = ai.uid; appInfo = ai; name = _name; singleton = _singleton; noReleaseNeeded = uid == 0 || uid == Process.SYSTEM_UID; &#125; ... ... ...&#125; 继续分析！ 5.1.3 ActivityManagerProxy.getContentProvider对于 getContentProvider，我们再去看下 ActivityManagerProxy 中是如何调用的： 123456789101112131415161718192021public ContentProviderHolder getContentProvider(IApplicationThread caller, String name, int userId, boolean stable) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(name); data.writeInt(userId); data.writeInt(stable ? 1 : 0); mRemote.transact(GET_CONTENT_PROVIDER_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); ContentProviderHolder cph = null; if (res != 0) &#123; //【*5.1.3.1】调用了 ContentProviderHolder.CREATOR 的 createFromParcel 方法！ cph = ContentProviderHolder.CREATOR.createFromParcel(reply); &#125; data.recycle(); reply.recycle(); return cph;&#125; getContentProvider 会返回一个 ContentProviderHolder 实例，ContentProviderHolder 看源码，实现了 Parcelable 接口，可以序列化! 5.1.3.1 ContentProviderHolder.CREATOR.createFromParcel我们来看下 ContentProviderHolder.CREATOR 的 createFromParcel 方法： 12345678910111213public static final Parcelable.Creator&lt;ContentProviderHolder&gt; CREATOR = new Parcelable.Creator&lt;ContentProviderHolder&gt;() &#123; @Override public ContentProviderHolder createFromParcel(Parcel source) &#123; //【*5.1.3.2】这里是通过服务端进程返回的 Parcel，再创建了一个 ContentProviderHolder！ return new ContentProviderHolder(source); &#125; @Override public ContentProviderHolder[] newArray(int size) &#123; return new ContentProviderHolder[size]; &#125;&#125;; 5.1.3.2 new ContentProviderHolder[Parcel]这里通过 ContentProviderHolder 另外一个构造器创建了访问者进程中的 ContentProviderHolder 实例！ 12345678private ContentProviderHolder(Parcel source) &#123; info = ProviderInfo.CREATOR.createFromParcel(source); //【1】初始化 provider 实例！ provider = ContentProviderNative.asInterface( source.readStrongBinder()); connection = source.readStrongBinder(); noReleaseNeeded = source.readInt() != 0;&#125; 我们知道在 provider 的宿主进程里，这里的 provider 是 Transport 实例！！ 但是在访问者进程中，这里的 provider 是一个 ContentProviderProxy 实例，也就是 Transport 的客户端代理对象！ 这样访问者进程就可以通过 ContentProviderProxy -&gt; Transport 来跨进程通信啦！！ 6 ActivityThread6.1 provider 未启动但是其进程已经启动6.1.1 scheduleInstallProvider发送了 INSTALL_PROVIDER 消息：12345@Overridepublic void scheduleInstallProvider(ProviderInfo provider) &#123; //【1】发送了 INSTALL_PROVIDER 消息！ sendMessage(H.INSTALL_PROVIDER, provider);&#125; 6.1.2 H.handleMessage[INSTALL_PROVIDER]1234case INSTALL_PROVIDER: //【6.1.3】安装 provider！ handleInstallProvider((ProviderInfo) msg.obj); break; 6.1.3 handleInstallProvider123456789public void handleInstallProvider(ProviderInfo info) &#123; final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites(); try &#123; //【×6.3】安装 content provider！ installContentProviders(mInitialApplication, Lists.newArrayList(info)); &#125; finally &#123; StrictMode.setThreadPolicy(oldPolicy); &#125;&#125; 这里就不多说了！！ 6.2 provider 未启动同时其进程也未启动6.2.1 AMS.attachApplicationLockedstartProcessLocked 方法，先会调用 attachApplicationLocked 方法，这里省略掉了和 ContentProvider 无关的逻辑和代码： attachApplicationLocked 我们在进程的启动中有分析过！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ... ... ... //【×6.2.1.1】获得进程中需要 install 和 publish 的 provider！ boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null; //【×6.2.1.2】如果有 provider 正在等待该进程启动，那么就设置超时消息！ if (providers != null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123; Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG); msg.obj = app; mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT); &#125; ... ... ... ... try &#123; ... ... ... ... //【×6.2.2】bind 应用程序进程，这个地方，我们将 providers 作为参数传递到了 bindApplication // 方法里！ thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); //【1】更新 lru 进程列表！ updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown during bind of \" + app, e); app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); startProcessLocked(app, \"bind fail\", processName); return false; &#125; ... ... ... return true;&#125; 6.2.1.1 generateApplicationProvidersLocked收集该进程中需要启动的 provider！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private final List&lt;ProviderInfo&gt; generateApplicationProvidersLocked(ProcessRecord app) &#123; List&lt;ProviderInfo&gt; providers = null; try &#123; //【1】获得该进程中所有 provider！ providers = AppGlobals.getPackageManager() .queryContentProviders(app.processName, app.uid, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS | MATCH_DEBUG_TRIAGED_MISSING) .getList(); &#125; catch (RemoteException ex) &#123; &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"generateApplicationProvidersLocked, app.info.uid = \" + app.uid); int userId = app.userId; //【2】遍历获得的所有的 provider！ if (providers != null) &#123; int N = providers.size(); app.pubProviders.ensureCapacity(N + app.pubProviders.size()); for (int i=0; i&lt;N; i++) &#123; ProviderInfo cpi = (ProviderInfo)providers.get(i); //【×5.1.1.1】判断 provider 是否是单例模式的！ boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags); //【2.1】如果 provider 是单例模式，那么他们只能在默认用户下的进程中运行，如果 // 进程的所属用户不是默认用户，那就不能运行！ if (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123; //【2.1.1】将该 provider 从集合中移除！ providers.remove(i); N--; i--; continue; &#125; //【2.3】创建 provider 对应的组件对象，并创建 provider 对应的 ContentProviderRecord 实例 // 将其添加到 mProviderMap 和 mProviderMap 中！ ComponentName comp = new ComponentName(cpi.packageName, cpi.name); ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId); if (cpr == null) &#123; cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton); mProviderMap.putProviderByClass(comp, cpr); &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"generateApplicationProvidersLocked, cpi.uid = \" + cpr.uid); //【2.4】将该 provdier 添加到所属进程的 app.pubProviders 集合中！ app.pubProviders.put(cpi.name, cpr); //【2.5】如果 provider 不是 multiprocess； // 或者 provider 是 multiprocess 同时其宿主进程名不是 android，我们会将其所属包名加入到该进程中！ if (!cpi.multiprocess || !\"android\".equals(cpi.packageName)) &#123; // 如果是平台组件的话，那么是不会加入的，因为其属于框架层！ app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, mProcessStats); &#125; notifyPackageUse(cpi.applicationInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER); &#125; &#125; //【2】返回要启动的 provider！ return providers;&#125; 这里就不多说了！！ 6.2.1.2 checkAppInLaunchingProvidersLocked判断是否有 content provider 等待该进程的启动！ 12345678910boolean checkAppInLaunchingProvidersLocked(ProcessRecord app) &#123; //【1】遍历 mLaunchingProviders 集合，如果有 provider 所属进程属于该 process，返回 true！ for (int i = mLaunchingProviders.size() - 1; i &gt;= 0; i--) &#123; ContentProviderRecord cpr = mLaunchingProviders.get(i); if (cpr.launchingApp == app) &#123; return true; &#125; &#125; return false;&#125; 6.2.2 handleBindApplicationstartProcessLocked 方法，最后会调用 handleBindApplication 方法，这里省略掉了和 ContentProvider 无关的逻辑和代码： handleBindApplication 我们在进程的启动中有分析过！ 1234567891011121314151617181920212223242526272829303132333435363738private void handleBindApplication(AppBindData data) &#123; ... ... ... ... final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); try &#123; Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; //【×6.3】安装 content provider！！ installContentProviders(app, data.providers); mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); &#125; &#125; try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Exception thrown in onCreate() of \" + data.instrumentationName + \": \" + e.toString(), e); &#125; try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125; 6.3 installContentProviders - 安装 provider安装 contentprovider：1234567891011121314151617181920212223242526272829303132333435private void installContentProviders( Context context, List&lt;ProviderInfo&gt; providers) &#123; //【1】该进程中的所有 provider！ final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results = new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;(); for (ProviderInfo cpi : providers) &#123; if (DEBUG_PROVIDER) &#123; StringBuilder buf = new StringBuilder(128); buf.append(\"Pub \"); buf.append(cpi.authority); buf.append(\": \"); buf.append(cpi.name); Log.i(TAG, buf.toString()); &#125; //【×6.4】封装 provider！ IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi, false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/); //【2】设置 ContentProviderHolder 的 noReleaseNeeded 属性 // 同时将其添加到 results 集合中！ if (cph != null) &#123; cph.noReleaseNeeded = true; results.add(cph); &#125; &#125; try &#123; //【×7.1】将 provider 注册到 ams 中！ ActivityManagerNative.getDefault().publishContentProviders( getApplicationThread(), results); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 这里我们要注意下参数： Context context：进程的上下文环境！ IActivityManager.ContentProviderHolder holder：null ProviderInfo info：provider 的信息对象； boolean noisy：false boolean noReleaseNeeded：true boolean stable：true 6.4 installProvider封装 provider，返回对应的 ContentProviderHolder 实例，注意，这里由于 provider 的进程刚启动，所以 installProvider 的 IActivityManager.ContentProviderHolder holder 参数为 null！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159private IActivityManager.ContentProviderHolder installProvider(Context context, IActivityManager.ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; IContentProvider provider; //【1】如果 if 条件满足，说明进程要创建自己的本地 provider 实例！！ if (holder == null || holder.provider == null) &#123; if (DEBUG_PROVIDER || noisy) &#123; Slog.d(TAG, \"Loading provider \" + info.authority + \": \" + info.name); &#125; //【1.1】获取 Context 上下文环境！ Context c = null; ApplicationInfo ai = info.applicationInfo; if (context.getPackageName().equals(ai.packageName)) &#123; c = context; &#125; else if (mInitialApplication != null &amp;&amp; mInitialApplication.getPackageName().equals(ai.packageName)) &#123; c = mInitialApplication; &#125; else &#123; try &#123; c = context.createPackageContext(ai.packageName, Context.CONTEXT_INCLUDE_CODE); &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; &#125; if (c == null) &#123; Slog.w(TAG, \"Unable to get context for package \" + ai.packageName + \" while loading content provider \" + info.name); return null; &#125; try &#123; final java.lang.ClassLoader cl = c.getClassLoader(); //【×6.4.1】第一次创建时，会通过反射，创建 ContentProvider 对象！ localProvider = (ContentProvider)cl. loadClass(info.name).newInstance(); //【×6.4.2】获得内部的 IContentProvider 对象，用于 Binder 通信； // 返回的是其内部的一个 Transport 实例！ provider = localProvider.getIContentProvider(); if (provider == null) &#123; Slog.e(TAG, \"Failed to instantiate class \" + info.name + \" from sourceDir \" + info.applicationInfo.sourceDir); return null; &#125; if (DEBUG_PROVIDER) Slog.v( TAG, \"Instantiating local provider \" + info.name); //【*6.4.3】设置 Context，解析保存 providerInfo 中的信息！ localProvider.attachInfo(c, info); &#125; catch (java.lang.Exception e) &#123; if (!mInstrumentation.onException(null, e)) &#123; throw new RuntimeException( \"Unable to get provider \" + info.name + \": \" + e.toString(), e); &#125; return null; &#125; &#125; else &#123; //【1.2】如果 if 条件不满足，说明进程不需要创建本地 provider 而是需要获得远程的 provider 连接对象！ // holder.provider 就是 6.4.2.1 的 Transport 实例，后面我们再看！！ provider = holder.provider; if (DEBUG_PROVIDER) Slog.v(TAG, \"Installing external provider \" + info.authority + \": \" + info.name); &#125; IActivityManager.ContentProviderHolder retHolder; synchronized (mProviderMap) &#123; if (DEBUG_PROVIDER) Slog.v(TAG, \"Checking to add \" + provider + \" / \" + info.name); //【2】获得 provider 的 Transport 对象！ IBinder jBinder = provider.asBinder(); //【3】如果进程需要创建自己的 local provider（比如 multi process 情况下）， // 那么此时 localProvider 不为 null！ if (localProvider != null) &#123; //【3.1】创建对应的 ComponentName！ ComponentName cname = new ComponentName(info.packageName, info.name); //【3.2】判断当前进程中是否已经有该 provider 对应的 ProviderClientRecord，当然， // 如果是第一次创建，是不会有的； ProviderClientRecord pr = mLocalProvidersByName.get(cname); if (pr != null) &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"installProvider: lost the race, \" + \"using existing local provider\"); &#125; //【3.2.1】获得其 Transport 实例 provider = pr.mProvider; &#125; else &#123; //【*6.4.4】如果本地还未创建，那就创建 ContentProviderHolder 对象！ // 并设置 holder.provider！！ holder = new IActivityManager.ContentProviderHolder(info); holder.provider = provider; holder.noReleaseNeeded = true; //【*6.4.5】处理 authority 返回一个 ProviderClientRecord 对象！ pr = installProviderAuthoritiesLocked(provider, localProvider, holder); //【3.3】将应用关系保存到进程内部的指定集合中！ mLocalProviders.put(jBinder, pr); mLocalProvidersByName.put(cname, pr); &#125; //【2.4】将创建的 Holder 保存到 retHolder 中； retHolder = pr.mHolder; &#125; else &#123; //【4】如果进程不需要创建自己的 local provider，而是需要访问远程的 provider， // 那么我们需要和远程的 provider，建立引用关系！ //【4.1】尝试根据 provider 的 Transport 对象，获得其对应的引用计数对象！ ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; //【2.5.1】如果引用计数对象存在，那就增加引用计数！ if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"installProvider: lost the race, updating ref count\"); &#125; if (!noReleaseNeeded) &#123; // 如果需要 release 的话，我们会增加引用，同时释放掉旧的引用； //【1.3.6】增加引用计数！ incProviderRefLocked(prc, stable); try &#123; //【×2.2】释放旧的引用！ ActivityManagerNative.getDefault().removeContentProvider( holder.connection, stable); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; else &#123; //【2.5.2】如果引用计数对象为 null，那就会创建引用计数对象，这里会分为稳定引用和不稳定引用！ ProviderClientRecord client = installProviderAuthoritiesLocked( provider, localProvider, holder); //【2.3.7】创建引用计数对象！ if (noReleaseNeeded) &#123; // 如果这个引用无需释放，那么会设置为 1000！ prc = new ProviderRefCount(holder, client, 1000, 1000); &#125; else &#123; prc = stable ? new ProviderRefCount(holder, client, 1, 0) : new ProviderRefCount(holder, client, 0, 1); &#125; // 将 Transport 和引用计数对象的映射关系保存到 mProviderRefCountMap 中！ mProviderRefCountMap.put(jBinder, prc); &#125; retHolder = prc.holder; &#125; &#125; //【3】返回创建的 Holder！ return retHolder;&#125; 在 ActivityThread 中有如下和 provider 相关的集合： 1234567891011//【1】用于保存 Transport 和对其他进程中的 provider 的引用计数 ProviderRefCount 的映射关系！final ArrayMap&lt;IBinder, ProviderRefCount&gt; mProviderRefCountMap = new ArrayMap&lt;IBinder, ProviderRefCount&gt;();//【2】用于保存 Transport 和 ProviderClientRecord 的映射关系！final ArrayMap&lt;IBinder, ProviderClientRecord&gt; mLocalProviders = new ArrayMap&lt;IBinder, ProviderClientRecord&gt;();//【3】用于保存 provide ComponentName 和 ProviderClientRecord 的映射关系！final ArrayMap&lt;ComponentName, ProviderClientRecord&gt; mLocalProvidersByName = new ArrayMap&lt;ComponentName, ProviderClientRecord&gt;(); 6.4.1 new ContentProvider创建 ContentProvider 实例，表示该进程中的 provider！ 1234567891011121314151617181920212223public abstract class ContentProvider implements ComponentCallbacks2 &#123; private static final String TAG = \"ContentProvider\"; private Context mContext = null; // provider 所在进程的上下文环境； private int mMyUid; // 所在进程 uid private String mAuthority; private String[] mAuthorities; private String mReadPermission; // 读权限 private String mWritePermission; // 写权限 private PathPermission[] mPathPermissions; // path 权限 private boolean mExported; // 是否 export 属性 private boolean mNoPerms; private boolean mSingleUser; // 是否是 single user private final ThreadLocal&lt;String&gt; mCallingPackage = new ThreadLocal&lt;String&gt;(); // 访问该 provider 的应用包名 private Transport mTransport = new Transport(); // 这个很重要，下面会分析！ public ContentProvider() &#123; &#125; ... ... ...&#125; 这里不多说！ 6.4.2 ContentProvider.getIContentProvider返回内部的一个 Transport 实例，该实例实现了 IContentProvider 接口！ 1234public IContentProvider getIContentProvider() &#123; //【*6.4.2.1】返回内部的 Transport 实例！ return mTransport;&#125; 6.4.2.1 new Transport123456class Transport extends ContentProviderNative &#123; AppOpsManager mAppOpsManager = null; int mReadOp = AppOpsManager.OP_NONE; int mWriteOp = AppOpsManager.OP_NONE; ... ... ...&#125; Transport 继承了 ContentProviderNative，其本质上是一个 Binder 对象，用于跨进程通信，作为 Binder 通信的服务端： 123456789101112131415161718192021222324252627282930313233abstract public class ContentProviderNative extends Binder implements IContentProvider &#123; public ContentProviderNative() &#123; attachInterface(this, descriptor); &#125; static public IContentProvider asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IContentProvider in = (IContentProvider)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ContentProviderProxy(obj); &#125; public abstract String getProviderName(); @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; ... ... ... // 省略这部分逻辑，后面再分析！ &#125; public IBinder asBinder() &#123; return this; // 返回的是自身！ &#125;&#125; 继续来看！！ 6.4.3 ContentProvider.attachInfo[2]-&gt;[3]attachInfo 方法的作用是，解析 provider 的属性！ 1234public void attachInfo(Context context, ProviderInfo info) &#123; //【1】调用三参数方法！ attachInfo(context, info, false);&#125; 继续分析：1234567891011121314151617181920212223242526private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123; mNoPerms = testing; if (mContext == null) &#123; //【1】将当前进程的 Context 保存到 mContext 中！ mContext = context; if (context != null) &#123; //【2】初始化内部 Transport 的 appOps 属性！ mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService( Context.APP_OPS_SERVICE); &#125; //【3】初始化 uid mMyUid = Process.myUid(); if (info != null) &#123; //【*6.4.3.1】解析 provider 的属性！ setReadPermission(info.readPermission); setWritePermission(info.writePermission); setPathPermissions(info.pathPermissions); mExported = info.exported; mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != 0; setAuthorities(info.authority); &#125; //【*6.4.3.2】拉起 provider 的 onCreate 方法！ ContentProvider.this.onCreate(); &#125;&#125; 6.4.3.1 parse attribute 读/写权限1234protected final void setReadPermission(@Nullable String permission) &#123; //【1】读权限； mReadPermission = permission;&#125; 1234protected final void setWritePermission(@Nullable String permission) &#123; //【1】写权限； mWritePermission = permission;&#125; Path 权限 1234protected final void setPathPermissions(@Nullable PathPermission[] permissions) &#123; //【1】path 权限； mPathPermissions = permissions;&#125; authority 权限 1234567891011protected final void setAuthorities(String authorities) &#123; if (authorities != null) &#123; if (authorities.indexOf(';') == -1) &#123; mAuthority = authorities; mAuthorities = null; &#125; else &#123; mAuthority = null; mAuthorities = authorities.split(\";\"); &#125; &#125;&#125; 不多说了！ 6.4.3.2 ContentProvider.onCreate - 生命周期方法 onCreate拉起 provider 的 onCreate 方法： 1public abstract boolean onCreate(); 当然，这个方法是抽象方法，因为我们 ContentProvider 这个类本身就是抽喜类，我们要实现自己的 provider 实例！！ 6.4.4 new ContentProviderHolder创建 ContentProviderHolder 对象！！ 1234567891011public static class ContentProviderHolder implements Parcelable &#123; public final ProviderInfo info; // provider 数据对象！ public IContentProvider provider; // 就是 Transport 对象！ public IBinder connection; // provider 连接对象！ public boolean noReleaseNeeded; public ContentProviderHolder(ProviderInfo _info) &#123; info = _info; &#125; ... ... ...&#125; 看到了 ContentProviderHolder 是实现了 Parcelable 接口，可以跨进程传输！！ 不多说，继续看： 6.4.5 installProviderAuthoritiesLocked处理 provider 的 authority 属性，同时创建 ProviderClientRecord 对象并返回： 12345678910111213141516171819202122232425262728private ProviderClientRecord installProviderAuthoritiesLocked(IContentProvider provider, ContentProvider localProvider, IActivityManager.ContentProviderHolder holder) &#123; //【1】获得 provider 的 authority 属性！ final String auths[] = holder.info.authority.split(\";\"); final int userId = UserHandle.getUserId(holder.info.applicationInfo.uid); // 应用程序的目标 userId //【*6.4.5.1】创建了 provider 对应的 ProviderClientRecord 对象！ final ProviderClientRecord pcr = new ProviderClientRecord( auths, provider, localProvider, holder); //【2】将该 provider 的 authority 和其 ProviderClientRecord 的映射关系，保存到 // mProviderMap 中！ for (String auth : auths) &#123; //【*6.4.5.2】创建 ProviderKey 对象！ final ProviderKey key = new ProviderKey(auth, userId); final ProviderClientRecord existing = mProviderMap.get(key); if (existing != null) &#123; //【2.1】已存在，就不会添加！ Slog.w(TAG, \"Content provider \" + pcr.mHolder.info.name + \" already published as \" + auth); &#125; else &#123; mProviderMap.put(key, pcr); &#125; &#125; //【3】返回 ProviderClientRecord 实例！ return pcr;&#125; 在 ActivityThread 中有一个 mProviderMap 哈希表：123//【1】保存该 authority 属性和其所属 provider 的 ProviderClientRecord 映射关系！final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap = new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;(); 继续看！ 6.4.5.1 new ProviderClientRecord创建 ProviderClientRecord 实例！ 123456789101112131415final class ProviderClientRecord &#123; final String[] mNames; // authority 属性！ final IContentProvider mProvider; // Transport 对象； final ContentProvider mLocalProvider; // ContentProvider 实例； final IActivityManager.ContentProviderHolder mHolder; // Holder 对象； ProviderClientRecord(String[] names, IContentProvider provider, ContentProvider localProvider, IActivityManager.ContentProviderHolder holder) &#123; mNames = names; mProvider = provider; mLocalProvider = localProvider; mHolder = holder; &#125;&#125; 不多说！！ 6.4.5.2 new ProviderKey创建 authority 属性对应的 ProviderKey 实例！ 12345678910private static final class ProviderKey &#123; final String authority; // authority 属性 final int userId; public ProviderKey(String authority, int userId) &#123; this.authority = authority; this.userId = userId; &#125; ... ... ...&#125; 不多说！ 6.4.6 incProviderRefLocked增加 provider 的引用计数， 参数 boolean stable 表示的是稳定引用，还是非稳定引用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private final void incProviderRefLocked(ProviderRefCount prc, boolean stable) &#123; //【1】stable 引用进入这里！ if (stable) &#123; prc.stableCount += 1; // 增加客户端引用计数 if (prc.stableCount == 1) &#123; int unstableDelta; if (prc.removePending) &#123; // 如果此时我们正在移除 provider，那就取消移除！ unstableDelta = -1; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef: stable \" + \"snatched provider from the jaws of death\"); &#125; prc.removePending = false; mH.removeMessages(H.REMOVE_PROVIDER, prc); &#125; else &#123; unstableDelta = 0; &#125; try &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef Now stable - \" + prc.holder.info.name + \": unstableDelta=\" + unstableDelta); &#125; //【*7.3】增加系统进程中 provider 的引用计数！ ActivityManagerNative.getDefault().refContentProvider( prc.holder.connection, 1, unstableDelta); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; else &#123; //【2】no stable 引用进入这里； prc.unstableCount += 1; // 增加客户端引用计数 if (prc.unstableCount == 1) &#123; if (prc.removePending) &#123; // 如果此时我们正在移除 provider，那就取消移除！ if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef: unstable \" + \"snatched provider from the jaws of death\"); &#125; prc.removePending = false; mH.removeMessages(H.REMOVE_PROVIDER, prc); &#125; else &#123; try &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"incProviderRef: Now unstable - \" + prc.holder.info.name); &#125; //【*7.3】增加系统进程中 provider 的引用计数！ ActivityManagerNative.getDefault().refContentProvider( prc.holder.connection, 0, 1); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; &#125;&#125; 可以看到，如果是第一次引用，那么会做一些额外的处理！ 6.4.7 new ProviderRefCount创建一个 provider 的引用计数对象： 123456789101112131415161718private static final class ProviderRefCount &#123; public final IActivityManager.ContentProviderHolder holder; public final ProviderClientRecord client; public int stableCount; public int unstableCount; // 如果为 true，那么 stable 和 unstable 的引用计数都为 0，同时 ams 准备移除引用计数 // 但是在 ams 中依然持有一个 unstable 的引用！ public boolean removePending; ProviderRefCount(IActivityManager.ContentProviderHolder inHolder, ProviderClientRecord inClient, int sCount, int uCount) &#123; holder = inHolder; client = inClient; stableCount = sCount; unstableCount = uCount; &#125;&#125; 先看到这里！ 7 ActivityManagerService - 系统进程2这里我们又从 provider 进程进入了系统进程！ 7.1 publishContentProviderspublishContentProviders 用于将 provider publish 到系统中！ 首先来看下 ActivityManagerNative 中的代码， 12345678910111213case PUBLISH_CONTENT_PROVIDERS_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); //【1】获得 provider 所在的进程的 ApplicationThreadProxy IApplicationThread app = ApplicationThreadNative.asInterface(b); //【2】这里是从 provider 的 Holder 对象！ ArrayList&lt;ContentProviderHolder&gt; providers = data.createTypedArrayList(ContentProviderHolder.CREATOR); //【3】调用 ams 的 publishContentProviders 方法！ publishContentProviders(app, providers); reply.writeNoException(); return true;&#125; 接着，进入了 ActivityManagerService 中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public final void publishContentProviders(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers) &#123; if (providers == null) &#123; return; &#125; enforceNotIsolatedCaller(\"publishContentProviders\"); synchronized (this) &#123; //【1】获得 provider 所在的进程 ProcessRecord！ final ProcessRecord r = getRecordForAppLocked(caller); if (DEBUG_MU) Slog.v(TAG_MU, \"ProcessRecord uid = \" + r.uid); if (r == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when publishing content providers\"); &#125; final long origId = Binder.clearCallingIdentity(); final int N = providers.size(); for (int i = 0; i &lt; N; i++) &#123; ContentProviderHolder src = providers.get(i); if (src == null || src.info == null || src.provider == null) &#123; continue; &#125; //【2】我们知道 provider 对应的 ContentProviderRecord 在前面就已经添加到 r.pubProviders 中了！ ContentProviderRecord dst = r.pubProviders.get(src.info.name); if (DEBUG_MU) Slog.v(TAG_MU, \"ContentProviderRecord uid = \" + dst.uid); if (dst != null) &#123; //【2.1】将 ContentProviderRecord 实例添加到 ProviderMap 中！ ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name); mProviderMap.putProviderByClass(comp, dst); String names[] = dst.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; mProviderMap.putProviderByName(names[j], dst); &#125; int launchingCount = mLaunchingProviders.size(); int j; //【2.2】判断其是否在 mLaunchingProviders 中，如果有，那就从中移除！ boolean wasInLaunchingProviders = false; for (j = 0; j &lt; launchingCount; j++) &#123; if (mLaunchingProviders.get(j) == dst) &#123; mLaunchingProviders.remove(j); wasInLaunchingProviders = true; j--; launchingCount--; &#125; &#125; //【2.3】移除 provider publish 超时消息！ if (wasInLaunchingProviders) &#123; mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r); &#125; synchronized (dst) &#123; //【2.4】更新 ContentProviderRecord 中的属性，包括 dst.provider 等等！ dst.provider = src.provider; dst.proc = r; //【important】这里调用了 Object.notifyAll 方法，唤醒在等待队列中等待的 Binder 线程 // 这里就回到了 5.1 getContentProvider[Impl] 方法中了！ dst.notifyAll(); &#125; // 更新进程的优先级！ updateOomAdjLocked(r); // 更新进程的使用情况！ maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125; 不多说了！ 7.2 removeContentProvider减少系统进程中的 provider 的引用计数！ 123456789case REMOVE_CONTENT_PROVIDER_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); boolean stable = data.readInt() != 0; //【1】调用了 removeContentProvider 方法！ removeContentProvider(b, stable); reply.writeNoException(); return true;&#125; 继续来看：123456789101112131415161718192021222324252627public void removeContentProvider(IBinder connection, boolean stable) &#123; enforceNotIsolatedCaller(\"removeContentProvider\"); long ident = Binder.clearCallingIdentity(); try &#123; synchronized (this) &#123; ContentProviderConnection conn; try &#123; //【1】获得 ContentProviderConnection 连接对象！ conn = (ContentProviderConnection)connection; &#125; catch (ClassCastException e) &#123; String msg =\"removeContentProvider: \" + connection + \" not a ContentProviderConnection\"; Slog.w(TAG, msg); throw new IllegalArgumentException(msg); &#125; if (conn == null) &#123; throw new NullPointerException(\"connection is null\"); &#125; //【×5.1.1.7】减少对 provider 的引用计数！ if (decProviderCountLocked(conn, null, null, stable)) &#123; updateOomAdjLocked(); // 调整进程优先级！ &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 这里就不多说了！ 7.3 refContentProvider增加系统进程中的 provider 的引用计数！ 123456789101112131415public boolean refContentProvider(IBinder connection, int stable, int unstable) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(connection); data.writeInt(stable); data.writeInt(unstable); mRemote.transact(REF_CONTENT_PROVIDER_TRANSACTION, data, reply, 0); reply.readException(); boolean res = reply.readInt() != 0; data.recycle(); reply.recycle(); return res;&#125; 继续来看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean refContentProvider(IBinder connection, int stable, int unstable) &#123; //【1】获得 ContentProviderConnection 连接对象！ ContentProviderConnection conn; try &#123; conn = (ContentProviderConnection)connection; &#125; catch (ClassCastException e) &#123; String msg =\"refContentProvider: \" + connection + \" not a ContentProviderConnection\"; Slog.w(TAG, msg); throw new IllegalArgumentException(msg); &#125; if (conn == null) &#123; throw new NullPointerException(\"connection is null\"); &#125; synchronized (this) &#123; if (stable &gt; 0) &#123; // 统计总的引用数，debug 用不关注！ conn.numStableIncs += stable; &#125; //【2】调整 stable connect 计数！ stable = conn.stableCount + stable; if (stable &lt; 0) &#123; throw new IllegalStateException(\"stableCount &lt; 0: \" + stable); &#125; if (unstable &gt; 0) &#123; // 统计总的引用数，debug 用不关注！ conn.numUnstableIncs += unstable; &#125; //【3】调整 unstable connect 计数！ unstable = conn.unstableCount + unstable; if (unstable &lt; 0) &#123; throw new IllegalStateException(\"unstableCount &lt; 0: \" + unstable); &#125; if ((stable+unstable) &lt;= 0) &#123; throw new IllegalStateException(\"ref counts can't go to zero here: stable=\" + stable + \" unstable=\" + unstable); &#125; //【4】更新 ContentProviderConnection 中的引用计数！ conn.stableCount = stable; conn.unstableCount = unstable; return !conn.dead; &#125;&#125; 不多说了！ 7.4 unstableProviderDied处理 unstable provider 进程的死亡后事： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void unstableProviderDied(IBinder connection) &#123; ContentProviderConnection conn; try &#123; //【1】获得引用的连接对象！ conn = (ContentProviderConnection)connection; &#125; catch (ClassCastException e) &#123; String msg =\"refContentProvider: \" + connection + \" not a ContentProviderConnection\"; Slog.w(TAG, msg); throw new IllegalArgumentException(msg); &#125; if (conn == null) &#123; throw new NullPointerException(\"connection is null\"); &#125; //【2】获得该 conn 对象绑定着的 provider，这里是返回 provider 内部的 Transport 实例！ IContentProvider provider; synchronized (this) &#123; provider = conn.provider.provider; &#125; if (provider == null) &#123; return; &#125; //【3】判读客户端的连接是否仍然存在，如果是，那就直接返回！ if (provider.asBinder().pingBinder()) &#123; synchronized (this) &#123; Slog.w(TAG, \"unstableProviderDied: caller \" + Binder.getCallingUid() + \" says \" + conn + \" died, but we don't agree\"); return; &#125; &#125; //【4】从处理进程死亡的后事！ synchronized (this) &#123; //【4.1】发生了神奇的变化，返回！ if (conn.provider.provider != provider) &#123; return; &#125; //【4.2】如果进程已经被清理了，那就返回！ ProcessRecord proc = conn.provider.proc; if (proc == null || proc.thread == null) &#123; return; &#125; Slog.i(TAG, \"Process \" + proc.processName + \" (pid \" + proc.pid + \") early provider death\"); final long ident = Binder.clearCallingIdentity(); try &#123; //【4.3】处理进程的死亡后事！ appDiedLocked(proc); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125;&#125; 不多说了！ 8 总结我们来看下 provider 相关的类图：","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"ContentProvider内容提供者","slug":"AndroidFramework源码分析/ContentProvider内容提供者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/ContentProvider内容提供者/"}],"tags":[{"name":"ContentProvider内容提供者","slug":"ContentProvider内容提供者","permalink":"https://coolqi.top/tags/ContentProvider内容提供者/"}]},{"title":"PMS 第 5 篇 - PMS_SCAN_END 阶段","slug":"PMS5-PMS_SCAN_END","date":"2018-03-02T16:00:00.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/03/03/PMS5-PMS_SCAN_END/","link":"","permalink":"https://coolqi.top/2018/03/03/PMS5-PMS_SCAN_END/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现，本文是作者原创，转载请说明出处！ 0 综述system 分区和 data 分区的扫描过程到这里就结束了，下面我们来分析下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100... ... ... ...// 第四阶段EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());Slog.i(TAG, \"Time to scan packages: \" + ((SystemClock.uptimeMillis()-startTime)/1000f) + \" seconds\");// 如果从我们上次启动，SDK 平台被改变了，我们需要重新授予应用程序权限。// 这里会有一些安全问题，就是可能会有应用通过这种方式获取那些用户没有显式允许的权限// 这里可能后续 google 会改善！int updateFlags = UPDATE_PERMISSIONS_ALL;if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \" + mSdkVersion + \"; regranting permissions for internal storage\"); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;&#125;//【1】更新系统中的权限和权限树，移除无效的权限和权限树，同时更新应用的权限授予情况！updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);ver.sdkVersion = mSdkVersion;//【2】如果这是第一次开机或从 Anroid M之前的版本升级上来的，然后我们需要初始化默认应用程序给所有的系统用户！if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123; for (UserInfo user : sUserManager.getUsers(true)) &#123; mSettings.applyDefaultPreferredAppsLPw(this, user.id); applyFactoryDefaultBrowserLPw(user.id); primeDomainVerificationsLPw(user.id); &#125;&#125;//【3】在启动完成前，为系统用户准备文件存储，因为很多核心的系统比如设置，系统界面等等会提前启动！final int storageFlags;if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123; storageFlags = StorageManager.FLAG_STORAGE_DE;&#125; else &#123; storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;&#125;reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM, storageFlags);//【4】如果这是在 OTA 升级后第一次正常启动，然后我们需要清除代码缓存目录。// 我们这里使用了 Installer.FLAG_CLEAR_CODE_CACHE_ONLY 标志位；if (mIsUpgrade &amp;&amp; !onlyCore) &#123; Slog.i(TAG, \"Build fingerprint changed; clearing code caches\"); for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123; final PackageSetting ps = mSettings.mPackages.valueAt(i); if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123; clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); &#125; &#125; ver.fingerprint = Build.FINGERPRINT;&#125;checkDefaultBrowser(); // 检查默认的浏览器// 当权限和其他默认设置被更新后，执行清除操作！mExistingSystemPackages.clear();mPromoteSystemApps = false;// 更新系统数据库版本号！ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;//【5】信息写回 packages.xml 等文件！mSettings.writeLPr();//【6】如果是第一次开机，或者是系统升级，对核心的系统应用执行 odex 操作！if ((isFirstBoot() || isUpgrade() || VMRuntime.didPruneDalvikCache()) &amp;&amp; !onlyCore) &#123; long start = System.nanoTime(); List&lt;PackageParser.Package&gt; coreApps = new ArrayList&lt;&gt;(); for (PackageParser.Package pkg : mPackages.values()) &#123; if (pkg.coreApp) &#123; coreApps.add(pkg); &#125; &#125; int[] stats = performDexOptUpgrade(coreApps, false, getCompilerFilterForReason(REASON_CORE_APP)); final int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start); MetricsLogger.histogram(mContext, \"opt_coreapps_time_s\", elapsedTimeSeconds); if (DEBUG_DEXOPT) &#123; Slog.i(TAG, \"Dex-opt core apps took : \" + elapsedTimeSeconds + \" seconds (\" + stats[0] + \", \" + stats[1] + \", \" + stats[2] + \")\"); &#125; // TODO: Should we log these stats to tron too ? // MetricsLogger.histogram(mContext, \"opt_coreapps_num_dexopted\", stats[0]); // MetricsLogger.histogram(mContext, \"opt_coreapps_num_skipped\", stats[1]); // MetricsLogger.histogram(mContext, \"opt_coreapps_num_failed\", stats[2]); // MetricsLogger.histogram(mContext, \"opt_coreapps_num_total\", coreApps.size());&#125;... ... ... ...// 见，第五阶段 下面我们来分析下这个过程！ 1 PackageMS.updatePermissionsLPw - 更新权限信息updatePermissionsLPw 方法用于更新应用的权限信息，首先我们来看看 updateFlags！ 12345678int updateFlags = UPDATE_PERMISSIONS_ALL; // 表示更新所有的权限信息；if (ver.sdkVersion != mSdkVersion) &#123; // 如果 sdkVersion 发生了变化，还会额外的设置以下的 2 个权限！ // sdkVersion 发生变化一般是在大版本系统升级时，比如 7.1 升级 8.0！ Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \" + mSdkVersion + \"; regranting permissions for internal storage\"); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;&#125; updatePermissionsLPw 的逻辑如下，这里的 changingPkg 和 pkgInfo 均为 null； replaceVolumeUuid 的值为：StorageManager.UUID_PRIVATE_INTERNAL，表示的是安装位置，这里传入的值表示内置存储； （这里简单的说一下参数的意思：String changingPkg 指定了权限发生变化的包名，PackageParser.Package pkgInfo 表示的是 changingPkg 对应的应用的信息） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107private void updatePermissionsLPw(String changingPkg, PackageParser.Package pkgInfo, String replaceVolumeUuid, int flags) &#123; //【1】确保系统中没有废弃的权限树； Iterator&lt;BasePermission&gt; it = mSettings.mPermissionTrees.values().iterator(); while (it.hasNext()) &#123; final BasePermission bp = it.next(); if (bp.packageSetting == null) &#123; //【1.1】如果 packageSetting 为 null，尝试查找定义的 package！ bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage); &#125; if (bp.packageSetting == null) &#123; //【1.2】如果找不到定义该权限的 package，那就移除该 permission-tree！ Slog.w(TAG, \"Removing dangling permission tree: \" + bp.name + \" from package \" + bp.sourcePackage); it.remove(); &#125; else if (changingPkg != null &amp;&amp; changingPkg.equals(bp.sourcePackage)) &#123; //【1.3】根据参数，不进入这里，但是我们来分析下这部分代码的意思 // 如果权限的定义者不再定义这个权限了，那就移除该权限的上一次信息！ if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) &#123; Slog.i(TAG, \"Removing old permission tree: \" + bp.name + \" from package \" + bp.sourcePackage); //【1.3.1】同时 flags 会被设置 UPDATE_PERMISSIONS_ALL 标志位！ flags |= UPDATE_PERMISSIONS_ALL; it.remove(); &#125; &#125; &#125; //【2】确保系统中所有的动态权限都已经分配给对应的 package，同时系统中也没有废弃的权限! it = mSettings.mPermissions.values().iterator(); while (it.hasNext()) &#123; final BasePermission bp = it.next(); //【2.1】如果是动态权限，尝试找到其所属的 permission-tree，并绑定到定义 tree 的 package 上！ if (bp.type == BasePermission.TYPE_DYNAMIC) &#123; if (DEBUG_SETTINGS) Log.v(TAG, \"Dynamic permission: name=\" + bp.name + \" pkg=\" + bp.sourcePackage + \" info=\" + bp.pendingInfo); if (bp.packageSetting == null &amp;&amp; bp.pendingInfo != null) &#123; final BasePermission tree = findPermissionTreeLP(bp.name); if (tree != null &amp;&amp; tree.perm != null) &#123; bp.packageSetting = tree.packageSetting; bp.perm = new PackageParser.Permission(tree.perm.owner, new PermissionInfo(bp.pendingInfo)); bp.perm.info.packageName = tree.perm.info.packageName; bp.perm.info.name = bp.name; bp.uid = tree.uid; &#125; &#125; &#125; //【2.2】如果权限的定义者为 null，尝试在系统中找到定义者！ if (bp.packageSetting == null) &#123; bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage); &#125; //【2.3】如果依然找不到定义该权限的 package，那就移除该 permission ！ if (bp.packageSetting == null) &#123; // 该权限无效，移除它！ Slog.w(TAG, \"Removing dangling permission: \" + bp.name + \" from package \" + bp.sourcePackage); it.remove(); &#125; else if (changingPkg != null &amp;&amp; changingPkg.equals(bp.sourcePackage)) &#123; //【2.4】根据参数，不进入这里，但是我们来分析下这部分代码的意思 // 如果权限的定义者不在定义这个权限了，那就移除该权限的上一次信息！ if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) &#123; Slog.i(TAG, \"Removing old permission: \" + bp.name + \" from package \" + bp.sourcePackage); //【2.4.1】同时 flags 会被设置 UPDATE_PERMISSIONS_ALL 标志位！ flags |= UPDATE_PERMISSIONS_ALL; it.remove(); &#125; &#125; &#125; //【3】如果 flags 设置了 UPDATE_PERMISSIONS_ALL 标志位，那么就更新除了 changingPkg 以外的其他 // 所有的 package 的权限授予信息 ，特别是替换系统包的授予权限！ if ((flags &amp; UPDATE_PERMISSIONS_ALL) != 0) &#123; for (PackageParser.Package pkg : mPackages.values()) &#123; if (pkg != pkgInfo) &#123; //【3.1】获得该应用的安装位置，我们只会修改安装在 replaceVolumeUuid 指定的位置的应用的权限信息！ // 当然默认是在内置存储，所以返回的是 UUID_PRIVATE_INTERNAL！ final String volumeUuid = getVolumeUuidForPackage(pkg); // 如果 sdk 发生了变化，replace 为 true！ final boolean replace = ((flags &amp; UPDATE_PERMISSIONS_REPLACE_ALL) != 0) &amp;&amp; Objects.equals(replaceVolumeUuid, volumeUuid); //【×1.2】重新授予其他 pkg 权限！ grantPermissionsLPw(pkg, replace, changingPkg); &#125; &#125; &#125; //【4】因为这里 pkgInfo 为 null，所以不进入这里！ // 这里的逻辑是，如果 changingPkg 不为 null，最后也会更新其权限的授予信息！ if (pkgInfo != null) &#123; //【4.1】获得该应用的安装位置，我们只会修改安装在 replaceVolumeUuid 指定的位置的应用的权限信息！ // 当然默认是在内置存储，所以返回的是 UUID_PRIVATE_INTERNAL！ final String volumeUuid = getVolumeUuidForPackage(pkgInfo); // 如果 sdk 发生了变化，replace 为 true！ final boolean replace = ((flags &amp; UPDATE_PERMISSIONS_REPLACE_PKG) != 0) &amp;&amp; Objects.equals(replaceVolumeUuid, volumeUuid); //【×1.2】重新授予发生 change 的 pkg 权限！ grantPermissionsLPw(pkgInfo, replace, changingPkg); &#125;&#125; 由于这里的 changingPkg 和 pkgInfo 均为 null，所以不仅移除了无效的权限和权限树，而且更新了系统中所有应用的权限信息！ 这里涉及到了 flags 标志位，可以取以下值： 123static final int UPDATE_PERMISSIONS_ALL = 1&lt;&lt;0; // 更新所有应用的权限信息；static final int UPDATE_PERMISSIONS_REPLACE_PKG = 1&lt;&lt;1;static final int UPDATE_PERMISSIONS_REPLACE_ALL = 1&lt;&lt;2; 下面的分析过程中会遇到： 我们继续分析！ 1.1 PackageMS.findPermissionTreeLP找到权限名所属的权限树！12345678910private BasePermission findPermissionTreeLP(String permName) &#123; for(BasePermission bp : mSettings.mPermissionTrees.values()) &#123; if (permName.startsWith(bp.name) &amp;&amp; permName.length() &gt; bp.name.length() &amp;&amp; permName.charAt(bp.name.length()) == '.') &#123; return bp; &#125; &#125; return null;&#125; 1.2 PackageMS.grantPermissionsLPw在更新过权限后，会再次授予应用权限，因为可能有些权限已经失效并且被移除！ Android 系统有两种类型的权限：安装和运行时，dangerous 属于运行时权限，normal 和 signiture 属于安装时权限。 正常和签名保护级别的权限是安装时权限。 而危险级别的权限是运行时权限！ 如果应用的目标 SDK 为 Lollipop MR1 或更早版本，则运行时权限默认按照安装时权限处理。根据上面的代码跟踪 这里的 replace 为 true，由于我们是更新所有的 pacakge，所以 pkg 和 packageOfInterest 均为 null，参数 pkg 是需要更新权限授予信息的应用！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace, String packageOfInterest) &#123; //【1】如果该应用的 PackageSetting 没有，那么不处理！ final PackageSetting ps = (PackageSetting) pkg.mExtras; if (ps == null) &#123; return; &#125; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"grantPermissions\"); //【2】获得该 package 的权限管理对象，此时这个权限管理对象是解析上次安装信息时恢复的！ // 我们将其保存到 origPermissions 中，作为原始数据！ PermissionsState permissionsState = ps.getPermissionsState(); PermissionsState origPermissions = permissionsState; final int[] currentUserIds = UserManagerService.getInstance().getUserIds(); boolean runtimePermissionsRevoked = false; int[] changedRuntimePermissionUserIds = EMPTY_INT_ARRAY; boolean changedInstallPermission = false; //【3】如果 replace 的值为 true，进入这里！ if (replace) &#123; // 设置 installPermissionsFixed 为 false，因为下面会对权限信息调整！ ps.installPermissionsFixed = false; if (!ps.isSharedUser()) &#123; //【3.1】如果该 package 不是共享 uid 的，那就重置 permissionsState，但是会将 // 原始信息 copy到 origPermissions 中！ origPermissions = new PermissionsState(permissionsState); permissionsState.reset(); &#125; else &#123; //【3.2】如果该 package 是共享 uid 的，那么我们会拒绝那些不用的共享 uid 相关权限信息！ // （我们只需要知道运行时权限更改，因为调用代码总是写入安装权限状态，但是运行时权限只有在更改时才写入。 // 这里更改运行时权限的唯一情况是将安装提升到运行时并从共享用户撤消运行时。） // 上面这段文字是根据注释翻译的，生涩，目前我自己也不是很明白。。。 changedRuntimePermissionUserIds = revokeUnusedSharedUserPermissionsLPw( ps.sharedUser, UserManagerService.getInstance().getUserIds()); if (!ArrayUtils.isEmpty(changedRuntimePermissionUserIds)) &#123; runtimePermissionsRevoked = true; &#125; &#125; &#125; permissionsState.setGlobalGids(mGlobalGids); //【4】处理该 package 请求的所有权限！ final int N = pkg.requestedPermissions.size(); for (int i=0; i &lt; N; i++) &#123; final String name = pkg.requestedPermissions.get(i); final BasePermission bp = mSettings.mPermissions.get(name); if (DEBUG_INSTALL) &#123; Log.i(TAG, \"Package \" + pkg.packageName + \" checking \" + name + \": \" + bp); &#125; //【4.1】如果该权限没有定义，那么跳过！！ if (bp == null || bp.packageSetting == null) &#123; if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Unknown permission \" + name + \" in package \" + pkg.packageName); &#125; continue; &#125; final String perm = bp.name; boolean allowedSig = false; int grant = GRANT_DENIED; // 用于保存每个权限的授予情况！ //【4.2】如果申请的权限设置了 PROTECTION_FLAG_APPOP 标志位， // 我们会将其添加到 mAppOpPermissionPackages 进行监控！ if ((bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; ArraySet&lt;String&gt; pkgs = mAppOpPermissionPackages.get(bp.name); if (pkgs == null) &#123; pkgs = new ArraySet&lt;&gt;(); mAppOpPermissionPackages.put(bp.name, pkgs); &#125; pkgs.add(pkg.packageName); &#125; //【4.3】计算权限的基本类型，并判断应用是否支持运行时权限！！！ final int level = bp.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE; final boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.M; //【4.4】根据权限的基本类型，判断权限的授予情况！！ switch (level) &#123; case PermissionInfo.PROTECTION_NORMAL: &#123; //【4.4.1】基本类型为 normal，为安装时权限，默认授予！ grant = GRANT_INSTALL; &#125; break; case PermissionInfo.PROTECTION_DANGEROUS: &#123; //【4.4.2】基本类型为 dangerous，那么我们要分不同的情况！！ if (!appSupportsRuntimePermissions &amp;&amp; !Build.PERMISSIONS_REVIEW_REQUIRED) &#123; //【4.4.2.1】如果 legacy apps，同时也不需要在组件启动之前重新 review 权限 // 说明应用的 targetSDKVersion &lt; 23 是 legacy apps，那么运行时权限视为安装时权限； grant = GRANT_INSTALL; &#125; else if (origPermissions.hasInstallPermission(bp.name)) &#123; //【4.4.2.2】如果应用支持安装是权限，或者需要在组件启动之前重新 review 权限 // 并且该运行时权限之前是属于安装时权限，那么就要升级为运行时权限（系统升级会出现） grant = GRANT_UPGRADE; &#125; else if (mPromoteSystemApps &amp;&amp; isSystemApp(ps) &amp;&amp; mExistingSystemPackages.contains(ps.name)) &#123; //【4.4.2.3】如果是从 API 22 升级上来的话，对于 Promote System Apps， // 那么安装时权限就要升级为运行时权限； grant = GRANT_UPGRADE; &#125; else &#123; //【4.4.2.4】其他情况，直接视为安装时权限！ grant = GRANT_RUNTIME; &#125; &#125; break; case PermissionInfo.PROTECTION_SIGNATURE: &#123; //【4.4.3】基本类型为 signature 的权限，需要校验签名！！ //【*1.2.2-important】校验签名是否匹配，如果是的话，是为安装时权限！ allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions); if (allowedSig) &#123; // 如果签名校验通过，直接视为安装时权限！ grant = GRANT_INSTALL; &#125; &#125; break; &#125; if (DEBUG_INSTALL) &#123; Log.i(TAG, \"Package \" + pkg.packageName + \" granting \" + perm); &#125; //【4.5】处理授予情况，如果授予情况不是拒绝 GRANT_DENIED，进入 IF 分支； // 如果授予情况是拒绝 GRANT_DENIED，进入 ELSE 分支！ if (grant != GRANT_DENIED) &#123; if (!isSystemApp(ps) &amp;&amp; ps.installPermissionsFixed) &#123; //【4.5.1】如果这是一个已经被安装了的非系统的应用，同时本次申请的权限之前不属于安装时权限 // 除非该权限属于 new platform permission 不然的话，我们是不会授予他这个权限的； if (!allowedSig &amp;&amp; !origPermissions.hasInstallPermission(perm)) &#123; if (!isNewPlatformPermissionForPackage(perm, pkg)) &#123; grant = GRANT_DENIED; &#125; &#125; &#125; //【4.5.2】处理权限的授予状态！ switch (grant) &#123; case GRANT_INSTALL: &#123; // 处理安装时权限； //【4.5.2.1.1】首先，判断该权限之前是否是运行时权限，如果是的话，那就要撤销之前的授予！ for (int userId : UserManagerService.getInstance().getUserIds()) &#123; if (origPermissions.getRuntimePermissionState( bp.name, userId) != null) &#123; // 撤销权限，并取消所有的标志位； origPermissions.revokeRuntimePermission(bp, userId); origPermissions.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, 0); // 将运行时权限授予状态发生变化的 userId 记录下来，后面用于持久化数据！ changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; //【4.5.2.1.2】授予安装时权限； if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; changedInstallPermission = true; &#125; &#125; break; case GRANT_RUNTIME: &#123; // 处理运行时权限； //【4.5.2.1.3】授予之前被授予的运行时权限； for (int userId : UserManagerService.getInstance().getUserIds()) &#123; //【4.5.2.1.3.1】获得每个 userId 下的该运行时权限对象和其 flags； PermissionState permissionState = origPermissions .getRuntimePermissionState(bp.name, userId); int flags = permissionState != null ? permissionState.getFlags() : 0; //【4.5.2.1.3.2】如果本次授予的权限是已经申请的，那么我们就再次授予！ if (origPermissions.hasRuntimePermission(bp.name, userId)) &#123; //【4.5.2.1.3.2.1】授予运行时权限，如果失败的话，意味着本次无法授予，那就更新 // changedRuntimePermissionUserIds 列表； if (permissionsState.grantRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; //【4.5.2.1.3.2.2】如果应用支持运行时权限，该权限之前是需要 review 的 // 那么这里会取消 review 的标志位！ if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; appSupportsRuntimePermissions &amp;&amp; (flags &amp; PackageManager .FLAG_PERMISSION_REVIEW_REQUIRED) != 0) &#123; flags &amp;= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED; // 标志位变了，那就更新 changedRuntimePermissionUserIds 列表； changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; else if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; !appSupportsRuntimePermissions) &#123; //【4.5.2.1.3.2】如果应用不支持运行时权限，但是系统需要权限 review // 每一个被授予的新的运行时权限，都要被 review！ // 如果是系统权限，强制增加 FLAG_PERMISSION_REVIEW_REQUIRED 标志位 if (PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage)) &#123; if ((flags &amp; FLAG_PERMISSION_REVIEW_REQUIRED) == 0) &#123; flags |= FLAG_PERMISSION_REVIEW_REQUIRED; // 标志位变了，那就更新 changedRuntimePermissionUserIds 列表； changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; // 授予这个新的运行时权限，如果授予失败，更新 changedRuntimePermissionUserIds 列表； if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; //【4.5.2.1.3.2.1】更新权限的 flags！ permissionsState.updatePermissionFlags(bp, userId, flags, flags); &#125; &#125; break; case GRANT_UPGRADE: &#123; // 处理安装时权限升级为运行时权限 //【4.5.2.1.4】授予安装时升级为运行时的权限； // 获得权限管理对象和 flags； PermissionState permissionState = origPermissions .getInstallPermissionState(bp.name); final int flags = permissionState != null ? permissionState.getFlags() : 0; //【4.5.2.1.4.1】撤销之前的安装时权限，并清空 flags； if (origPermissions.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; origPermissions.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0); changedInstallPermission = true; &#125; //【4.5.2.1.4.2】如果该权限没有设置 FLAG_PERMISSION_REVOKE_ON_UPGRADE， // 表示在升级后可以授予，那么我们就授予运行时权限； if ((flags &amp; PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) &#123; for (int userId : currentUserIds) &#123; if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; // 将旧的 flags 更新到运行时权限； permissionsState.updatePermissionFlags(bp, userId, flags, flags); // 标志位变了，那就更新 changedRuntimePermissionUserIds 列表； changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; &#125; &#125; break; default: &#123; if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Not granting permission \" + perm + \" to package \" + pkg.packageName + \" because it was previously installed without\"); &#125; &#125; break; &#125; &#125; else &#123; //【4.6】处理撤销情况，撤销该权限，同时清空所有的标志位； if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; // 清空标志位； permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0); changedInstallPermission = true; Slog.i(TAG, \"Un-granting permission \" + perm + \" from package \" + pkg.packageName + \" (protectionLevel=\" + bp.protectionLevel + \" flags=0x\" + Integer.toHexString(pkg.applicationInfo.flags) + \")\"); &#125; else if ((bp.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) == 0) &#123; //【4.6.1】如果撤销失败，但是该权限和一个 appOp 相关联，这种情况可以不处理。因为 // 对于这类权限，我们不处理，因为我们会通过 appOps 进行控制，通过 ui 给用户选择； if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Not granting permission \" + perm + \" to package \" + pkg.packageName + \" (protectionLevel=\" + bp.protectionLevel + \" flags=0x\" + Integer.toHexString(pkg.applicationInfo.flags) + \")\"); &#125; &#125; &#125; &#125; if ((changedInstallPermission || replace) &amp;&amp; !ps.installPermissionsFixed &amp;&amp; !isSystemApp(ps) || isUpdatedSystemApp(ps))&#123; // 这是我们第一次听说过这个包，所以我们现在选择的权限是固定的，直到明确更改为止。 // （没看懂这段逻辑...） ps.installPermissionsFixed = true; &#125; //【5】持久化变化调整后的运行时权限数据！ for (int userId : changedRuntimePermissionUserIds) &#123; mSettings.writeRuntimePermissionsForUserLPr(userId, runtimePermissionsRevoked); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);&#125; 1.2.1 PackageMS.revokeUnusedSharedUserPermissionsLPw撤销不再使用的共享用户权限； 参数 SharedUserSetting su 表示的是共享 uid 的信息对象！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private int[] revokeUnusedSharedUserPermissionsLPw(SharedUserSetting su, int[] allUserIds) &#123; //【1】收集该 shared user 下的所有被请求的权限！ ArraySet&lt;String&gt; usedPermissions = new ArraySet&lt;&gt;(); final int packageCount = su.packages.size(); for (int i = 0; i &lt; packageCount; i++) &#123; PackageSetting ps = su.packages.valueAt(i); if (ps.pkg == null) &#123; continue; &#125; final int requestedPermCount = ps.pkg.requestedPermissions.size(); for (int j = 0; j &lt; requestedPermCount; j++) &#123; String permission = ps.pkg.requestedPermissions.get(j); BasePermission bp = mSettings.mPermissions.get(permission); if (bp != null) &#123; usedPermissions.add(permission); &#125; &#125; &#125; //【2】获得该 shared user 的权限管理对象！! PermissionsState permissionsState = su.getPermissionsState(); //【3】撤销那些本次不再申请，但是之前申请了的安装时权限！! List&lt;PermissionState&gt; installPermStates = permissionsState.getInstallPermissionStates(); final int installPermCount = installPermStates.size(); for (int i = installPermCount - 1; i &gt;= 0; i--) &#123; PermissionState permissionState = installPermStates.get(i); if (!usedPermissions.contains(permissionState.getName())) &#123; BasePermission bp = mSettings.mPermissions.get(permissionState.getName()); if (bp != null) &#123; //【3.1】撤销权限，移除所有标志位； permissionsState.revokeInstallPermission(bp); permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0); &#125; &#125; &#125; int[] runtimePermissionChangedUserIds = EmptyArray.INT; //【4】撤销那些本次不再申请，但是之前申请了的运行时权限！! for (int userId : allUserIds) &#123; List&lt;PermissionState&gt; runtimePermStates = permissionsState .getRuntimePermissionStates(userId); final int runtimePermCount = runtimePermStates.size(); for (int i = runtimePermCount - 1; i &gt;= 0; i--) &#123; PermissionState permissionState = runtimePermStates.get(i); if (!usedPermissions.contains(permissionState.getName())) &#123; BasePermission bp = mSettings.mPermissions.get(permissionState.getName()); if (bp != null) &#123; //【4.1】撤销权限，移除所有标志位； permissionsState.revokeRuntimePermission(bp, userId); permissionsState.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, 0); //【4.2】返回该运行时权限所在的 userId； runtimePermissionChangedUserIds = ArrayUtils.appendInt( runtimePermissionChangedUserIds, userId); &#125; &#125; &#125; &#125; //【5】返回该运行时权限所在的 userId； return runtimePermissionChangedUserIds;&#125; runtimePermissionChangedUserIds 用于持久化运行时数据库； ###1.2.2 PackageMS.grantSignaturePermission grantSignaturePermission 方法用于判断签名是否能校验通过，我们在这里先忽略掉签名校验的过程，假设要么校验成功，要么校验失败！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private boolean grantSignaturePermission(String perm, PackageParser.Package pkg, BasePermission bp, PermissionsState origPermissions) &#123; boolean allowed; //【1】判断应用的签名和权限定义者签名或者平台签名是否匹配！ allowed = (compareSignatures( bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (compareSignatures(mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH); //【2】如果和权限定义者签名或者平台签名不匹配，并且该权限是 PRIVILEGED 的，进行进一步的判断！ if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) &#123; if (isSystemApp(pkg)) &#123; // 对于 PRIVILEGED 类型的权限，首先必须是系统应用！ //【2.1】如果该应用是一个被更新过的系统应用，那么只有更新前的旧 apk 被授予了这个权限， // 新的 apk 才能被授予这个权限！ if (pkg.isUpdatedSystemApp()) &#123; // 获得更新前的安装数据(system)！ final PackageSetting sysPs = mSettings .getDisabledSystemPkgLPr(pkg.packageName); if (sysPs != null &amp;&amp; sysPs.getPermissionsState().hasInstallPermission(perm)) &#123; //【2.1.1】如果更新前，其已经被授予了该权限，并且其是一个特权应用， // 那么本次也允许授予！！ if (sysPs.isPrivileged()) &#123; allowed = true; &#125; &#125; else &#123; //【2.1.2】如果更新前，并没有被授予该权限，该权限是更新后新申请的权限！ // 那就要看之前是否有请求该权限，只有请求了该权限，才允许授予； if (sysPs != null &amp;&amp; sysPs.pkg != null &amp;&amp; sysPs.isPrivileged()) &#123; for (int j = 0; j &lt; sysPs.pkg.requestedPermissions.size(); j++) &#123; if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) &#123; allowed = true; break; &#125; &#125; &#125; // 此外，如果系统映像上的特权父包或其父包任何子代请求特权权限，则更新的子包也可以获得该许可。 if (pkg.parentPackage != null) &#123; final PackageSetting disabledSysParentPs = mSettings .getDisabledSystemPkgLPr(pkg.parentPackage.packageName); if (disabledSysParentPs != null &amp;&amp; disabledSysParentPs.pkg != null &amp;&amp; disabledSysParentPs.isPrivileged()) &#123; if (isPackageRequestingPermission(disabledSysParentPs.pkg, perm)) &#123; allowed = true; &#125; else if (disabledSysParentPs.pkg.childPackages != null) &#123; final int count = disabledSysParentPs.pkg.childPackages.size(); for (int i = 0; i &lt; count; i++) &#123; PackageParser.Package disabledSysChildPkg = disabledSysParentPs.pkg.childPackages.get(i); if (isPackageRequestingPermission(disabledSysChildPkg, perm)) &#123; allowed = true; break; &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; //【2.2】如果该应用是一个没有被更新过的系统应用，那就要判读其是否是特权应用！ allowed = isPrivilegedApp(pkg); &#125; &#125; &#125; //【3】经过了上面的判断，依然不允许，接着进行下一步的判断，下面会根据额外的标志位继续判断！ if (!allowed) &#123; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_PRE23) != 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123; //【3.1】PROTECTION_FLAG_PRE23 指定此权限会自动授予低于 M（在引入运行时权限之前）的 API 级别的应用程序。 // 如果应用的 targetSdkVersion 是小于 M 的，那么我们授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0 &amp;&amp; pkg.packageName.equals(mRequiredInstallerPackage)) &#123; //【3.2】PROTECTION_FLAG_INSTALLER 指定此权限可以自动授予包软件应用程序。 // 而此时的 apk 就是 packageInstaller，那么授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0 &amp;&amp; pkg.packageName.equals(mRequiredVerifierPackage)) &#123; //【3.3】PROTECTION_FLAG_INSTALLER 指定此权限可以被自动授予给验证软件包的系统应用程序。 // 而此时的 apk 就是 VerifierPackage，那么授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0 &amp;&amp; isSystemApp(pkg)) &#123; //【3.4】PROTECTION_FLAG_PREINSTALLED 指定此权限可以自动授予 system 分区预先安装的任何应用程序 // 而此时的 apk 就是 system app，那么授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) &#123; //【3.4】PROTECTION_FLAG_DEVELOPMENT 指定此权限可以授予（可选）给开发应用程序 // 而上一次应用是被授予了这个权限，那么一次也不被授予 allowed = origPermissions.hasInstallPermission(perm); &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_SETUP) != 0 &amp;&amp; pkg.packageName.equals(mSetupWizardPackage)) &#123; //【3.5】PROTECTION_FLAG_SETUP 指定此权限可以被自动授予给开机向导应用程序 // 而此时的 apk 就是开机向导，那么授予他签名权限！. allowed = true; &#125; &#125; return allowed;&#125; 可以看到，这里对 Signature 类型的权限做了详细的处理！ 2 Settings.applyDefaultPreferredAppsLPw - 默认应用设置该方法用于设置默认应用！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void applyDefaultPreferredAppsLPw(PackageManagerService service, int userId) &#123; //【1】从之前安装过应用中设置默认应用； for (PackageSetting ps : mPackages.values()) &#123; if ((ps.pkgFlags&amp;ApplicationInfo.FLAG_SYSTEM) != 0 &amp;&amp; ps.pkg != null &amp;&amp; ps.pkg.preferredActivityFilters != null) &#123; ArrayList&lt;PackageParser.ActivityIntentInfo&gt; intents = ps.pkg.preferredActivityFilters; for (int i=0; i&lt;intents.size(); i++) &#123; PackageParser.ActivityIntentInfo aii = intents.get(i); applyDefaultPreferredActivityLPw(service, aii, new ComponentName( ps.name, aii.activity.className), userId); &#125; &#125; &#125; //【2】从 /etc/preferred-apps 目录下读取默认应用的配置！ File preferredDir = new File(Environment.getRootDirectory(), \"etc/preferred-apps\"); if (!preferredDir.exists() || !preferredDir.isDirectory()) &#123; return; &#125; if (!preferredDir.canRead()) &#123; Slog.w(TAG, \"Directory \" + preferredDir + \" cannot be read\"); return; &#125; // Iterate over the files in the directory and scan .xml files for (File f : preferredDir.listFiles()) &#123; if (!f.getPath().endsWith(\".xml\")) &#123; Slog.i(TAG, \"Non-xml file \" + f + \" in \" + preferredDir + \" directory, ignoring\"); continue; &#125; if (!f.canRead()) &#123; Slog.w(TAG, \"Preferred apps file \" + f + \" cannot be read\"); continue; &#125; if (PackageManagerService.DEBUG_PREFERRED) Log.d(TAG, \"Reading default preferred \" + f); InputStream str = null; try &#123; str = new BufferedInputStream(new FileInputStream(f)); XmlPullParser parser = Xml.newPullParser(); parser.setInput(str, null); int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; ; &#125; if (type != XmlPullParser.START_TAG) &#123; Slog.w(TAG, \"Preferred apps file \" + f + \" does not have start tag\"); continue; &#125; if (!\"preferred-activities\".equals(parser.getName())) &#123; Slog.w(TAG, \"Preferred apps file \" + f + \" does not start with 'preferred-activities'\"); continue; &#125; //【1】读取默认应用的配置信息！ readDefaultPreferredActivitiesLPw(service, parser, userId); &#125; catch (XmlPullParserException e) &#123; Slog.w(TAG, \"Error reading apps file \" + f, e); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Error reading apps file \" + f, e); &#125; finally &#123; if (str != null) &#123; try &#123; str.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; &#125;&#125; 3 PMS.reconcileAppsDataLI - 准备数据目录reconcileAppsDataLI 方法用于调整所有应用的数据，该方法会清楚那些被卸载或者重新安装到其他分区上的应用的已有数据，同时也会校验应用对应的数据目录是否存在，不存在的话，会创建对应的目录！ StorageManager.isFileEncryptedNativeOrEmulated() 方法用于判断系统是否运行在文件加密模式，如果是文件加密模式的话，storageFlags 只有 StorageManager.FLAG_STORAGE_DE； 12345if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123; storageFlags = StorageManager.FLAG_STORAGE_DE;&#125; else &#123; storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;&#125; 下面我们来看看 reconcileAppsDataLI 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void reconcileAppsDataLI(String volumeUuid, int userId, int flags) &#123; Slog.v(TAG, \"reconcileAppsData for \" + volumeUuid + \" u\" + userId + \" 0x\" + Integer.toHexString(flags)); // cdDir 文件对应的目录是：/data/user/&lt;userId&gt;，在默认用户下是 /data/user/0 // deDir 文件对应的目录是：/data/user_de/&lt;userId&gt;，在默认用户下是 /data/user_de/0 final File ceDir = Environment.getDataUserCeDirectory(volumeUuid, userId); final File deDir = Environment.getDataUserDeDirectory(volumeUuid, userId); //【1】系统运行在文件加密模式下，是不会就进入这里的，正常情况会进入这里； if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; if (StorageManager.isFileEncryptedNativeOrEmulated() &amp;&amp; !StorageManager.isUserKeyUnlocked(userId)) &#123; // 再次校验是否处于文件加密模式下！ throw new RuntimeException( \"Yikes, someone asked us to reconcile CE storage while \" + userId + \" was still locked; this would have caused massive data loss!\"); &#125; //【1.1】遍历 /data/user/0 目录，处理该目录下的每个文件！ final File[] files = FileUtils.listFilesOrEmpty(ceDir); for (File file : files) &#123; final String packageName = file.getName(); try &#123; //【1.2】校验所有已经安装的应用的数据 assertPackageKnownAndInstalled(volumeUuid, packageName, userId); &#125; catch (PackageManagerException e) &#123; logCriticalInfo(Log.WARN, \"Destroying \" + file + \" due to: \" + e); try &#123; // 通过 installd 删除该 package 的旧数据！ mInstaller.destroyAppData(volumeUuid, packageName, userId, StorageManager.FLAG_STORAGE_CE, 0); &#125; catch (InstallerException e2) &#123; logCriticalInfo(Log.WARN, \"Failed to destroy: \" + e2); &#125; &#125; &#125; &#125; //【2】遍历 /data/user_de/0 目录，处理该目录下的每个文件！ if ((flags &amp; StorageManager.FLAG_STORAGE_DE) != 0) &#123; final File[] files = FileUtils.listFilesOrEmpty(deDir); for (File file : files) &#123; final String packageName = file.getName(); try &#123; assertPackageKnownAndInstalled(volumeUuid, packageName, userId); &#125; catch (PackageManagerException e) &#123; logCriticalInfo(Log.WARN, \"Destroying \" + file + \" due to: \" + e); try &#123; // 通过 installd 删除该 package 的旧数据！ mInstaller.destroyAppData(volumeUuid, packageName, userId, StorageManager.FLAG_STORAGE_DE, 0); &#125; catch (InstallerException e2) &#123; logCriticalInfo(Log.WARN, \"Failed to destroy: \" + e2); &#125; &#125; &#125; &#125; //【3】确定系统中所有应用都有对应的 data 目录！ final List&lt;PackageSetting&gt; packages; synchronized (mPackages) &#123; packages = mSettings.getVolumePackagesLPr(volumeUuid); &#125; int preparedCount = 0; for (PackageSetting ps : packages) &#123; final String packageName = ps.name; if (ps.pkg == null) &#123; Slog.w(TAG, \"Odd, missing scanned package \" + packageName); continue; &#125; //【3.1】如果 package 已经安装了，那么就会调用 prepareAppDataLIF 方法，准备数据目录！ if (ps.getInstalled(userId)) &#123; prepareAppDataLIF(ps.pkg, userId, flags); if (maybeMigrateAppDataLIF(ps.pkg, userId)) &#123; prepareAppDataLIF(ps.pkg, userId, flags); &#125; preparedCount++; &#125; &#125; Slog.v(TAG, \"reconcileAppsData finished \" + preparedCount + \" packages\");&#125; 这里想说下 /data/user/0 和 /data/user_de/0，其实它们是 /data/data 目录的 link 名称，本质上指向了一个目录！ 这个过程如下： 校验所有已经安装的应用，删除那些异常情况下的应用的数据，如果应用改了包名等等的情况，删除之前的数据； 为没有数据目录的应用创建目录； 这个过程首先处理了 rename package 的情况，对于 rename package 的情况，重命名之前的数据是不可用的，所以这里会使用 assertPackageKnownAndInstalled 方法来进行处理！ 12345678910111213141516171819private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException &#123; synchronized (mPackages) &#123; // 如果重命名过，会返回 oldName，不然则是当前的包名！ packageName = normalizePackageNameLPr(packageName); // 尝试在上次安装信息中，查找这个 package 对应的安装信息； final PackageSetting ps = mSettings.mPackages.get(packageName); if (ps == null) &#123; throw new PackageManagerException(\"Package \" + packageName + \" is unknown\"); &#125; else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) &#123; throw new PackageManagerException( \"Package \" + packageName + \" found on unknown volume \" + volumeUuid + \"; expected volume \" + ps.volumeUuid); &#125; else if (!ps.getInstalled(userId)) &#123; throw new PackageManagerException( \"Package \" + packageName + \" not installed for user \" + userId); &#125; &#125;&#125; 如果查不到安装数据，或者 volumeUuid 不匹配，或者该应用在当前设备用户 id 下不存在了，那就会抛出异常，然后 pms 会删除掉之前的数据！ normalizePackageNameLPr 会根据传入的 packageName，在 mRenamedPackages 找到重命名前的 oldName，如果该 package 之前重命名过，那么其一定会有 old name； 1234private String normalizePackageNameLPr(String packageName) &#123; String normalizedPackageName = mSettings.mRenamedPackages.get(packageName); return normalizedPackageName != null ? normalizedPackageName : packageName;&#125; 方法逻辑很简单！ 3.1 PMS.prepareAppDataLIFprepareAppDataLIF 方法为应用准备数据目录！ 1234567891011121314private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; //【3.2】为该应用准备数据目录！ prepareAppDataLeafLIF(pkg, userId, flags); // 为 childPackage 创建数据目录！ final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; prepareAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 3.2 PMS.prepareAppDataLeafLIFprepareAppDataLeafLIF 方法会继续处理数据目录操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (DEBUG_APP_DATA) &#123; Slog.v(TAG, \"prepareAppData for \" + pkg.packageName + \" u\" + userId + \" 0x\" + Integer.toHexString(flags)); &#125; final String volumeUuid = pkg.volumeUuid; final String packageName = pkg.packageName; final ApplicationInfo app = pkg.applicationInfo; final int appId = UserHandle.getAppId(app.uid); Preconditions.checkNotNull(app.seinfo); try &#123; // 通过 Installd 来创建应用的数据目录； mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seinfo, app.targetSdkVersion); &#125; catch (InstallerException e) &#123; // 如果创建失败，那么如果该应用是系统 apk，pms 会尝试重新创建一次，如果再次失败，那就不会处理！ if (app.isSystemApp()) &#123; logCriticalInfo(Log.ERROR, \"Failed to create app data for \" + packageName + \", but trying to recover: \" + e); destroyAppDataLeafLIF(pkg, userId, flags); try &#123; mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, app.seinfo, app.targetSdkVersion); logCriticalInfo(Log.DEBUG, \"Recovery succeeded!\"); &#125; catch (InstallerException e2) &#123; logCriticalInfo(Log.DEBUG, \"Recovery failed!\"); &#125; &#125; else &#123; Slog.e(TAG, \"Failed to create app data for \" + packageName + \": \" + e); &#125; &#125; // 系统运行在文件加密模式下，不会进入这里！ if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; try &#123; // CE storage is unlocked right now, so read out the inode and // remember for use later when it's locked // TODO: mark this structure as dirty so we persist it! final long ceDataInode = mInstaller.getAppDataInode(volumeUuid, packageName, userId, StorageManager.FLAG_STORAGE_CE); synchronized (mPackages) &#123; final PackageSetting ps = mSettings.mPackages.get(packageName); if (ps != null) &#123; ps.setCeDataInode(ceDataInode, userId); &#125; &#125; &#125; catch (InstallerException e) &#123; Slog.e(TAG, \"Failed to find inode for \" + packageName + \": \" + e); &#125; &#125; //【3.3】继续调用 prepareAppDataContentsLeafLIF 进入下一步； prepareAppDataContentsLeafLIF(pkg, userId, flags);&#125; 3.3 PMS.prepareAppDataContentsLeafLIF1234567891011121314151617181920private void prepareAppDataContentsLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; final String volumeUuid = pkg.volumeUuid; final String packageName = pkg.packageName; final ApplicationInfo app = pkg.applicationInfo; // 系统运行在文件加密模式下，不会进入这里！ if ((flags &amp; StorageManager.FLAG_STORAGE_CE) != 0) &#123; // 如果应用使用的是 32 位架构的话，为 23 位库建立本地库符号链接； if (app.primaryCpuAbi != null &amp;&amp; !VMRuntime.is64BitAbi(app.primaryCpuAbi)) &#123; final String nativeLibPath = app.nativeLibraryDir; try &#123; // 同样的，通过 installd 来建立 mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, nativeLibPath, userId); &#125; catch (InstallerException e) &#123; Slog.e(TAG, \"Failed to link native for \" + packageName + \": \" + e); &#125; &#125; &#125;&#125; 可以看到，PMS 对于应用的数据目录的一系列操作，都是通过 installd 来实现的，因为 pms 本身没有 selinux 权限，所以他必须将权限交给一个特权进程，也就是 installd 来做！ 4 PackageManagerService.clearAppDataLIF清楚缓存数据的前提是：ps.volumeUuid == StorageManager.UUID_PRIVATE_INTERNAL 参数传递：flags 为 StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY1234567891011private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) &#123; if (pkg == null) &#123; Slog.wtf(TAG, \"Package was null!\", new Throwable()); return; &#125; clearAppDataLeafLIF(pkg, userId, flags); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; clearAppDataLeafLIF(pkg.childPackages.get(i), userId, flags); &#125;&#125; 继续调用：12345678910111213141516private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) &#123; final PackageSetting ps; synchronized (mPackages) &#123; ps = mSettings.mPackages.get(pkg.packageName); &#125; for (int realUserId : resolveUserIds(userId)) &#123; final long ceDataInode = (ps != null) ? ps.getCeDataInode(realUserId) : 0; try &#123; mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ceDataInode); &#125; catch (InstallerException e) &#123; Slog.w(TAG, String.valueOf(e)); &#125; &#125;&#125; 仍然是调用 mInstaller 来对用户的应用数据进行操作！ 5 Settings.writeLPr - 持久化最新数据将解析到的安装数据写回到 packages.xml 等文件中！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165void writeLPr() &#123; Debug.startMethodTracing(\"/data/system/packageprof\", 8 * 1024 * 1024); //【1】下面会先将最新的数据写入到 packages-backup.xml 文件中！ if (mSettingsFilename.exists()) &#123; if (!mBackupSettingsFilename.exists()) &#123; if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to backup package manager settings, \" + \" current changes will be lost at reboot\"); return; &#125; &#125; else &#123; mSettingsFilename.delete(); Slog.w(PackageManagerService.TAG, \"Preserving older settings backup\"); &#125; &#125; mPastSignatures.clear(); try &#123; FileOutputStream fstr = new FileOutputStream(mSettingsFilename); BufferedOutputStream str = new BufferedOutputStream(fstr); //XmlSerializer serializer = XmlUtils.serializerInstance(); XmlSerializer serializer = new FastXmlSerializer(); serializer.setOutput(str, StandardCharsets.UTF_8.name()); serializer.startDocument(null, true); serializer.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); serializer.startTag(null, \"packages\"); //【2】写入 \"packages\"！ for (int i = 0; i &lt; mVersion.size(); i++) &#123; //【3】写入 \"version\" final String volumeUuid = mVersion.keyAt(i); final VersionInfo ver = mVersion.valueAt(i); serializer.startTag(null, TAG_VERSION); XmlUtils.writeStringAttribute(serializer, ATTR_VOLUME_UUID, volumeUuid); XmlUtils.writeIntAttribute(serializer, ATTR_SDK_VERSION, ver.sdkVersion); XmlUtils.writeIntAttribute(serializer, ATTR_DATABASE_VERSION, ver.databaseVersion); XmlUtils.writeStringAttribute(serializer, ATTR_FINGERPRINT, ver.fingerprint); serializer.endTag(null, TAG_VERSION); &#125; if (mVerifierDeviceIdentity != null) &#123; //【4】写入 \"verifier\" serializer.startTag(null, \"verifier\"); serializer.attribute(null, \"device\", mVerifierDeviceIdentity.toString()); serializer.endTag(null, \"verifier\"); &#125; if (mReadExternalStorageEnforced != null) &#123; serializer.startTag(null, TAG_READ_EXTERNAL_STORAGE); serializer.attribute( null, ATTR_ENFORCEMENT, mReadExternalStorageEnforced ? \"1\" : \"0\"); serializer.endTag(null, TAG_READ_EXTERNAL_STORAGE); &#125; serializer.startTag(null, \"permission-trees\"); //【4.1】写入 \"permission-trees\" for (BasePermission bp : mPermissionTrees.values()) &#123; writePermissionLPr(serializer, bp); &#125; serializer.endTag(null, \"permission-trees\"); serializer.startTag(null, \"permissions\"); //【4.1】写入 \"permissions\" for (BasePermission bp : mPermissions.values()) &#123; writePermissionLPr(serializer, bp); &#125; serializer.endTag(null, \"permissions\"); for (final PackageSetting pkg : mPackages.values()) &#123; // 写入 \"package\" writePackageLPr(serializer, pkg); &#125; for (final PackageSetting pkg : mDisabledSysPackages.values()) &#123; // 写入 \"updated-package\" writeDisabledSysPackageLPr(serializer, pkg); &#125; for (final SharedUserSetting usr : mSharedUsers.values()) &#123; // 写入 \"shared-user\" serializer.startTag(null, \"shared-user\"); serializer.attribute(null, ATTR_NAME, usr.name); serializer.attribute(null, \"userId\", Integer.toString(usr.userId)); usr.signatures.writeXml(serializer, \"sigs\", mPastSignatures); // 写入 shared-user 的安装时权限！ writePermissionsLPr(serializer, usr.getPermissionsState() .getInstallPermissionStates()); serializer.endTag(null, \"shared-user\"); &#125; if (mPackagesToBeCleaned.size() &gt; 0) &#123; // 写入 \"cleaning-package\" for (PackageCleanItem item : mPackagesToBeCleaned) &#123; final String userStr = Integer.toString(item.userId); serializer.startTag(null, \"cleaning-package\"); serializer.attribute(null, ATTR_NAME, item.packageName); serializer.attribute(null, ATTR_CODE, item.andCode ? \"true\" : \"false\"); serializer.attribute(null, ATTR_USER, userStr); serializer.endTag(null, \"cleaning-package\"); &#125; &#125; if (mRenamedPackages.size() &gt; 0) &#123; // 写入 \"renamed-package\" for (Map.Entry&lt;String, String&gt; e : mRenamedPackages.entrySet()) &#123; serializer.startTag(null, \"renamed-package\"); serializer.attribute(null, \"new\", e.getKey()); serializer.attribute(null, \"old\", e.getValue()); serializer.endTag(null, \"renamed-package\"); &#125; &#125; final int numIVIs = mRestoredIntentFilterVerifications.size(); if (numIVIs &gt; 0) &#123; if (DEBUG_DOMAIN_VERIFICATION) &#123; Slog.i(TAG, \"Writing restored-ivi entries to packages.xml\"); &#125; serializer.startTag(null, \"restored-ivi\"); for (int i = 0; i &lt; numIVIs; i++) &#123; IntentFilterVerificationInfo ivi = mRestoredIntentFilterVerifications.valueAt(i); writeDomainVerificationsLPr(serializer, ivi); &#125; serializer.endTag(null, \"restored-ivi\"); &#125; else &#123; if (DEBUG_DOMAIN_VERIFICATION) &#123; Slog.i(TAG, \" no restored IVI entries to write\"); &#125; &#125; mKeySetManagerService.writeKeySetManagerServiceLPr(serializer); serializer.endTag(null, \"packages\"); // 结束 packages-backup.xml 文件的写入！ serializer.endDocument(); str.flush(); FileUtils.sync(fstr); str.close(); // New settings successfully written, old ones are no longer // needed. mBackupSettingsFilename.delete(); FileUtils.setPermissions(mSettingsFilename.toString(), FileUtils.S_IRUSR|FileUtils.S_IWUSR |FileUtils.S_IRGRP|FileUtils.S_IWGRP, -1, -1); writeKernelMappingLPr(); writePackageListLPr(); //【4.4】写入 packageslist 文件！ writeAllUsersPackageRestrictionsLPr(); //【4.5】写入偏好设置信息； writeAllRuntimePermissionsLPr(); //【4.6】写入运行时权限授予信息！ return; &#125; catch(XmlPullParserException e) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to write package manager settings, \" + \"current changes will be lost at reboot\", e); &#125; catch(java.io.IOException e) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to write package manager settings, \" + \"current changes will be lost at reboot\", e); &#125; // Clean up partially written files if (mSettingsFilename.exists()) &#123; if (!mSettingsFilename.delete()) &#123; Slog.wtf(PackageManagerService.TAG, \"Failed to clean up mangled file: \" + mSettingsFilename); &#125; &#125; //Debug.stopMethodTracing();&#125; 5.1 Settings.writePermissionLPr - 保存 “permission-trees” / “permission”1234567891011121314151617181920212223242526272829void writePermissionLPr(XmlSerializer serializer, BasePermission bp) throws XmlPullParserException, java.io.IOException &#123; if (bp.sourcePackage != null) &#123; serializer.startTag(null, TAG_ITEM); // item 标签 serializer.attribute(null, ATTR_NAME, bp.name); // name 属性 serializer.attribute(null, \"package\", bp.sourcePackage); // package 属性，表示定义者 package if (bp.protectionLevel != PermissionInfo.PROTECTION_NORMAL) &#123; // protection 属性，权限级别！ serializer.attribute(null, \"protection\", Integer.toString(bp.protectionLevel)); &#125; if (PackageManagerService.DEBUG_SETTINGS) Log.v(PackageManagerService.TAG, \"Writing perm: name=\" + bp.name + \" type=\" + bp.type); if (bp.type == BasePermission.TYPE_DYNAMIC) &#123; // 如果是动态权限，这里是针对于权限树的操作！ final PermissionInfo pi = bp.perm != null ? bp.perm.info : bp.pendingInfo; if (pi != null) &#123; serializer.attribute(null, \"type\", \"dynamic\"); if (pi.icon != 0) &#123; serializer.attribute(null, \"icon\", Integer.toString(pi.icon)); &#125; if (pi.nonLocalizedLabel != null) &#123; serializer.attribute(null, \"label\", pi.nonLocalizedLabel.toString()); &#125; &#125; &#125; serializer.endTag(null, TAG_ITEM); &#125;&#125; 权限树以 &lt;permission-trees&gt; &lt;/permission-trees&gt; 开始和结束，权限树以 &lt;permissions&gt; &lt;/permissions&gt; 开始和结束！ 5.2 Settings.writePackageLPr - 保存 “package”12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void writePackageLPr(XmlSerializer serializer, final PackageSetting pkg) throws java.io.IOException &#123; serializer.startTag(null, \"package\"); serializer.attribute(null, ATTR_NAME, pkg.name); if (pkg.realName != null) &#123; serializer.attribute(null, \"realName\", pkg.realName); &#125; serializer.attribute(null, \"codePath\", pkg.codePathString); if (!pkg.resourcePathString.equals(pkg.codePathString)) &#123; serializer.attribute(null, \"resourcePath\", pkg.resourcePathString); &#125; if (pkg.legacyNativeLibraryPathString != null) &#123; serializer.attribute(null, \"nativeLibraryPath\", pkg.legacyNativeLibraryPathString); &#125; if (pkg.primaryCpuAbiString != null) &#123; serializer.attribute(null, \"primaryCpuAbi\", pkg.primaryCpuAbiString); &#125; if (pkg.secondaryCpuAbiString != null) &#123; serializer.attribute(null, \"secondaryCpuAbi\", pkg.secondaryCpuAbiString); &#125; if (pkg.cpuAbiOverrideString != null) &#123; serializer.attribute(null, \"cpuAbiOverride\", pkg.cpuAbiOverrideString); &#125; serializer.attribute(null, \"publicFlags\", Integer.toString(pkg.pkgFlags)); serializer.attribute(null, \"privateFlags\", Integer.toString(pkg.pkgPrivateFlags)); serializer.attribute(null, \"ft\", Long.toHexString(pkg.timeStamp)); serializer.attribute(null, \"it\", Long.toHexString(pkg.firstInstallTime)); serializer.attribute(null, \"ut\", Long.toHexString(pkg.lastUpdateTime)); serializer.attribute(null, \"version\", String.valueOf(pkg.versionCode)); if (pkg.sharedUser == null) &#123; serializer.attribute(null, \"userId\", Integer.toString(pkg.appId)); &#125; else &#123; serializer.attribute(null, \"sharedUserId\", Integer.toString(pkg.appId)); &#125; if (pkg.uidError) &#123; serializer.attribute(null, \"uidError\", \"true\"); &#125; if (pkg.installStatus == PackageSettingBase.PKG_INSTALL_INCOMPLETE) &#123; serializer.attribute(null, \"installStatus\", \"false\"); &#125; if (pkg.installerPackageName != null) &#123; serializer.attribute(null, \"installer\", pkg.installerPackageName); &#125; if (pkg.isOrphaned) &#123; serializer.attribute(null, \"isOrphaned\", \"true\"); &#125; if (pkg.volumeUuid != null) &#123; serializer.attribute(null, \"volumeUuid\", pkg.volumeUuid); &#125; if (pkg.parentPackageName != null) &#123; serializer.attribute(null, \"parentPackageName\", pkg.parentPackageName); &#125; writeChildPackagesLPw(serializer, pkg.childPackageNames); pkg.signatures.writeXml(serializer, \"sigs\", mPastSignatures); // 写入该 package 持有的安装时权限！ writePermissionsLPr(serializer, pkg.getPermissionsState() .getInstallPermissionStates()); writeSigningKeySetLPr(serializer, pkg.keySetData); writeUpgradeKeySetsLPr(serializer, pkg.keySetData); writeKeySetAliasesLPr(serializer, pkg.keySetData); writeDomainVerificationsLPr(serializer, pkg.verificationInfo); serializer.endTag(null, \"package\");&#125; 应用包信息以 &lt;package&gt; &lt;/package&gt; 开始和结束，不多说了！ 5.3 Settings.writeDisabledSysPackageLPr - 保存 “updated-package”12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void writeDisabledSysPackageLPr(XmlSerializer serializer, final PackageSetting pkg) throws java.io.IOException &#123; serializer.startTag(null, \"updated-package\"); serializer.attribute(null, ATTR_NAME, pkg.name); if (pkg.realName != null) &#123; serializer.attribute(null, \"realName\", pkg.realName); &#125; serializer.attribute(null, \"codePath\", pkg.codePathString); serializer.attribute(null, \"ft\", Long.toHexString(pkg.timeStamp)); serializer.attribute(null, \"it\", Long.toHexString(pkg.firstInstallTime)); serializer.attribute(null, \"ut\", Long.toHexString(pkg.lastUpdateTime)); serializer.attribute(null, \"version\", String.valueOf(pkg.versionCode)); if (!pkg.resourcePathString.equals(pkg.codePathString)) &#123; serializer.attribute(null, \"resourcePath\", pkg.resourcePathString); &#125; if (pkg.legacyNativeLibraryPathString != null) &#123; serializer.attribute(null, \"nativeLibraryPath\", pkg.legacyNativeLibraryPathString); &#125; if (pkg.primaryCpuAbiString != null) &#123; serializer.attribute(null, \"primaryCpuAbi\", pkg.primaryCpuAbiString); &#125; if (pkg.secondaryCpuAbiString != null) &#123; serializer.attribute(null, \"secondaryCpuAbi\", pkg.secondaryCpuAbiString); &#125; if (pkg.cpuAbiOverrideString != null) &#123; serializer.attribute(null, \"cpuAbiOverride\", pkg.cpuAbiOverrideString); &#125; if (pkg.sharedUser == null) &#123; serializer.attribute(null, \"userId\", Integer.toString(pkg.appId)); &#125; else &#123; serializer.attribute(null, \"sharedUserId\", Integer.toString(pkg.appId)); &#125; if (pkg.parentPackageName != null) &#123; serializer.attribute(null, \"parentPackageName\", pkg.parentPackageName); &#125; writeChildPackagesLPw(serializer, pkg.childPackageNames); // If this is a shared user, the permissions will be written there. if (pkg.sharedUser == null) &#123; writePermissionsLPr(serializer, pkg.getPermissionsState() .getInstallPermissionStates()); &#125; serializer.endTag(null, \"updated-package\");&#125; 被更新过的应用的信息以 &lt;updated-package&gt; &lt;/updated-package&gt; 开始和结束，不多说了！ 5.4 Settings.writePackageListLPr - 写入 “packages.list”123void writePackageListLPr() &#123; writePackageListLPr(-1);&#125; 最后，调用的是 writePackageListLPr 一参数方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192void writePackageListLPr(int creatingUserId) &#123; //【1】首先获得所有的设备用户信息！ final List&lt;UserInfo&gt; users = UserManagerService.getInstance().getUsers(true); int[] userIds = new int[users.size()]; for (int i = 0; i &lt; userIds.length; i++) &#123; userIds[i] = users.get(i).id; &#125; if (creatingUserId != -1) &#123; // 这里不进入！ userIds = ArrayUtils.appendInt(userIds, creatingUserId); &#125; // Write package list file now, use a JournaledFile. File tempFile = new File(mPackageListFilename.getAbsolutePath() + \".tmp\"); JournaledFile journal = new JournaledFile(mPackageListFilename, tempFile); final File writeTarget = journal.chooseForWrite(); FileOutputStream fstr; BufferedWriter writer = null; try &#123; fstr = new FileOutputStream(writeTarget); writer = new BufferedWriter(new OutputStreamWriter(fstr, Charset.defaultCharset())); FileUtils.setPermissions(fstr.getFD(), 0640, SYSTEM_UID, PACKAGE_INFO_GID); StringBuilder sb = new StringBuilder(); //【2】遍历系统中所有被安装过的 package！ for (final PackageSetting pkg : mPackages.values()) &#123; //【2.1】跳过哪些异常的 package！ if (pkg.pkg == null || pkg.pkg.applicationInfo == null || pkg.pkg.applicationInfo.dataDir == null) &#123; if (!\"android\".equals(pkg.name)) &#123; Slog.w(TAG, \"Skipping \" + pkg + \" due to missing metadata\"); &#125; continue; &#125; final ApplicationInfo ai = pkg.pkg.applicationInfo; final String dataPath = ai.dataDir; final boolean isDebug = (ai.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; final int[] gids = pkg.getPermissionsState().computeGids(userIds); //【2.2】跳过哪些 dataPath 有空格的应用！ if (dataPath.indexOf(' ') &gt;= 0) continue; // we store on each line the following information for now: // // pkgName - package name // userId - application-specific user id // debugFlag - 0 or 1 if the package is debuggable. // dataPath - path to package's data path // seinfo - seinfo label for the app (assigned at install time) // gids - supplementary gids this app launches with // // NOTE: We prefer not to expose all ApplicationInfo flags for now. // // DO NOT MODIFY THIS FORMAT UNLESS YOU CAN ALSO MODIFY ITS USERS // FROM NATIVE CODE. AT THE MOMENT, LOOK AT THE FOLLOWING SOURCES: // frameworks/base/libs/packagelistparser // system/core/run-as/run-as.c // //【2.3】根据指定的格式写入数据！ sb.setLength(0); sb.append(ai.packageName); sb.append(\" \"); sb.append(ai.uid); sb.append(isDebug ? \" 1 \" : \" 0 \"); sb.append(dataPath); sb.append(\" \"); sb.append(ai.seinfo); sb.append(\" \"); if (gids != null &amp;&amp; gids.length &gt; 0) &#123; sb.append(gids[0]); for (int i = 1; i &lt; gids.length; i++) &#123; sb.append(\",\"); sb.append(gids[i]); &#125; &#125; else &#123; sb.append(\"none\"); &#125; sb.append(\"\\n\"); writer.append(sb); &#125; writer.flush(); FileUtils.sync(fstr); writer.close(); journal.commit(); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Failed to write packages.list\", e); IoUtils.closeQuietly(writer); journal.rollback(); &#125;&#125; 我们可以看到，在 packages.list 文件中，存储的格式为：1pkgName userId debugFlag dataPath seinfo gids 大家可以去看那个文件内容！！ 5.5 Settings.writeAllUsersPackageRestrictionsLPr - 保存偏好设置接下来，写入最新的偏好设置！12345678void writeAllUsersPackageRestrictionsLPr() &#123; List&lt;UserInfo&gt; users = getAllUsers(); if (users == null) return; for (UserInfo user : users) &#123; writePackageRestrictionsLPr(user.id); &#125;&#125; 接着，调用 writePackageRestrictionsLPr 方法！这个方法我们前面分析过，这里不处理！ 5.6 Settings.writeAllRuntimePermissionsLPr - 保存运行时权限授予信息接下来，写入最新的运行时权限授予信息！123456void writeAllRuntimePermissionsLPr() &#123; for (int userId : UserManagerService.getInstance().getUserIds()) &#123; //【5.6.1】对每一个设备用户，保存其运行时权限授予信息！ mRuntimePermissionsPersistence.writePermissionsForUserAsyncLPr(userId); &#125;&#125; 5.6.1 RuntimePermissionsPersistence.writePermissionsForUserAsyncLPr12345678910111213141516171819202122232425262728293031public void writePermissionsForUserAsyncLPr(int userId) &#123; final long currentTimeMillis = SystemClock.uptimeMillis(); if (mWriteScheduled.get(userId)) &#123; mHandler.removeMessages(userId); // If enough time passed, write without holding off anymore. final long lastNotWrittenMutationTimeMillis = mLastNotWrittenMutationTimesMillis .get(userId); final long timeSinceLastNotWrittenMutationMillis = currentTimeMillis - lastNotWrittenMutationTimeMillis; if (timeSinceLastNotWrittenMutationMillis &gt;= MAX_WRITE_PERMISSIONS_DELAY_MILLIS) &#123; mHandler.obtainMessage(userId).sendToTarget(); return; &#125; // Hold off a bit more as settings are frequently changing. final long maxDelayMillis = Math.max(lastNotWrittenMutationTimeMillis + MAX_WRITE_PERMISSIONS_DELAY_MILLIS - currentTimeMillis, 0); final long writeDelayMillis = Math.min(WRITE_PERMISSIONS_DELAY_MILLIS, maxDelayMillis); Message message = mHandler.obtainMessage(userId); mHandler.sendMessageDelayed(message, writeDelayMillis); &#125; else &#123; mLastNotWrittenMutationTimesMillis.put(userId, currentTimeMillis); Message message = mHandler.obtainMessage(userId); mHandler.sendMessageDelayed(message, WRITE_PERMISSIONS_DELAY_MILLIS); mWriteScheduled.put(userId, true); &#125;&#125; 就是发送消息给 MyHandler： 5.6.2 RuntimePermissionsPersistence.MyHandler.handleMessage12345678910111213141516private final class MyHandler extends Handler &#123; public MyHandler() &#123; super(BackgroundThread.getHandler().getLooper()); &#125; @Override public void handleMessage(Message message) &#123; final int userId = message.what; Runnable callback = (Runnable) message.obj; //【4.6.3】writePermissionsSync！ writePermissionsSync(userId); if (callback != null) &#123; callback.run(); &#125; &#125;&#125; 5.6.3 RuntimePermissionsPersistence.writePermissionsSyncwritePermissionsSync 会将上一次运行时权限的授予情况保存到文件中！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private void writePermissionsSync(int userId) &#123; AtomicFile destination = new AtomicFile(getUserRuntimePermissionsFile(userId)); //【1】用于保存 package 和 SharedUser 运行时权限！ ArrayMap&lt;String, List&lt;PermissionState&gt;&gt; permissionsForPackage = new ArrayMap&lt;&gt;(); ArrayMap&lt;String, List&lt;PermissionState&gt;&gt; permissionsForSharedUser = new ArrayMap&lt;&gt;(); synchronized (mLock) &#123; mWriteScheduled.delete(userId); //【2】收集 package 运行时权限，保存到 permissionsForPackage！ final int packageCount = mPackages.size(); for (int i = 0; i &lt; packageCount; i++) &#123; String packageName = mPackages.keyAt(i); PackageSetting packageSetting = mPackages.valueAt(i); if (packageSetting.sharedUser == null) &#123; PermissionsState permissionsState = packageSetting.getPermissionsState(); List&lt;PermissionState&gt; permissionsStates = permissionsState .getRuntimePermissionStates(userId); if (!permissionsStates.isEmpty()) &#123; permissionsForPackage.put(packageName, permissionsStates); &#125; &#125; &#125; //【3】收集 SharedUser 运行时权限，保存到 permissionsForSharedUser！ final int sharedUserCount = mSharedUsers.size(); for (int i = 0; i &lt; sharedUserCount; i++) &#123; String sharedUserName = mSharedUsers.keyAt(i); SharedUserSetting sharedUser = mSharedUsers.valueAt(i); PermissionsState permissionsState = sharedUser.getPermissionsState(); List&lt;PermissionState&gt; permissionsStates = permissionsState .getRuntimePermissionStates(userId); if (!permissionsStates.isEmpty()) &#123; permissionsForSharedUser.put(sharedUserName, permissionsStates); &#125; &#125; &#125; FileOutputStream out = null; try &#123; out = destination.startWrite(); XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(out, StandardCharsets.UTF_8.name()); serializer.setFeature( \"http://xmlpull.org/v1/doc/features.html#indent-output\", true); serializer.startDocument(null, true); serializer.startTag(null, TAG_RUNTIME_PERMISSIONS); // 根标签 runtime-permissions！ String fingerprint = mFingerprints.get(userId); if (fingerprint != null) &#123; serializer.attribute(null, ATTR_FINGERPRINT, fingerprint); // 属性 fingerprint！ &#125; // 写入 package 运行时权限！ final int packageCount = permissionsForPackage.size(); for (int i = 0; i &lt; packageCount; i++) &#123; String packageName = permissionsForPackage.keyAt(i); List&lt;PermissionState&gt; permissionStates = permissionsForPackage.valueAt(i); serializer.startTag(null, TAG_PACKAGE); // pkg 标签 serializer.attribute(null, ATTR_NAME, packageName); // name 属性！ //【4.6.3.1】写入运行时权限信息 writePermissions(serializer, permissionStates); serializer.endTag(null, TAG_PACKAGE); &#125; // 写入 SharedUser 运行时权限！ final int sharedUserCount = permissionsForSharedUser.size(); for (int i = 0; i &lt; sharedUserCount; i++) &#123; String packageName = permissionsForSharedUser.keyAt(i); List&lt;PermissionState&gt; permissionStates = permissionsForSharedUser.valueAt(i); serializer.startTag(null, TAG_SHARED_USER); // shared-user 标签； serializer.attribute(null, ATTR_NAME, packageName); // name 属性； //【4.6.3.1】写入运行时权限信息； writePermissions(serializer, permissionStates); serializer.endTag(null, TAG_SHARED_USER); &#125; serializer.endTag(null, TAG_RUNTIME_PERMISSIONS); // Now any restored permission grants that are waiting for the apps // in question to be installed. These are stored as per-package // TAG_RESTORED_RUNTIME_PERMISSIONS blocks, each containing some // number of individual permission grant entities. if (mRestoredUserGrants.get(userId) != null) &#123; ArrayMap&lt;String, ArraySet&lt;RestoredPermissionGrant&gt;&gt; restoredGrants = mRestoredUserGrants.get(userId); if (restoredGrants != null) &#123; final int pkgCount = restoredGrants.size(); for (int i = 0; i &lt; pkgCount; i++) &#123; final ArraySet&lt;RestoredPermissionGrant&gt; pkgGrants = restoredGrants.valueAt(i); if (pkgGrants != null &amp;&amp; pkgGrants.size() &gt; 0) &#123; final String pkgName = restoredGrants.keyAt(i); serializer.startTag(null, TAG_RESTORED_RUNTIME_PERMISSIONS); // restored-perms 标签； serializer.attribute(null, ATTR_PACKAGE_NAME, pkgName); // packageName 属性； final int N = pkgGrants.size(); for (int z = 0; z &lt; N; z++) &#123; RestoredPermissionGrant g = pkgGrants.valueAt(z); serializer.startTag(null, TAG_PERMISSION_ENTRY); // perm 标签； serializer.attribute(null, ATTR_NAME, g.permissionName); // name 属性； if (g.granted) &#123; serializer.attribute(null, ATTR_GRANTED, \"true\"); // granted 属性 &#125; if ((g.grantBits&amp;FLAG_PERMISSION_USER_SET) != 0) &#123; // set 属性 serializer.attribute(null, ATTR_USER_SET, \"true\"); &#125; if ((g.grantBits&amp;FLAG_PERMISSION_USER_FIXED) != 0) &#123; // fixed 属性 serializer.attribute(null, ATTR_USER_FIXED, \"true\"); &#125; if ((g.grantBits&amp;FLAG_PERMISSION_REVOKE_ON_UPGRADE) != 0) &#123; // rou 属性 serializer.attribute(null, ATTR_REVOKE_ON_UPGRADE, \"true\"); &#125; serializer.endTag(null, TAG_PERMISSION_ENTRY); &#125; serializer.endTag(null, TAG_RESTORED_RUNTIME_PERMISSIONS); &#125; &#125; &#125; &#125; serializer.endDocument(); destination.finishWrite(out); if (Build.FINGERPRINT.equals(fingerprint)) &#123; // 如果 mDefaultPermissionsGranted.put(userId, true); &#125; // Any error while writing is fatal. &#125; catch (Throwable t) &#123; Slog.wtf(PackageManagerService.TAG, \"Failed to write settings, restoring backup\", t); destination.failWrite(out); &#125; finally &#123; IoUtils.closeQuietly(out); &#125;&#125; 5.6.3.1 RuntimePermissionsPersistence.writePermissions123456789101112private void writePermissions(XmlSerializer serializer, List&lt;PermissionState&gt; permissionStates) throws IOException &#123; for (PermissionState permissionState : permissionStates) &#123; serializer.startTag(null, TAG_ITEM); // item 标签 serializer.attribute(null, ATTR_NAME,permissionState.getName()); // name 属性 serializer.attribute(null, ATTR_GRANTED, String.valueOf(permissionState.isGranted())); // graned 属性 serializer.attribute(null, ATTR_FLAGS, Integer.toHexString(permissionState.getFlags())); // flags 属性 serializer.endTag(null, TAG_ITEM); &#125;&#125; 这里就不多说了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 4 篇 - PMS_DATA_SCAN_START 阶段","slug":"PMS4-PMS_DATA_SCAN_START","date":"2018-02-16T16:00:00.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/02/17/PMS4-PMS_DATA_SCAN_START/","link":"","permalink":"https://coolqi.top/2018/02/17/PMS4-PMS_DATA_SCAN_START/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现，本文是作者原创，转载请说明出处！ 0 综述通过扫描 system 分区阶段，我们得到如下的几个集合： mExpectingBetter：用来存放那些在 data 分区有更高版本的系统 app！ possiblyDeletedUpdatedSystemApps：用来存储那些不存在的被更新过的系统 app！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// Set flag to monitor and not change apk file paths when// scanning install directories.final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;... ... ... ...// 第三阶段if (!mOnlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis()); // 同理，扫描 /data/app 目录和 /data/app-private 目录！ scanDirTracedLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirTracedLI(mDrmAppPrivateInstallDir, mDefParseFlags | PackageParser.PARSE_FORWARD_LOCK, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirLI(mEphemeralInstallDir, mDefParseFlags | PackageParser.PARSE_IS_EPHEMERAL, scanFlags | SCAN_REQUIRE_KNOWN, 0); // 处理那些不存在的系统 app！ for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123; PackageParser.Package deletedPkg = mPackages.get(deletedAppName); mSettings.removeDisabledSystemPackageLPw(deletedAppName); String msg; if (deletedPkg == null) &#123; msg = \"Updated system package \" + deletedAppName + \" no longer exists; it's data will be wiped\"; // Actual deletion of code and data will be handled by later // reconciliation step &#125; else &#123; msg = \"Updated system app + \" + deletedAppName + \" no longer present; removing system privileges for \" + deletedAppName; deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM; PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName); deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM; &#125; logCriticalInfo(Log.WARN, msg); &#125; // 确保所有在用户 data 分区的应用都显示出来了，如果 data 分区的无法显示，就显示 system 分区的！ for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123; final String packageName = mExpectingBetter.keyAt(i); // 如果 PMS 仍然没有扫描到 mExpectingBetter 列表中的 apk，说明 data 分区的 apk 无法显示 // 那就要显示原来 system 分区的 apk！ if (!mPackages.containsKey(packageName)) &#123; final File scanFile = mExpectingBetter.valueAt(i); logCriticalInfo(Log.WARN, \"Expected better \" + packageName + \" but never showed up; reverting to system\"); // 根据目录，初始化解析标志！ int reparseFlags = mDefParseFlags; if (FileUtils.contains(privilegedAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED; &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else &#123; Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile); continue; &#125; // 使得 system 的 apk 可用； mSettings.enableSystemPackageLPw(packageName); try &#123; // 重新扫描 system 的 apk！ scanPackageTracedLI(scanFile, reparseFlags, scanFlags, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"Failed to parse original system package: \" + e.getMessage()); &#125; &#125; &#125;&#125;mExpectingBetter.clear();// Resolve the storage manager.mStorageManagerPackage = getStorageManagerPackageName();// Resolve protected action filters. Only the setup wizard is allowed to// have a high priority filter for these actions.mSetupWizardPackage = getSetupWizardPackageName();if (mProtectedFilters.size() &gt; 0) &#123; if (DEBUG_FILTERS &amp;&amp; mSetupWizardPackage == null) &#123; Slog.i(TAG, \"No setup wizard;\" + \" All protected intents capped to priority 0\"); &#125; for (ActivityIntentInfo filter : mProtectedFilters) &#123; if (filter.activity.info.packageName.equals(mSetupWizardPackage)) &#123; if (DEBUG_FILTERS) &#123; Slog.i(TAG, \"Found setup wizard;\" + \" allow priority \" + filter.getPriority() + \";\" + \" package: \" + filter.activity.info.packageName + \" activity: \" + filter.activity.className + \" priority: \" + filter.getPriority()); &#125; // skip setup wizard; allow it to keep the high priority filter continue; &#125; Slog.w(TAG, \"Protected action; cap priority to 0;\" + \" package: \" + filter.activity.info.packageName + \" activity: \" + filter.activity.className + \" origPrio: \" + filter.getPriority()); filter.setPriority(0); &#125;&#125;mDeferProtectedFilters = false;mProtectedFilters.clear();// 我们需要更新所有的应用，保证他们有正确的共享库路径。updateAllSharedLibrariesLPw();for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */, false /* boot complete */);&#125;// 更新所有 package 的最新使用时间！mPackageUsage.read(mPackages);mCompilerStats.read();... ... ... ...// 见，第四阶段 1 扫描 data 分区data 分区比较特殊，data 分区的 apk 有两种： 一种是非系统 apk； 另外一种是系统 apk 通过覆盖安装的方式，安装到了 data 分区； 下面我们来看看 data 分区的扫描过程！123456789101112final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL; // 同理，扫描 /data/app 目录和 /data/app-private 目录！ scanDirTracedLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirTracedLI(mDrmAppPrivateInstallDir, mDefParseFlags | PackageParser.PARSE_FORWARD_LOCK, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirLI(mEphemeralInstallDir, mDefParseFlags | PackageParser.PARSE_IS_EPHEMERAL, scanFlags | SCAN_REQUIRE_KNOWN, 0); 扫描的目录如下： /data/app； parseFlags：0 scanFlags：scanFlags | SCAN_REQUIRE_KNOWN /data/app-private； parseFlags：PackageParser.PARSE_FORWARD_LOCK scanFlags：scanFlags | SCAN_REQUIRE_KNOWN /data/app-ephemeral； parseFlags：PackageParser.PARSE_IS_EPHEMERAL scanFlags：scanFlags | SCAN_REQUIRE_KNOWN 这里的步骤和扫描 system 分区是一样的，但是因为 flag 不同，所以会涉及不同的逻辑，这里我们分析一下重点方法，根据之前的扫描顺序，最后会调用一下方法：scanPackageInternalLI 方法！ 1.1 PMS.scanPackageInternalLI我们继续来看，通过前面的扫描解析，我们获得了应用程序的 PackageParser.Package 对象，接下来，就是要处理解析获得的数据，policyFlags 的值就是最开始传入的 parseFlags！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110private PackageParser.Package scanPackageInternalLI(PackageParser.Package pkg, File scanFile, int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; PackageSetting ps = null; PackageSetting updatedPkg; synchronized (mPackages) &#123; // 对于系统 apk 来说，才有源包！！ String oldName = mSettings.mRenamedPackages.get(pkg.packageName); if (pkg.mOriginalPackages != null &amp;&amp; pkg.mOriginalPackages.contains(oldName)) &#123; ps = mSettings.peekPackageLPr(oldName); &#125; // 尝试获得 PackageSetting 对象！ if (ps == null) &#123; ps = mSettings.peekPackageLPr(pkg.packageName); &#125; // 对于非系统的 apk，updatedPkg 是为 null 的！ // 但对于覆盖安装的系统 apk 来说，updatedPkg 不为 null 的！ updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName); if (DEBUG_INSTALL &amp;&amp; updatedPkg != null) Slog.d(TAG, \"updatedPkg = \" + updatedPkg); // 因为扫描的是 data 分区，不进入这个分支！ if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0) &#123; ... ... ... ... &#125; &#125; // 目前，不进入这个分支！ boolean updatedPkgBetter = false; if (updatedPkg != null &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0) &#123; ... ... ... ... &#125; // 非系统 apk，不进入这个分支！ // 但是对于覆盖安装的系统 apk，updatedPkg 不为 null，所以要添加指定的扫描位，表示当前解析的是一个系统 apk！ if (updatedPkg != null) &#123; policyFlags |= PackageParser.PARSE_IS_SYSTEM; if ((updatedPkg.pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) &#123; policyFlags |= PackageParser.PARSE_IS_PRIVILEGED; &#125; &#125; collectCertificatesLI(ps, pkg, scanFile, policyFlags); // 同样的， policyFlags 并没有置 PackageParser.PARSE_IS_SYSTEM_DIR 位为 1，所以不进入改分支！ boolean shouldHideSystemApp = false; if (updatedPkg == null &amp;&amp; ps != null &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0 &amp;&amp; !isSystemApp(ps)) &#123; ... ... ... ... &#125; // 对于非系统的 apk，可能存在 apk 路径和 data 路径不一样的情况！ if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; if (ps != null &amp;&amp; !ps.codePath.equals(ps.resourcePath)) &#123; // 如果不一样，就加上 PackageParser.PARSE_FORWARD_LOCK 位！ policyFlags |= PackageParser.PARSE_FORWARD_LOCK; &#125; &#125; // 下面是处理 data apk 的 apk 路径和资源路径！ String resourcePath = null; String baseResourcePath = null; if ((policyFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != 0 &amp;&amp; !updatedPkgBetter) &#123; if (ps != null &amp;&amp; ps.resourcePathString != null) &#123; resourcePath = ps.resourcePathString; baseResourcePath = ps.resourcePathString; &#125; else &#123; // Should not happen at all. Just log an error. Slog.e(TAG, \"Resource path not set for package \" + pkg.packageName); &#125; &#125; else &#123; resourcePath = pkg.codePath; baseResourcePath = pkg.baseCodePath; &#125; // 设置 ApplicationInfo 对象的属性！ pkg.setApplicationVolumeUuid(pkg.volumeUuid); pkg.setApplicationInfoCodePath(pkg.codePath); pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath); pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths); pkg.setApplicationInfoResourcePath(resourcePath); pkg.setApplicationInfoBaseResourcePath(baseResourcePath); pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths); //【1.2】接着调用 scanPackageLI，继续处理扫描数据！ PackageParser.Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); // 对于非系统的 app，shouldHideSystemApp 为 false，不走这个分支！ if (shouldHideSystemApp) &#123; synchronized (mPackages) &#123; mSettings.disableSystemPackageLPw(pkg.packageName, true); &#125; &#125; return scannedPkg;&#125; 对于非系统 apk，有两种情况： apk 之前已经安装到了 data 分区，所以肯定有对应的 PackageSetting 对象； apk 之前并没有安装，这次通过 OTA 升级的方式，通过 data 分区内置 app 的方式安装 apk； 下面，我们继续来分析： 1.2 PMS.scanPackageLI继续来看：123456789101112131415161718192021private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; boolean success = false; try &#123; //【1.3】继续调用 scanPackageDirtyLI 处理扫描数据！ final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user); success = true; return res; &#125; finally &#123; if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) &#123; // DELETE_DATA_ON_FAILURES is only used by frozen paths // 失败了就清楚掉数据！ destroyAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); destroyAppProfilesLIF(pkg, UserHandle.USER_ALL); &#125; &#125;&#125; 继续看： 1.3 PMS.scanPackageDirtyLI最终，同样调用 scanPackageDirtyLI 方法处理扫描得到的数据，传入参数： PackageParser.Package pkg：非系统目录下解析的 apk 数据； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; final File scanFile = new File(pkg.codePath); if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Code and resource paths haven't been set correctly\"); &#125; //【×】扫描 data 分区不会进入这里，那么 package 也就不会被设置 ApplicationInfo.FLAG_SYSTEM 标志位！ if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM; if (pkg.applicationInfo.isDirectBootAware()) &#123; for (PackageParser.Service s : pkg.services) &#123; s.info.encryptionAware = s.info.directBootAware = true; &#125; for (PackageParser.Provider p : pkg.providers) &#123; p.info.encryptionAware = p.info.directBootAware = true; &#125; for (PackageParser.Activity a : pkg.activities) &#123; a.info.encryptionAware = a.info.directBootAware = true; &#125; for (PackageParser.Activity r : pkg.receivers) &#123; r.info.encryptionAware = r.info.directBootAware = true; &#125; &#125; &#125; else &#123; //【×】data 分区 apk 进入这个分支，coreApp 的值为 false，并清除一些 flag； pkg.coreApp = false; pkg.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE; pkg.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE; &#125; // 下面这部分扫描 data 分区也不会遇到！ pkg.mTrustedOverlay = (policyFlags&amp;PackageParser.PARSE_TRUSTED_OVERLAY) != 0; if ((policyFlags&amp;PackageParser.PARSE_IS_PRIVILEGED) != 0) &#123; pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; if ((policyFlags &amp; PackageParser.PARSE_ENFORCE_CODE) != 0) &#123; enforceCodePolicy(pkg); &#125; if (mCustomResolverComponentName != null &amp;&amp; mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) &#123; setUpCustomResolverActivity(pkg); &#125; // 扫描 data 不会进入这里！！ if (pkg.packageName.equals(\"android\")) &#123; ... ... ... ... &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Scanning package \" + pkg.packageName); &#125; synchronized (mPackages) &#123; // 如果 PMS 已经扫描并处理了这个 apk，就抛异常，跳过！ if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) &#123; throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, \"Application package \" + pkg.packageName + \" already installed. Skipping duplicate.\"); &#125; //【A】对于 data 分区的 apk，进入该分支！ if ((scanFlags &amp; SCAN_REQUIRE_KNOWN) != 0) &#123; // 如果 mExpectingBetter 中有该应用的包名，说明该应用是覆盖了 system apk！ // 这种情况，我们后续会选择 versionCode 更高的显示出来！ if (mExpectingBetter.containsKey(pkg.packageName)) &#123; logCriticalInfo(Log.WARN, \"Relax SCAN_REQUIRE_KNOWN requirement for package \" + pkg.packageName); &#125; else &#123; // 获得上一次安装的信息! PackageSetting known = mSettings.peekPackageLPr(pkg.packageName); if (known != null) &#123; if (DEBUG_PACKAGE_SCANNING) &#123; Log.d(TAG, \"Examining \" + pkg.codePath + \" and requiring known paths \" + known.codePathString + \" &amp; \" + known.resourcePathString); &#125; //【B】如果本次扫描和之前安装后的的 codePath 或者 ResourcePath 不一样，抛出异常，结束处理！ // 这种情况，我们会忽视这个 apk！！ if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals( known.resourcePathString)) &#123; throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, \"Application package \" + pkg.packageName + \" found at \" + pkg.applicationInfo.getCodePath() + \" but expected at \" + known.codePathString + \"; ignoring.\"); &#125; &#125; &#125; &#125; &#125; // 初始化资源路径！ File destCodeFile = new File(pkg.applicationInfo.getCodePath()); File destResourceFile = new File(pkg.applicationInfo.getResourcePath()); SharedUserSetting suid = null; PackageSetting pkgSetting = null; // 非系统 apk ，要取消以下属性！！，判断是否是 system app 的依据是 // 是否有这个 ApplicationInfo.FLAG_SYSTEM 标志位！ if (!isSystemApp(pkg)) &#123; pkg.mOriginalPackages = null; pkg.mRealPackage = null; pkg.mAdoptPermissions = null; &#125; // Getting the package setting may have a side-effect, so if we // are only checking if scan would succeed, stash a copy of the // old setting to restore at the end. PackageSetting nonMutatedPs = null; synchronized (mPackages) &#123; // 如果 apk 是共享 uid 的！ if (pkg.mSharedUserId != null) &#123; // 获得 SharedUserSetting 对象！ suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true); if (suid == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Creating application package \" + pkg.packageName + \" for shared user failed\"); &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Shared UserID \" + pkg.mSharedUserId + \" (uid=\" + suid.userId + \"): packages=\" + suid.packages); &#125; &#125; // 非系统 apk 无源包，不进入这个分支！ // 覆盖安装的系统 apk，可以进入这个分支，这里的目的是找到合适的源包，用来设置包名，已经复用源包的数据！ PackageSetting origPackage = null; String realName = null; if (pkg.mOriginalPackages != null) &#123; final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage); if (pkg.mOriginalPackages.contains(renamed)) &#123; realName = pkg.mRealPackage; if (!pkg.packageName.equals(renamed)) &#123; pkg.setPackageName(renamed); &#125; &#125; else &#123; for (int i=pkg.mOriginalPackages.size()-1; i&gt;=0; i--) &#123; if ((origPackage = mSettings.peekPackageLPr( pkg.mOriginalPackages.get(i))) != null) &#123; if (!verifyPackageUpdateLPr(origPackage, pkg)) &#123; // New package is not compatible with original. origPackage = null; continue; &#125; else if (origPackage.sharedUser != null) &#123; if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) &#123; Slog.w(TAG, \"Unable to migrate data from \" + origPackage.name + \" to \" + pkg.packageName + \": old uid \" + origPackage.sharedUser.name + \" differs from \" + pkg.mSharedUserId); origPackage = null; continue; &#125; // TODO: Add case when shared user id is added [b/28144775] &#125; else &#123; if (DEBUG_UPGRADE) Log.v(TAG, \"Renaming new package \" + pkg.packageName + \" to old name \" + origPackage.name); &#125; break; &#125; &#125; &#125; &#125; if (mTransferedPackages.contains(pkg.packageName)) &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" was transferred to another, but its .apk remains\"); &#125; // See comments in nonMutatedPs declaration if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; PackageSetting foundPs = mSettings.peekPackageLPr(pkg.packageName); if (foundPs != null) &#123; nonMutatedPs = new PackageSetting(foundPs); &#125; &#125; //【1.3.1】获得当前扫描的这个 package 对应的 packageSetting 对象，如果已经存在就直接返回，不存在就创建！ // 如果 origPackage 不为 null，创建新的需要重命名为源包的名字！ pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false); if (pkgSetting == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Creating application package \" + pkg.packageName + \" failed\"); &#125; if (pkgSetting.origPackage != null) &#123; // 非系统 apk 不会进入该分支! pkg.setPackageName(origPackage.name); String msg = \"New package \" + pkgSetting.realName + \" renamed to replace old package \" + pkgSetting.name; reportSettingsProblem(Log.WARN, msg); if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; mTransferedPackages.add(origPackage.name); &#125; pkgSetting.origPackage = null; &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; realName != null) &#123; mTransferedPackages.add(pkg.packageName); &#125; // 如果是被覆盖安装的系统 apk，需要添加 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标签 if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; updateSharedLibrariesLPw(pkg, null); &#125; // 设置 Polisy 标签！ if (mFoundPolicyFile) &#123; SELinuxMMAC.assignSeinfoValue(pkg); &#125; pkg.applicationInfo.uid = pkgSetting.appId; pkg.mExtras = pkgSetting; // 处理 keySet 更新和签名校验！ if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) &#123; if (checkUpgradeKeySetLP(pkgSetting, pkg)) &#123; // We just determined the app is signed correctly, so bring // over the latest parsed certs. pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; else &#123; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" upgrade keys do not match the \" + \"previously installed version\"); &#125; else &#123; pkgSetting.signatures.mSignatures = pkg.mSignatures; String msg = \"System package \" + pkg.packageName + \" signature changed; retaining data.\"; reportSettingsProblem(Log.WARN, msg); &#125; &#125; &#125; else &#123; try &#123; verifySignaturesLP(pkgSetting, pkg); pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; catch (PackageManagerException e) &#123; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw e; &#125; pkgSetting.signatures.mSignatures = pkg.mSignatures; if (pkgSetting.sharedUser != null) &#123; if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; throw new PackageManagerException( INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, \"Signature mismatch for shared user: \" + pkgSetting.sharedUser); &#125; &#125; // File a report about this. String msg = \"System package \" + pkg.packageName + \" signature changed; retaining data.\"; reportSettingsProblem(Log.WARN, msg); &#125; &#125; // 安装的时候才会进入这个分支，这里不看！ // 判断这个 package 使用的 content providers 是否和已经存在 package 冲突！ if ((scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123; final int N = pkg.providers.size(); int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); if (p.info.authority != null) &#123; String names[] = p.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; if (mProvidersByAuthority.containsKey(names[j])) &#123; PackageParser.Provider other = mProvidersByAuthority.get(names[j]); final String otherPackageName = ((other != null &amp;&amp; other.getComponentName() != null) ? other.getComponentName().getPackageName() : \"?\"); throw new PackageManagerException( INSTALL_FAILED_CONFLICTING_PROVIDER, \"Can't install because provider name \" + names[j] + \" (in package \" + pkg.applicationInfo.packageName + \") is already used by \" + otherPackageName); &#125; &#125; &#125; &#125; &#125; // 同样的，只有系统 apk 才能进入该分支！ if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; pkg.mAdoptPermissions != null) &#123; // This package wants to adopt ownership of permissions from // another package. for (int i = pkg.mAdoptPermissions.size() - 1; i &gt;= 0; i--) &#123; final String origName = pkg.mAdoptPermissions.get(i); final PackageSetting orig = mSettings.peekPackageLPr(origName); if (orig != null) &#123; if (verifyPackageUpdateLPr(orig, pkg)) &#123; Slog.i(TAG, \"Adopting permissions from \" + origName + \" to \" + pkg.packageName); mSettings.transferPermissionsLPw(origName, pkg.packageName); &#125; &#125; &#125; &#125; &#125; final String pkgName = pkg.packageName; final long scanFileTime = getLastModifiedTime(pkg, scanFile); final boolean forceDex = (scanFlags &amp; SCAN_FORCE_DEX) != 0; // 设置 pacakge 对应的进程名！ pkg.applicationInfo.processName = fixProcessName( pkg.applicationInfo.packageName, pkg.applicationInfo.processName, pkg.applicationInfo.uid); if (pkg != mPlatformPackage) &#123; // Get all of our default paths setup pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM); &#125; final String path = scanFile.getPath(); final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting); // 下面是设置本地库和系统平台相关的属性！ if ((scanFlags &amp; SCAN_NEW_INSTALL) == 0) &#123; derivePackageAbi(pkg, scanFile, cpuAbiOverride, true /* extract libs */); if (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp() &amp;&amp; pkg.applicationInfo.primaryCpuAbi == null) &#123; setBundledAppAbisAndRoots(pkg, pkgSetting); setNativeLibraryPaths(pkg); &#125; &#125; else &#123; if ((scanFlags &amp; SCAN_MOVE) != 0) &#123; &#125; setNativeLibraryPaths(pkg); &#125; if (mPlatformPackage == pkg) &#123; pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0]; &#125; if ((scanFlags &amp; SCAN_NO_DEX) == 0 &amp;&amp; (scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123; if (cpuAbiOverride == null &amp;&amp; pkgSetting.cpuAbiOverrideString != null) &#123; Slog.w(TAG, \"Ignoring persisted ABI override \" + cpuAbiOverride + \" for package \" + pkg.packageName); &#125; &#125; pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi; pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi; pkgSetting.cpuAbiOverrideString = cpuAbiOverride; pkg.cpuAbiOverride = cpuAbiOverride; if (DEBUG_ABI_SELECTION) &#123; Slog.d(TAG, \"Resolved nativeLibraryRoot for \" + pkg.applicationInfo.packageName + \" to root=\" + pkg.applicationInfo.nativeLibraryRootDir + \", isa=\" + pkg.applicationInfo.nativeLibraryRootRequiresIsa); &#125; pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir; if (DEBUG_ABI_SELECTION) &#123; Log.d(TAG, \"Abis for package[\" + pkg.packageName + \"] are\" + \" primary=\" + pkg.applicationInfo.primaryCpuAbi + \" secondary=\" + pkg.applicationInfo.secondaryCpuAbi); &#125; if ((scanFlags &amp; SCAN_BOOTING) == 0 &amp;&amp; pkgSetting.sharedUser != null) &#123; adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg, true /* boot complete */); &#125; if (mFactoryTest &amp;&amp; pkg.requestedPermissions.contains( android.Manifest.permission.FACTORY_TEST)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST; &#125; // 如果是系统 package，设置 isOrphaned 的属性为 true！ if (isSystemApp(pkg)) &#123; pkgSetting.isOrphaned = true; &#125; ArrayList&lt;PackageParser.Package&gt; clientLibPkgs = null; if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; if (nonMutatedPs != null) &#123; synchronized (mPackages) &#123; mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs); &#125; &#125; return pkg; &#125; // 处理特权 apk 的子包，只有特权 apk 才能添加子包； // 特权 apk 包括两部分： // 1、特定 uid 的 app // 2、framework-res.apk 和 system/priv-app 目录下的 apk！ if (pkg.childPackages != null &amp;&amp; !pkg.childPackages.isEmpty()) &#123; if ((policyFlags &amp; PARSE_IS_PRIVILEGED) == 0) &#123; throw new PackageManagerException(\"Only privileged apps and updated \" + \"privileged apps can add child packages. Ignoring package \" + pkg.packageName); &#125; final int childCount = pkg.childPackages.size(); for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); if (mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, childPkg.packageName)) &#123; throw new PackageManagerException(\"Cannot override a child package of \" + \"another disabled system app. Ignoring package \" + pkg.packageName); &#125; &#125; &#125; synchronized (mPackages) &#123; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0) &#123; // 如果是系统 package，并且他之前更新过，就要尝试对共享库 lib 进行更新！ // 只有系统 package 才能添加共享 lib if (pkg.libraryNames != null) &#123; for (int i=0; i&lt;pkg.libraryNames.size(); i++) &#123; String name = pkg.libraryNames.get(i); boolean allowed = false; if (pkg.isUpdatedSystemApp()) &#123; // New library entries can only be added through the // system image. This is important to get rid of a lot // of nasty edge cases: for example if we allowed a non- // system update of the app to add a library, then uninstalling // the update would make the library go away, and assumptions // we made such as through app install filtering would now // have allowed apps on the device which aren't compatible // with it. Better to just have the restriction here, be // conservative, and create many fewer cases that can negatively // impact the user experience. final PackageSetting sysPs = mSettings .getDisabledSystemPkgLPr(pkg.packageName); if (sysPs.pkg != null &amp;&amp; sysPs.pkg.libraryNames != null) &#123; for (int j=0; j&lt;sysPs.pkg.libraryNames.size(); j++) &#123; if (name.equals(sysPs.pkg.libraryNames.get(j))) &#123; allowed = true; break; &#125; &#125; &#125; &#125; else &#123; allowed = true; &#125; if (allowed) &#123; if (!mSharedLibraries.containsKey(name)) &#123; mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName)); &#125; else if (!name.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" library \" + name + \" already exists; skipping\"); &#125; &#125; else &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" declares lib \" + name + \" that is not declared on system image; skipping\"); &#125; &#125; if ((scanFlags &amp; SCAN_BOOTING) == 0) &#123; // If we are not booting, we need to update any applications // that are clients of our shared library. If we are booting, // this will all be done once the scan is complete. clientLibPkgs = updateAllSharedLibrariesLPw(pkg); &#125; &#125; &#125; &#125; if ((scanFlags &amp; SCAN_BOOTING) != 0) &#123; &#125; else if ((scanFlags &amp; SCAN_DONT_KILL_APP) != 0) &#123; &#125; else if ((scanFlags &amp; SCAN_IGNORE_FROZEN) != 0) &#123; &#125; else &#123; // 尝试去冻结 apk！ checkPackageFrozen(pkgName); &#125; if (clientLibPkgs != null) &#123; for (int i=0; i&lt;clientLibPkgs.size(); i++) &#123; PackageParser.Package clientPkg = clientLibPkgs.get(i); killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, \"update lib\"); &#125; &#125; // Make sure we're not adding any bogus keyset info KeySetManagerService ksms = mSettings.mKeySetManagerService; ksms.assertScannedPackageValid(pkg); // writer Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\"); boolean createIdmapFailed = false; synchronized (mPackages) &#123; // We don't expect installation to fail beyond this point if (pkgSetting.pkg != null) &#123; // Note that |user| might be null during the initial boot scan. If a codePath // for an app has changed during a boot scan, it's due to an app update that's // part of the system partition and marker changes must be applied to all users. maybeRenameForeignDexMarkers(pkgSetting.pkg, pkg, (user != null) ? user : UserHandle.ALL); &#125; //【×】将新创建的 PackageSetting 添加到 mSettings 中！ mSettings.insertPackageSettingLPw(pkgSetting, pkg); // 将新创建的 PackageSetting 添加到 PMS.mPackages 中！ mPackages.put(pkg.applicationInfo.packageName, pkg); // 将当前的 package 从 mSettings.mPackagesToBeCleaned 中移除，防止数据清除！ final Iterator&lt;PackageCleanItem&gt; iter = mSettings.mPackagesToBeCleaned.iterator(); while (iter.hasNext()) &#123; PackageCleanItem item = iter.next(); if (pkgName.equals(item.packageName)) &#123; iter.remove(); &#125; &#125; // 处理 package 的第一次安装时间和最近更新时间！ if (currentTime != 0) &#123; if (pkgSetting.firstInstallTime == 0) &#123; pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime; &#125; else if ((scanFlags&amp;SCAN_UPDATE_TIME) != 0) &#123; pkgSetting.lastUpdateTime = currentTime; &#125; &#125; else if (pkgSetting.firstInstallTime == 0) &#123; // We need *something*. Take time time stamp of the file. pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime; &#125; else if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM_DIR) != 0) &#123; if (scanFileTime != pkgSetting.timeStamp) &#123; // A package on the system image has changed; consider this // to be an update. pkgSetting.lastUpdateTime = scanFileTime; &#125; &#125; // Add the package's KeySets to the global KeySetManagerService ksms.addScannedPackageLPw(pkg); // 处理该 Package 中 的 Provider 信息，添加到 mProviders 中！ int N = pkg.providers.size(); StringBuilder r = null; int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid); mProviders.addProvider(p); p.syncable = p.info.isSyncable; if (p.info.authority != null) &#123; String names[] = p.info.authority.split(\";\"); p.info.authority = null; for (int j = 0; j &lt; names.length; j++) &#123; if (j == 1 &amp;&amp; p.syncable) &#123; // We only want the first authority for a provider to possibly be // syncable, so if we already added this provider using a different // authority clear the syncable flag. We copy the provider before // changing it because the mProviders object contains a reference // to a provider that we don't want to change. // Only do this for the second authority since the resulting provider // object can be the same for all future authorities for this provider. p = new PackageParser.Provider(p); p.syncable = false; &#125; if (!mProvidersByAuthority.containsKey(names[j])) &#123; mProvidersByAuthority.put(names[j], p); if (p.info.authority == null) &#123; p.info.authority = names[j]; &#125; else &#123; p.info.authority = p.info.authority + \";\" + names[j]; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Registered content provider: \" + names[j] + \", className = \" + p.info.name + \", isSyncable = \" + p.info.isSyncable); &#125; &#125; else &#123; PackageParser.Provider other = mProvidersByAuthority.get(names[j]); Slog.w(TAG, \"Skipping provider name \" + names[j] + \" (in package \" + pkg.applicationInfo.packageName + \"): name already used by \" + ((other != null &amp;&amp; other.getComponentName() != null) ? other.getComponentName().getPackageName() : \"?\")); &#125; &#125; &#125; if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Providers: \" + r); &#125; // 处理该 Package 中的 Service 信息，添加到 PMS.mService 中！ N = pkg.services.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Service s = pkg.services.get(i); s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid); mServices.addService(s); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(s.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Services: \" + r); &#125; // 处理该 Package 中的 BroadcastReceiver 信息,添加到 PMS.mReceivers 中。 N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); mReceivers.addActivity(a, \"receiver\"); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Receivers: \" + r); &#125; // 处理该 Package 中的 activity 信息，添加到 PMS.mActivities 中！ N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); mActivities.addActivity(a, \"activity\"); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Activities: \" + r); &#125; // 处理该 Package 中的 PermissionGroups 信息 N = pkg.permissionGroups.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i); PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name); final String curPackageName = cur == null ? null : cur.info.packageName; final boolean isPackageUpdate = pg.info.packageName.equals(curPackageName); if (cur == null || isPackageUpdate) &#123; mPermissionGroups.put(pg.info.name, pg); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; if (isPackageUpdate) &#123; r.append(\"UPD:\"); &#125; r.append(pg.info.name); &#125; &#125; else &#123; Slog.w(TAG, \"Permission group \" + pg.info.name + \" from package \" + pg.info.packageName + \" ignored: original from \" + cur.info.packageName); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(\"DUP:\"); r.append(pg.info.name); &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Permission Groups: \" + r); &#125; // 处理该 Package 中的 Permissions 信息！ N = pkg.permissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Permission p = pkg.permissions.get(i); // Assume by default that we did not install this permission into the system. p.info.flags &amp;= ~PermissionInfo.FLAG_INSTALLED; // Now that permission groups have a special meaning, we ignore permission // groups for legacy apps to prevent unexpected behavior. In particular, // permissions for one app being granted to someone just becase they happen // to be in a group defined by another app (before this had no implications). if (pkg.applicationInfo.targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123; p.group = mPermissionGroups.get(p.info.group); // Warn for a permission in an unknown group. if (p.info.group != null &amp;&amp; p.group == null) &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" in an unknown group \" + p.info.group); &#125; &#125; // 从 Settings 中获得权限管理集合！ ArrayMap&lt;String, BasePermission&gt; permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions; // 获得 package 的权限对应的 BasePermission 对象！ BasePermission bp = permissionMap.get(p.info.name); // Allow system apps to redefine non-system permissions // BasePermission 不为 null，且当前解析的 package 也不是权限的定义者！ if (bp != null &amp;&amp; !Objects.equals(bp.sourcePackage, p.info.packageName)) &#123; final boolean currentOwnerIsSystem = (bp.perm != null &amp;&amp; isSystemApp(bp.perm.owner)); if (isSystemApp(p.owner)) // 如果当前 package 申请的权限拥有者是系统 app if (bp.type == BasePermission.TYPE_BUILTIN &amp;&amp; bp.perm == null) &#123; // It's a built-in permission and no owner, take ownership now bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; &#125; else if (!currentOwnerIsSystem) &#123; String msg = \"New decl \" + p.owner + \" of permission \" + p.info.name + \" is system; overriding \" + bp.sourcePackage; reportSettingsProblem(Log.WARN, msg); bp = null; &#125; &#125; &#125; if (bp == null) &#123; bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL); permissionMap.put(p.info.name, bp); &#125; if (bp.perm == null) &#123; if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) &#123; BasePermission tree = findPermissionTreeLP(p.info.name); if (tree == null || tree.sourcePackage.equals(p.info.packageName)) &#123; bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; else &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" ignored: base tree \" + tree.name + \" is from package \" + tree.sourcePackage); &#125; &#125; else &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" ignored: original from \" + bp.sourcePackage); &#125; &#125; else if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(\"DUP:\"); r.append(p.info.name); &#125; if (bp.perm == p) &#123; bp.protectionLevel = p.info.protectionLevel; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Permissions: \" + r); &#125; N = pkg.instrumentation.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Instrumentation a = pkg.instrumentation.get(i); a.info.packageName = pkg.applicationInfo.packageName; a.info.sourceDir = pkg.applicationInfo.sourceDir; a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir; a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs; a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs; a.info.dataDir = pkg.applicationInfo.dataDir; a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir; a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir; a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir; a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir; mInstrumentation.put(a.getComponentName(), a); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Instrumentation: \" + r); &#125; // 处理该 Package 中的 protectedBroadcasts 信息！ if (pkg.protectedBroadcasts != null) &#123; N = pkg.protectedBroadcasts.size(); for (i=0; i&lt;N; i++) &#123; mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i)); &#125; &#125; pkgSetting.setTimeStamp(scanFileTime); // Create idmap files for pairs of (packages, overlay packages). // Note: \"android\", ie framework-res.apk, is handled by native layers. if (pkg.mOverlayTarget != null) &#123; // This is an overlay package. if (pkg.mOverlayTarget != null &amp;&amp; !pkg.mOverlayTarget.equals(\"android\")) &#123; if (!mOverlays.containsKey(pkg.mOverlayTarget)) &#123; mOverlays.put(pkg.mOverlayTarget, new ArrayMap&lt;String, PackageParser.Package&gt;()); &#125; ArrayMap&lt;String, PackageParser.Package&gt; map = mOverlays.get(pkg.mOverlayTarget); map.put(pkg.packageName, pkg); PackageParser.Package orig = mPackages.get(pkg.mOverlayTarget); if (orig != null &amp;&amp; !createIdmapForPackagePairLI(orig, pkg)) &#123; createIdmapFailed = true; &#125; &#125; &#125; else if (mOverlays.containsKey(pkg.packageName) &amp;&amp; !pkg.packageName.equals(\"android\")) &#123; // This is a regular package, with one or more known overlay packages. createIdmapsForPackageLI(pkg); &#125; &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); if (createIdmapFailed) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"scanPackageLI failed to createIdmap\"); &#125; return pkg;&#125; 1.3.1 Settings.getPackageLPw上面又再次调用了 getPackageLPw 方法，注意根据参数传递： boolean add：传入的值为 false！ boolean allowInstall：传入的值为 true； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// 最终进入这个方法！private PackageSetting getPackageLPw(String name, PackageSetting origPackage, String realName, SharedUserSetting sharedUser, File codePath, File resourcePath, String legacyNativeLibraryPathString, String primaryCpuAbiString, String secondaryCpuAbiString, int vc, int pkgFlags, int pkgPrivateFlags, UserHandle installUser, boolean add, boolean allowInstall, String parentPackage, List&lt;String&gt; childPackageNames) &#123; // 尝试获得之前的安装数据！ // 如果是非系统 apk，这个安装就是他自身的；如果是覆盖安装的系统 app，那么这个数据是 data 分区下的； PackageSetting p = mPackages.get(name); UserManagerService userManager = UserManagerService.getInstance(); //【×】如果 p 不为 null，说明这个 data 分区的 apk 之前就存在，它可能是一个非系统 apk； // 也可能是一个系统的 apk 覆盖安装到了 data 分区！ if (p != null) &#123; p.primaryCpuAbiString = primaryCpuAbiString; p.secondaryCpuAbiString = secondaryCpuAbiString; if (childPackageNames != null) &#123; p.childPackageNames = new ArrayList&lt;&gt;(childPackageNames); &#125; // 对于扫描 data 分区的情况，如果 codePath 不匹配，会在【1.3】【B】的位置抛出异常，也就是说会忽略掉这个包！ // 这里是不会进入的！！ if (!p.codePath.equals(codePath)) &#123; if ((p.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; Slog.w(PackageManagerService.TAG, \"Trying to update system app code path from \" + p.codePathString + \" to \" + codePath.toString()); &#125; else &#123; Slog.i(PackageManagerService.TAG, \"Package \" + name + \" codePath changed from \" + p.codePath + \" to \" + codePath + \"; Retaining data and using new\"); if ((pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) != 0 &amp;&amp; getDisabledSystemPkgLPr(name) == null) &#123; List&lt;UserInfo&gt; allUserInfos = getAllUsers(); if (allUserInfos != null) &#123; for (UserInfo userInfo : allUserInfos) &#123; p.setInstalled(true, userInfo.id); &#125; &#125; &#125; p.legacyNativeLibraryPathString = legacyNativeLibraryPathString; &#125; &#125; if (p.sharedUser != sharedUser) &#123; // 如果共享 uid 不匹配，就需要创建新的 PackageSetting 替换以前的！ PackageManagerService.reportSettingsProblem(Log.WARN, \"Package \" + name + \" shared user changed from \" + (p.sharedUser != null ? p.sharedUser.name : \"&lt;nothing&gt;\") + \" to \" + (sharedUser != null ? sharedUser.name : \"&lt;nothing&gt;\") + \"; replacing with new\"); p = null; &#125; else &#123; // 如果不是共享 uid，或者共享 uid 匹配，会进入这里： // 这里要注意：pkgFlags 是没有 FLAG_SYSTEM 标志位的，所以 pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM // 会置空该标志，但是由于 | 的特性，并没有影响上一次安装信息的 pkgFlags 位！ // 就是说如果是覆盖更新的 system app，即使扫描了 data 分区，也不会取消 FLAG_SYSTEM 位！ p.pkgFlags |= pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM; p.pkgPrivateFlags |= pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; &#125; //【×】如果 p == null， // 说明这个 data 分区的 apk 是新增的，比如一些 OTA 版本会在 data 分区内置一些应用！ // 或者是之前的数据和最新的扫描数据比较，共享 uid 不匹配，那就需要创建新的 PackageSetting！ // 或者是 system 的 app 移动到了 data 分区！ if (p == null) &#123; if (origPackage != null) &#123; p = new PackageSetting(origPackage.name, name, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags, parentPackage, childPackageNames); if (PackageManagerService.DEBUG_UPGRADE) Log.v(PackageManagerService.TAG, \"Package \" + name + \" is adopting original package \" + origPackage.name); PackageSignatures s = p.signatures; p.copyFrom(origPackage); p.signatures = s; p.sharedUser = origPackage.sharedUser; p.appId = origPackage.appId; p.origPackage = origPackage; p.getPermissionsState().copyFrom(origPackage.getPermissionsState()); // 重命名为源包的名字后，将新旧名字加入 mRenamedPackages 集合！ mRenamedPackages.put(name, origPackage.name); name = origPackage.name; p.setTimeStamp(codePath.lastModified()); &#125; else &#123; // 非系统 app 会进入这里，使用本次扫描的信息创建 PackageSetting！ p = new PackageSetting(name, realName, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags, parentPackage, childPackageNames); p.setTimeStamp(codePath.lastModified()); p.sharedUser = sharedUser; // 系统 apk 不会进入这个分支！ if ((pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; if (DEBUG_STOPPED) &#123; RuntimeException e = new RuntimeException(\"here\"); e.fillInStackTrace(); Slog.i(PackageManagerService.TAG, \"Stopping package \" + name, e); &#125; List&lt;UserInfo&gt; users = getAllUsers(); final int installUserId = installUser != null ? installUser.getIdentifier() : 0; if (users != null &amp;&amp; allowInstall) &#123; for (UserInfo user : users) &#123; final boolean installed = installUser == null || (installUserId == UserHandle.USER_ALL &amp;&amp; !isAdbInstallDisallowed(userManager, user.id)) || installUserId == user.id; p.setUserState(user.id, 0, COMPONENT_ENABLED_STATE_DEFAULT, installed, true, // stopped, true, // notLaunched false, // hidden false, // suspended null, null, null, false, // blockUninstall INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0); writePackageRestrictionsLPr(user.id); &#125; &#125; &#125; // 设置系统 package 的 appid // 如果是共享用户 id，那 appId 就是共享用户 id； // 如果不是共享用户 id，就看系统 app 是否被覆盖更新过，如果有，就克隆更新前的旧数据，初始化 appId，权限等等 // 如果系统 app 没有被覆盖更新过，就创建新的 uid！ if (sharedUser != null) &#123; p.appId = sharedUser.userId; &#125; else &#123; PackageSetting dis = mDisabledSysPackages.get(name); if (dis != null) &#123; if (dis.signatures.mSignatures != null) &#123; p.signatures.mSignatures = dis.signatures.mSignatures.clone(); &#125; p.appId = dis.appId; p.getPermissionsState().copyFrom(dis.getPermissionsState()); List&lt;UserInfo&gt; users = getAllUsers(); if (users != null) &#123; for (UserInfo user : users) &#123; int userId = user.id; p.setDisabledComponentsCopy( dis.getDisabledComponents(userId), userId); p.setEnabledComponentsCopy( dis.getEnabledComponents(userId), userId); &#125; &#125; // 将这个新的 PackageSetting 根据 uid 添加到 mUserIds 或者 mOtherUserIds 中！ addUserIdLPw(p.appId, p, name); &#125; else &#123; // 分配一个新的 uid，并将映射关系保存到 mUserIds 中！ p.appId = newUserIdLPw(p); &#125; &#125; &#125; if (p.appId &lt; 0) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Package \" + name + \" could not be assigned a valid uid\"); return null; &#125; if (add) &#123; // add 为 false，这里不添加，添加的操作在 PMS.scanPackageDirtyLI 方法中！ addPackageSettingLPw(p, name, sharedUser); &#125; &#125; else &#123; if (installUser != null &amp;&amp; allowInstall) &#123; // The caller has explicitly specified the user they want this // package installed for, and the package already exists. // Make sure it conforms to the new request. List&lt;UserInfo&gt; users = getAllUsers(); if (users != null) &#123; for (UserInfo user : users) &#123; if ((installUser.getIdentifier() == UserHandle.USER_ALL &amp;&amp; !isAdbInstallDisallowed(userManager, user.id)) || installUser.getIdentifier() == user.id) &#123; boolean installed = p.getInstalled(user.id); if (!installed) &#123; p.setInstalled(true, user.id); writePackageRestrictionsLPr(user.id); &#125; &#125; &#125; &#125; &#125; &#125; // 返回查到或者是创建的新的系统 package 对应的 PackageSetting 对象！ return p;&#125; 整个过程其实还是很复杂的，要忽视很多的细节，抓住脉络才行！ 2 Data 分区扫描结尾工作下面我们来看看 Data 分区扫描的结尾工作！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 //【1】处理那些已经不存在的被更新过的系统 app！ for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123; PackageParser.Package deletedPkg = mPackages.get(deletedAppName); mSettings.removeDisabledSystemPackageLPw(deletedAppName); String msg; if (deletedPkg == null) &#123; // 如果无扫描结果，那么系统中一已经没有该 apk 了，那就删掉它！ msg = \"Updated system package \" + deletedAppName + \" no longer exists; it's data will be wiped\"; &#125; else &#123; // 如果有扫描结果，说明 data 分区的 apk 还在，那么这个系统 apk 此时就已经是一个非系统 apk 了 // 那就要去掉 FLAG_SYSTEM 标志位！ msg = \"Updated system app + \" + deletedAppName + \" no longer present; removing system privileges for \" + deletedAppName; deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM; PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName); deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM; &#125; logCriticalInfo(Log.WARN, msg); &#125; //【2】确保所有在用户 data 分区的应用都显示出来了，如果 data 分区的无法显示，就显示 system 分区的！ for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123; final String packageName = mExpectingBetter.keyAt(i); // 如果 PMS 仍然没有扫描到 mExpectingBetter 列表中的 apk，说明 data 分区的 apk 无法显示 // 那就要显示原来 system 分区的 apk！ if (!mPackages.containsKey(packageName)) &#123; final File scanFile = mExpectingBetter.valueAt(i); logCriticalInfo(Log.WARN, \"Expected better \" + packageName + \" but never showed up; reverting to system\"); //【2.1】根据目录，初始化解析标志！！！ int reparseFlags = mDefParseFlags; if (FileUtils.contains(privilegedAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED; &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else &#123; Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile); continue; &#125; //【2.2】使得 system 的 apk 可用； mSettings.enableSystemPackageLPw(packageName); try &#123; //【2.3】重新扫描 system 的 apk！ scanPackageTracedLI(scanFile, reparseFlags, scanFlags, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"Failed to parse original system package: \" + e.getMessage()); &#125; &#125; &#125;&#125;mExpectingBetter.clear(); // 清空 mExpectingBetter 因为已经处理完了！// 获得存储管理对象！mStorageManagerPackage = getStorageManagerPackageName();// Resolve protected action filters. Only the setup wizard is allowed to// have a high priority filter for these actions.// 获得开机向导应用mSetupWizardPackage = getSetupWizardPackageName();if (mProtectedFilters.size() &gt; 0) &#123; if (DEBUG_FILTERS &amp;&amp; mSetupWizardPackage == null) &#123; Slog.i(TAG, \"No setup wizard;\" + \" All protected intents capped to priority 0\"); &#125; for (ActivityIntentInfo filter : mProtectedFilters) &#123; if (filter.activity.info.packageName.equals(mSetupWizardPackage)) &#123; if (DEBUG_FILTERS) &#123; Slog.i(TAG, \"Found setup wizard;\" + \" allow priority \" + filter.getPriority() + \";\" + \" package: \" + filter.activity.info.packageName + \" activity: \" + filter.activity.className + \" priority: \" + filter.getPriority()); &#125; // skip setup wizard; allow it to keep the high priority filter continue; &#125; Slog.w(TAG, \"Protected action; cap priority to 0;\" + \" package: \" + filter.activity.info.packageName + \" activity: \" + filter.activity.className + \" origPrio: \" + filter.getPriority()); filter.setPriority(0); &#125;&#125;mDeferProtectedFilters = false;mProtectedFilters.clear();//【3】我们需要更新所有的应用，保证他们有正确的共享库路径。updateAllSharedLibrariesLPw();//【4】调整所有共享 uid 的 package 的指令集！for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */, false /* boot complete */);&#125;//【5】更新所有 package 的最新使用时间！mPackageUsage.read(mPackages);mCompilerStats.read(); 到这里，data 分区的扫描就结束了！！ 接下来我们重点分析下： 123//【5】更新所有 package 的最新使用时间！mPackageUsage.read(mPackages);mCompilerStats.read(); #3 PackageUsage 和 CompilerStats 在 PMS 的启动时，会创建 PackageUsage 和 CompilerStats 对象！12private final PackageUsage mPackageUsage = new PackageUsage();private final CompilerStats mCompilerStats = new CompilerStats(); PackageUsage 用来统计 Package 的使用信息！ 123456class PackageUsage extends AbstractStatsBase&lt;Map&lt;String, PackageParser.Package&gt;&gt; &#123; PackageUsage() &#123; super(\"package-usage.list\", \"PackageUsage_DiskWriter\", /* lock */ true); &#125; ... ... ...&#125; PackageUsage 继承了抽象类 AbstractStatsBase，他会从 data/system/package-usage.list 中读取 package 的使用信息！ 1234567class CompilerStats extends AbstractStatsBase&lt;Void&gt; &#123; public CompilerStats() &#123; super(&quot;package-cstats.list&quot;, &quot;CompilerStats_DiskWriter&quot;, /* lock */ false); packageStats = new HashMap&lt;&gt;(); &#125; ... ... ...&#125; CompilerStats 同样继承了抽象类 AbstractStatsBase，他会从 data/system/package-cstats.list 中读取 package 的编译信息！ ##3.1 PackageUsage.read package-usage.list 的格式如下：包名 + 8 个时间戳123PACKAGE_USAGE__VERSION_1com.android.providers.telephony 0 0 0 1531174607101 1531246438563 0 1531246438760 0com.android.providers.calendar 0 1531246463197 0 1531246463181 1531246461258 0 0 0 我们来看看他是如何解析的！ read 方法会调用自身的 readInternal 方法！ ###3.1.1 PackageUsage.readInternal 我们来看下 readInternal 的方法调用！123456789101112131415161718192021222324@Overrideprotected void readInternal(Map&lt;String, PackageParser.Package&gt; packages) &#123; AtomicFile file = getFile(); BufferedInputStream in = null; try &#123; in = new BufferedInputStream(file.openRead()); StringBuffer sb = new StringBuffer(); String firstLine = readLine(in, sb); if (firstLine == null) &#123; &#125; else if (USAGE_FILE_MAGIC_VERSION_1.equals(firstLine)) &#123; //【3.1.2】根据第一行，我们会进入这里！ readVersion1LP(packages, in, sb); &#125; else &#123; readVersion0LP(packages, in, sb, firstLine); &#125; &#125; catch (FileNotFoundException expected) &#123; mIsHistoricalPackageUsageAvailable = false; &#125; catch (IOException e) &#123; Log.w(PackageManagerService.TAG, \"Failed to read package usage times\", e); &#125; finally &#123; IoUtils.closeQuietly(in); &#125;&#125; ###3.1.2 PackageUsage.readVersion1LP 我们来看下 readVersion1LP 的方法调用！123456789101112131415161718192021222324private void readVersion1LP(Map&lt;String, PackageParser.Package&gt; packages, InputStream in, StringBuffer sb) throws IOException &#123; String line; while ((line = readLine(in, sb)) != null) &#123; //【1】从 \" \" 将每一行分割开！ String[] tokens = line.split(\" \"); if (tokens.length != PackageManager.NOTIFY_PACKAGE_USE_REASONS_COUNT + 1) &#123; throw new IOException(\"Failed to parse \" + line + \" as a timestamp array.\"); &#125; String packageName = tokens[0]; PackageParser.Package pkg = packages.get(packageName); if (pkg == null) &#123; continue; &#125; //【2】将这 8 个时间戳保存到 PackageParser.Package.mLastPackageUsageTimeInMills 数组中！ for (int reason = 0; reason &lt; PackageManager.NOTIFY_PACKAGE_USE_REASONS_COUNT; reason++) &#123; pkg.mLastPackageUsageTimeInMills[reason] = parseAsLong(tokens[reason + 1]); &#125; &#125;&#125; 整个流程很简单！ ##3.2 CompilerStats.read package-cstats.list 的格式如下：12345PACKAGE_MANAGER__COMPILER_STATS__1com.android.storagemanager-StorageManager.apk:1362com.android.printspooler-PrintSpooler.apk:659 我们来看看他是如何解析的，CompilerStats.read[0] 会调用 CompilerStats.read(Reader r) 方法！ ###3.2.1 CompilerStats.read CompilerStats 内部有一个 map 表 packageStats 保存了 packageName 和对应的 PackageStats 的映射关系！1private final Map&lt;String, PackageStats&gt; packageStats; 我们来继续看 read 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public boolean read(Reader r) &#123; synchronized (packageStats) &#123; //【1】清空内部的 packageStats！ packageStats.clear(); try &#123; BufferedReader in = new BufferedReader(r); //【2】版本号校验！ String versionLine = in.readLine(); if (versionLine == null) &#123; throw new IllegalArgumentException(\"No version line found.\"); &#125; else &#123; if (!versionLine.startsWith(COMPILER_STATS_VERSION_HEADER)) &#123; throw new IllegalArgumentException(\"Invalid version line: \" + versionLine); &#125; int version = Integer.parseInt( versionLine.substring(COMPILER_STATS_VERSION_HEADER.length())); if (version != COMPILER_STATS_VERSION) &#123; // TODO: Upgrade older formats? For now, just reject and regenerate. throw new IllegalArgumentException(\"Unexpected version: \" + version); &#125; &#125; //【3】创建第一行 package 对应的 PackageStats 对象！ // 开始读取文件内容！ PackageStats currentPackage = new PackageStats(\"fake package\"); String s = null; while ((s = in.readLine()) != null) &#123; //【3.1】\"-\" 开头的 line 是 PackageStats 要封装的信息！ if (s.startsWith(\"-\")) &#123; int colonIndex = s.indexOf(':'); // 使用 \":\" 将每一行分割开！ if (colonIndex == -1 || colonIndex == 1) &#123; throw new IllegalArgumentException(\"Could not parse data \" + s); &#125; String codePath = s.substring(1, colonIndex); long time = Long.parseLong(s.substring(colonIndex + 1)); //【3.1.1】设置编译文件名和编译时间属性！ currentPackage.setCompileTime(codePath, time); &#125; else &#123; //【3.2.2】创建或者获得下一个 PackageStats 实例！ currentPackage = getOrCreatePackageStats(s); &#125; &#125; &#125; catch (Exception e) &#123; Log.e(PackageManagerService.TAG, \"Error parsing compiler stats\", e); return false; &#125; return true; &#125; &#125; 我们来看看 PackageStats 类：123456789static class PackageStats &#123; private final String packageName; private final Map&lt;String, Long&gt; compileTimePerCodePath; public PackageStats(String packageName) &#123; this.packageName = packageName; // We expect at least one element in here, but let's make it minimal. compileTimePerCodePath = new ArrayMap&lt;&gt;(2); &#125; packageName 是包名，compileTimePerCodePath 用来保存被编译的 code 文件名和编译的时间！ ###3.2.2 CompilerStats.getOrCreatePackageStats getOrCreatePackageStats 方法用来获得或者创建一个新的 PackageStats 对象！123456789101112131415161718public PackageStats getOrCreatePackageStats(String packageName) &#123; synchronized (packageStats) &#123; PackageStats existingStats = packageStats.get(packageName); if (existingStats != null) &#123; return existingStats; &#125; return createPackageStats(packageName); &#125;&#125;public PackageStats createPackageStats(String packageName) &#123; synchronized (packageStats) &#123; PackageStats newStats = new PackageStats(packageName); packageStats.put(packageName, newStats); return newStats; &#125;&#125; 整个方法流程很简单！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 3 篇 - PMS_SYSTEM_SCAN_START 阶段","slug":"PMS3-PMS_SYSTEM_SCAN_START","date":"2018-02-05T12:46:25.000Z","updated":"2018-11-20T16:24:24.000Z","comments":true,"path":"2018/02/05/PMS3-PMS_SYSTEM_SCAN_START/","link":"","permalink":"https://coolqi.top/2018/02/05/PMS3-PMS_SYSTEM_SCAN_START/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现，本文是作者原创，转载请说明出处！ 0 综述我们进入第二阶段系统目录扫描来分析，代码比较长，我们来回顾下该阶段的流程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213... ... ... ...// 接上面long startTime = SystemClock.uptimeMillis(); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);// 设置扫描参数！final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;// 获得环境变量：BOOTCLASSPATH 和 SYSTEMSERVERCLASSPATH！final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");if (bootClassPath == null) &#123; Slog.w(TAG, \"No BOOTCLASSPATH found!\");&#125;if (systemServerClassPath == null) &#123; Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");&#125;// 获得系统指令集合！final List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();final String[] dexCodeInstructionSets = getDexCodeInstructionSets( allInstructionSets.toArray(new String[allInstructionSets.size()]));// 对所有的共享库执行 odex 操作！if (mSharedLibraries.size() &gt; 0) &#123; for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123; final String lib = libEntry.path; if (lib == null) &#123; continue; &#125; try &#123; // Shared libraries do not have profiles so we perform a full // AOT compilation (if needed). int dexoptNeeded = DexFile.getDexOptNeeded( lib, dexCodeInstructionSet, getCompilerFilterForReason(REASON_SHARED_APK), false /* newProfile */); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/, getCompilerFilterForReason(REASON_SHARED_APK), StorageManager.UUID_PRIVATE_INTERNAL, SKIP_SHARED_LIBRARY_CHECK); &#125; &#125; catch (FileNotFoundException e) &#123; Slog.w(TAG, \"Library not found: \" + lib); &#125; catch (IOException | InstallerException e) &#123; Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \" + e.getMessage()); &#125; &#125; &#125;&#125;// 获得目录 /system/framework，对其目录下的文件进行优化 !File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");// 获得系统版本信息final VersionInfo ver = mSettings.getInternalVersion();// 判断是否是 OTA 升级，如果当前版本的指纹与历史版本的指纹信息不一致，表示当前版本是一次 OTA 升级上来更新版本！mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);// 判断是否是从 Android M 之前的版本升级过来的，如果是就需要把系统 app 的权限从安装时提高到运行时！mPromoteSystemApps = mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;// When upgrading from pre-N, we need to handle package extraction like first boot,// as there is no profiling data available.// 判断是否是从 Android 7.0 升级过来的！mIsPreNUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N;mIsPreNMR1Upgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N_MR1;// 保存从 Android 6.0 升级前已经存在的系统应用，并对他们进行优先扫描！// 扫描过程会将安装时权限变为运行时权限！if (mPromoteSystemApps) &#123; Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator(); while (pkgSettingIter.hasNext()) &#123; PackageSetting ps = pkgSettingIter.next(); if (isSystemApp(ps)) &#123; mExistingSystemPackages.add(ps.name); &#125; &#125;&#125;//【1】扫描收集目录 /vendor/overlay 下的供应商应用包！File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);scanDirTracedLI(vendorOverlayDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);// Find base frameworks (resource packages without code).//【2】扫描收集目录 /system/framework 下的应用包！ scanDirTracedLI(frameworkDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0);//【3】扫描收集目录 /system/priv-app 下的应用包！ final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");scanDirTracedLI(privilegedAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);//【4】扫描收集目录 /system/app 下的应用包！ final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");scanDirTracedLI(systemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//【5】扫描收集目录 /vendor/app 下的应用包！ File vendorAppDir = new File(\"/vendor/app\");try &#123; vendorAppDir = vendorAppDir.getCanonicalFile();&#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one&#125;scanDirTracedLI(vendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//【6】扫描收集目录 /oem/app 下的应用包！ final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");scanDirTracedLI(oemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);// 收集可能已经被删掉的系统应用包！final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();if (!mOnlyCore) &#123; // 遍历上一次安装的信息！ Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); while (psit.hasNext()) &#123; PackageSetting ps = psit.next(); // 如果不是系统应用，跳过！ if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; continue; &#125; final PackageParser.Package scannedPkg = mPackages.get(ps.name); if (scannedPkg != null) &#123; // 如果系统应用包不仅被扫描过（在mPackages中），并且在不可用列表中！ // 说明一定是通过覆盖更新的，移除之前扫描的结果，保证之前用户安装的应用能够被扫描！ if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; logCriticalInfo(Log.WARN, \"Expecting better updated system app for \" + ps.name + \"; removing system app. Last known codePath=\" + ps.codePathString + \", installStatus=\" + ps.installStatus + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\" + scannedPkg.mVersionCode); // 将之前的扫描结果移除！ removePackageLI(scannedPkg, true); // 将这包添加到 mExpectingBetter 列表中！ mExpectingBetter.put(ps.name, ps.codePath); &#125; // 跳出循环，确保不会被删掉！ continue; &#125; // 如果系统应用包没有被扫描，并且他也不在不可用的列表中，移除它，这个包不存在！ if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; psit.remove(); logCriticalInfo(Log.WARN, \"System package \" + ps.name + \" no longer exists; it's data will be wiped\"); // Actual deletion of code and data will be handled by later // reconciliation step &#125; else &#123; // 如果系统应用包没有被扫描，却在不可用的列表中，就将他加入到 // possiblyDeletedUpdatedSystemApps 集合中，需要被删除！ final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name); if (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123; possiblyDeletedUpdatedSystemApps.add(ps.name); &#125; &#125; &#125;&#125;// 清理所有安装不完全的应用包！ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();for (int i = 0; i &lt; deletePkgsList.size(); i++) &#123; // Actual deletion of code and data will be handled by later // reconciliation step final String packageName = deletePkgsList.get(i).name; logCriticalInfo(Log.WARN, \"Cleaning up incompletely installed app: \" + packageName); synchronized (mPackages) &#123; mSettings.removePackageLPw(packageName); &#125;&#125;// 移除临时文件deleteTempPackageFiles();// 移除没有和应用程序包相关联的共享用户 id！mSettings.pruneSharedUsersLPw(); ... ... ... ...// 见，第三阶段 主要流程如下： 对所有的共享库执行 odex 操作！ 扫描手机系统目录信息！ 收集那些可能已经不存在的系统应用包，在扫描完 data 分区后再处理！ 清理所有安装不完全的应用包！ 我们接下来继续分析： 1 对共享库执行 odex 操作主要代码块如下：1234567891011121314151617181920212223242526272829303132333435// 对所有的共享库执行 odex 操作！if (mSharedLibraries.size() &gt; 0) &#123; for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123; final String lib = libEntry.path; if (lib == null) &#123; continue; &#125; try &#123; // Shared libraries do not have profiles so we perform a full // AOT compilation (if needed). // 判断共享库是否需要执行 odex 操作 int dexoptNeeded = DexFile.getDexOptNeeded( lib, dexCodeInstructionSet, getCompilerFilterForReason(REASON_SHARED_APK), false /* newProfile */); // 如果需要 odex 操作，对共享库进行一次预编译（AOT） if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/, getCompilerFilterForReason(REASON_SHARED_APK), StorageManager.UUID_PRIVATE_INTERNAL, SKIP_SHARED_LIBRARY_CHECK); &#125; &#125; catch (FileNotFoundException e) &#123; Slog.w(TAG, \"Library not found: \" + lib); &#125; catch (IOException | InstallerException e) &#123; Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \" + e.getMessage()); &#125; &#125; &#125;&#125; 主要流程： 判断共享库是否需要执行 odex 操作; 如果需要执行 odex 操作，就对共享库进行预（AOT）处理; 2 系统目录扫描 - 开始阶段主要代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 设置扫描参数！final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;... ... ... ...// 扫描收集目录 /vendor/overlay 下的供应商应用包，用于资源替换！！File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);scanDirTracedLI(vendorOverlayDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);// Find base frameworks (resource packages without code).// 扫描收集目录 /system/framework 下的应用包！ scanDirTracedLI(frameworkDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0);// 扫描收集目录 /system/priv-app 下的应用包！ final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");scanDirTracedLI(privilegedAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);// 扫描收集目录 /system/app 下的应用包！ final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");scanDirTracedLI(systemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);// 扫描收集目录 /vendor/app 下的应用包！ File vendorAppDir = new File(\"/vendor/app\");try &#123; vendorAppDir = vendorAppDir.getCanonicalFile();&#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one&#125;scanDirTracedLI(vendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // 扫描收集目录 /oem/app 下的应用包！ final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");scanDirTracedLI(oemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); 扫描参数的设置为：int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL; 按照顺序扫描的目录有： /vendor/overlay /system/framework /system/priv-app /system/app /vendor/app /oem/app 调用 PMS.scanDirTracedLI 进行扫描，需要注意的是被扫描目录的顺序，这个顺序意味着：先被扫描到的文件，就是最终被用到的文件。 下面我们以 /system/app 目录为例，跟踪系统路径扫描的全过程！！ 2.1 PMS.scanDirTracedLI调用 scanDirTracedLI 方法进行目录扫描：1234567891011private void scanDirTracedLI(File dir, final int parseFlags, int scanFlags, long currentTime) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanDir\"); try &#123; //【2.2】进一步调用 scanDirLI 方法！ scanDirLI(dir, parseFlags, scanFlags, currentTime); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 2.2 PMS.scanDirLI12345678910111213141516171819202122232425262728293031323334353637383940414243private void scanDirLI(File dir, final int parseFlags, int scanFlags, long currentTime) &#123; // 获得 dir 目录中的文件集合！ final File[] files = dir.listFiles(); if (ArrayUtils.isEmpty(files)) &#123; Log.d(TAG, \"No files in app dir \" + dir); return; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; Log.d(TAG, \"Scanning app dir \" + dir + \" scanFlags=\" + scanFlags + \" flags=0x\" + Integer.toHexString(parseFlags)); &#125; // 遍历 dir 目录下的所有文件！ for (File file : files) &#123; //【1】判断 file 是否是 Package，必须要同时满足下面 2 个条件： // 1、file 以 \".apk\" 结尾或者 file 是一个目录； // 2、file 不是存储类型的文件； final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; continue; &#125; try &#123; //【2.3】如果 file 是 package 类型，继续调用 scanPackageTracedLI 进行扫描！ // 解析参数增加：必须是 apk！ scanPackageTracedLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); &#125; catch (PackageManagerException e) &#123; Slog.w(TAG, \"Failed to parse \" + file + \": \" + e.getMessage()); // 如果扫描 data 分区的 Apk 失败，则删除 data 分区扫描失败的文件 if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123; logCriticalInfo(Log.WARN, \"Deleting invalid package at \" + file); removeCodePathLI(file); &#125; &#125; &#125;&#125; 注意这里的 try catch 语句，后面方法抛出的异常都是在这个进行 catch 的！ 判断 file 是否是 Package，必须要同时满足下面 2 个条件： file 以 “.apk” 结尾或者 file 是一个目录； file 不是存储类型的文件： file 不以 vmdl 开头且不以 .tmp 结尾； file 不以 smdl 开头且不以 .tmp 结尾； file 不以 smdl2tmp 开头； 2.3 PMS.scanPackageTracedLI1234567891011private PackageParser.Package scanPackageTracedLI(File scanFile, final int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"scanPackage\"); try &#123; //【2.4】继续调用 scanPackageLI，执行扫描解析！ return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 继续： 2.4 PMS.scanPackageLI1234567891011121314151617181920212223242526272829303132private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"Parsing: \" + scanFile); //【1】创建一个 PackageParser 对象，用来执行解析操作！ PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); // mOnlyCore 为 false！ pp.setDisplayMetrics(mMetrics); if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) &#123; parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY; &#125; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"parsePackage\"); //【2】PackageParser.Package 用来保存解析结果！ final PackageParser.Package pkg; try &#123; //【3.1】开始扫描解析 scanFile，返回解析结果！ pkg = pp.parsePackage(scanFile, parseFlags); &#125; catch (PackageParserException e) &#123; throw PackageManagerException.from(e); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; //【3.2】继续扫描！ return scanPackageLI(pkg, scanFile, paraseFlags, scanFlags, currentTime, user);&#125; 下面我们来分析扫描的过程！ 3 系统目录扫描 - 扫描阶段下面，我把 PackageParser 简称为 PParser！ 3.1 PParser.parsePackage参数 flags 为 parseFlags，不同的目录取值不同： 123456789public Package parsePackage(File packageFile, int flags) throws PackageParserException &#123; if (packageFile.isDirectory()) &#123; //【3.1.1】Android 5.0 以后进入下面的分支！ return parseClusterPackage(packageFile, flags); &#125; else &#123; //【3.1.2】Android 5.0 以前进入下面的分支！ return parseMonolithicPackage(packageFile, flags); &#125;&#125; 这里有 2 中解析方式： 如果 packageFile 是一个目录的话，比如 /system/app/TimeService，那就采用第一种解析方式！ 如果 packageFile 是一个非目录文件的话，比如 /system/app/MyService.apk，那就采用第二种解析方式！ 这里给大家解释一下： Android 5.0 以前，apk 都是直接位于 app 目录下的，比如：/system/app/MyService.apk； 从 5.0 以后，谷歌引入了 apk 拆分机制，就是支持将一个 apk 拆分成很多个具有相同签名的子 apk，为了支持 apk 拆分，谷歌增加了一级目录：/system/app/MyService/，这个目录里会存放一到多个 apk，比如 base.apk，split.apk； pms 在解析 package 时，会把多个 apk 的数据封装成一个 Package，加载到内存中！！ 3.1.1 PParser.parseClusterPackage1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private Package parseClusterPackage(File packageDir, int flags) throws PackageParserException &#123; //【3.1.1.1】继续调用 parseClusterPackageLite 对 packageDir 目录下的！ final PackageLite lite = parseClusterPackageLite(packageDir, 0); // 根据前面的解析结果，判断是否有核心的应用，如果 lite 中没有核心应用，退出！ if (mOnlyCoreApps &amp;&amp; !lite.coreApp) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, \"Not a coreApp: \" + packageDir); &#125; final AssetManager assets = new AssetManager(); try &#123; // 装载应用程序的资源到 AssetManager！ loadApkIntoAssetManager(assets, lite.baseCodePath, flags); if (!ArrayUtils.isEmpty(lite.splitCodePaths)) &#123; // 如果 apk 被拆分了，加载子 apk 的资源！ for (String path : lite.splitCodePaths) &#123; loadApkIntoAssetManager(assets, path, flags); &#125; &#125; //【3.1.1.2】对核心 apk 解析，返回封装核心 apk 信息的 Package 对象 pkg! final File baseApk = new File(lite.baseCodePath); final Package pkg = parseBaseApk(baseApk, assets, flags); if (pkg == null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK, \"Failed to parse base APK: \" + baseApk); &#125; // 如果 apk 被拆分了，那就对非核心 apk 也进行处理！ if (!ArrayUtils.isEmpty(lite.splitNames)) &#123; final int num = lite.splitNames.length; pkg.splitNames = lite.splitNames; pkg.splitCodePaths = lite.splitCodePaths; pkg.splitRevisionCodes = lite.splitRevisionCodes; pkg.splitFlags = new int[num]; pkg.splitPrivateFlags = new int[num]; for (int i = 0; i &lt; num; i++) &#123; //【3.1.1.3】对拆分后的非核心 apk 也进行解析！ parseSplitApk(pkg, i, assets, flags); &#125; &#125; pkg.setCodePath(packageDir.getAbsolutePath()); // 设置 package 的 codePath！ pkg.setUse32bitAbi(lite.use32bitAbi); // 返回解析对象！ return pkg; &#125; finally &#123; IoUtils.closeQuietly(assets); &#125;&#125; 这里我们分为 3 个阶段来看： 对目录下的所有 apk 进行整体解析； 对目录中的核心 apk 进行解析； 如果 apk 被拆分了，对非核心应用进行解析； 3.1.1.1 PParser.parseClusterPackageLite首先，对目录下的所有 apk 进行整体解析：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private static PackageLite parseClusterPackageLite(File packageDir, int flags) throws PackageParserException &#123; final File[] files = packageDir.listFiles(); if (ArrayUtils.isEmpty(files)) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK, \"No packages found in split\"); &#125; String packageName = null; int versionCode = 0; final ArrayMap&lt;String, ApkLite&gt; apks = new ArrayMap&lt;&gt;(); //【1】遍历目录下的所有 apk 文件，包括主 apk 和子 apk！ for (File file : files) &#123; if (isApkFile(file)) &#123; //【3.1.1.1.1】解析 apk，将解析数据保存到 ApkLite 中！ final ApkLite lite = parseApkLite(file, flags); if (packageName == null) &#123; packageName = lite.packageName; versionCode = lite.versionCode; &#125; else &#123; if (!packageName.equals(lite.packageName)) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST, \"Inconsistent package \" + lite.packageName + \" in \" + file + \"; expected \" + packageName); &#125; if (versionCode != lite.versionCode) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST, \"Inconsistent version \" + lite.versionCode + \" in \" + file + \"; expected \" + versionCode); &#125; &#125; // 将解析得到的 ApkLite 对象添加到一个 ArrayMap 集合中！ // 注意：对于核心 apk，splitName 为 null！ if (apks.put(lite.splitName, lite) != null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST, \"Split name \" + lite.splitName + \" defined more than once; most recent was \" + file); &#125; &#125; &#125; //【2】从列表中移除核心 apk，保存到 baseApk 中，之所以 remove null，是因为 base apk 的 splitName 为 null！ // 如果没有 base apk，那就报错！！ final ApkLite baseApk = apks.remove(null); if (baseApk == null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST, \"Missing base APK in \" + packageDir); &#125; //【3】处理非核心的 apk！ final int size = apks.size(); String[] splitNames = null; String[] splitCodePaths = null; int[] splitRevisionCodes = null; if (size &gt; 0) &#123; //【3.1】获得非核心 apk 的 splitName，codePath 和 splitRevisionCodes！ splitNames = new String[size]; splitCodePaths = new String[size]; splitRevisionCodes = new int[size]; splitNames = apks.keySet().toArray(splitNames); Arrays.sort(splitNames, sSplitNameComparator); for (int i = 0; i &lt; size; i++) &#123; splitCodePaths[i] = apks.get(splitNames[i]).codePath; splitRevisionCodes[i] = apks.get(splitNames[i]).revisionCode; &#125; &#125; final String codePath = packageDir.getAbsolutePath(); //【3.1.1.1.2】创建所有应用的 PackageLite 解析对象，返回！ return new PackageLite(codePath, baseApk, splitNames, splitCodePaths, splitRevisionCodes);&#125; 这里调用了 parseApkLite 方法，解析 dir 下的核心 apk 和非核心 apk（如果有），然后获得非核心 apk 的 splitNames、splitCodePaths 和 splitRevisionCodes，最后创建 package 的 PackageLite 对象，并返回！ 3.1.1.1.1 PParser.parseApkLite[2]解析 apk 文件！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static ApkLite parseApkLite(File apkFile, int flags) throws PackageParserException &#123; final String apkPath = apkFile.getAbsolutePath(); AssetManager assets = null; XmlResourceParser parser = null; try &#123; // 创建资源管理器 assets = new AssetManager(); assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Build.VERSION.RESOURCES_SDK_INT); // 首先将 apk 中的资源加载到资源管理器 asserts 中。 int cookie = assets.addAssetPath(apkPath); if (cookie == 0) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK, \"Failed to parse \" + apkPath); &#125; final DisplayMetrics metrics = new DisplayMetrics(); metrics.setToDefaults(); final Resources res = new Resources(assets, metrics, null); //【1】创建解析器，用来解析 apk 的 AndroidMenifest.xml 文件。 parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME); final Signature[] signatures; final Certificate[][] certificates; if ((flags &amp; PARSE_COLLECT_CERTIFICATES) != 0) &#123; // TODO: factor signature related items out of Package object final Package tempPkg = new Package(null); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"collectCertificates\"); try &#123; // 进行签名验证，并将签名保存在 signatures 中。 collectCertificates(tempPkg, apkFile, 0 /*parseFlags*/); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; signatures = tempPkg.mSignatures; certificates = tempPkg.mCertificates; &#125; else &#123; signatures = null; certificates = null; &#125; // 将 &lt;manifest&gt; 标签的属性付给 attrs！ final AttributeSet attrs = parser; //【3.1.1.1.1.1】接着调用 parseApkLite 继续解析！ return parseApkLite(apkPath, res, parser, attrs, flags, signatures, certificates); &#125; catch (XmlPullParserException | IOException | RuntimeException e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION, \"Failed to parse \" + apkPath, e); &#125; finally &#123; IoUtils.closeQuietly(parser); IoUtils.closeQuietly(assets); &#125;&#125; 调用重载函数 parseApkLite 函数，继续解析，参数传递： 3.1.1.1.1.1 PParser.parseApkLite[7]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private static ApkLite parseApkLite(String codePath, Resources res, XmlPullParser parser, AttributeSet attrs, int flags, Signature[] signatures, Certificate[][] certificates) throws IOException, XmlPullParserException, PackageParserException &#123; //【3.1.1.1.1.2】解析获得应用的 final Pair&lt;String, String&gt; packageSplit = parsePackageSplitNames(parser, attrs); int installLocation = PARSE_DEFAULT_INSTALL_LOCATION; int versionCode = 0; int revisionCode = 0; boolean coreApp = false; boolean multiArch = false; boolean use32bitAbi = false; boolean extractNativeLibs = true; //【1】解析 &lt;manifest&gt; 标签的属性！ for (int i = 0; i &lt; attrs.getAttributeCount(); i++) &#123; final String attr = attrs.getAttributeName(i); // 解析 android:installLocation 属性，表示安装位置，取值为 auto|internalOnly|preferExternal if (attr.equals(\"installLocation\")) &#123; installLocation = attrs.getAttributeIntValue(i, PARSE_DEFAULT_INSTALL_LOCATION); &#125; else if (attr.equals(\"versionCode\")) &#123; // 解析版本号 versionCode！ versionCode = attrs.getAttributeIntValue(i, 0); &#125; else if (attr.equals(\"revisionCode\")) &#123; revisionCode = attrs.getAttributeIntValue(i, 0); &#125; else if (attr.equals(\"coreApp\")) &#123; // 是否是核心 apk coreApp = attrs.getAttributeBooleanValue(i, false); &#125; &#125; //【2】接着，解析 manifest 标签的直接子标签！ int type; final int searchDepth = parser.getDepth() + 1; final List&lt;VerifierInfo&gt; verifiers = new ArrayList&lt;VerifierInfo&gt;(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt;= searchDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; //【2.1】解析 &lt;package-verifier&gt; 标签的属性！ if (parser.getDepth() == searchDepth &amp;&amp; \"package-verifier\".equals(parser.getName())) &#123; final VerifierInfo verifier = parseVerifier(res, parser, attrs, flags); if (verifier != null) &#123; verifiers.add(verifier); &#125; &#125; //【2.2】解析 &lt;application&gt; 标签的属性！ if (parser.getDepth() == searchDepth &amp;&amp; \"application\".equals(parser.getName())) &#123; for (int i = 0; i &lt; attrs.getAttributeCount(); ++i) &#123; final String attr = attrs.getAttributeName(i); if (\"multiArch\".equals(attr)) &#123; multiArch = attrs.getAttributeBooleanValue(i, false); &#125; if (\"use32bitAbi\".equals(attr)) &#123; use32bitAbi = attrs.getAttributeBooleanValue(i, false); &#125; if (\"extractNativeLibs\".equals(attr)) &#123; extractNativeLibs = attrs.getAttributeBooleanValue(i, true); &#125; &#125; &#125; &#125; //【3.1.1.1.1.3】创建 apk 对应的 ApkLite 对象！！ return new ApkLite(codePath, packageSplit.first, packageSplit.second, versionCode, revisionCode, installLocation, verifiers, signatures, certificates, coreApp, multiArch, use32bitAbi, extractNativeLibs);&#125; 3.1.1.1.1.2 PParser.parsePackageSplitNames该方法用于解析 apk 的 “manifest” 标签的 package 属性和 split 属性！12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static Pair&lt;String, String&gt; parsePackageSplitNames(XmlPullParser parser, AttributeSet attrs) throws IOException, XmlPullParserException, PackageParserException &#123; int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; &#125; if (type != XmlPullParser.START_TAG) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, \"No start tag found\"); &#125; if (!parser.getName().equals(TAG_MANIFEST)) &#123; // 如果不是 manifest 标签！ throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, \"No &lt;manifest&gt; tag\"); &#125; //【1】解析 manifest 标签的 package 属性！ final String packageName = attrs.getAttributeValue(null, \"package\"); if (!\"android\".equals(packageName)) &#123; // 如果 package 不是 android，那需要校验格式！ final String error = validateName(packageName, true, true); if (error != null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, \"Invalid manifest package: \" + error); &#125; &#125; //【2】解析 manifest 标签的 split 属性！ String splitName = attrs.getAttributeValue(null, \"split\"); if (splitName != null) &#123; if (splitName.length() == 0) &#123; splitName = null; &#125; else &#123; final String error = validateName(splitName, false, false); if (error != null) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME, \"Invalid manifest split: \" + error); &#125; &#125; &#125; //【3】返回 packageName 和 splitName 的 Pair 对象！ return Pair.create(packageName.intern(), (splitName != null) ? splitName.intern() : splitName);&#125; 接着创建一个 ApkLite 对象，用来封装 apk 的解析信息！ 3.1.1.1.1.3 new ApkLite最后，将结果封装为一个 ApkLite 对象，并返回！12345678910111213141516171819202122232425262728293031323334public static class ApkLite &#123; public final String codePath; // apk 路径，就是 apk 文件的绝对路径！ public final String packageName; // 应用程序包名 public final String splitName; // 非核心 apk 包名 public final int versionCode; // 版本号 public final int revisionCode; // 修订版本号 public final int installLocation; // 安装位置 public final VerifierInfo[] verifiers; // 校验信息 public final Signature[] signatures; // 签名信息 public final Certificate[][] certificates; // 证书信息 public final boolean coreApp; // 是否是核心应用 public final boolean multiArch; // 是否支持多软件架构 public final boolean use32bitAbi; // 是否使用 32 位系统指令集 public final boolean extractNativeLibs; // 是否依赖额外的本地库 public ApkLite(String codePath, String packageName, String splitName, int versionCode, int revisionCode, int installLocation, List&lt;VerifierInfo&gt; verifiers, Signature[] signatures, Certificate[][] certificates, boolean coreApp, boolean multiArch, boolean use32bitAbi, boolean extractNativeLibs) &#123; this.codePath = codePath; this.packageName = packageName; this.splitName = splitName; this.versionCode = versionCode; this.revisionCode = revisionCode; this.installLocation = installLocation; this.verifiers = verifiers.toArray(new VerifierInfo[verifiers.size()]); this.signatures = signatures; this.certificates = certificates; this.coreApp = coreApp; this.multiArch = multiArch; this.use32bitAbi = use32bitAbi; this.extractNativeLibs = extractNativeLibs; &#125;&#125; 然后返回，回到 PP.parseClusterPackageLite 函数中，根据解析的结果，创建 PackageLite 对象： 3.1.1.1.2 new PackageLitePackageLite 用来封装一个应用程序包的信息，PackageLite 的构造器如下： 12345678910111213141516171819202122232425262728293031323334353637383940public static class PackageLite &#123; public final String packageName; // base apk 应用程序包名； public final int versionCode; // base apk 的版本号； public final int installLocation; // base apk 的安装位置； public final VerifierInfo[] verifiers; // base apk 的安装位置； public final String[] splitNames; // 非核心 apk 的名称； public final String codePath; // 应用程序包的绝对路径，/system/app/com.coolqi.papapa public final String baseCodePath; // base apk 的路径，/system/app/com.coolqi.papapa/base.apk public final String[] splitCodePaths; //非核心 apk 的路径 public final int baseRevisionCode; // 核心 apk 的修订版版本号 public final int[] splitRevisionCodes; // 非核心 apk 的修订版版本号 public final boolean coreApp; // 是否有核心 apk！ public final boolean multiArch; // 是否支持多软件平台架构！ public final boolean use32bitAbi; // 是否使用 23 位的系统指令集！ public final boolean extractNativeLibs; // 是否支持！ public PackageLite(String codePath, ApkLite baseApk, String[] splitNames, String[] splitCodePaths, int[] splitRevisionCodes) &#123; this.packageName = baseApk.packageName; this.versionCode = baseApk.versionCode; this.installLocation = baseApk.installLocation; this.verifiers = baseApk.verifiers; this.splitNames = splitNames; this.codePath = codePath; this.baseCodePath = baseApk.codePath; this.splitCodePaths = splitCodePaths; this.baseRevisionCode = baseApk.revisionCode; this.splitRevisionCodes = splitRevisionCodes; this.coreApp = baseApk.coreApp; this.multiArch = baseApk.multiArch; this.use32bitAbi = baseApk.use32bitAbi; this.extractNativeLibs = baseApk.extractNativeLibs; &#125;&#125; 这里我们不在过多分析！！ 3.1.1.2 PParser.parseBaseApk[3]解析 base apk：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Package parseBaseApk(File apkFile, AssetManager assets, int flags) throws PackageParserException &#123; final String apkPath = apkFile.getAbsolutePath(); String volumeUuid = null; if (apkPath.startsWith(MNT_EXPAND)) &#123; // 解析 /mnt/expand/ final int end = apkPath.indexOf('/', MNT_EXPAND.length()); volumeUuid = apkPath.substring(MNT_EXPAND.length(), end); &#125; mParseError = PackageManager.INSTALL_SUCCEEDED; mArchiveSourcePath = apkFile.getAbsolutePath(); if (DEBUG_JAR) Slog.d(TAG, \"Scanning base APK: \" + apkPath); final int cookie = loadApkIntoAssetManager(assets, apkPath, flags); Resources res = null; XmlResourceParser parser = null; try &#123; res = new Resources(assets, mMetrics, null); assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Build.VERSION.RESOURCES_SDK_INT); //【1】用于解析 AndroidManifest.xml 文件！ parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME); final String[] outError = new String[1]; //【3.1.1.2】解析核心 apk！ final Package pkg = parseBaseApk(res, parser, flags, outError); if (pkg == null) &#123; throw new PackageParserException(mParseError, apkPath + \" (at \" + parser.getPositionDescription() + \"): \" + outError[0]); &#125; pkg.setVolumeUuid(volumeUuid); pkg.setApplicationVolumeUuid(volumeUuid); pkg.setBaseCodePath(apkPath); pkg.setSignatures(null); return pkg; &#125; catch (PackageParserException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION, \"Failed to read manifest from \" + apkPath, e); &#125; finally &#123; IoUtils.closeQuietly(parser); &#125;&#125; 接着，调用重载 parseBaseApk 方法： 3.1.1.2.1 PParser.parseBaseApk[4]我们继续来看：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; final String splitName; final String pkgName; try &#123; //【3.1.1.1.1.2】解析 &lt;manifest&gt; 标签，获得 packageName 和 splitName， // 以 Pair&lt;packageName, splitName&gt; 的形式返回！ Pair&lt;String, String&gt; packageSplit = parsePackageSplitNames(parser, parser); pkgName = packageSplit.first; splitName = packageSplit.second; if (!TextUtils.isEmpty(splitName)) &#123; outError[0] = \"Expected base APK, but found split \" + splitName; mParseError = PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME; return null; &#125; &#125; catch (PackageParserException e) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME; return null; &#125; //【3.1.3】创建一个 Package 对象，用于保存最终的解析信息！ final Package pkg = new Package(pkgName); // 解析 &lt;manifest&gt; 标签，获得 versionCode、revisionCode、versionName、coreApp 值！ TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifest); pkg.mVersionCode = pkg.applicationInfo.versionCode = sa.getInteger( com.android.internal.R.styleable.AndroidManifest_versionCode, 0); pkg.baseRevisionCode = sa.getInteger( com.android.internal.R.styleable.AndroidManifest_revisionCode, 0); pkg.mVersionName = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifest_versionName, 0); if (pkg.mVersionName != null) &#123; pkg.mVersionName = pkg.mVersionName.intern(); &#125; pkg.coreApp = parser.getAttributeBooleanValue(null, \"coreApp\", false); sa.recycle(); //【3.1.1.2.2】接着，调用 parseBaseApkCommon 方法，继续解析！ return parseBaseApkCommon(pkg, null, res, parser, flags, outError);&#125; 3.1.1.2.2 PParser.parseBaseApkCommon [6]进入最终的解析方法中： Package pkg：应用程序的信息封装对象； Set acceptedTags：需要解析的标签，如果传入 null ，表示解析所有，这里传入 null； Resources res： XmlResourceParser parser： int flags： String[] outError：用于保存解析过程中的错误信息； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566private Package parseBaseApkCommon(Package pkg, Set&lt;String&gt; acceptedTags, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; mParseInstrumentationArgs = null; mParseActivityArgs = null; mParseServiceArgs = null; mParseProviderArgs = null; int type; boolean foundApp = false; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifest); //【1】获得 sharedUserId 属性！ String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifest_sharedUserId, 0); if (str != null &amp;&amp; str.length() &gt; 0) &#123; String nameError = validateName(str, true, false); if (nameError != null &amp;&amp; !\"android\".equals(pkg.packageName)) &#123; outError[0] = \"&lt;manifest&gt; specifies bad sharedUserId name \\\"\" + str + \"\\\": \" + nameError; mParseError = PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID; return null; &#125; pkg.mSharedUserId = str.intern(); pkg.mSharedUserLabel = sa.getResourceId( com.android.internal.R.styleable.AndroidManifest_sharedUserLabel, 0); &#125; //【2】获得 installLocation 属性！ pkg.installLocation = sa.getInteger( com.android.internal.R.styleable.AndroidManifest_installLocation, PARSE_DEFAULT_INSTALL_LOCATION); pkg.applicationInfo.installLocation = pkg.installLocation; /* Set the global \"forward lock\" flag */ if ((flags &amp; PARSE_FORWARD_LOCK) != 0) &#123; pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_FORWARD_LOCK; &#125; /* Set the global \"on SD card\" flag */ if ((flags &amp; PARSE_EXTERNAL_STORAGE) != 0) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_EXTERNAL_STORAGE; &#125; if ((flags &amp; PARSE_IS_EPHEMERAL) != 0) &#123; pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_EPHEMERAL; &#125; // Resource boolean are -1, so 1 means we don't know the value. int supportsSmallScreens = 1; int supportsNormalScreens = 1; int supportsLargeScreens = 1; int supportsXLargeScreens = 1; int resizeable = 1; int anyDensity = 1; int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (acceptedTags != null &amp;&amp; !acceptedTags.contains(tagName)) &#123; Slog.w(TAG, \"Skipping unsupported element under &lt;manifest&gt;: \" + tagName + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; if (tagName.equals(TAG_APPLICATION)) &#123; // 解析 \"application\" 标签 if (foundApp) &#123; if (RIGID_PARSER) &#123; outError[0] = \"&lt;manifest&gt; has more than one &lt;application&gt;\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; else &#123; Slog.w(TAG, \"&lt;manifest&gt; has more than one &lt;application&gt;\"); XmlUtils.skipCurrentTag(parser); continue; &#125; &#125; foundApp = true; //【3.1.1.2.3】接着调用 parseBaseApplication 方法解析 \"application\" 标签的属性以及四大组件的信息！ if (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_OVERLAY)) &#123; // 解析 \"overlay\" 标签 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestResourceOverlay); pkg.mOverlayTarget = sa.getString( com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage); pkg.mOverlayPriority = sa.getInt( com.android.internal.R.styleable.AndroidManifestResourceOverlay_priority, -1); sa.recycle(); if (pkg.mOverlayTarget == null) &#123; outError[0] = \"&lt;overlay&gt; does not specify a target package\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; if (pkg.mOverlayPriority &lt; 0 || pkg.mOverlayPriority &gt; 9999) &#123; outError[0] = \"&lt;overlay&gt; priority must be between 0 and 9999\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_KEY_SETS)) &#123; // 解析 'key-sets\" 标签 if (!parseKeySets(pkg, res, parser, outError)) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_PERMISSION_GROUP)) &#123; //【3.1.1.2.2.1】解析 'permission-group\" 标签 if (parsePermissionGroup(pkg, flags, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_PERMISSION)) &#123; //【3.1.1.2.2.2】解析 'permission\" 标签 if (parsePermission(pkg, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_PERMISSION_TREE)) &#123; //【3.1.1.2.2.3】解析 'permission-tree\" 标签 if (parsePermissionTree(pkg, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_USES_PERMISSION)) &#123; //【3.1.1.2.2.4】解析 'uses-permission\" 标签 if (!parseUsesPermission(pkg, res, parser)) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_USES_PERMISSION_SDK_M) || tagName.equals(TAG_USES_PERMISSION_SDK_23)) &#123; // 解析 'uses-permission-sdk-m\" 或 \"uses-permission-sdk-23\" 标签 if (!parseUsesPermission(pkg, res, parser)) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_USES_CONFIGURATION)) &#123; // 解析 \"uses-configuration\" 标签 ConfigurationInfo cPref = new ConfigurationInfo(); sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestUsesConfiguration); cPref.reqTouchScreen = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen, Configuration.TOUCHSCREEN_UNDEFINED); cPref.reqKeyboardType = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType, Configuration.KEYBOARD_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard, false)) &#123; cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD; &#125; cPref.reqNavigation = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation, Configuration.NAVIGATION_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav, false)) &#123; cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV; &#125; sa.recycle(); pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_USES_FEATURE)) &#123; // 解析 \"uses-feature\" 标签 FeatureInfo fi = parseUsesFeature(res, parser); pkg.reqFeatures = ArrayUtils.add(pkg.reqFeatures, fi); if (fi.name == null) &#123; ConfigurationInfo cPref = new ConfigurationInfo(); cPref.reqGlEsVersion = fi.reqGlEsVersion; pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_FEATURE_GROUP)) &#123; // 解析 \"feature-group\" 标签 FeatureGroupInfo group = new FeatureGroupInfo(); ArrayList&lt;FeatureInfo&gt; features = null; final int innerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; final String innerTagName = parser.getName(); if (innerTagName.equals(\"uses-feature\")) &#123; FeatureInfo featureInfo = parseUsesFeature(res, parser); // FeatureGroups are stricter and mandate that // any &lt;uses-feature&gt; declared are mandatory. featureInfo.flags |= FeatureInfo.FLAG_REQUIRED; features = ArrayUtils.add(features, featureInfo); &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;feature-group&gt;: \" + innerTagName + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; XmlUtils.skipCurrentTag(parser); &#125; if (features != null) &#123; group.features = new FeatureInfo[features.size()]; group.features = features.toArray(group.features); &#125; pkg.featureGroups = ArrayUtils.add(pkg.featureGroups, group); &#125; else if (tagName.equals(TAG_USES_SDK)) &#123; // 解析 \"uses-sdk\" 标签 if (SDK_VERSION &gt; 0) &#123; sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestUsesSdk); int minVers = 1; String minCode = null; int targetVers = 0; String targetCode = null; TypedValue val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion); if (val != null) &#123; if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) &#123; targetCode = minCode = val.string.toString(); &#125; else &#123; // If it's not a string, it's an integer. targetVers = minVers = val.data; &#125; &#125; val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion); if (val != null) &#123; if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) &#123; targetCode = val.string.toString(); if (minCode == null) &#123; minCode = targetCode; &#125; &#125; else &#123; // If it's not a string, it's an integer. targetVers = val.data; &#125; &#125; sa.recycle(); if (minCode != null) &#123; boolean allowedCodename = false; for (String codename : SDK_CODENAMES) &#123; if (minCode.equals(codename)) &#123; allowedCodename = true; break; &#125; &#125; if (!allowedCodename) &#123; if (SDK_CODENAMES.length &gt; 0) &#123; outError[0] = \"Requires development platform \" + minCode + \" (current platform is any of \" + Arrays.toString(SDK_CODENAMES) + \")\"; &#125; else &#123; outError[0] = \"Requires development platform \" + minCode + \" but this is a release platform.\"; &#125; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; &#125; pkg.applicationInfo.minSdkVersion = android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; &#125; else if (minVers &gt; SDK_VERSION) &#123; outError[0] = \"Requires newer sdk version #\" + minVers + \" (current version is #\" + SDK_VERSION + \")\"; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; &#125; else &#123; pkg.applicationInfo.minSdkVersion = minVers; &#125; if (targetCode != null) &#123; boolean allowedCodename = false; for (String codename : SDK_CODENAMES) &#123; if (targetCode.equals(codename)) &#123; allowedCodename = true; break; &#125; &#125; if (!allowedCodename) &#123; if (SDK_CODENAMES.length &gt; 0) &#123; outError[0] = \"Requires development platform \" + targetCode + \" (current platform is any of \" + Arrays.toString(SDK_CODENAMES) + \")\"; &#125; else &#123; outError[0] = \"Requires development platform \" + targetCode + \" but this is a release platform.\"; &#125; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; &#125; // If the code matches, it definitely targets this SDK. pkg.applicationInfo.targetSdkVersion = android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; &#125; else &#123; pkg.applicationInfo.targetSdkVersion = targetVers; &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_SUPPORT_SCREENS)) &#123; // 解析 \"supports-screens\" 标签 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestSupportsScreens); pkg.applicationInfo.requiresSmallestWidthDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_requiresSmallestWidthDp, 0); pkg.applicationInfo.compatibleWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_compatibleWidthLimitDp, 0); pkg.applicationInfo.largestWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largestWidthLimitDp, 0); // 和屏幕相关的参数解析，屏幕大小等等！ supportsSmallScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens, supportsSmallScreens); supportsNormalScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens, supportsNormalScreens); supportsLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens, supportsLargeScreens); supportsXLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_xlargeScreens, supportsXLargeScreens); resizeable = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable, resizeable); anyDensity = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity, anyDensity); sa.recycle(); XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_PROTECTED_BROADCAST)) &#123; // 解析 \"protected-broadcast\" 标签 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestProtectedBroadcast); // Note: don't allow this value to be a reference to a resource // that may change. String name = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name); sa.recycle(); if (name != null &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) != 0) &#123; if (pkg.protectedBroadcasts == null) &#123; pkg.protectedBroadcasts = new ArrayList&lt;String&gt;(); &#125; if (!pkg.protectedBroadcasts.contains(name)) &#123; pkg.protectedBroadcasts.add(name.intern()); &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_INSTRUMENTATION)) &#123; // 解析 \"instrumentation\" 标签 if (parseInstrumentation(pkg, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_ORIGINAL_PACKAGE)) &#123; // 解析 \"original-package\" 标签 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String orig =sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); if (!pkg.packageName.equals(orig)) &#123; if (pkg.mOriginalPackages == null) &#123; pkg.mOriginalPackages = new ArrayList&lt;String&gt;(); pkg.mRealPackage = pkg.packageName; &#125; pkg.mOriginalPackages.add(orig); &#125; sa.recycle(); XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_ADOPT_PERMISSIONS)) &#123; // 解析 \"adopt-permissions\" 标签 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String name = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); sa.recycle(); if (name != null) &#123; if (pkg.mAdoptPermissions == null) &#123; pkg.mAdoptPermissions = new ArrayList&lt;String&gt;(); &#125; pkg.mAdoptPermissions.add(name); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(TAG_USES_GL_TEXTURE)) &#123; // 跳过一下标签！ // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; &#125; else if (tagName.equals(TAG_COMPATIBLE_SCREENS)) &#123; // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; &#125; else if (tagName.equals(TAG_SUPPORTS_INPUT)) &#123; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (tagName.equals(TAG_EAT_COMMENT)) &#123; // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; &#125; else if (tagName.equals(TAG_PACKAGE)) &#123; // 解析 \"package\" 标签，该标签表示应用的子包！ if (!MULTI_PACKAGE_APK_ENABLED) &#123; XmlUtils.skipCurrentTag(parser); continue; &#125; // 所有的子包都会解析保存到 ArrayList&lt;Package&gt; childPackages 集合中！ if (!parseBaseApkChild(pkg, res, parser, flags, outError)) &#123; // If parsing a child failed the error is already set return null; &#125; &#125; else if (tagName.equals(TAG_RESTRICT_UPDATE)) &#123; // 解析 \"restrict-update\" 标签 if ((flags &amp; PARSE_IS_SYSTEM_DIR) != 0) &#123; sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestRestrictUpdate); final String hash = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestRestrictUpdate_hash, 0); sa.recycle(); pkg.restrictUpdateHash = null; if (hash != null) &#123; final int hashLength = hash.length(); final byte[] hashBytes = new byte[hashLength / 2]; for (int i = 0; i &lt; hashLength; i += 2)&#123; hashBytes[i/2] = (byte) ((Character.digit(hash.charAt(i), 16) &lt;&lt; 4) + Character.digit(hash.charAt(i + 1), 16)); &#125; pkg.restrictUpdateHash = hashBytes; &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (RIGID_PARSER) &#123; outError[0] = \"Bad element under &lt;manifest&gt;: \" + parser.getName(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;manifest&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; &#125; if (!foundApp &amp;&amp; pkg.instrumentation.size() == 0) &#123; outError[0] = \"&lt;manifest&gt; does not contain an &lt;application&gt; or &lt;instrumentation&gt;\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY; &#125; final int NP = PackageParser.NEW_PERMISSIONS.length; StringBuilder implicitPerms = null; for (int ip=0; ip&lt;NP; ip++) &#123; final PackageParser.NewPermissionInfo npi = PackageParser.NEW_PERMISSIONS[ip]; if (pkg.applicationInfo.targetSdkVersion &gt;= npi.sdkVersion) &#123; break; &#125; if (!pkg.requestedPermissions.contains(npi.name)) &#123; if (implicitPerms == null) &#123; implicitPerms = new StringBuilder(128); implicitPerms.append(pkg.packageName); implicitPerms.append(\": compat added \"); &#125; else &#123; implicitPerms.append(' '); &#125; implicitPerms.append(npi.name); pkg.requestedPermissions.add(npi.name); &#125; &#125; if (implicitPerms != null) &#123; Slog.i(TAG, implicitPerms.toString()); &#125; final int NS = PackageParser.SPLIT_PERMISSIONS.length; for (int is=0; is&lt;NS; is++) &#123; final PackageParser.SplitPermissionInfo spi = PackageParser.SPLIT_PERMISSIONS[is]; if (pkg.applicationInfo.targetSdkVersion &gt;= spi.targetSdk || !pkg.requestedPermissions.contains(spi.rootPerm)) &#123; continue; &#125; for (int in=0; in&lt;spi.newPerms.length; in++) &#123; final String perm = spi.newPerms[in]; if (!pkg.requestedPermissions.contains(perm)) &#123; pkg.requestedPermissions.add(perm); &#125; &#125; &#125; // 解析屏幕大小、像素密度相关的属性！ if (supportsSmallScreens &lt; 0 || (supportsSmallScreens &gt; 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &gt;= android.os.Build.VERSION_CODES.DONUT)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS; &#125; if (supportsNormalScreens != 0) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS; &#125; if (supportsLargeScreens &lt; 0 || (supportsLargeScreens &gt; 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &gt;= android.os.Build.VERSION_CODES.DONUT)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS; &#125; if (supportsXLargeScreens &lt; 0 || (supportsXLargeScreens &gt; 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SUPPORTS_XLARGE_SCREENS; &#125; if (resizeable &lt; 0 || (resizeable &gt; 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &gt;= android.os.Build.VERSION_CODES.DONUT)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS; &#125; if (anyDensity &lt; 0 || (anyDensity &gt; 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &gt;= android.os.Build.VERSION_CODES.DONUT)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES; &#125; // 返回 Package 对象！ return pkg;&#125; 在这个方法中，解析 apk 中的四大组件，权限等信息，核心 apk 解析到此为止！ 3.1.1.2.2.1 PParser.parsePermissionGroup - 解析 permission-groupparsePermissionGroup 用于解析该应用所使用到的 permission-group： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private PermissionGroup parsePermissionGroup(Package owner, int flags, Resources res, XmlResourceParser parser, String[] outError) throws XmlPullParserException, IOException &#123; //【1】对于权限组，创建了 PermissionGroup 对象！ PermissionGroup perm = new PermissionGroup(owner); TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPermissionGroup); if (!parsePackageItemInfo(owner, perm.info, outError, \"&lt;permission-group&gt;\", sa, true /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestPermissionGroup_name, com.android.internal.R.styleable.AndroidManifestPermissionGroup_label, com.android.internal.R.styleable.AndroidManifestPermissionGroup_icon, com.android.internal.R.styleable.AndroidManifestPermissionGroup_roundIcon, com.android.internal.R.styleable.AndroidManifestPermissionGroup_logo, com.android.internal.R.styleable.AndroidManifestPermissionGroup_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; //【2】解析相关的属性 perm.info.descriptionRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestPermissionGroup_description, 0); perm.info.flags = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermissionGroup_permissionGroupFlags, 0); perm.info.priority = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermissionGroup_priority, 0); if (perm.info.priority &gt; 0 &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) == 0) &#123; perm.info.priority = 0; &#125; sa.recycle(); if (!parseAllMetaData(res, parser, \"&lt;permission-group&gt;\", perm, outError)) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; //【3】保存到 owner.permissionGroups 中！ owner.permissionGroups.add(perm); return perm;&#125; 这里就不多说了！ 3.1.1.2.2.2 PParser.parsePermission - 解析 permissionparsePermission 解析该应用中定义的权限！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private Permission parsePermission(Package owner, Resources res, XmlResourceParser parser, String[] outError) throws XmlPullParserException, IOException &#123; //【1】创建 Permission 对象 Permission perm = new Permission(owner); TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPermission); if (!parsePackageItemInfo(owner, perm.info, outError, \"&lt;permission&gt;\", sa, true /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestPermission_name, com.android.internal.R.styleable.AndroidManifestPermission_label, com.android.internal.R.styleable.AndroidManifestPermission_icon, com.android.internal.R.styleable.AndroidManifestPermission_roundIcon, com.android.internal.R.styleable.AndroidManifestPermission_logo, com.android.internal.R.styleable.AndroidManifestPermission_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; // 解析 android:permissionGroup 属性 perm.info.group = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestPermission_permissionGroup); if (perm.info.group != null) &#123; perm.info.group = perm.info.group.intern(); &#125; perm.info.descriptionRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestPermission_description, 0); // 解析 android:protectionLevel 属性 perm.info.protectionLevel = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermission_protectionLevel, PermissionInfo.PROTECTION_NORMAL); // 解析 android:permissionFlags 属性 perm.info.flags = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermission_permissionFlags, 0); sa.recycle(); if (perm.info.protectionLevel == -1) &#123; outError[0] = \"&lt;permission&gt; does not specify protectionLevel\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; perm.info.protectionLevel = PermissionInfo.fixProtectionLevel(perm.info.protectionLevel); if ((perm.info.protectionLevel&amp;PermissionInfo.PROTECTION_MASK_FLAGS) != 0) &#123; if ((perm.info.protectionLevel&amp;PermissionInfo.PROTECTION_MASK_BASE) != PermissionInfo.PROTECTION_SIGNATURE) &#123; outError[0] = \"&lt;permission&gt; protectionLevel specifies a flag but is \" + \"not based on signature type\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; &#125; if (!parseAllMetaData(res, parser, \"&lt;permission&gt;\", perm, outError)) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; // 将解析的权限信息保存到 owner.permissions 中！ owner.permissions.add(perm); return perm;&#125; 解析很简单，不多说了！ 3.1.1.2.2.3 PParser.parsePermissionTree - 解析 permission-treeparsePermissionTree 用于解析该应用所使用到的 permission-tree： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Permission parsePermissionTree(Package owner, Resources res, XmlResourceParser parser, String[] outError) throws XmlPullParserException, IOException &#123; //【1】可以看到对于 permission-tree，依然是会创建一个 Permission 对象！ Permission perm = new Permission(owner); TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPermissionTree); if (!parsePackageItemInfo(owner, perm.info, outError, \"&lt;permission-tree&gt;\", sa, true /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestPermissionTree_name, com.android.internal.R.styleable.AndroidManifestPermissionTree_label, com.android.internal.R.styleable.AndroidManifestPermissionTree_icon, com.android.internal.R.styleable.AndroidManifestPermissionTree_roundIcon, com.android.internal.R.styleable.AndroidManifestPermissionTree_logo, com.android.internal.R.styleable.AndroidManifestPermissionTree_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; sa.recycle(); //【2】解析权限的属性； int index = perm.info.name.indexOf('.'); if (index &gt; 0) &#123; index = perm.info.name.indexOf('.', index+1); &#125; if (index &lt; 0) &#123; outError[0] = \"&lt;permission-tree&gt; name has less than three segments: \" + perm.info.name; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; perm.info.descriptionRes = 0; perm.info.protectionLevel = PermissionInfo.PROTECTION_NORMAL; perm.tree = true; if (!parseAllMetaData(res, parser, \"&lt;permission-tree&gt;\", perm, outError)) &#123; // 解析 meta-data，这里不关注！ mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; //【3】将该 Permission 对象添加到 owner.permissions 中！ owner.permissions.add(perm); return perm;&#125; 3.1.1.2.2.4 PParser.parseUsesPermission - 解析 uses-permissionparseUsesPermission 解析该应用所使用的权限！ 123456789101112131415161718192021222324252627282930313233343536private boolean parseUsesPermission(Package pkg, Resources res, XmlResourceParser parser) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestUsesPermission); String name = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesPermission_name); int maxSdkVersion = 0; TypedValue val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesPermission_maxSdkVersion); if (val != null) &#123; if (val.type &gt;= TypedValue.TYPE_FIRST_INT &amp;&amp; val.type &lt;= TypedValue.TYPE_LAST_INT) &#123; maxSdkVersion = val.data; &#125; &#125; sa.recycle(); if ((maxSdkVersion == 0) || (maxSdkVersion &gt;= Build.VERSION.RESOURCES_SDK_INT)) &#123; if (name != null) &#123; int index = pkg.requestedPermissions.indexOf(name); if (index == -1) &#123; //【1】将权限添加到 pkg.requestedPermissions 中去！ pkg.requestedPermissions.add(name.intern()); &#125; else &#123; Slog.w(TAG, \"Ignoring duplicate uses-permissions/uses-permissions-sdk-m: \" + name + \" in package: \" + pkg.packageName + \" at: \" + parser.getPositionDescription()); &#125; &#125; &#125; XmlUtils.skipCurrentTag(parser); return true;&#125; 解析很简单，不多说了！ 3.1.1.2.3 PParser.parseBaseApplication调用 parseBaseApplication 方法来解析核心 apk 的 applicaiton 标签和内部的四大组件信息！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443private boolean parseBaseApplication(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; //【1】解析 application 标签的属性！ final ApplicationInfo ai = owner.applicationInfo; final String pkgName = owner.applicationInfo.packageName; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestApplication); // 解析 android:name android:label android:icon android:roundIcon android:logo android:banner 属性！ if (!parsePackageItemInfo(owner, ai, outError, \"&lt;application&gt;\", sa, false /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestApplication_name, com.android.internal.R.styleable.AndroidManifestApplication_label, com.android.internal.R.styleable.AndroidManifestApplication_icon, com.android.internal.R.styleable.AndroidManifestApplication_roundIcon, com.android.internal.R.styleable.AndroidManifestApplication_logo, com.android.internal.R.styleable.AndroidManifestApplication_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; if (ai.name != null) &#123; ai.className = ai.name; &#125; // 解析 android:manageSpaceActivity 属性！ String manageSpaceActivity = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity, Configuration.NATIVE_CONFIG_VERSION); if (manageSpaceActivity != null) &#123; ai.manageSpaceActivityName = buildClassName(pkgName, manageSpaceActivity, outError); &#125; //【1】解析 android:allowBackup 属性，为 true 表示应用允许备份！ boolean allowBackup = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_allowBackup, true); if (allowBackup) &#123; ai.flags |= ApplicationInfo.FLAG_ALLOW_BACKUP; // 如果为 true，设置 FLAG_ALLOW_BACKUP 标志位 // 解析 android:backupAgent 属性！ String backupAgent = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_backupAgent, Configuration.NATIVE_CONFIG_VERSION); if (backupAgent != null) &#123; ai.backupAgentName = buildClassName(pkgName, backupAgent, outError); if (DEBUG_BACKUP) &#123; Slog.v(TAG, \"android:backupAgent = \" + ai.backupAgentName + \" from \" + pkgName + \"+\" + backupAgent); &#125; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore, true)) &#123; // 解析 android:killAfterRestore 属性，为 true 设置 FLAG_KILL_AFTER_RESTORE 标志位 ai.flags |= ApplicationInfo.FLAG_KILL_AFTER_RESTORE; &#125; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_restoreAnyVersion, false)) &#123; // 解析 android:restoreAnyVersion 属性，为 true 设置 FLAG_RESTORE_ANY_VERSION 标志位 ai.flags |= ApplicationInfo.FLAG_RESTORE_ANY_VERSION; &#125; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_fullBackupOnly, false)) &#123; // 解析 android:fullBackupOnly 属性，为 true 设置 FLAG_FULL_BACKUP_ONLY 标志位 ai.flags |= ApplicationInfo.FLAG_FULL_BACKUP_ONLY; &#125; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_backupInForeground, false)) &#123; // 解析 android:backupInForeground 属性，为 true 设置 PRIVATE_FLAG_BACKUP_IN_FOREGROUND 标志位 ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_BACKUP_IN_FOREGROUND; &#125; &#125; // 解析 android:fullBackupContent 属性！ TypedValue v = sa.peekValue( com.android.internal.R.styleable.AndroidManifestApplication_fullBackupContent); if (v != null &amp;&amp; (ai.fullBackupContent = v.resourceId) == 0) &#123; if (DEBUG_BACKUP) &#123; Slog.v(TAG, \"fullBackupContent specified as boolean=\" + (v.data == 0 ? \"false\" : \"true\")); &#125; // \"false\" =&gt; -1, \"true\" =&gt; 0 ai.fullBackupContent = (v.data == 0 ? -1 : 0); &#125; if (DEBUG_BACKUP) &#123; Slog.v(TAG, \"fullBackupContent=\" + ai.fullBackupContent + \" for \" + pkgName); &#125; &#125; // 解析 android:theme android:description 属性！ ai.theme = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestApplication_theme, 0); ai.descriptionRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestApplication_description, 0); // 如果设置了 PARSE_IS_SYSTEM，并且 android:persistent 为 true // 那么 ai.flags 设置 ApplicationInfo.FLAG_PERSISTENT 标志位，其为 persistent 属性！ if ((flags&amp;PARSE_IS_SYSTEM) != 0) &#123; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_persistent, false)) &#123; ai.flags |= ApplicationInfo.FLAG_PERSISTENT; &#125; &#125; // 解析 android:requiredForAllUsers 属性，为true，表示该应用在所有 user 下都可用！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_requiredForAllUsers, false)) &#123; owner.mRequiredForAllUsers = true; &#125; // 解析 android:requiredAccountType android:restrictedAccountType 的属性！ String restrictedAccountType = sa.getString(com.android.internal.R.styleable .AndroidManifestApplication_restrictedAccountType); if (restrictedAccountType != null &amp;&amp; restrictedAccountType.length() &gt; 0) &#123; owner.mRestrictedAccountType = restrictedAccountType; &#125; String requiredAccountType = sa.getString(com.android.internal.R.styleable .AndroidManifestApplication_requiredAccountType); if (requiredAccountType != null &amp;&amp; requiredAccountType.length() &gt; 0) &#123; owner.mRequiredAccountType = requiredAccountType; &#125; // 解析 android:debuggable android:vmSafeMode 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_debuggable, false)) &#123; ai.flags |= ApplicationInfo.FLAG_DEBUGGABLE; &#125; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_vmSafeMode, false)) &#123; ai.flags |= ApplicationInfo.FLAG_VM_SAFE_MODE; &#125; // 解析 android:hardwareAccelerated 属性！ owner.baseHardwareAccelerated = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_hardwareAccelerated, owner.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH); if (owner.baseHardwareAccelerated) &#123; ai.flags |= ApplicationInfo.FLAG_HARDWARE_ACCELERATED; &#125; // 解析 android:hasCode 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_hasCode, true)) &#123; ai.flags |= ApplicationInfo.FLAG_HAS_CODE; &#125; // 解析 android:allowTaskReparenting 属性，这个属性很重要，决定了 acivity 和 task 的关系 // 在 application 标签上设置该属性对内部的所有 activity 生效！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting, false)) &#123; ai.flags |= ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING; &#125; // 解析 android:allowClearUserData 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData, true)) &#123; ai.flags |= ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA; &#125; // The parent package controls installation, hence specify test only installs. if (owner.parentPackage == null) &#123; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_testOnly, false)) &#123; ai.flags |= ApplicationInfo.FLAG_TEST_ONLY; &#125; &#125; // 解析 android:largeHeap 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_largeHeap, false)) &#123; ai.flags |= ApplicationInfo.FLAG_LARGE_HEAP; &#125; // 解析 android:usesCleartextTraffic 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_usesCleartextTraffic, true)) &#123; ai.flags |= ApplicationInfo.FLAG_USES_CLEARTEXT_TRAFFIC; &#125; // 解析 android:supportsRtl 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_supportsRtl, false /* default is no RTL support*/)) &#123; ai.flags |= ApplicationInfo.FLAG_SUPPORTS_RTL; &#125; // 解析 android:multiArch 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_multiArch, false)) &#123; ai.flags |= ApplicationInfo.FLAG_MULTIARCH; &#125; // 解析 android:extractNativeLibs 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_extractNativeLibs, true)) &#123; ai.flags |= ApplicationInfo.FLAG_EXTRACT_NATIVE_LIBS; &#125; // 解析 android:defaultToDeviceProtectedStorage 属性！ if (sa.getBoolean( R.styleable.AndroidManifestApplication_defaultToDeviceProtectedStorage, false)) &#123; ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE; &#125; // 解析 android:directBootAware 属性！ if (sa.getBoolean( R.styleable.AndroidManifestApplication_directBootAware, false)) &#123; ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE; &#125; // 解析 android:resizeableActivity 属性！ if (sa.getBoolean(R.styleable.AndroidManifestApplication_resizeableActivity, owner.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N)) &#123; ai.privateFlags |= PRIVATE_FLAG_RESIZEABLE_ACTIVITIES; &#125; // 解析 android:networkSecurityConfig 属性！ ai.networkSecurityConfigRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestApplication_networkSecurityConfig, 0); // 解析 android:permission 属性！ String str; str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_permission, 0); ai.permission = (str != null &amp;&amp; str.length() &gt; 0) ? str.intern() : null; // 解析 android:taskAffinity 属性，这个属性很重要，决定了 acivity 和 task 的关系 // 在 application 标签上设置该属性对内部的所有 activity 生效！ if (owner.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.FROYO) &#123; str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity, Configuration.NATIVE_CONFIG_VERSION); &#125; else &#123; str = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity); &#125; ai.taskAffinity = buildTaskAffinityName(ai.packageName, ai.packageName, str, outError); if (outError[0] == null) &#123; CharSequence pname; // 解析 android:process 属性，这个属性很重要，决定了组件运行所在的进程名 // 在 application 标签上设置该属性对内部的所有组件生效！ if (owner.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.FROYO) &#123; pname = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_process, Configuration.NATIVE_CONFIG_VERSION); &#125; else &#123; pname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestApplication_process); &#125; ai.processName = buildProcessName(ai.packageName, null, pname, flags, mSeparateProcesses, outError); // 解析 android:isGame android:enabled 属性， ai.enabled = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_enabled, true); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_isGame, false)) &#123; ai.flags |= ApplicationInfo.FLAG_IS_GAME; &#125; if (false) &#123; // 解析 android:cantSaveState 属性，这里由于 if 为 false，所以不会解析！ // 主要用于 height-weight 类型的应用！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_cantSaveState, false)) &#123; ai.privateFlags |= ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE; // 对于 height-weight 类型的应用，其所在进程的进程名只能是包名，我们无法自定义其进程名！ if (ai.processName != null &amp;&amp; ai.processName != ai.packageName) &#123; outError[0] = \"cantSaveState applications can not use custom processes\"; &#125; &#125; &#125; &#125; // 解析 android:uiOptions 属性！ ai.uiOptions = sa.getInt( com.android.internal.R.styleable.AndroidManifestApplication_uiOptions, 0); sa.recycle(); if (outError[0] != null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; //【2】解析四大组件！ final int innerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); //【2.1】解析 \"activity\" 组件 if (tagName.equals(\"activity\")) &#123; Activity a = parseActivity(owner, res, parser, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); //【2.2】解析 \"receiver\" 组件 &#125; else if (tagName.equals(\"receiver\")) &#123; Activity a = parseActivity(owner, res, parser, flags, outError, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.receivers.add(a); //【2.3】解析 \"service\" 组件 &#125; else if (tagName.equals(\"service\")) &#123; Service s = parseService(owner, res, parser, flags, outError); if (s == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.services.add(s); //【2.4】解析 \"provider\" 组件 &#125; else if (tagName.equals(\"provider\")) &#123; Provider p = parseProvider(owner, res, parser, flags, outError); if (p == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.providers.add(p); &#125; else if (tagName.equals(\"activity-alias\")) &#123; //【2.5】解析 \"activity-alias\" 组件 Activity a = parseActivityAlias(owner, res, parser, flags, outError); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); &#125; else if (parser.getName().equals(\"meta-data\")) &#123; //【2.6】解析 \"meta-data\" 组件 if ((owner.mAppMetaData = parseMetaData(res, parser, owner.mAppMetaData, outError)) == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; &#125; else if (tagName.equals(\"library\")) &#123; //【2.6】解析 \"library\" 组件 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestLibrary); String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestLibrary_name); sa.recycle(); if (lname != null) &#123; lname = lname.intern(); if (!ArrayUtils.contains(owner.libraryNames, lname)) &#123; owner.libraryNames = ArrayUtils.add(owner.libraryNames, lname); &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(\"uses-library\")) &#123; //【2.7】解析 \"uses-library\" 组件 sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestUsesLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesLibrary_name); boolean req = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesLibrary_required, true); sa.recycle(); if (lname != null) &#123; lname = lname.intern(); if (req) &#123; owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname); &#125; else &#123; owner.usesOptionalLibraries = ArrayUtils.add( owner.usesOptionalLibraries, lname); &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(\"uses-package\")) &#123; // Dependencies for app installers; we don't currently try to // enforce this. XmlUtils.skipCurrentTag(parser); &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Unknown element under &lt;application&gt;: \" + tagName + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; outError[0] = \"Bad element under &lt;application&gt;: \" + tagName; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; &#125; &#125; modifySharedLibrariesForBackwardCompatibility(owner); if (hasDomainURLs(owner)) &#123; owner.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_HAS_DOMAIN_URLS; &#125; else &#123; owner.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_HAS_DOMAIN_URLS; &#125; return true;&#125; 这里重点的是四大组件的解析： 3.1.1.2.3.1 PParser.parseActivity - 解析 activity 和 receiver我们来看看 activity 的解析过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319private Activity parseActivity(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError, boolean receiver, boolean hardwareAccelerated) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestActivity); // 解析 android:name android:label android:icon android:roundIcon android:logo android:banner 属性！ if (mParseActivityArgs == null) &#123; mParseActivityArgs = new ParseComponentArgs(owner, outError, R.styleable.AndroidManifestActivity_name, R.styleable.AndroidManifestActivity_label, R.styleable.AndroidManifestActivity_icon, R.styleable.AndroidManifestActivity_roundIcon, R.styleable.AndroidManifestActivity_logo, R.styleable.AndroidManifestActivity_banner, mSeparateProcesses, R.styleable.AndroidManifestActivity_process, R.styleable.AndroidManifestActivity_description, R.styleable.AndroidManifestActivity_enabled); &#125; // 由于 activty 和 receiver 使用的同一个方法，所以需要区分解析的是哪个，此时 receiver 为 false！ mParseActivityArgs.tag = receiver ? \"&lt;receiver&gt;\" : \"&lt;activity&gt;\"; mParseActivityArgs.sa = sa; mParseActivityArgs.flags = flags; //【2】创建了一个 Activity 对象！ Activity a = new Activity(mParseActivityArgs, new ActivityInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; // 解析 android:exported 属性！ boolean setExported = sa.hasValue(R.styleable.AndroidManifestActivity_exported); if (setExported) &#123; a.info.exported = sa.getBoolean(R.styleable.AndroidManifestActivity_exported, false); &#125; // 解析 android:theme 属性！ a.info.theme = sa.getResourceId(R.styleable.AndroidManifestActivity_theme, 0); // 解析 android:uiOptions 属性！ a.info.uiOptions = sa.getInt(R.styleable.AndroidManifestActivity_uiOptions, a.info.applicationInfo.uiOptions); // 解析 android:parentActivityName 属性！ String parentName = sa.getNonConfigurationString( R.styleable.AndroidManifestActivity_parentActivityName, Configuration.NATIVE_CONFIG_VERSION); if (parentName != null) &#123; String parentClassName = buildClassName(a.info.packageName, parentName, outError); if (outError[0] == null) &#123; a.info.parentActivityName = parentClassName; &#125; else &#123; Log.e(TAG, \"Activity \" + a.info.name + \" specified invalid parentActivityName \" + parentName); outError[0] = null; &#125; &#125; // 解析 android:permission 属性！ String str; str = sa.getNonConfigurationString(R.styleable.AndroidManifestActivity_permission, 0); if (str == null) &#123; a.info.permission = owner.applicationInfo.permission; &#125; else &#123; a.info.permission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; // 解析 android:taskAffinity 属性，这个属性真重要，能决定该 acitivty 和 task 的关系！！ str = sa.getNonConfigurationString( R.styleable.AndroidManifestActivity_taskAffinity, Configuration.NATIVE_CONFIG_VERSION); a.info.taskAffinity = buildTaskAffinityName(owner.applicationInfo.packageName, owner.applicationInfo.taskAffinity, str, outError); a.info.flags = 0; // 解析 android:multiprocess 属性 if (sa.getBoolean( R.styleable.AndroidManifestActivity_multiprocess, false)) &#123; a.info.flags |= ActivityInfo.FLAG_MULTIPROCESS; &#125; // 解析 android:finishOnTaskLaunch 属性，这个属性真重要，能决定该 acitivty 和 task 的关系！！ if (sa.getBoolean(R.styleable.AndroidManifestActivity_finishOnTaskLaunch, false)) &#123; a.info.flags |= ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH; &#125; // 解析 android:clearTaskOnLaunch 属性，这个属性真重要，能决定该 acitivty 和 task 的关系！ if (sa.getBoolean(R.styleable.AndroidManifestActivity_clearTaskOnLaunch, false)) &#123; a.info.flags |= ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH; &#125; // 解析 android:noHistory 属性，这个属性真重要，能决定该 acitivty 和 task 的关系！ if (sa.getBoolean(R.styleable.AndroidManifestActivity_noHistory, false)) &#123; a.info.flags |= ActivityInfo.FLAG_NO_HISTORY; &#125; // 解析 android:alwaysRetainTaskState 属性，这个属性真重要，能决定该 acitivty 和 task 的关系！ if (sa.getBoolean(R.styleable.AndroidManifestActivity_alwaysRetainTaskState, false)) &#123; a.info.flags |= ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE; &#125; // 解析 android:stateNotNeeded 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_stateNotNeeded, false)) &#123; a.info.flags |= ActivityInfo.FLAG_STATE_NOT_NEEDED; &#125; // 解析 android:excludeFromRecents 属性，不再最近任务显示 if (sa.getBoolean(R.styleable.AndroidManifestActivity_excludeFromRecents, false)) &#123; a.info.flags |= ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS; &#125; // 解析 android:allowTaskReparenting 属性，这个属性真重要，能决定该 acitivty 和 task 的关系！ if (sa.getBoolean(R.styleable.AndroidManifestActivity_allowTaskReparenting, (owner.applicationInfo.flags&amp;ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) &#123; a.info.flags |= ActivityInfo.FLAG_ALLOW_TASK_REPARENTING; &#125; // 解析 android:finishOnCloseSystemDialogs 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs, false)) &#123; a.info.flags |= ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS; &#125; // 解析 android:showOnLockScreen 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_showOnLockScreen, false) || sa.getBoolean(R.styleable.AndroidManifestActivity_showForAllUsers, false)) &#123; a.info.flags |= ActivityInfo.FLAG_SHOW_FOR_ALL_USERS; &#125; // 解析 android:immersive 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_immersive, false)) &#123; a.info.flags |= ActivityInfo.FLAG_IMMERSIVE; &#125; // 解析 android:systemUserOnly 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_systemUserOnly, false)) &#123; a.info.flags |= ActivityInfo.FLAG_SYSTEM_USER_ONLY; &#125; // 接下来，对于 activity 和 receiver 解析不同的属性！ if (!receiver) &#123; // 对于 activity 进入这个！ // 解析 android:hardwareAccelerated 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_hardwareAccelerated, hardwareAccelerated)) &#123; a.info.flags |= ActivityInfo.FLAG_HARDWARE_ACCELERATED; &#125; // 解析 android:launchMode 属性 a.info.launchMode = sa.getInt( R.styleable.AndroidManifestActivity_launchMode, ActivityInfo.LAUNCH_MULTIPLE); // 解析 android:documentLaunchMode 属性 a.info.documentLaunchMode = sa.getInt( R.styleable.AndroidManifestActivity_documentLaunchMode, ActivityInfo.DOCUMENT_LAUNCH_NONE); // 解析 android:maxRecents 属性 a.info.maxRecents = sa.getInt( R.styleable.AndroidManifestActivity_maxRecents, ActivityManager.getDefaultAppRecentsLimitStatic()); // 解析 android:configChanges 属性 a.info.configChanges = sa.getInt(R.styleable.AndroidManifestActivity_configChanges, 0); // 解析 android:windowSoftInputMode 属性 a.info.softInputMode = sa.getInt( R.styleable.AndroidManifestActivity_windowSoftInputMode, 0); // 解析 android:persistableMode 属性 a.info.persistableMode = sa.getInteger( R.styleable.AndroidManifestActivity_persistableMode, ActivityInfo.PERSIST_ROOT_ONLY); // 解析 android:allowEmbedded 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_allowEmbedded, false)) &#123; a.info.flags |= ActivityInfo.FLAG_ALLOW_EMBEDDED; &#125; // 解析 android:autoRemoveFromRecents 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_autoRemoveFromRecents, false)) &#123; a.info.flags |= ActivityInfo.FLAG_AUTO_REMOVE_FROM_RECENTS; &#125; // 解析 android:relinquishTaskIdentity 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_relinquishTaskIdentity, false)) &#123; a.info.flags |= ActivityInfo.FLAG_RELINQUISH_TASK_IDENTITY; &#125; // 解析 android:resumeWhilePausing 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_resumeWhilePausing, false)) &#123; a.info.flags |= ActivityInfo.FLAG_RESUME_WHILE_PAUSING; &#125; // 解析 android:screenOrientation 属性 a.info.screenOrientation = sa.getInt( R.styleable.AndroidManifestActivity_screenOrientation, SCREEN_ORIENTATION_UNSPECIFIED); // 解析 android:resizeableActivity android:supportsPictureInPicture 属性 a.info.resizeMode = RESIZE_MODE_UNRESIZEABLE; final boolean appDefault = (owner.applicationInfo.privateFlags &amp; PRIVATE_FLAG_RESIZEABLE_ACTIVITIES) != 0; final boolean resizeableSetExplicitly = sa.hasValue(R.styleable.AndroidManifestActivity_resizeableActivity); final boolean resizeable = sa.getBoolean( R.styleable.AndroidManifestActivity_resizeableActivity, appDefault); if (resizeable) &#123; if (sa.getBoolean(R.styleable.AndroidManifestActivity_supportsPictureInPicture, false)) &#123; a.info.resizeMode = RESIZE_MODE_RESIZEABLE_AND_PIPABLE; &#125; else &#123; a.info.resizeMode = RESIZE_MODE_RESIZEABLE; &#125; &#125; else if (owner.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N || resizeableSetExplicitly) &#123; a.info.resizeMode = RESIZE_MODE_UNRESIZEABLE; &#125; else if (!a.info.isFixedOrientation() &amp;&amp; (a.info.flags &amp; FLAG_IMMERSIVE) == 0) &#123; a.info.resizeMode = RESIZE_MODE_FORCE_RESIZEABLE; &#125; // 解析 android:alwaysFocusable 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_alwaysFocusable, false)) &#123; a.info.flags |= FLAG_ALWAYS_FOCUSABLE; &#125; // 解析 android:lockTaskMode 属性 a.info.lockTaskLaunchMode = sa.getInt(R.styleable.AndroidManifestActivity_lockTaskMode, 0); // 解析 android:directBootAware 属性 a.info.encryptionAware = a.info.directBootAware = sa.getBoolean( R.styleable.AndroidManifestActivity_directBootAware, false); // 解析 android:enableVrMode 属性 a.info.requestedVrComponent = sa.getString(R.styleable.AndroidManifestActivity_enableVrMode); &#125; else &#123; // 对于 receiver，会进入这里！ a.info.launchMode = ActivityInfo.LAUNCH_MULTIPLE; a.info.configChanges = 0; // 解析 android:singleUser 属性 if (sa.getBoolean(R.styleable.AndroidManifestActivity_singleUser, false)) &#123; a.info.flags |= ActivityInfo.FLAG_SINGLE_USER; if (a.info.exported &amp;&amp; (flags &amp; PARSE_IS_PRIVILEGED) == 0) &#123; Slog.w(TAG, \"Activity exported request ignored due to singleUser: \" + a.className + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); a.info.exported = false; setExported = true; &#125; &#125; // 解析 android:directBootAware 属性 a.info.encryptionAware = a.info.directBootAware = sa.getBoolean( R.styleable.AndroidManifestActivity_directBootAware, false); &#125; if (a.info.directBootAware) &#123; owner.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PARTIALLY_DIRECT_BOOT_AWARE; &#125; sa.recycle(); // 如果解析的是 receiver，针对 height-weight 类型的进程做处理 if (receiver &amp;&amp; (owner.applicationInfo.privateFlags &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; if (a.info.processName == owner.packageName) &#123; outError[0] = \"Heavy-weight applications can not have receivers in main process\"; &#125; &#125; if (outError[0] != null) &#123; return null; &#125; int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (parser.getName().equals(\"intent-filter\")) &#123; // 解析 \"intent-filter\" ActivityIntentInfo intent = new ActivityIntentInfo(a); if (!parseIntent(res, parser, true, true, intent, outError)) &#123; return null; &#125; if (intent.countActions() == 0) &#123; Slog.w(TAG, \"No actions in intent filter at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; else &#123; a.intents.add(intent); &#125; &#125; else if (!receiver &amp;&amp; parser.getName().equals(\"preferred\")) &#123; // 解析 \"preferred\" ActivityIntentInfo intent = new ActivityIntentInfo(a); if (!parseIntent(res, parser, false, false, intent, outError)) &#123; return null; &#125; if (intent.countActions() == 0) &#123; Slog.w(TAG, \"No actions in preferred at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; else &#123; if (owner.preferredActivityFilters == null) &#123; owner.preferredActivityFilters = new ArrayList&lt;ActivityIntentInfo&gt;(); &#125; owner.preferredActivityFilters.add(intent); &#125; &#125; else if (parser.getName().equals(\"meta-data\")) &#123; // 解析 \"meta-data\" if ((a.metaData = parseMetaData(res, parser, a.metaData, outError)) == null) &#123; return null; &#125; &#125; else if (!receiver &amp;&amp; parser.getName().equals(\"layout\")) &#123; // 解析 \"layout\" parseLayout(res, parser, a); &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Problem in package \" + mArchiveSourcePath + \":\"); if (receiver) &#123; Slog.w(TAG, \"Unknown element under &lt;receiver&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;activity&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; if (receiver) &#123; outError[0] = \"Bad element under &lt;receiver&gt;: \" + parser.getName(); &#125; else &#123; outError[0] = \"Bad element under &lt;activity&gt;: \" + parser.getName(); &#125; return null; &#125; &#125; &#125; if (!setExported) &#123; a.info.exported = a.intents.size() &gt; 0; &#125; return a;&#125; 整个解析过程很清晰，就是不断读取对应标签的属性，然后设置 Activity 的属性和标志位！ ######3.1.1.2.3.2 PParser.parseService - 解析 service 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136private Service parseService(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestService); // 解析 android:name android:label android:icon android:roundIcon android:logo android:banner 属性！ if (mParseServiceArgs == null) &#123; mParseServiceArgs = new ParseComponentArgs(owner, outError, com.android.internal.R.styleable.AndroidManifestService_name, com.android.internal.R.styleable.AndroidManifestService_label, com.android.internal.R.styleable.AndroidManifestService_icon, com.android.internal.R.styleable.AndroidManifestService_roundIcon, com.android.internal.R.styleable.AndroidManifestService_logo, com.android.internal.R.styleable.AndroidManifestService_banner, mSeparateProcesses, com.android.internal.R.styleable.AndroidManifestService_process, com.android.internal.R.styleable.AndroidManifestService_description, com.android.internal.R.styleable.AndroidManifestService_enabled); mParseServiceArgs.tag = &quot;&lt;service&gt;&quot;; &#125; mParseServiceArgs.sa = sa; mParseServiceArgs.flags = flags; // 创建 Service 对象！ Service s = new Service(mParseServiceArgs, new ServiceInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; // 解析 android:exported 属性！ boolean setExported = sa.hasValue( com.android.internal.R.styleable.AndroidManifestService_exported); if (setExported) &#123; s.info.exported = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestService_exported, false); &#125; // 解析 android:permission 属性！ String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestService_permission, 0); if (str == null) &#123; s.info.permission = owner.applicationInfo.permission; &#125; else &#123; s.info.permission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; // 解析 android:stopWithTask 属性！ s.info.flags = 0; if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestService_stopWithTask, false)) &#123; s.info.flags |= ServiceInfo.FLAG_STOP_WITH_TASK; &#125; // 解析 android:isolatedProcess 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestService_isolatedProcess, false)) &#123; s.info.flags |= ServiceInfo.FLAG_ISOLATED_PROCESS; &#125; // 解析 android:externalService 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestService_externalService, false)) &#123; s.info.flags |= ServiceInfo.FLAG_EXTERNAL_SERVICE; &#125; // 解析 android:singleUser 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestService_singleUser, false)) &#123; s.info.flags |= ServiceInfo.FLAG_SINGLE_USER; if (s.info.exported &amp;&amp; (flags &amp; PARSE_IS_PRIVILEGED) == 0) &#123; Slog.w(TAG, &quot;Service exported request ignored due to singleUser: &quot; + s.className + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); s.info.exported = false; setExported = true; &#125; &#125; // 解析 android:directBootAware 属性！ s.info.encryptionAware = s.info.directBootAware = sa.getBoolean( R.styleable.AndroidManifestService_directBootAware, false); if (s.info.directBootAware) &#123; owner.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PARTIALLY_DIRECT_BOOT_AWARE; &#125; sa.recycle(); // 如果应用属于 height-weight 类型的进程，要对进程名做处理！ if ((owner.applicationInfo.privateFlags&amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; if (s.info.processName == owner.packageName) &#123; outError[0] = &quot;Heavy-weight applications can not have services in main process&quot;; return null; &#125; &#125; int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (parser.getName().equals(&quot;intent-filter&quot;)) &#123; // 解析 &quot;intent-filter&quot;！ ServiceIntentInfo intent = new ServiceIntentInfo(s); if (!parseIntent(res, parser, true, false, intent, outError)) &#123; return null; &#125; s.intents.add(intent); &#125; else if (parser.getName().equals(&quot;meta-data&quot;)) &#123; if ((s.metaData=parseMetaData(res, parser, s.metaData, outError)) == null) &#123; return null; &#125; &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, &quot;Unknown element under &lt;service&gt;: &quot; + parser.getName() + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; outError[0] = &quot;Bad element under &lt;service&gt;: &quot; + parser.getName(); return null; &#125; &#125; &#125; if (!setExported) &#123; s.info.exported = s.intents.size() &gt; 0; &#125; return s;&#125; ######3.1.1.2.3.3 PParser.parseProvider - 解析 parseProvider 接下来是解析 provider：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private Provider parseProvider(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestProvider); // 解析 android:name android:label android:icon android:roundIcon android:logo android:banner 属性！ if (mParseProviderArgs == null) &#123; mParseProviderArgs = new ParseComponentArgs(owner, outError, com.android.internal.R.styleable.AndroidManifestProvider_name, com.android.internal.R.styleable.AndroidManifestProvider_label, com.android.internal.R.styleable.AndroidManifestProvider_icon, com.android.internal.R.styleable.AndroidManifestProvider_roundIcon, com.android.internal.R.styleable.AndroidManifestProvider_logo, com.android.internal.R.styleable.AndroidManifestProvider_banner, mSeparateProcesses, com.android.internal.R.styleable.AndroidManifestProvider_process, com.android.internal.R.styleable.AndroidManifestProvider_description, com.android.internal.R.styleable.AndroidManifestProvider_enabled); mParseProviderArgs.tag = \"&lt;provider&gt;\"; &#125; mParseProviderArgs.sa = sa; mParseProviderArgs.flags = flags; // 创建一个 Provider 对象！ Provider p = new Provider(mParseProviderArgs, new ProviderInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; boolean providerExportedDefault = false; if (owner.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; // For compatibility, applications targeting API level 16 or lower // should have their content providers exported by default, unless they // specify otherwise. providerExportedDefault = true; &#125; // 解析 android:exported 属性！ p.info.exported = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_exported, providerExportedDefault); // 解析 android:authorities 属性！ String cpname = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_authorities, 0); // 解析 android:syncable 属性！ p.info.isSyncable = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_syncable, false); // 解析 android:permission 属性！ String permission = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_permission, 0); // 解析 android:readPermission 属性！ String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_readPermission, 0); if (str == null) &#123; str = permission; &#125; if (str == null) &#123; p.info.readPermission = owner.applicationInfo.permission; &#125; else &#123; p.info.readPermission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; // 解析 android:writePermission 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_writePermission, 0); if (str == null) &#123; str = permission; &#125; if (str == null) &#123; p.info.writePermission = owner.applicationInfo.permission; &#125; else &#123; p.info.writePermission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; // 解析 android:grantUriPermissions 属性！ p.info.grantUriPermissions = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_grantUriPermissions, false); // 解析 android:multiprocess 属性！ p.info.multiprocess = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_multiprocess, false); // 解析 android:initOrder 属性！ p.info.initOrder = sa.getInt( com.android.internal.R.styleable.AndroidManifestProvider_initOrder, 0); p.info.flags = 0; // 解析 android:singleUser 属性！ if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_singleUser, false)) &#123; p.info.flags |= ProviderInfo.FLAG_SINGLE_USER; if (p.info.exported &amp;&amp; (flags &amp; PARSE_IS_PRIVILEGED) == 0) &#123; Slog.w(TAG, \"Provider exported request ignored due to singleUser: \" + p.className + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); p.info.exported = false; &#125; &#125; // 解析 android:directBootAware 属性！ p.info.encryptionAware = p.info.directBootAware = sa.getBoolean( R.styleable.AndroidManifestProvider_directBootAware, false); if (p.info.directBootAware) &#123; owner.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PARTIALLY_DIRECT_BOOT_AWARE; &#125; sa.recycle(); // 如果应用设置为 height-weight 类型的应用，对进程名要做校验！ if ((owner.applicationInfo.privateFlags&amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; if (p.info.processName == owner.packageName) &#123; outError[0] = \"Heavy-weight applications can not have providers in main process\"; return null; &#125; &#125; if (cpname == null) &#123; outError[0] = \"&lt;provider&gt; does not include authorities attribute\"; return null; &#125; if (cpname.length() &lt;= 0) &#123; outError[0] = \"&lt;provider&gt; has empty authorities attribute\"; return null; &#125; p.info.authority = cpname.intern(); if (!parseProviderTags(res, parser, p, outError)) &#123; return null; &#125; return p;&#125; 对 provider 的解析就分析到这里！ 3.1.1.2.3.4 PParser.parseIntent - 解析 intent-filter接下来，我们来看看对 activity receiver provider 的 intent-filter 的解析！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179private boolean parseIntent(Resources res, XmlResourceParser parser, boolean allowGlobs, boolean allowAutoVerify, IntentInfo outInfo, String[] outError) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestIntentFilter); // 解析 android:priority 属性！ int priority = sa.getInt( com.android.internal.R.styleable.AndroidManifestIntentFilter_priority, 0); outInfo.setPriority(priority); // 解析 android:label 属性！ TypedValue v = sa.peekValue( com.android.internal.R.styleable.AndroidManifestIntentFilter_label); if (v != null &amp;&amp; (outInfo.labelRes=v.resourceId) == 0) &#123; outInfo.nonLocalizedLabel = v.coerceToString(); &#125; // 解析 android:useRoundIcon 属性！ final boolean useRoundIcon = Resources.getSystem().getBoolean(com.android.internal.R.bool.config_useRoundIcon); // 解析 android:roundIcon android:icon 属性！ int roundIconVal = useRoundIcon ? sa.getResourceId( com.android.internal.R.styleable.AndroidManifestIntentFilter_roundIcon, 0) : 0; if (roundIconVal != 0) &#123; outInfo.icon = roundIconVal; &#125; else &#123; outInfo.icon = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestIntentFilter_icon, 0); &#125; // 解析 android:logo 属性！ outInfo.logo = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestIntentFilter_logo, 0); // 解析 android:banner 属性！ outInfo.banner = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestIntentFilter_banner, 0); // 解析 android:autoVerify 属性！ if (allowAutoVerify) &#123; outInfo.setAutoVerify(sa.getBoolean( com.android.internal.R.styleable.AndroidManifestIntentFilter_autoVerify, false)); &#125; sa.recycle(); int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String nodeName = parser.getName(); if (nodeName.equals(\"action\")) &#123; // 解析 \"action\" 标签！ String value = parser.getAttributeValue( ANDROID_RESOURCES, \"name\"); if (value == null || value == \"\") &#123; outError[0] = \"No value supplied for &lt;android:name&gt;\"; return false; &#125; XmlUtils.skipCurrentTag(parser); outInfo.addAction(value); &#125; else if (nodeName.equals(\"category\")) &#123; // 解析 \"category\" 标签！ String value = parser.getAttributeValue( ANDROID_RESOURCES, \"name\"); if (value == null || value == \"\") &#123; outError[0] = \"No value supplied for &lt;android:name&gt;\"; return false; &#125; XmlUtils.skipCurrentTag(parser); outInfo.addCategory(value); &#125; else if (nodeName.equals(\"data\")) &#123; // 解析 \"data\" 标签！ sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestData); // 解析 android:mimeType 属性！ String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_mimeType, 0); if (str != null) &#123; try &#123; outInfo.addDataType(str); &#125; catch (IntentFilter.MalformedMimeTypeException e) &#123; outError[0] = e.toString(); sa.recycle(); return false; &#125; &#125; // 解析 android:scheme 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_scheme, 0); if (str != null) &#123; outInfo.addDataScheme(str); &#125; // 解析 android:ssp 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_ssp, 0); if (str != null) &#123; outInfo.addDataSchemeSpecificPart(str, PatternMatcher.PATTERN_LITERAL); &#125; // 解析 android:sspPrefix 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_sspPrefix, 0); if (str != null) &#123; outInfo.addDataSchemeSpecificPart(str, PatternMatcher.PATTERN_PREFIX); &#125; // 解析 android:sspPattern 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_sspPattern, 0); if (str != null) &#123; if (!allowGlobs) &#123; outError[0] = \"sspPattern not allowed here; ssp must be literal\"; return false; &#125; outInfo.addDataSchemeSpecificPart(str, PatternMatcher.PATTERN_SIMPLE_GLOB); &#125; // 解析 android:host android:port 属性！ String host = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_host, 0); String port = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_port, 0); if (host != null) &#123; outInfo.addDataAuthority(host, port); &#125; // 解析 android:path 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_path, 0); if (str != null) &#123; outInfo.addDataPath(str, PatternMatcher.PATTERN_LITERAL); &#125; // 解析 android:pathPrefix 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_pathPrefix, 0); if (str != null) &#123; outInfo.addDataPath(str, PatternMatcher.PATTERN_PREFIX); &#125; // 解析 android:pathPattern 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_pathPattern, 0); if (str != null) &#123; if (!allowGlobs) &#123; outError[0] = \"pathPattern not allowed here; path must be literal\"; return false; &#125; outInfo.addDataPath(str, PatternMatcher.PATTERN_SIMPLE_GLOB); &#125; sa.recycle(); XmlUtils.skipCurrentTag(parser); &#125; else if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Unknown element under &lt;intent-filter&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); &#125; else &#123; outError[0] = \"Bad element under &lt;intent-filter&gt;: \" + parser.getName(); return false; &#125; &#125; outInfo.hasDefault = outInfo.hasCategory(Intent.CATEGORY_DEFAULT); if (DEBUG_PARSER) &#123; final StringBuilder cats = new StringBuilder(\"Intent d=\"); cats.append(outInfo.hasDefault); cats.append(\", cat=\"); final Iterator&lt;String&gt; it = outInfo.categoriesIterator(); if (it != null) &#123; while (it.hasNext()) &#123; cats.append(' '); cats.append(it.next()); &#125; &#125; Slog.d(TAG, cats.toString()); &#125; return true;&#125; 对 intent-filter 的解析就到这里！ 3.1.1.3 PParser.parseSplitApk[4]核心 apk 解析完成后，会返回一个 Package 对象，传入 parseSplitApk，用于解析非核心 apk：1234567891011121314151617181920212223242526272829303132333435363738394041private void parseSplitApk(Package pkg, int splitIndex, AssetManager assets, int flags) throws PackageParserException &#123; final String apkPath = pkg.splitCodePaths[splitIndex]; mParseError = PackageManager.INSTALL_SUCCEEDED; mArchiveSourcePath = apkPath; if (DEBUG_JAR) Slog.d(TAG, \"Scanning split APK: \" + apkPath); final int cookie = loadApkIntoAssetManager(assets, apkPath, flags); Resources res = null; XmlResourceParser parser = null; try &#123; res = new Resources(assets, mMetrics, null); assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Build.VERSION.RESOURCES_SDK_INT); // 用于解析 AndroidManifest.xml 文件！ parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME); final String[] outError = new String[1]; //【3.1.1.3.1】解析非核心 apk！ pkg = parseSplitApk(pkg, res, parser, flags, splitIndex, outError); if (pkg == null) &#123; throw new PackageParserException(mParseError, apkPath + \" (at \" + parser.getPositionDescription() + \"): \" + outError[0]); &#125; &#125; catch (PackageParserException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION, \"Failed to read manifest from \" + apkPath, e); &#125; finally &#123; IoUtils.closeQuietly(parser); &#125;&#125; 这个过程个解析 base apk 一样，我们不多关注！ 3.1.1.3.1 PParser.parseSplitApk[5]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private Package parseSplitApk(Package pkg, Resources res, XmlResourceParser parser, int flags, int splitIndex, String[] outError) throws XmlPullParserException, IOException, PackageParserException &#123; AttributeSet attrs = parser; //【3.1.1.1.1.2】解析 package 和 sliptName 属性！ parsePackageSplitNames(parser, attrs); mParseInstrumentationArgs = null; mParseActivityArgs = null; mParseServiceArgs = null; mParseProviderArgs = null; int type; boolean foundApp = false; int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"application\")) &#123; // 解析非核心 apk 的 \"application\" 标签！ if (foundApp) &#123; if (RIGID_PARSER) &#123; outError[0] = \"&lt;manifest&gt; has more than one &lt;application&gt;\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; else &#123; Slog.w(TAG, \"&lt;manifest&gt; has more than one &lt;application&gt;\"); XmlUtils.skipCurrentTag(parser); continue; &#125; &#125; foundApp = true; //【3.1.1.3.2】调用 parseSplitApplication 方法继续解析！ if (!parseSplitApplication(pkg, res, parser, flags, splitIndex, outError)) &#123; return null; &#125; &#125; else if (RIGID_PARSER) &#123; outError[0] = \"Bad element under &lt;manifest&gt;: \" + parser.getName(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;manifest&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; &#125; if (!foundApp) &#123; outError[0] = \"&lt;manifest&gt; does not contain an &lt;application&gt;\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY; &#125; //【3】返回最终的 Package 对象！ return pkg;&#125; 进入 parseSplitApplication 方法！ 3.1.1.3.2 PParser.parseSplitApplication123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private boolean parseSplitApplication(Package owner, Resources res, XmlResourceParser parser, int flags, int splitIndex, String[] outError) throws XmlPullParserException, IOException &#123; // 获得 \"application\" 标签的属性，保存到 TypedArray 对象 sa 中！ TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestApplication); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestApplication_hasCode, true)) &#123; owner.splitFlags[splitIndex] |= ApplicationInfo.FLAG_HAS_CODE; &#125; final int innerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"activity\")) &#123; // 解析非核心 apk 的 \"activity\" //【1】调用 parseActivity Activity a = parseActivity(owner, res, parser, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); &#125; else if (tagName.equals(\"receiver\")) &#123; // 解析非核心 apk 的 \"receiver\" //【2】调用 parseReceiver Activity a = parseActivity(owner, res, parser, flags, outError, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.receivers.add(a); &#125; else if (tagName.equals(\"service\")) &#123; // 解析非核心 apk 的 \"service\" //【3】调用 parseService Service s = parseService(owner, res, parser, flags, outError); if (s == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.services.add(s); &#125; else if (tagName.equals(\"provider\")) &#123; // 解析非核心 apk 的 \"provider\" //【4】调用 parseProvider Provider p = parseProvider(owner, res, parser, flags, outError); if (p == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.providers.add(p); &#125; else if (tagName.equals(\"activity-alias\")) &#123; // 解析非核心 apk 的 \"activity-alias\" //【5】调用 parseActivityAlias Activity a = parseActivityAlias(owner, res, parser, flags, outError); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); &#125; else if (parser.getName().equals(\"meta-data\")) &#123; // 解析非核心 apk 的 \"meta-data\" //【6】调用 parseMetaData if ((owner.mAppMetaData = parseMetaData(res, parser, owner.mAppMetaData, outError)) == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; &#125; else if (tagName.equals(\"uses-library\")) &#123; // 解析非核心 apk 的 \"uses-library\" sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestUsesLibrary); // lib 库名称！ String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesLibrary_name); // lib 库是否强制被使用！ boolean req = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesLibrary_required, true); sa.recycle(); // 将 lib 库信息添加到 usesLibraries 或者 usesOptionalLibraries 中！ if (lname != null) &#123; lname = lname.intern(); if (req) &#123; // Upgrade to treat as stronger constraint owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname); owner.usesOptionalLibraries = ArrayUtils.remove( owner.usesOptionalLibraries, lname); &#125; else &#123; // Ignore if someone already defined as required if (!ArrayUtils.contains(owner.usesLibraries, lname)) &#123; owner.usesOptionalLibraries = ArrayUtils.add( owner.usesOptionalLibraries, lname); &#125; &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (tagName.equals(\"uses-package\")) &#123; // 解析非核心 apk 的 \"uses-package\"，不处理！ // Dependencies for app installers; we don't currently try to // enforce this. XmlUtils.skipCurrentTag(parser); &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Unknown element under &lt;application&gt;: \" + tagName + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; outError[0] = \"Bad element under &lt;application&gt;: \" + tagName; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; &#125; &#125; return true;&#125; 到这里，应用程序包就已经被解析完了，最终，所有 apk 的数据都会封装到一个 Package 对象中返回！ 3.1.2 PParser.parseMonolithicPackage对于不支持 apk 拆分的 package，PMS 使用 parseMonolithicPackage 进行解析，典型的不支持拆分的 apk，是 /system/framework/framework-res.apk，下面我们来看看这个方法： 123456789101112131415161718192021222324@Deprecatedpublic Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException &#123; //【3.1.2.1】同样的，先对 apk 进行一次整体解析！ final PackageLite lite = parseMonolithicPackageLite(apkFile, flags); if (mOnlyCoreApps) &#123; if (!lite.coreApp) &#123; throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, \"Not a coreApp: \" + apkFile); &#125; &#125; final AssetManager assets = new AssetManager(); try &#123; //【3.1.1.2】再次调用 parseBaseApk 进行二次解析！ final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.setCodePath(apkFile.getAbsolutePath()); pkg.setUse32bitAbi(lite.use32bitAbi); return pkg; &#125; finally &#123; IoUtils.closeQuietly(assets); &#125;&#125; 3.1.2.1 PParser.parseMonolithicPackageLite继续调用 parseMonolithicPackageLite 方法：12345678910private static PackageLite parseMonolithicPackageLite(File packageFile, int flags) throws PackageParserException &#123; // 同样的，调用 parseApkLite 直接对 apk 进行解析，返回 ApkLite 对象！ final ApkLite baseApk = parseApkLite(packageFile, flags); final String packagePath = packageFile.getAbsolutePath(); // 创建 PackageLite 对象！ return new PackageLite(packagePath, baseApk, null, null, null);&#125; 最后，同样的，还是返回一个 PackageParser.Package 对象！ 这里就不多说了！ 3.1.3 Package我们来看看 Pacakge 结构体，他用来分装一个应用程序包的完整信息：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public final static class Package &#123; public String packageName; // 应用程序包名 public String[] splitNames; // 非核心 apk 的名称 public String volumeUuid; public String codePath; // 应用程序包的路径 public String baseCodePath; // 核心 apk 的路径 public String[] splitCodePaths; // 非核心 apk 的路径 public int baseRevisionCode; // 核心 apk public int[] splitRevisionCodes; public int[] splitFlags; public int[] splitPrivateFlags; public boolean baseHardwareAccelerated; // For now we only support one application per package. public final ApplicationInfo applicationInfo = new ApplicationInfo(); // 核心 apk 的 application 对象！ public final ArrayList&lt;Permission&gt; permissions = new ArrayList&lt;Permission&gt;(0); public final ArrayList&lt;PermissionGroup&gt; permissionGroups = new ArrayList&lt;PermissionGroup&gt;(0); public final ArrayList&lt;Activity&gt; activities = new ArrayList&lt;Activity&gt;(0); public final ArrayList&lt;Activity&gt; receivers = new ArrayList&lt;Activity&gt;(0); public final ArrayList&lt;Provider&gt; providers = new ArrayList&lt;Provider&gt;(0); public final ArrayList&lt;Service&gt; services = new ArrayList&lt;Service&gt;(0); public final ArrayList&lt;Instrumentation&gt; instrumentation = new ArrayList&lt;Instrumentation&gt;(0); public final ArrayList&lt;String&gt; requestedPermissions = new ArrayList&lt;String&gt;(); public ArrayList&lt;String&gt; protectedBroadcasts; public Package parentPackage; public ArrayList&lt;Package&gt; childPackages; public ArrayList&lt;String&gt; libraryNames = null; public ArrayList&lt;String&gt; usesLibraries = null; public ArrayList&lt;String&gt; usesOptionalLibraries = null; public String[] usesLibraryFiles = null; public ArrayList&lt;ActivityIntentInfo&gt; preferredActivityFilters = null; public ArrayList&lt;String&gt; mOriginalPackages = null; public String mRealPackage = null; public ArrayList&lt;String&gt; mAdoptPermissions = null; // We store the application meta-data independently to avoid multiple unwanted references public Bundle mAppMetaData = null; // The version code declared for this package. public int mVersionCode; // The version name declared for this package. public String mVersionName; // The shared user id that this package wants to use. public String mSharedUserId; // The shared user label that this package wants to use. public int mSharedUserLabel; // Signatures that were read from the package. public Signature[] mSignatures; public Certificate[][] mCertificates; // For use by package manager service for quick lookup of // preferred up order. public int mPreferredOrder = 0; // For use by package manager to keep track of when a package was last used. public long[] mLastPackageUsageTimeInMills = new long[PackageManager.NOTIFY_PACKAGE_USE_REASONS_COUNT]; // // User set enabled state. // public int mSetEnabled = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT; // // // Whether the package has been stopped. // public boolean mSetStopped = false; // Additional data supplied by callers. public Object mExtras; // Applications hardware preferences public ArrayList&lt;ConfigurationInfo&gt; configPreferences = null; // Applications requested features public ArrayList&lt;FeatureInfo&gt; reqFeatures = null; // Applications requested feature groups public ArrayList&lt;FeatureGroupInfo&gt; featureGroups = null; public int installLocation; public boolean coreApp; /* An app that's required for all users and cannot be uninstalled for a user */ public boolean mRequiredForAllUsers; /* The restricted account authenticator type that is used by this application */ public String mRestrictedAccountType; /* The required account type without which this application will not function */ public String mRequiredAccountType; public String mOverlayTarget; public int mOverlayPriority; public boolean mTrustedOverlay; public ArraySet&lt;PublicKey&gt; mSigningKeys; public ArraySet&lt;String&gt; mUpgradeKeySets; public ArrayMap&lt;String, ArraySet&lt;PublicKey&gt;&gt; mKeySetMapping; public String cpuAbiOverride; public boolean use32bitAbi; public byte[] restrictUpdateHash; public Package(String packageName) &#123; this.packageName = packageName; applicationInfo.packageName = packageName; applicationInfo.uid = -1; &#125; ... ... ... ...&#125; 通过 PParser.parsePackage 方法，最终会返回一个 Package 对象，封装了应用程序包的所有信息！！ 3.2 PMS.scanPackageLI参数 policyFlags 为 paraseFlags！ 前一个阶段，通过解析获得了 package 的信息，接着继续扫描：1234567891011121314151617181920212223242526272829303132333435private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; //【1】SCAN_CHECK_ONLY 标签是为了检测是否所有的包（parent 和 child）都可以被成功的扫描到！ if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; if (pkg.childPackages != null &amp;&amp; pkg.childPackages.size() &gt; 0) &#123; scanFlags |= SCAN_CHECK_ONLY; // 设置 SCAN_CHECK_ONLY 位！ &#125; &#125; else &#123; scanFlags &amp;= ~SCAN_CHECK_ONLY; // 取消 SCAN_CHECK_ONLY 位！ &#125; //【3.2.1】继续扫描当前 package，返回扫描结果 scannedPkg！ PackageParser.Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user); // 扫描当前 package 的子 pacakge（如果有） final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPackage = pkg.childPackages.get(i); // 解析子包！ scanPackageInternalLI(childPackage, scanFile, policyFlags, scanFlags, currentTime, user); &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; // 如果设置了 SCAN_CHECK_ONLY 位， 就调用自身，再次处理！ return scanPackageLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user); &#125; return scannedPkg;&#125; 如果被扫描的 package 有 child package，并且是第一次进入该方法的话，就需要检测是否所有的包（parent 和 child）都可以被成功的扫描到，scanFlags 本来是没有 SCAN_CHECK_ONLY 位的，所以这里会将其 SCAN_CHECK_ONLY 置为 1，这样在方法的最后，又会调用自身，这次又会将 SCAN_CHECK_ONLY 位置为 0！ 继续看： 3.2.1 PMS.scanPackageInternalLI我们继续来看，通过前面的扫描解析，我们获得了应用程序的 PackageParser.Package 对象，同时，我们也已经获得了上一次的安装信息，接下来，就是要处理解析获得的数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257private PackageParser.Package scanPackageInternalLI(PackageParser.Package pkg, File scanFile, int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; PackageSetting ps = null; PackageSetting updatedPkg; synchronized (mPackages) &#123; // package 是否被重命名过，有的话，获得其 oldName！ String oldName = mSettings.mRenamedPackages.get(pkg.packageName); //【3.2.1.1】如果 package 有源包，并且源包的名字是当前扫描的 package 的旧名字， // 那就用源包的 PackageSetting 作为当前 package 的数据！ if (pkg.mOriginalPackages != null &amp;&amp; pkg.mOriginalPackages.contains(oldName)) &#123; ps = mSettings.peekPackageLPr(oldName); &#125; // 如果没有源包，就用当前 package 的包名查找一个已的 PackageSetting！ if (ps == null) &#123; ps = mSettings.peekPackageLPr(pkg.packageName); &#125; //【3.2.1.2】如果当前系统 package 被更新过，就查找到被更新之前的 PackageSetting！ updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName); if (DEBUG_INSTALL &amp;&amp; updatedPkg != null) Slog.d(TAG, \"updatedPkg = \" + updatedPkg); // 如果系统 package，并且被更新过，需要处理新旧 child package 的差异！ // 比较更新后的 child package 和更新前的 child package，如果更新前的 child package 不存在了； // 就要移除！ if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0) &#123; PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName); if (disabledPs != null) &#123; // 当前 package 的 child package 个数！ final int scannedChildCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; // 更新之前的 child package 个数！ final int disabledChildCount = disabledPs.childPackageNames != null ? disabledPs.childPackageNames.size() : 0; for (int i = 0; i &lt; disabledChildCount; i++) &#123; String disabledChildPackageName = disabledPs.childPackageNames.get(i); boolean disabledPackageAvailable = false; for (int j = 0; j &lt; scannedChildCount; j++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(j); if (childPkg.packageName.equals(disabledChildPackageName)) &#123; disabledPackageAvailable = true; break; &#125; &#125; if (!disabledPackageAvailable) &#123; //【3.2.1.3】更新前的 child package，不包含在更新后的 child package 中，无效， // 就从 mDisabledSysPackages 中删除掉！ mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName); &#125; &#125; &#125; &#125; &#125; boolean updatedPkgBetter = false; //【A】处理覆盖更新的情况！ // 如果当前解析的系统 apk，并且他之前被覆盖更新过！ // 注意：ps 是上次安装的信息，updatedPkg 是由于覆盖安装更新前的信息！，pkg 则是本次扫描的 system app 的信息！ if (updatedPkg != null &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0) &#123; if (locationIsPrivileged(scanFile)) &#123; // 对于 /system/priv-app 目录下的 app，需要增加 ApplicationInfo.PRIVATE_FLAG_PRIVILEGED 的 flag！ updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; else &#123; updatedPkg.pkgPrivateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; // 上次更新后的应用路径和这次扫描解析的路径不一样，上次更新到了 data 分区，而这次扫描的是 system 分区， // 就需要比较一下 versionCode 的大小， if (ps != null &amp;&amp; !ps.codePath.equals(scanFile)) &#123; if (DEBUG_INSTALL) Slog.d(TAG, \"Path changing from \" + ps.codePath); // pkg 的 versioncode 小于等于上次更新后的 versioncode，说明 data 分区的 apk 仍然是最新的 // 那就用本次扫描解析的数据，来更新上次更新前的旧数据！ if (pkg.mVersionCode &lt;= ps.versionCode) &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"Package \" + ps.name + \" at \" + scanFile + \" ignored: updated version \" + ps.versionCode + \" better than this \" + pkg.mVersionCode); // updatedPkg.codePath 不等于当前的扫描目录，说明该 system app 目录发生了变化！ // 而该 system apk 是被覆盖更新了，所以也需要更新 updatedPkg 的数据～ if (!updatedPkg.codePath.equals(scanFile)) &#123; Slog.w(PackageManagerService.TAG, \"Code path for hidden system pkg \" + ps.name + \" changing from \" + updatedPkg.codePathString + \" to \" + scanFile); updatedPkg.codePath = scanFile; updatedPkg.codePathString = scanFile.toString(); updatedPkg.resourcePath = scanFile; updatedPkg.resourcePathString = scanFile.toString(); &#125; updatedPkg.pkg = pkg; updatedPkg.versionCode = pkg.mVersionCode; final int childCount = updatedPkg.childPackageNames != null ? updatedPkg.childPackageNames.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; String childPackageName = updatedPkg.childPackageNames.get(i); PackageSetting updatedChildPkg = mSettings.getDisabledSystemPkgLPr( childPackageName); if (updatedChildPkg != null) &#123; updatedChildPkg.pkg = pkg; updatedChildPkg.versionCode = pkg.mVersionCode; &#125; &#125; throw new PackageManagerException(Log.WARN, \"Package \" + ps.name + \" at \" + scanFile + \" ignored: updated version \" + ps.versionCode + \" better than this \" + pkg.mVersionCode); &#125; else &#123; // pkg 的 versioncode 大于上次更新后的 versioncode， // 说明当前在 system 分区的 apk 要比 data 分区的新，这说明 system app 又通过 OTA 升级更新了 // 那就要保留本次扫描解析的数据，删除上一次更新的数据！ synchronized (mPackages) &#123; // 从 PMS.mPackages 中删除上一次的扫描数据！ mPackages.remove(ps.name); &#125; logCriticalInfo(Log.WARN, \"Package \" + ps.name + \" at \" + scanFile + \" reverting from \" + ps.codePathString + \": new version \" + pkg.mVersionCode + \" better than installed \" + ps.versionCode); // 创建一个安装参数对象，封装了上次安装的信息！！ InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps)); synchronized (mInstallLock) &#123; // 移除 data 分区的 apk 和 相应的 dex 文件！ args.cleanUpResourcesLI(); &#125; synchronized (mPackages) &#123; //【3.2.1.4】将更新前的旧数据 PackageSetting ，从 mDisabledSysPackages 中移除， // 并复用旧数据，创建一个新的PackageSetting，添加到 Setting 的 mPackage 中！ mSettings.enableSystemPackageLPw(ps.name); &#125; updatedPkgBetter = true; // 设置 updatedPkgBetter 为 true！ &#125; &#125; &#125; if (updatedPkg != null) &#123; // 对于被更新的系统 app 的 flag 进行设置！ policyFlags |= PackageParser.PARSE_IS_SYSTEM; if ((updatedPkg.pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) &#123; policyFlags |= PackageParser.PARSE_IS_PRIVILEGED; &#125; &#125; collectCertificatesLI(ps, pkg, scanFile, policyFlags); //【B】处理没有覆盖，但是 data 和 system 分区出现了相同的 apk 的情况！ // package 并没有发生覆盖更新，但之前 apk 是安装在 data 分区，而后来出现了相同包名的新 apk 安装在了 system 分区 //（比如系统 OTA 升级导致的 apk 分区改变，或者 root 后 push 一个相同 apk 到 system 分区然后重启）！ // 或者还有一种是之前安装在 data 分区，然后应用移动到了 system 分区！ // 那就要判断是否隐藏 system 分区的这个 apk 了！ boolean shouldHideSystemApp = false; if (updatedPkg == null &amp;&amp; ps != null &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0 &amp;&amp; !isSystemApp(ps)) &#123; // 校验签名，如果不匹配的话，就冻结掉安装在 system 分区的 apk，并清除数据！ if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; logCriticalInfo(Log.WARN, \"Package \" + ps.name + \" appeared on system, but\" + \" signatures don't match existing userdata copy; removing\"); // 创建一个 PackageFreezer 用来冻结指定的 package！ try (PackageFreezer freezer = freezePackage(pkg.packageName, \"scanPackageInternalLI\")) &#123; deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null); &#125; ps = null; &#125; else &#123; // 如果新添加的位于 system 分区的 apk 的版本号小于等于位于 data 分区的 apk； // 那就要隐藏 system 分区的 apk； if (pkg.mVersionCode &lt;= ps.versionCode) &#123; shouldHideSystemApp = true; // 设置 shouldHideSystemApp 为 true！ logCriticalInfo(Log.INFO, \"Package \" + ps.name + \" appeared at \" + scanFile + \" but new version \" + pkg.mVersionCode + \" better than installed \" + ps.versionCode + \"; hiding system\"); &#125; else &#123; // system 分区的应用版本更高，删除 data 分区的 apk，同时保留数据！ logCriticalInfo(Log.WARN, \"Package \" + ps.name + \" at \" + scanFile + \" reverting from \" + ps.codePathString + \": new version \" + pkg.mVersionCode + \" better than installed \" + ps.versionCode); // 创建一个安装参数！ InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps)); synchronized (mInstallLock) &#123; // 删除 data 分区的 apk，并保留用户数据！ args.cleanUpResourcesLI(); &#125; &#125; &#125; &#125; // 系统 apk 不进入！ if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; if (ps != null &amp;&amp; !ps.codePath.equals(ps.resourcePath)) &#123; policyFlags |= PackageParser.PARSE_FORWARD_LOCK; &#125; &#125; String resourcePath = null; String baseResourcePath = null; if ((policyFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != 0 &amp;&amp; !updatedPkgBetter) &#123; if (ps != null &amp;&amp; ps.resourcePathString != null) &#123; resourcePath = ps.resourcePathString; baseResourcePath = ps.resourcePathString; &#125; else &#123; Slog.e(TAG, \"Resource path not set for package \" + pkg.packageName); &#125; &#125; else &#123; resourcePath = pkg.codePath; baseResourcePath = pkg.baseCodePath; &#125; // 设置 Package.ApplicationInfo 对象的 path 属性！ pkg.setApplicationVolumeUuid(pkg.volumeUuid); pkg.setApplicationInfoCodePath(pkg.codePath); pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath); pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths); pkg.setApplicationInfoResourcePath(resourcePath); pkg.setApplicationInfoBaseResourcePath(baseResourcePath); pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths); //【3.2.1.7】接着调用 scanPackageLI，继续处理扫描数据！ PackageParser.Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); //【3.2.1.8】如果确认 data 分区的 apk 版本比 system 分区的版本高 // 就隐藏 system 分区的 app，让 data 分区的 apk 显示出来！ if (shouldHideSystemApp) &#123; synchronized (mPackages) &#123; mSettings.disableSystemPackageLPw(pkg.packageName, true); &#125; &#125; return scannedPkg;&#125; 到这里，我们先来总结一下，对于一个系统 app 而言， app 升级有如下两种途径： 覆盖安装：这种方式 PMS 会动态修改 packages.xml 文件！ OTA 升级方式：这种方式并不会动态修改 package.xml 文件！ 下面我们来分开分析一下： 覆盖安装 对于系统 app，覆盖安装的话，新的 app 会安装到 data 分区，packages.xml 中相应数据会发生如下变化：12345678 &lt;package name=\"com.android.pic\" codePath=\"/data/app/com.android.pic-1\" nativeLibraryPath=\"/data/app/com.android.pic-1/lib\" primaryCpuAbi=\"arm64-v8a\" publicFlags=\"944258757\" privateFlags=\"0\" ft=\"15c38695c40\" it=\"15baf6278f0\" ut=\"15c38695e98\" version=\"3002\" sharedUserId=\"1000\" installer=\"com.android.packageinstaller\" isOrphaned=\"true\"&gt; &lt;/package&gt; &lt;updated-package name=\"com.android.pic\" codePath=\"/system/app/pic\" ft=\"15baf6278f0\" it=\"15baf6278f0\" ut=\"15baf6278f0\" version=\"3002\" nativeLibraryPath=\"/system/app/pic/lib\" primaryCpuAbi=\"arm64-v8a\" sharedUserId=\"1000\" /&gt; 可以看到，package 的 codePath、nativeLibraryPath 都发生了变化，根据上面的解析过程，data 分区的覆盖安装的 apk 将被保存到 mPackages 中，system 分区原来的旧 apk 将被保存到 mDisablePackage 中！ OTA 升级方式 这种方式是通过进入 Recovery 升级（或者是 A/B 升级方式），通过 patch 和文件覆盖方式来升级，这种方式不会即时更改 Packages.xml 文件，真正的修改是在重启后的 PMS 中去做的！ 3.2.1.1 Settings.peekPackageLPr123PackageSetting peekPackageLPr(String name) &#123; return mPackages.get(name);&#125; 该方法用于获得 packageName 对应的 PackageSetting 对象！ 3.2.1.2 Settings.getDisabledSystemPkgLPr1234public PackageSetting getDisabledSystemPkgLPr(String name) &#123; PackageSetting ps = mDisabledSysPackages.get(name); return ps;&#125; 我们知道 mDisabledSysPackages 中的数据来自 updated-package 标签！ 3.2.1.3 Settings.removeDisabledSystemPackageLPw123void removeDisabledSystemPackageLPw(String name) &#123; mDisabledSysPackages.remove(name);&#125; 3.2.1.4 Settings.enableSystemPackageLPw这里用于恢复一个 system pacakge！ 12345678910111213141516171819202122PackageSetting enableSystemPackageLPw(String name) &#123; // 从 mDisabledSysPackages 中获得被更新前的 PackageSettings！ PackageSetting p = mDisabledSysPackages.get(name); if(p == null) &#123; Log.w(PackageManagerService.TAG, \"Package \" + name + \" is not disabled\"); return null; &#125; // 去掉 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标志位！ if((p.pkg != null) &amp;&amp; (p.pkg.applicationInfo != null)) &#123; p.pkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; // 复用数据，创建一个新的 PackageSetting，并根据 uid 添加到指定集合中！ PackageSetting ret = addPackageLPw(name, p.realName, p.codePath, p.resourcePath, p.legacyNativeLibraryPathString, p.primaryCpuAbiString, p.secondaryCpuAbiString, p.cpuAbiOverrideString, p.appId, p.versionCode, p.pkgFlags, p.pkgPrivateFlags, p.parentPackageName, p.childPackageNames); // 从 mDisabledSysPackages 移除这个 package mDisabledSysPackages.remove(name); return ret;&#125; 方法的流程很简单，不多说了！ 3.2.1.6 PMS.deletePackageLIF对于之前 apk 是安装在 data 分区，而后来出现了相同包名的新 apk 安装在了 system 分区这种情况，需要校验签名，如果不匹配的话，就要删掉 data 分区的 apk！ 首先创建了一个 PackageFreezer 对象，用来冻结这个应用！12345678910111213141516171819202122232425262728public PackageFreezer(String packageName, int userId, String killReason) &#123; synchronized (mPackages) &#123; // 添加到 mFrozenPackages 集合中！ mPackageName = packageName; mWeFroze = mFrozenPackages.add(mPackageName); final PackageSetting ps = mSettings.mPackages.get(mPackageName); if (ps != null) &#123; // 杀掉应用的进程 killApplication(ps.name, ps.appId, userId, killReason); &#125; // 对子包进行相同的操作！ final PackageParser.Package p = mPackages.get(packageName); if (p != null &amp;&amp; p.childPackages != null) &#123; final int N = p.childPackages.size(); mChildren = new PackageFreezer[N]; for (int i = 0; i &lt; N; i++) &#123; mChildren[i] = new PackageFreezer(p.childPackages.get(i).packageName, userId, killReason); &#125; &#125; else &#123; mChildren = null; &#125; &#125; mCloseGuard.open(\"close\");&#125; 接着，调用 deletePackageLIF 方法来处理这个 package，传入参数： String packageName：传入 pkg.packageName； UserHandle user：传入 null； boolean deleteCodeAndResources：传入 true； int[] allUserHandles：传入 null； int flags：传入 0； PackageRemovedInfo outInfo：传入 null； boolean writeSettings：传入 false； PackageParser.Package replacingPackage：传入 null; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) &#123; if (packageName == null) &#123; Slog.w(TAG, \"Attempt to delete null packageName.\"); return false; &#125; if (DEBUG_REMOVE) Slog.d(TAG, \"deletePackageLI: \" + packageName + \" user \" + user); PackageSetting ps; synchronized (mPackages) &#123; // 获得之前安装的信息，如果为 null，谁明这个 ps = mSettings.mPackages.get(packageName); if (ps == null) &#123; Slog.w(TAG, \"Package named '\" + packageName + \"' doesn't exist.\"); return false; &#125; // 如果当前的 package 是 child package，且不是系统 apk 的话，进入这个分支！ if (ps.parentPackageName != null &amp;&amp; (!isSystemApp(ps) || (flags &amp; PackageManager.DELETE_SYSTEM_APP) != 0)) &#123; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"Uninstalled child package:\" + packageName + \" for user:\" + ((user == null) ? UserHandle.USER_ALL : user)); &#125; // 根据参数传递，removedUserId 的值为 UserHandle.USER_ALL； final int removedUserId = (user != null) ? user.getIdentifier() : UserHandle.USER_ALL; if (!clearPackageStateForUserLIF(ps, removedUserId, outInfo)) &#123; return false; &#125; markPackageUninstalledForUserLPw(ps, user); scheduleWritePackageRestrictionsLocked(user); return true; &#125; &#125; // 当 user 不为 null 才会进入这里，表示为指定的设备用户删除该 apk！ if (((!isSystemApp(ps) || (flags&amp;PackageManager.DELETE_SYSTEM_APP) != 0) &amp;&amp; user != null &amp;&amp; user.getIdentifier() != UserHandle.USER_ALL)) &#123; ... ... ... ... &#125; // 这里也不进入！ if (ps.childPackageNames != null &amp;&amp; outInfo != null) &#123; ... ... ... ... &#125; boolean ret = false; if (isSystemApp(ps)) &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Removing system package: \" + ps.name); // When an updated system application is deleted we delete the existing resources // as well and fall back to existing code in system partition ret = deleteSystemPackageLIF(ps.pkg, ps, allUserHandles, flags, outInfo, writeSettings); &#125; else &#123; if (DEBUG_REMOVE) Slog.d(TAG, \"Removing non-system package: \" + ps.name); // 进入这个分支，因为 data 分区的 apk 已经存在，所以进入这个分支，删除掉非系统 apk！ ret = deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles, outInfo, writeSettings, replacingPackage); &#125; // 根据参数，不会进入这个分支 if (outInfo != null) &#123; ... ... ... &#125; return ret;&#125; 关于 apk 删除的逻辑，我们在另开一篇讲解，这个的逻辑是会删掉之前已经安装的 data 分区的 apk 的！ 继续看： 3.2.1.7 PMS.scanPackageLI接下来，进一步的扫描：123456789101112131415161718192021private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; boolean success = false; try &#123; //【3.2.1.7.1】继续调用 scanPackageDirtyLI 处理扫描数据！ final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user); success = true; return res; &#125; finally &#123; if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) &#123; // DELETE_DATA_ON_FAILURES is only used by frozen paths // 失败了就清楚掉数据！ destroyAppDataLIF(pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); destroyAppProfilesLIF(pkg, UserHandle.USER_ALL); &#125; &#125;&#125; 下面，我们继续看 scanPackageDirtyLI 方法中的逻辑！ 3.2.1.7.1 *PMS.scanPackageDirtyLI最终调用 scanPackageDirtyLI 方法处理扫描得到的数据： 因为我们本次扫描的是 system app，所以 PackageParser.Package pkg 分装了扫描的结果信息！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; final File scanFile = new File(pkg.codePath); if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, \"Code and resource paths haven't been set correctly\"); &#125; //【1】处理系统 apk 标志位； if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0) &#123; // 对于系统 app，增加 ApplicationInfo.FLAG_SYSTEM 的 flags，表示是系统 apk！ //【1.1】注意系统和非系统的区别是，apk 所在的目录！ pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM; // 处理 Direct Boot Mode 属性，设备启动后进入的一个新模式，直到用户解锁（unlock）设备此阶段结束！ if (pkg.applicationInfo.isDirectBootAware()) &#123; for (PackageParser.Service s : pkg.services) &#123; s.info.encryptionAware = s.info.directBootAware = true; &#125; for (PackageParser.Provider p : pkg.providers) &#123; p.info.encryptionAware = p.info.directBootAware = true; &#125; for (PackageParser.Activity a : pkg.activities) &#123; a.info.encryptionAware = a.info.directBootAware = true; &#125; for (PackageParser.Activity r : pkg.receivers) &#123; r.info.encryptionAware = r.info.directBootAware = true; &#125; &#125; &#125; else &#123; pkg.coreApp = false; pkg.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE; pkg.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE; &#125; pkg.mTrustedOverlay = (policyFlags&amp;PackageParser.PARSE_TRUSTED_OVERLAY) != 0; //【2】设置 ApplicationInfo.PRIVATE_FLAG_PRIVILEGED 标记位，说明这个 apk 是特权 apk！ if ((policyFlags&amp;PackageParser.PARSE_IS_PRIVILEGED) != 0) &#123; pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; if ((policyFlags &amp; PackageParser.PARSE_ENFORCE_CODE) != 0) &#123; enforceCodePolicy(pkg); &#125; if (mCustomResolverComponentName != null &amp;&amp; mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) &#123; setUpCustomResolverActivity(pkg); &#125; //【3】处理包名为 \"android\" 的 apk，也就是 framework-res.apk，属于系统平台包！ if (pkg.packageName.equals(\"android\")) &#123; synchronized (mPackages) &#123; if (mAndroidApplication != null) &#123; Slog.w(TAG, \"*************************************************\"); Slog.w(TAG, \"Core android package being redefined. Skipping.\"); Slog.w(TAG, \" file=\" + scanFile); Slog.w(TAG, \"*************************************************\"); throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, \"Core android package being redefined. Skipping.\"); &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; // 进入该分支，设置系统平台包相关的属性！ // Set up information for our fall-back user intent resolution activity. mPlatformPackage = pkg; pkg.mVersionCode = mSdkVersion; mAndroidApplication = pkg.applicationInfo; if (!mResolverReplaced) &#123; // 建立 ResolverActivity 的内存对象。 mResolveActivity.applicationInfo = mAndroidApplication; mResolveActivity.name = ResolverActivity.class.getName(); mResolveActivity.packageName = mAndroidApplication.packageName; mResolveActivity.processName = \"system:ui\"; mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE; mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER; mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS; mResolveActivity.theme = R.style.Theme_Material_Dialog_Alert; mResolveActivity.exported = true; mResolveActivity.enabled = true; mResolveActivity.resizeMode = ActivityInfo.RESIZE_MODE_RESIZEABLE; mResolveActivity.configChanges = ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_KEYBOARD | ActivityInfo.CONFIG_KEYBOARD_HIDDEN; mResolveInfo.activityInfo = mResolveActivity; mResolveInfo.priority = 0; mResolveInfo.preferredOrder = 0; mResolveInfo.match = 0; mResolveComponentName = new ComponentName( mAndroidApplication.packageName, mResolveActivity.name); &#125; &#125; &#125; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Scanning package \" + pkg.packageName); &#125; synchronized (mPackages) &#123; //【4】如果 PMS.mPackages 已经包含当前的 Package，说明这个包已经被扫描过了，抛异常，不继续处理！ if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) &#123; throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, \"Application package \" + pkg.packageName + \" already installed. Skipping duplicate.\"); &#125; //【5】系统 apk 不进入这个分支，SCAN_REQUIRE_KNOWN 只有在扫描 data 分区是才会被设置！！ if ((scanFlags &amp; SCAN_REQUIRE_KNOWN) != 0) &#123; //【5.1】扫描 data 分区时，会判断 mExpectingBetter 中是否包含该 package！ if (mExpectingBetter.containsKey(pkg.packageName)) &#123; logCriticalInfo(Log.WARN, \"Relax SCAN_REQUIRE_KNOWN requirement for package \" + pkg.packageName); &#125; else &#123; PackageSetting known = mSettings.peekPackageLPr(pkg.packageName); if (known != null) &#123; if (DEBUG_PACKAGE_SCANNING) &#123; Log.d(TAG, \"Examining \" + pkg.codePath + \" and requiring known paths \" + known.codePathString + \" &amp; \" + known.resourcePathString); &#125; if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals( known.resourcePathString)) &#123; throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, \"Application package \" + pkg.packageName + \" found at \" + pkg.applicationInfo.getCodePath() + \" but expected at \" + known.codePathString + \"; ignoring.\"); &#125; &#125; &#125; &#125; &#125; //【6】获得扫描到的 apk 和资源的路径，下面会用到！ File destCodeFile = new File(pkg.applicationInfo.getCodePath()); File destResourceFile = new File(pkg.applicationInfo.getResourcePath()); SharedUserSetting suid = null; PackageSetting pkgSetting = null; //【7】系统 apk 才能有 mOriginalPackages，mRealPackage 和 mAdoptPermissions！ if (!isSystemApp(pkg)) &#123; pkg.mOriginalPackages = null; pkg.mRealPackage = null; pkg.mAdoptPermissions = null; &#125; // Getting the package setting may have a side-effect, so if we // are only checking if scan would succeed, stash a copy of the // old setting to restore at the end. PackageSetting nonMutatedPs = null; synchronized (mPackages) &#123; //【8】当前的系统（三方） package 是共享 uid 的，要判断其对应的共享 uid 是否存在， // 不存在就抛出异常！ if (pkg.mSharedUserId != null) &#123; suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true); if (suid == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Creating application package \" + pkg.packageName + \" for shared user failed\"); &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Shared UserID \" + pkg.mSharedUserId + \" (uid=\" + suid.userId + \"): packages=\" + suid.packages); &#125; &#125; //【9】对于系统 package，如果有源包，那就要尝试将 package 的名字改为源包的名字！ // 需要找到一个合适的源包，用来改名！ PackageSetting origPackage = null; String realName = null if (pkg.mOriginalPackages != null) &#123; final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage); //【9.1】如果当前 package 被重命名过，并且有源包的名字是重命名前的名字，就将 package 的名字改为以前的！ if (pkg.mOriginalPackages.contains(renamed)) &#123; realName = pkg.mRealPackage; if (!pkg.packageName.equals(renamed)) &#123; pkg.setPackageName(renamed); &#125; &#125; else &#123; for (int i=pkg.mOriginalPackages.size()-1; i&gt;=0; i--) &#123; if ((origPackage = mSettings.peekPackageLPr( pkg.mOriginalPackages.get(i))) != null) &#123; //【9.2】对当前 package 和其源包进行校验 // 如果源包是非系统 package，不是同一分区，无法重命名为源包名，返回 false； // 或者源包是系统 package，但是 PMS.mPackage 中仍然有其扫描数据，源包仍然存在，返回 false； if (!verifyPackageUpdateLPr(origPackage, pkg)) &#123; origPackage = null; continue; &#125; else if (origPackage.sharedUser != null) &#123; //【9.3】源包是系统 package，并且共享用户 uid； // 如果当前的 package 和源包的共享 uid 不匹配，也会返回 false！ // 表示无法迁移数据； if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) &#123; Slog.w(TAG, \"Unable to migrate data from \" + origPackage.name + \" to \" + pkg.packageName + \": old uid \" + origPackage.sharedUser.name + \" differs from \" + pkg.mSharedUserId); origPackage = null; continue; &#125; &#125; else &#123; // 可以看到，如果找到用于重命名的源包，origPackage 不会为 null！ if (DEBUG_UPGRADE) Log.v(TAG, \"Renaming new package \" + pkg.packageName + \" to old name \" + origPackage.name); &#125; break; &#125; &#125; &#125; &#125; // mTransferedPackages 用于保存那些自身数据已经被转移到其他 package 的 package！ if (mTransferedPackages.contains(pkg.packageName)) &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" was transferred to another, but its .apk remains\"); &#125; // See comments in nonMutatedPs declaration if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; PackageSetting foundPs = mSettings.peekPackageLPr(pkg.packageName); if (foundPs != null) &#123; nonMutatedPs = new PackageSetting(foundPs); &#125; &#125; //【3.2.1.7.1.1】获得当前扫描的这个 package 对应的 packageSetting 对象，如果已经存在就直接返回， // 不存在就创建！如果 origPackage 不为 null，创建新的需要重命名为源包的名字！ pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false); if (pkgSetting == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Creating application package \" + pkg.packageName + \" failed\"); &#125; //【11】对于系统 package，如果 origPackage 不为 null，改名为源包的名字！ if (pkgSetting.origPackage != null) &#123; pkg.setPackageName(origPackage.name); String msg = \"New package \" + pkgSetting.realName + \" renamed to replace old package \" + pkgSetting.name; reportSettingsProblem(Log.WARN, msg); if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; // 如果没有设置 SCAN_CHECK_ONLY，并且源包是存在的，就将源包添加到 mTransferedPackages 中！ mTransferedPackages.add(origPackage.name); &#125; // 清空 originPackage 属性！ pkgSetting.origPackage = null; &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; realName != null) &#123; mTransferedPackages.add(pkg.packageName); &#125; //【12】如果当前的系统 apk 被覆盖更新过，就添加 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标签！ if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; updateSharedLibrariesLPw(pkg, null); &#125; if (mFoundPolicyFile) &#123; //【13】给当前的 Package 分配一个标签，用于 seLinux！ SELinuxMMAC.assignSeinfoValue(pkg); &#125; pkg.applicationInfo.uid = pkgSetting.appId; pkg.mExtras = pkgSetting; //【13】处理 keySet 更新和签名校验！ if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) &#123; if (checkUpgradeKeySetLP(pkgSetting, pkg)) &#123; // 签名正确，更新本地的签名信息！ pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; else &#123; // 签名异常处理 if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" upgrade keys do not match the \" + \"previously installed version\"); &#125; else &#123; pkgSetting.signatures.mSignatures = pkg.mSignatures; String msg = \"System package \" + pkg.packageName + \" signature changed; retaining data.\"; reportSettingsProblem(Log.WARN, msg); &#125; &#125; &#125; else &#123; // 如果不检查 KetSet 更新的话，就直接校验签名！ try &#123; verifySignaturesLP(pkgSetting, pkg); pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; catch (PackageManagerException e) &#123; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw e; &#125; // 如果签名校验出现问题，这里会先恢复成本次解析的签名！ pkgSetting.signatures.mSignatures = pkg.mSignatures; // 但是如果是 sharedUser 的情况，就会报错！ if (pkgSetting.sharedUser != null) &#123; if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; throw new PackageManagerException( INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, \"Signature mismatch for shared user: \" + pkgSetting.sharedUser); &#125; &#125; String msg = \"System package \" + pkg.packageName + \" signature changed; retaining data.\"; reportSettingsProblem(Log.WARN, msg); &#125; &#125; //【14】安装的时候才会进入这个分支，这里不看！ // 判断这个 package 使用的 content providers 是否和已经存在 package 冲突！ if ((scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123; final int N = pkg.providers.size(); int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); if (p.info.authority != null) &#123; String names[] = p.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; if (mProvidersByAuthority.containsKey(names[j])) &#123; PackageParser.Provider other = mProvidersByAuthority.get(names[j]); final String otherPackageName = ((other != null &amp;&amp; other.getComponentName() != null) ? other.getComponentName().getPackageName() : \"?\"); throw new PackageManagerException( INSTALL_FAILED_CONFLICTING_PROVIDER, \"Can't install because provider name \" + names[j] + \" (in package \" + pkg.applicationInfo.packageName + \") is already used by \" + otherPackageName); &#125; &#125; &#125; &#125; &#125; //【15】同样的，只有系统 apk 才能进入该分支，用于权限继承！ if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; pkg.mAdoptPermissions != null) &#123; for (int i = pkg.mAdoptPermissions.size() - 1; i &gt;= 0; i--) &#123; final String origName = pkg.mAdoptPermissions.get(i); final PackageSetting orig = mSettings.peekPackageLPr(origName); if (orig != null) &#123; //【15.1】校验要被继承权限的 package 一是否存在，二是否是系统应用！ // 条件不满足，无法权限继承！ if (verifyPackageUpdateLPr(orig, pkg)) &#123; Slog.i(TAG, \"Adopting permissions from \" + origName + \" to \" + pkg.packageName); mSettings.transferPermissionsLPw(origName, pkg.packageName); &#125; &#125; &#125; &#125; &#125; final String pkgName = pkg.packageName; // 从 base.apk 和其 split.apk（如果有）中选择修改时间最晚的作为扫描时间！ final long scanFileTime = getLastModifiedTime(pkg, scanFile); final boolean forceDex = (scanFlags &amp; SCAN_FORCE_DEX) != 0; // 没用到，应该是废弃代码！ //【16】设置 pacakge 对应的进程名，如果 processName 为 null，默认进程名为包名！ pkg.applicationInfo.processName = fixProcessName( pkg.applicationInfo.packageName, pkg.applicationInfo.processName, pkg.applicationInfo.uid); if (pkg != mPlatformPackage) &#123; // Get all of our default paths setup pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM); &#125; final String path = scanFile.getPath(); final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting); //【17】下面是设置本地库和系统平台相关的属性！！ if ((scanFlags &amp; SCAN_NEW_INSTALL) == 0) &#123; derivePackageAbi(pkg, scanFile, cpuAbiOverride, true /* extract libs */); if (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp() &amp;&amp; pkg.applicationInfo.primaryCpuAbi == null) &#123; setBundledAppAbisAndRoots(pkg, pkgSetting); setNativeLibraryPaths(pkg); &#125; &#125; else &#123; if ((scanFlags &amp; SCAN_MOVE) != 0) &#123; pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString; pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString; &#125; setNativeLibraryPaths(pkg); &#125; if (mPlatformPackage == pkg) &#123; pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0]; &#125; if ((scanFlags &amp; SCAN_NO_DEX) == 0 &amp;&amp; (scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123; if (cpuAbiOverride == null &amp;&amp; pkgSetting.cpuAbiOverrideString != null) &#123; Slog.w(TAG, \"Ignoring persisted ABI override \" + cpuAbiOverride + \" for package \" + pkg.packageName); &#125; &#125; pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi; pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi; pkgSetting.cpuAbiOverrideString = cpuAbiOverride; pkg.cpuAbiOverride = cpuAbiOverride; if (DEBUG_ABI_SELECTION) &#123; Slog.d(TAG, \"Resolved nativeLibraryRoot for \" + pkg.applicationInfo.packageName + \" to root=\" + pkg.applicationInfo.nativeLibraryRootDir + \", isa=\" + pkg.applicationInfo.nativeLibraryRootRequiresIsa); &#125; pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir; if (DEBUG_ABI_SELECTION) &#123; Log.d(TAG, \"Abis for package[\" + pkg.packageName + \"] are\" + \" primary=\" + pkg.applicationInfo.primaryCpuAbi + \" secondary=\" + pkg.applicationInfo.secondaryCpuAbi); &#125; if ((scanFlags &amp; SCAN_BOOTING) == 0 &amp;&amp; pkgSetting.sharedUser != null) &#123; adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg, true /* boot complete */); &#125; if (mFactoryTest &amp;&amp; pkg.requestedPermissions.contains( android.Manifest.permission.FACTORY_TEST)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST; &#125; // 如果是系统 package，设置 isOrphaned 的属性为 true！ if (isSystemApp(pkg)) &#123; pkgSetting.isOrphaned = true; &#125; ArrayList&lt;PackageParser.Package&gt; clientLibPkgs = null; if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; if (nonMutatedPs != null) &#123; synchronized (mPackages) &#123; mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs); &#125; &#125; return pkg; &#125; //【18】处理特权 apk 的子包，只有特权 apk 才能添加子包； // 特权 apk 包括两部分： // 1、特定 uid 的 app // 2、framework-res.apk 和 system/priv-app 目录下的 apk！ if (pkg.childPackages != null &amp;&amp; !pkg.childPackages.isEmpty()) &#123; if ((policyFlags &amp; PARSE_IS_PRIVILEGED) == 0) &#123; throw new PackageManagerException(\"Only privileged apps and updated \" + \"privileged apps can add child packages. Ignoring package \" + pkg.packageName); &#125; final int childCount = pkg.childPackages.size(); for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); if (mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, childPkg.packageName)) &#123; throw new PackageManagerException(\"Cannot override a child package of \" + \"another disabled system app. Ignoring package \" + pkg.packageName); &#125; &#125; &#125; synchronized (mPackages) &#123; //【19】如果是系统 package，并且他之前更新过，就要尝试对共享库 lib 进行更新！ // 只有系统 package 才能添加共享 lib if ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; if (pkg.libraryNames != null) &#123; for (int i=0; i&lt;pkg.libraryNames.size(); i++) &#123; String name = pkg.libraryNames.get(i); boolean allowed = false; if (pkg.isUpdatedSystemApp()) &#123; final PackageSetting sysPs = mSettings .getDisabledSystemPkgLPr(pkg.packageName); if (sysPs.pkg != null &amp;&amp; sysPs.pkg.libraryNames != null) &#123; for (int j=0; j&lt;sysPs.pkg.libraryNames.size(); j++) &#123; if (name.equals(sysPs.pkg.libraryNames.get(j))) &#123; allowed = true; break; &#125; &#125; &#125; &#125; else &#123; allowed = true; &#125; if (allowed) &#123; if (!mSharedLibraries.containsKey(name)) &#123; mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName)); &#125; else if (!name.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" library \" + name + \" already exists; skipping\"); &#125; &#125; else &#123; Slog.w(TAG, \"Package \" + pkg.packageName + \" declares lib \" + name + \" that is not declared on system image; skipping\"); &#125; &#125; if ((scanFlags &amp; SCAN_BOOTING) == 0) &#123; // 如果不是开机扫描，我们需要更新下该应用的共享库，对于开机扫描的情况，我们会在扫描完成后自动更新 clientLibPkgs = updateAllSharedLibrariesLPw(pkg); &#125; &#125; &#125; &#125; //【20】处理和冻结相关的逻辑 if ((scanFlags &amp; SCAN_BOOTING) != 0) &#123; // 如果是开机扫描，不需要冻结，因为没有应用在此时可以运行！ &#125; else if ((scanFlags &amp; SCAN_DONT_KILL_APP) != 0) &#123; // 如果扫描过程中不允许 kill app，那就不会冻结！ &#125; else if ((scanFlags &amp; SCAN_IGNORE_FROZEN) != 0) &#123; // 如果扫描过程中显式指定忽略冻结，那就不会冻结！ &#125; else &#123; // 其他情况，我们会默认冻结该应用，防止其启动！ checkPackageFrozen(pkgName); &#125; //【21】杀掉所以依赖于库文件的应用，因为库发生了更新！ if (clientLibPkgs != null) &#123; for (int i=0; i&lt;clientLibPkgs.size(); i++) &#123; PackageParser.Package clientPkg = clientLibPkgs.get(i); killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, \"update lib\"); &#125; &#125; KeySetManagerService ksms = mSettings.mKeySetManagerService; // 校验 keyset 的真实性 ksms.assertScannedPackageValid(pkg); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\"); // 记录 trace 事件！ boolean createIdmapFailed = false; synchronized (mPackages) &#123; // We don't expect installation to fail beyond this point if (pkgSetting.pkg != null) &#123; // Note that |user| might be null during the initial boot scan. If a codePath // for an app has changed during a boot scan, it's due to an app update that's // part of the system partition and marker changes must be applied to all users. maybeRenameForeignDexMarkers(pkgSetting.pkg, pkg, (user != null) ? user : UserHandle.ALL); &#125; //【3.2.1.7.1.2 important】将新创建或者更新后的 PackageSetting 重新添加到 mSettings 中！ mSettings.insertPackageSettingLPw(pkgSetting, pkg); //【important】将本次扫描的 Package 添加到 PMS.mPackages 中去！ mPackages.put(pkg.applicationInfo.packageName, pkg); //【22】将当前的 package 从 mSettings.mPackagesToBeCleaned 中移除，防止被清除！ final Iterator&lt;PackageCleanItem&gt; iter = mSettings.mPackagesToBeCleaned.iterator(); while (iter.hasNext()) &#123; PackageCleanItem item = iter.next(); if (pkgName.equals(item.packageName)) &#123; iter.remove(); &#125; &#125; //【23】处理 package 的第一次安装时间和最近更新时间！ if (currentTime != 0) &#123; if (pkgSetting.firstInstallTime == 0) &#123; pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime; &#125; else if ((scanFlags &amp; SCAN_UPDATE_TIME) != 0) &#123; pkgSetting.lastUpdateTime = currentTime; &#125; &#125; else if (pkgSetting.firstInstallTime == 0) &#123; pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime; &#125; else if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0) &#123; if (scanFileTime != pkgSetting.timeStamp) &#123; pkgSetting.lastUpdateTime = scanFileTime; &#125; &#125; ksms.addScannedPackageLPw(pkg); // 将 package 的 KeySets 添加到 KeySetManagerService 中！ //【24】处理四大组件！ //【24.1】处理该 Package 中 的 Provider 信息，添加到 PMS.mProviders 中！ int N = pkg.providers.size(); StringBuilder r = null; int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid); mProviders.addProvider(p); // 添加到 PMS.mProviders 中！ p.syncable = p.info.isSyncable; if (p.info.authority != null) &#123; String names[] = p.info.authority.split(\";\"); p.info.authority = null; for (int j = 0; j &lt; names.length; j++) &#123; if (j == 1 &amp;&amp; p.syncable) &#123; // We only want the first authority for a provider to possibly be // syncable, so if we already added this provider using a different // authority clear the syncable flag. We copy the provider before // changing it because the mProviders object contains a reference // to a provider that we don't want to change. // Only do this for the second authority since the resulting provider // object can be the same for all future authorities for this provider. p = new PackageParser.Provider(p); p.syncable = false; &#125; if (!mProvidersByAuthority.containsKey(names[j])) &#123; mProvidersByAuthority.put(names[j], p); if (p.info.authority == null) &#123; p.info.authority = names[j]; &#125; else &#123; p.info.authority = p.info.authority + \";\" + names[j]; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Registered content provider: \" + names[j] + \", className = \" + p.info.name + \", isSyncable = \" + p.info.isSyncable); &#125; &#125; else &#123; PackageParser.Provider other = mProvidersByAuthority.get(names[j]); Slog.w(TAG, \"Skipping provider name \" + names[j] + \" (in package \" + pkg.applicationInfo.packageName + \"): name already used by \" + ((other != null &amp;&amp; other.getComponentName() != null) ? other.getComponentName().getPackageName() : \"?\")); &#125; &#125; &#125; if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Providers: \" + r); &#125; //【24.2】处理该 Package 中的 Service 信息，添加到 PMS.mService 中！ N = pkg.services.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Service s = pkg.services.get(i); s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid); mServices.addService(s); // 添加到 PMS.mServices 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(s.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Services: \" + r); &#125; //【24.3】处理该 Package 中的 BroadcastReceiver 信息,添加到 PMS.mReceivers 中。 N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); mReceivers.addActivity(a, \"receiver\"); // 添加到 PMS.mReceivers 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Receivers: \" + r); &#125; //【24.4】处理该 Package 中的 activity 信息，添加到 PMS.mActivities 中！ N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); mActivities.addActivity(a, \"activity\"); // 添加到 PMS.mActivities 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Activities: \" + r); &#125; //【24.5】处理该 Package 中的 PermissionGroups 信息，添加到 PMS.mPermissionGroups 中！ N = pkg.permissionGroups.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i); PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name); final String curPackageName = cur == null ? null : cur.info.packageName; //【5.1】如果 isPackageUpdate 为 true，说明要更新权限组的信息！ // 如果 cur 为 null，说明是新添加的权限组信息！ final boolean isPackageUpdate = pg.info.packageName.equals(curPackageName); if (cur == null || isPackageUpdate) &#123; mPermissionGroups.put(pg.info.name, pg); // 添加到 PMS.mPermissionGroups 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; if (isPackageUpdate) &#123; r.append(\"UPD:\"); &#125; r.append(pg.info.name); &#125; &#125; else &#123; Slog.w(TAG, \"Permission group \" + pg.info.name + \" from package \" + pg.info.packageName + \" ignored: original from \" + cur.info.packageName); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(\"DUP:\"); r.append(pg.info.name); &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Permission Groups: \" + r); &#125; //【24.6】处理该 Package 中的定义 Permission 和 Permission-tree 信息！ N = pkg.permissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Permission p = pkg.permissions.get(i); // 默认取消掉 PermissionInfo.FLAG_INSTALLED 标志位！ p.info.flags &amp;= ~PermissionInfo.FLAG_INSTALLED; //【6.1】设置权限所属的 group，前提是只有 Android5.1 以后才支持 Permission Groups！ if (pkg.applicationInfo.targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123; p.group = mPermissionGroups.get(p.info.group); if (p.info.group != null &amp;&amp; p.group == null) &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" in an unknown group \" + p.info.group); &#125; &#125; //【6.2】从 Settings 中获得权限管理集合，如果该权限是一个 Permission-tree， // 那就返回 mSettings.mPermissionTrees；否则，返回 mSettings.mPermissions！ ArrayMap&lt;String, BasePermission&gt; permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions; //【6.3】尝试获得上次安装时该权限对应的 BasePermission 对象！ BasePermission bp = permissionMap.get(p.info.name); //【6.4】允许系统应用来重新定义非系统权限！ // 如果上次安装时的 BasePermission 不为 null，但是当前解析的 package 不是上次安装时该权限的定义者！ if (bp != null &amp;&amp; !Objects.equals(bp.sourcePackage, p.info.packageName)) &#123; //【6.4.1】判断上一次安装时，定义该权限的 package 是否是系统应用！ // 如果是 currentOwnerIsSystem 为 true！ final boolean currentOwnerIsSystem = (bp.perm != null &amp;&amp; isSystemApp(bp.perm.owner)); // 如果当前解析的定义了该权限的 package 是系统 app，那么进入这里！ if (isSystemApp(p.owner)) &#123; // 如果上次安装时，该权限是一个 BasePermission.TYPE_BUILTIN 系统权限，且 bp.perm 为 null， // 即：拥有者未知，那么这里我们将这个 system package 分配给这个权限！ if (bp.type == BasePermission.TYPE_BUILTIN &amp;&amp; bp.perm == null) &#123; bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; // 判断上一次安装时，定义该权限的 package 不是系统应用，而定义相同权限的 // 本次解析的 package 是系统应用，那么该权限会被系统应用重新定义！ &#125; else if (!currentOwnerIsSystem) &#123; String msg = \"New decl \" + p.owner + \" of permission \" + p.info.name + \" is system; overriding \" + bp.sourcePackage; reportSettingsProblem(Log.WARN, msg); // 设置 bp 为 null！ bp = null; &#125; &#125; &#125; // 因为 bp 为 null，所谓我们会使用系统应用重新定义权限，如果是 permission-tree，会被添加到 // mSettings.mPermissionTrees 中！ if (bp == null) &#123; bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL); permissionMap.put(p.info.name, bp); &#125; // 重新分配拥有者为该系统应用！ if (bp.perm == null) &#123; if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) &#123; BasePermission tree = findPermissionTreeLP(p.info.name); if (tree == null || tree.sourcePackage.equals(p.info.packageName)) &#123; bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; else &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" ignored: base tree \" + tree.name + \" is from package \" + tree.sourcePackage); &#125; &#125; else &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" ignored: original from \" + bp.sourcePackage); &#125; &#125; else if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(\"DUP:\"); r.append(p.info.name); &#125; // 如果上次安装时的权限的定义者，就是本次解析的 package，设置 protectionLevel！ if (bp.perm == p) &#123; bp.protectionLevel = p.info.protectionLevel; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Permissions: \" + r); &#125; N = pkg.instrumentation.size(); r = null; for (i=0; i&lt;N; i++) &#123; ... ... ... ...// 这里省略掉，暂时不看！ &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Instrumentation: \" + r); &#125; //【25】处理该 Package 中的 protectedBroadcasts 信息！ if (pkg.protectedBroadcasts != null) &#123; N = pkg.protectedBroadcasts.size(); for (i=0; i&lt;N; i++) &#123; mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i)); &#125; &#125; //【27】更新 PackageSettings 中的时间戳！ pkgSetting.setTimeStamp(scanFileTime); // Create idmap files for pairs of (packages, overlay packages). // Note: \"android\", ie framework-res.apk, is handled by native layers. if (pkg.mOverlayTarget != null) &#123; // This is an overlay package. if (pkg.mOverlayTarget != null &amp;&amp; !pkg.mOverlayTarget.equals(\"android\")) &#123; if (!mOverlays.containsKey(pkg.mOverlayTarget)) &#123; mOverlays.put(pkg.mOverlayTarget, new ArrayMap&lt;String, PackageParser.Package&gt;()); &#125; ArrayMap&lt;String, PackageParser.Package&gt; map = mOverlays.get(pkg.mOverlayTarget); map.put(pkg.packageName, pkg); PackageParser.Package orig = mPackages.get(pkg.mOverlayTarget); if (orig != null &amp;&amp; !createIdmapForPackagePairLI(orig, pkg)) &#123; createIdmapFailed = true; &#125; &#125; &#125; else if (mOverlays.containsKey(pkg.packageName) &amp;&amp; !pkg.packageName.equals(\"android\")) &#123; // This is a regular package, with one or more known overlay packages. createIdmapsForPackageLI(pkg); &#125; &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); if (createIdmapFailed) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"scanPackageLI failed to createIdmap\"); &#125; return pkg;&#125; 到这里，对于扫描的 package 的数据就处理完了！ 3.2.1.7.1.1 Settings.getPackageLPw上面又再次调用了 getPackageLPw 方法，注意根据参数传递： boolean add：传入的值为 false！ boolean allowInstall：传入的值为 true； 该方法传入的参数的是本次扫描解析获得的 apk 的数据！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210// 最终进入这个方法！private PackageSetting getPackageLPw(String name, PackageSetting origPackage, String realName, SharedUserSetting sharedUser, File codePath, File resourcePath, String legacyNativeLibraryPathString, String primaryCpuAbiString, String secondaryCpuAbiString, int vc, int pkgFlags, int pkgPrivateFlags, UserHandle installUser, boolean add, boolean allowInstall, String parentPackage, List&lt;String&gt; childPackageNames) &#123; //【1】尝试获得之前的安装数据！ PackageSetting p = mPackages.get(name); UserManagerService userManager = UserManagerService.getInstance(); //【2】如果 p 不为 null，说明这个 apk 之前就存在！ // 下面就要比较 codePath！ if (p != null) &#123; p.primaryCpuAbiString = primaryCpuAbiString; p.secondaryCpuAbiString = secondaryCpuAbiString; if (childPackageNames != null) &#123; p.childPackageNames = new ArrayList&lt;&gt;(childPackageNames); &#125; if (!p.codePath.equals(codePath)) &#123; if ((p.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; // 这是被更新的 system app 的情况，此时在 system 分区和 app 分区都会有该 apk，我们只需要 // 将高 versionCode 的 apk 显示出来即可！ Slog.w(PackageManagerService.TAG, \"Trying to update system app code path from \" + p.codePathString + \" to \" + codePath.toString()); &#125; else &#123; // 这种情况是说明这个 system apk 的路径发生了变化！ // 或者说这个应用是一个三方应用！ Slog.i(PackageManagerService.TAG, \"Package \" + name + \" codePath changed from \" + p.codePath + \" to \" + codePath + \"; Retaining data and using new\"); // 如果当前扫描的是 system apk，并且其不是被覆盖安装的，即 getDisabledSystemPkgLPr 为 null； // 更新所有用户下的安装状态为 true！ if ((pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) != 0 &amp;&amp; getDisabledSystemPkgLPr(name) == null) &#123; List&lt;UserInfo&gt; allUserInfos = getAllUsers(); if (allUserInfos != null) &#123; for (UserInfo userInfo : allUserInfos) &#123; p.setInstalled(true, userInfo.id); &#125; &#125; &#125; p.legacyNativeLibraryPathString = legacyNativeLibraryPathString; &#125; &#125; if (p.sharedUser != sharedUser) &#123; // 如果共享 uid 不匹配，就需要创建新的 PackageSetting 替换以前的！ PackageManagerService.reportSettingsProblem(Log.WARN, \"Package \" + name + \" shared user changed from \" + (p.sharedUser != null ? p.sharedUser.name : \"&lt;nothing&gt;\") + \" to \" + (sharedUser != null ? sharedUser.name : \"&lt;nothing&gt;\") + \"; replacing with new\"); p = null; &#125; else &#123; // 如果共享 uid 匹配，或者没有使用共享，进入这里！ // 如果我们扫描的是一个 system 分区的 apk, 无论其之前是否在 data 分区存在！ // 我们都会给上一次的安装信息设置 FLAG_SYSTEM 和 PRIVATE_FLAG_PRIVILEGED 标志位； // 这里和【3.2.1】【B】有关联 p.pkgFlags |= pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM; p.pkgPrivateFlags |= pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; &#125; //【3】处理需要重新创建 PackageSetting 的情况！ // 如果 p 为 null，说明这个系统 apk 是通过 OTA 升级方式新添加的，或者 shareUserId 不匹配！ // 如果有源包，就用源包的命名，创建新的 PackageSetting 对象，并源包的数据来初始化！ // 没有源包，就用当前包的命名，创建新的 PackageSetting 对象！ if (p == null) &#123; if (origPackage != null) &#123; //【3.1】源包不为 null 的情况，进入这里，使用本次扫描的信息创建新的 PackageSetting！ p = new PackageSetting(origPackage.name, name, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags, parentPackage, childPackageNames); if (PackageManagerService.DEBUG_UPGRADE) Log.v(PackageManagerService.TAG, \"Package \" + name + \" is adopting original package \" + origPackage.name); PackageSignatures s = p.signatures; p.copyFrom(origPackage); p.signatures = s; p.sharedUser = origPackage.sharedUser; p.appId = origPackage.appId; p.origPackage = origPackage; p.getPermissionsState().copyFrom(origPackage.getPermissionsState()); // 重命名为源包的名字后，将新旧名字加入 mRenamedPackages 集合！ mRenamedPackages.put(name, origPackage.name); name = origPackage.name; p.setTimeStamp(codePath.lastModified()); &#125; else &#123; //【3.2】源包为 null 的情况，进入这里，使用本次扫描的信息创建新的 PackageSetting！ p = new PackageSetting(name, realName, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags, parentPackage, childPackageNames); p.setTimeStamp(codePath.lastModified()); p.sharedUser = sharedUser; // 系统 apk 不会进入这个分支！ if ((pkgFlags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; if (DEBUG_STOPPED) &#123; RuntimeException e = new RuntimeException(\"here\"); e.fillInStackTrace(); Slog.i(PackageManagerService.TAG, \"Stopping package \" + name, e); &#125; List&lt;UserInfo&gt; users = getAllUsers(); final int installUserId = installUser != null ? installUser.getIdentifier() : 0; if (users != null &amp;&amp; allowInstall) &#123; for (UserInfo user : users) &#123; final boolean installed = installUser == null || (installUserId == UserHandle.USER_ALL &amp;&amp; !isAdbInstallDisallowed(userManager, user.id)) || installUserId == user.id; p.setUserState(user.id, 0, COMPONENT_ENABLED_STATE_DEFAULT, installed, true, // stopped, true, // notLaunched false, // hidden false, // suspended null, null, null, false, // blockUninstall INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0); writePackageRestrictionsLPr(user.id); &#125; &#125; &#125; // 设置系统 package 的 appid // 如果是共享用户 id，那 appId 就是共享用户 id； // 如果不是共享用户 id，就看系统 app 是否被覆盖更新过，如果有，就克隆更新前的旧数据，初始化 appId，权限等等 // 如果系统 app 没有被覆盖更新过，就创建新的 uid！ if (sharedUser != null) &#123; p.appId = sharedUser.userId; &#125; else &#123; PackageSetting dis = mDisabledSysPackages.get(name); if (dis != null) &#123; if (dis.signatures.mSignatures != null) &#123; p.signatures.mSignatures = dis.signatures.mSignatures.clone(); &#125; p.appId = dis.appId; p.getPermissionsState().copyFrom(dis.getPermissionsState()); List&lt;UserInfo&gt; users = getAllUsers(); if (users != null) &#123; for (UserInfo user : users) &#123; int userId = user.id; p.setDisabledComponentsCopy( dis.getDisabledComponents(userId), userId); p.setEnabledComponentsCopy( dis.getEnabledComponents(userId), userId); &#125; &#125; // 将这个新的 PackageSetting 根据 uid 添加到 mUserIds 或者 mOtherUserIds 中！ addUserIdLPw(p.appId, p, name); &#125; else &#123; // 分配一个新的 uid，并将映射关系保存到 mUserIds 中！ p.appId = newUserIdLPw(p); &#125; &#125; &#125; if (p.appId &lt; 0) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Package \" + name + \" could not be assigned a valid uid\"); return null; &#125; if (add) &#123; // add 为 false，这里不添加，添加的操作在 PMS.scanPackageDirtyLI 方法中！ addPackageSettingLPw(p, name, sharedUser); &#125; &#125; else &#123; if (installUser != null &amp;&amp; allowInstall) &#123; // The caller has explicitly specified the user they want this // package installed for, and the package already exists. // Make sure it conforms to the new request. List&lt;UserInfo&gt; users = getAllUsers(); if (users != null) &#123; for (UserInfo user : users) &#123; if ((installUser.getIdentifier() == UserHandle.USER_ALL &amp;&amp; !isAdbInstallDisallowed(userManager, user.id)) || installUser.getIdentifier() == user.id) &#123; boolean installed = p.getInstalled(user.id); if (!installed) &#123; p.setInstalled(true, user.id); writePackageRestrictionsLPr(user.id); &#125; &#125; &#125; &#125; &#125; &#125; //【4】返回查到或者是创建的新的系统 package 对应的 PackageSetting 对象！ return p;&#125; 3.2.1.7.1.2 Settings.insertPackageSettingLPw该方法会将 PackageSetting 保存到 mUserIds 或 mOtherIds 中去，同时用本次扫描的的 Package 更新 PackageSetting！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void insertPackageSettingLPw(PackageSetting p, PackageParser.Package pkg) &#123; p.pkg = pkg; //【1】建立引用关系！ // pkg.mSetEnabled = p.getEnabled(userId); // pkg.mSetStopped = p.getStopped(userId); final String volumeUuid = pkg.applicationInfo.volumeUuid; final String codePath = pkg.applicationInfo.getCodePath(); final String resourcePath = pkg.applicationInfo.getResourcePath(); final String legacyNativeLibraryPath = pkg.applicationInfo.nativeLibraryRootDir; // Update volume if needed if (!Objects.equals(volumeUuid, p.volumeUuid)) &#123; Slog.w(PackageManagerService.TAG, \"Volume for \" + p.pkg.packageName + \" changing from \" + p.volumeUuid + \" to \" + volumeUuid); p.volumeUuid = volumeUuid; &#125; // Update code path if needed if (!Objects.equals(codePath, p.codePathString)) &#123; Slog.w(PackageManagerService.TAG, \"Code path for \" + p.pkg.packageName + \" changing from \" + p.codePathString + \" to \" + codePath); p.codePath = new File(codePath); p.codePathString = codePath; &#125; //Update resource path if needed if (!Objects.equals(resourcePath, p.resourcePathString)) &#123; Slog.w(PackageManagerService.TAG, \"Resource path for \" + p.pkg.packageName + \" changing from \" + p.resourcePathString + \" to \" + resourcePath); p.resourcePath = new File(resourcePath); p.resourcePathString = resourcePath; &#125; // Update the native library paths if needed if (!Objects.equals(legacyNativeLibraryPath, p.legacyNativeLibraryPathString)) &#123; p.legacyNativeLibraryPathString = legacyNativeLibraryPath; &#125; // Update the required Cpu Abi p.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi; p.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi; p.cpuAbiOverrideString = pkg.cpuAbiOverride; // Update version code if needed if (pkg.mVersionCode != p.versionCode) &#123; p.versionCode = pkg.mVersionCode; &#125; // Update signatures if needed. if (p.signatures.mSignatures == null) &#123; p.signatures.assignSignatures(pkg.mSignatures); &#125; // Update flags if needed. if (pkg.applicationInfo.flags != p.pkgFlags) &#123; p.pkgFlags = pkg.applicationInfo.flags; &#125; // If this app defines a shared user id initialize // the shared user signatures as well. if (p.sharedUser != null &amp;&amp; p.sharedUser.signatures.mSignatures == null) &#123; p.sharedUser.signatures.assignSignatures(pkg.mSignatures); &#125; //【2】将 PackageSetting 保存到 mUserIds 或则会 mOtherIds 中去 addPackageSettingLPw(p, pkg.packageName, p.sharedUser);&#125; 这里就不多说了！ ######3.2.1.7.1.3 ActivityIntentResolver.addActivity - 添加 activity 3.2.1.8 Settings.disableSystemPackageLPw当需要隐藏掉 system app 的时候，会调用 disableSystemPackageLPw 方法： 参数传递： boolean replaced：true！ 123456789101112131415161718192021222324252627282930boolean disableSystemPackageLPw(String name, boolean replaced) &#123; // 判断一下，这个系统 apk 是否已经安装，没有安装就不用 disable！ final PackageSetting p = mPackages.get(name); if(p == null) &#123; Log.w(PackageManagerService.TAG, \"Package \" + name + \" is not an installed package\"); return false; &#125; // 系统 apk 已经安装了，并且之前没有被覆盖更新过， // 且之前没有添加 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标签！ final PackageSetting dp = mDisabledSysPackages.get(name); if (dp == null &amp;&amp; p.pkg != null &amp;&amp; p.pkg.isSystemApp() &amp;&amp; !p.pkg.isUpdatedSystemApp()) &#123; if((p.pkg != null) &amp;&amp; (p.pkg.applicationInfo != null)) &#123; p.pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; // 将其添加到 mDisabledSysPackages 列表中！ mDisabledSysPackages.put(name, p); if (replaced) &#123; // 这里为 true //【3.2.1.8.1】为更新的后的应用重新创建一个 PackageSetting，添加到 mPackages 中 // 因为旧的 PackageSetting 被添加到了 mDisabledSysPackages！ PackageSetting newp = new PackageSetting(p); replacePackageLPw(name, newp); &#125; return true; &#125; return false;&#125; 这里面会设置到 pkgFlags 和 pkgPrivateFlags 的设置：123456789101112void setFlags(int pkgFlags) &#123; this.pkgFlags = pkgFlags &amp; (ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_EXTERNAL_STORAGE);&#125;void setPrivateFlags(int pkgPrivateFlags) &#123; this.pkgPrivateFlags = pkgPrivateFlags &amp; (ApplicationInfo.PRIVATE_FLAG_PRIVILEGED | ApplicationInfo.PRIVATE_FLAG_FORWARD_LOCK | ApplicationInfo.PRIVATE_FLAG_REQUIRED_FOR_SYSTEM_USER);&#125; 到这里 system 分区的扫描流程就结束了！ 3.2.1.8.1 Settings.replacePackageLPw123456789101112private void replacePackageLPw(String name, PackageSetting newp) &#123; final PackageSetting p = mPackages.get(name); if (p != null) &#123; if (p.sharedUser != null) &#123; p.sharedUser.removePackage(p); p.sharedUser.addPackage(newp); &#125; else &#123; replaceUserIdLPw(p.appId, newp); &#125; &#125; mPackages.put(name, newp);&#125; 更新 mPackages 中的数据！ 3.2.1.8.1.1 Settings.replaceUserIdLPw123456789private void replaceUserIdLPw(int uid, Object obj) &#123; if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; final int N = mUserIds.size(); final int index = uid - Process.FIRST_APPLICATION_UID; if (index &lt; N) mUserIds.set(index, obj); &#125; else &#123; mOtherUserIds.put(uid, obj); &#125;&#125; 更新 mOtherUserIds 和 mUserIds 中的数据！ 3.3 扫描总结下面我们来总结下扫描过程： 3.3.1 扫描过程总结接下来，用一张图来总结一下，扫描的过程： 流程很清晰了，不多说。 3.3.2 数据关系总结下面我们来看看解析获得的数据之间的关系： 这个图展示了解析得到的一个 Package 对象在内存中的结果。 组件的基类是 Component，AndroidManifest.xml 中定义的组件 activity，service，provider，permission等，都继承了 Component； activity，service 这样的组件，都可以配置 属性，在 pms 中体现在 IntentInfo 这个数据结构中，从上图可以看到，每一种组件所依赖的 intentInfo 不同，Component 和 IntentInfo 之间的依赖关系采用了桥接模式，通过泛型实现！ 4 系统目录扫描 - 收尾阶段接下来，是收集可能被删掉的系统应用包！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//【×】用于收集可能已经被删掉的系统应用包！final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();if (!mOnlyCore) &#123; // 遍历上次安装的所有的 package！ Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); while (psit.hasNext()) &#123; PackageSetting ps = psit.next(); //【×】如果是非系统应用，跳过，如果是被覆盖安装！ if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; continue; &#125; final PackageParser.Package scannedPkg = mPackages.get(ps.name); if (scannedPkg != null) &#123; //【4.1】如果系统应用包不仅被扫描过（在mPackages中），并且在不可用列表中！ // 说明一定是通过覆盖安装的，移除之前扫描的结果，保证之前用户安装的应用能够被扫描！ if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; logCriticalInfo(Log.WARN, \"Expecting better updated system app for \" + ps.name + \"; removing system app. Last known codePath=\" + ps.codePathString + \", installStatus=\" + ps.installStatus + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\" + scannedPkg.mVersionCode); //【4.2】将之前的扫描结果移除！ removePackageLI(scannedPkg, true); // 将这包添加到 mExpectingBetter 列表中！ mExpectingBetter.put(ps.name, ps.codePath); &#125; // 跳出循环，确保不会被删掉！ continue; &#125; if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; // 如果系统应用包没有被扫描，并且他也不在不可用的列表中，说明其没有被更新过， // 可能被删除了，也可能被移动到了 data 分区，那就清楚其前面的数据！ // 如果移动到了 data 分区，那就在扫描 data 的过程中处理！ psit.remove(); logCriticalInfo(Log.WARN, \"System package \" + ps.name + \" no longer exists; it's data will be wiped\"); &#125; else &#123; // 如果系统应用包没有被扫描，却在不可用的列表中，说明其被更新过了，但是 apk 被删除了 // 就将他加入到 possiblyDeletedUpdatedSystemApps 集合中！ final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name); if (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123; possiblyDeletedUpdatedSystemApps.add(ps.name); &#125; &#125; &#125;&#125;//【×】清理所有安装不完全的应用包！ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();for (int i = 0; i &lt; deletePkgsList.size(); i++) &#123; final String packageName = deletePkgsList.get(i).name; logCriticalInfo(Log.WARN, \"Cleaning up incompletely installed app: \" + packageName); synchronized (mPackages) &#123; mSettings.removePackageLPw(packageName); &#125;&#125;// 移除临时文件deleteTempPackageFiles();// 移除没有和应用程序包相关联的共享用户 id！mSettings.pruneSharedUsersLPw(); 对于已经被扫描到的系统 app，如果发现他存在于被更新过的列表中，说明这个系统 apk 在 data 分区有更新的版本了，那就需要把之前扫描的清楚掉，这样我们要确保在扫描 data 分区时，data 分区的 app 能够显示出来！！ 4.1 PMS.isDisabledSystemPackageLPr123boolean isDisabledSystemPackageLPr(String name) &#123; return mDisabledSysPackages.containsKey(name);&#125; 4.2 PMS.removePackageLIremovePackageLI 会移除指定 pacakge 的扫描结果！ 1234567891011121314151617181920212223242526272829303132private void removePackageLI(PackageParser.Package pkg, boolean chatty) &#123; // Remove the parent package setting PackageSetting ps = (PackageSetting) pkg.mExtras; if (ps != null) &#123; removePackageLI(ps, chatty); &#125; // Remove the child package setting final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); ps = (PackageSetting) childPkg.mExtras; if (ps != null) &#123; removePackageLI(ps, chatty); &#125; &#125;&#125;void removePackageLI(PackageSetting ps, boolean chatty) &#123; if (DEBUG_INSTALL) &#123; if (chatty) Log.d(TAG, \"Removing package \" + ps.name); &#125; // writer synchronized (mPackages) &#123; mPackages.remove(ps.name); final PackageParser.Package pkg = ps.pkg; if (pkg != null) &#123; cleanPackageDataStructuresLILPw(pkg, chatty); &#125; &#125;&#125; 5 总结我们用一张流程图来总结一下系统 apk 的扫描解析处理过程： 需要隐藏的系统 apk 都会被添加到 mExpectingBetter 列表中：1、系统 apk 被覆盖安装过，且 system 分区的 versionCode 的是不高于 data 分区的；2、之前已经有一相同包名的 apk 安装在 data 分区中了，这次有同样的包名的 app 出现在了 system 分区， versionCode 不高于 data 分区的；","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 2 篇 - PMS_START 阶段","slug":"PMS2-PMS_START","date":"2018-01-25T16:00:00.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/01/26/PMS2-PMS_START/","link":"","permalink":"https://coolqi.top/2018/01/26/PMS2-PMS_START/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 PackageManagerService 的架构和逻辑实现，本文是作者原创，转载请说明出处！ 0 综述我们进入第一阶段来分析，代码比较长，我们先来个总体的阶段回顾： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis()); if (mSdkVersion &lt;= 0) &#123; // mSdkVersion 是 PKMS 的成员变量，定义的时候进行赋值， // 其值取自系统属性 ro.build.version.sdk，即编译的 SDK 版本。 Slog.w(TAG, \"**** ro.build.version.sdk not set!\"); &#125; mContext = context; // 系统进程的上下文实例！ mFactoryTest = factoryTest; // 默认为 false，即运行在非工厂模式下 mOnlyCore = onlyCore; // 默认为 false，标记是否是只加载核心服务 // 用于存储与显示屏相关的一些属性，例如屏幕的宽 / 高尺寸，分辨率等信息。 mMetrics = new DisplayMetrics(); //【1】在 Settings 中，创建 packages.xml、packages-backup.xml、packages.list 等文件对象 // 并添加 system, phone, log, nfc, bluetooth, shell 这六种 shareUserId 到 mSettings，后面扫描和安装有用！ mSettings = new Settings(mPackages); mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); String separateProcesses = SystemProperties.get(\"debug.separate_processes\"); if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123; if (\"*\".equals(separateProcesses)) &#123; mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES; mSeparateProcesses = null; Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\"); &#125; else &#123; mDefParseFlags = 0; mSeparateProcesses = separateProcesses.split(\",\"); Slog.w(TAG, \"Running with debug.separate_processes: \" + separateProcesses); &#125; &#125; else &#123; mDefParseFlags = 0; mSeparateProcesses = null; &#125; // 初始化 mInstaller 对象，installer 对象和 Native 进程 installd 交互，以后分析 installd 时再来讨论它的作用！ mInstaller = installer; //【2】创建 PackageDexOptimizer 对象，用于 dex 优化！ mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context, \"*dexopt*\"); //【3】创建 MoveCallbacks 对象，用于操作回滚！ mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper()); //【4】创建 OnPermissionChangeListeners 对象，用于监听权限改变！ mOnPermissionChangeListeners = new OnPermissionChangeListeners( FgThread.get().getLooper()); getDefaultDisplayMetrics(context, mMetrics); //【5】创建 SystemConfig 对象，用于获取系统配置信息 // 主要有 /system/etc/ 目录和 /system/etc/ 目录下的 sysconfig 和 permissions 文件夹中的 xml 文件 SystemConfig systemConfig = SystemConfig.getInstance(); mGlobalGids = systemConfig.getGlobalGids(); mSystemPermissions = systemConfig.getSystemPermissions(); mAvailableFeatures = systemConfig.getAvailableFeatures(); mProtectedPackages = new ProtectedPackages(mContext); synchronized (mInstallLock) &#123; // writer synchronized (mPackages) &#123; //【6】建立并启动一个名为 “PackageManager” 的 HandlerThread，类型是 ServiceThread，处理安装卸载的消息！ mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/); mHandlerThread.start(); //【7】创建一个 PackageHandler 对象，绑定前面创建的 HandlerThread！ mHandler = new PackageHandler(mHandlerThread.getLooper()); mProcessLoggingHandler = new ProcessLoggingHandler(); Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT); //【8】创建默认权限管理对象，用于给某些预制的 apk 给予权限，也可以撤销！ mDefaultPermissionPolicy = new DefaultPermissionGrantPolicy(this); // 创建需要扫描检测的目录文件对象，为扫描做准备！ File dataDir = Environment.getDataDirectory(); mAppInstallDir = new File(dataDir, \"app\"); // /data/data，存放应用程序的数据 mAppLib32InstallDir = new File(dataDir, \"app-lib\"); // /data/app-lib，用于存放用户自己安装的第三方应用程序 mEphemeralInstallDir = new File(dataDir, \"app-ephemeral\"); // /data/app-ephemeral mAsecInternalPath = new File(dataDir, \"app-asec\").getPath(); // /data/app-asec mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\"); // /data/app-private，存放私有应用程序！ //【9】创建用户管理服务！ sUserManager = new UserManagerService(context, this, mPackages); //【10】将前面 SystemConfig 获得的系统权限保存到 mSettings.mPermissions 中！ ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions(); for (int i=0; i&lt;permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123; bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125; &#125; //【11】处理共享库！ ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries(); for (int i=0; i&lt;libConfig.size(); i++) &#123; mSharedLibraries.put(libConfig.keyAt(i), new SharedLibraryEntry(libConfig.valueAt(i), null)); &#125; //【12】从 /etc/security/mac_permissions.xml 读取 SELinux 信息！ mFoundPolicyFile = SELinuxMMAC.readInstallPolicy(); //【13】解析 packages.xml 文件，获得上一次的安装信息。返回值表示是否是第一次开机！ // 如果是第一次开机，那么是读不到上次的数据的！ mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false)); //【14】如果应用是被更新过的系统应用，且位于 data 分区的 apk 文件不存在了 // 那就移除上一次的 data 分区的安装信息，恢复为 system 分区的安装信息！ // 这里貌似是为了解决一个 bug:32321269! final int packageSettingCount = mSettings.mPackages.size(); for (int i = packageSettingCount - 1; i &gt;= 0; i--) &#123; PackageSetting ps = mSettings.mPackages.valueAt(i); if (!isExternal(ps) &amp;&amp; (ps.codePath == null || !ps.codePath.exists()) &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != null) &#123; mSettings.mPackages.removeAt(i); mSettings.enableSystemPackageLPw(ps.name); &#125; &#125; if (mFirstBoot) &#123; //【15】如果是第一次开机，从另外一个系统拷贝 odex 文件到当前系统的 data 分区 // Android 7.1 引进了 AB 升级，这个是 AB 升级的特性，可以先不看！ requestCopyPreoptedFiles(); &#125; String customResolverActivity = Resources.getSystem().getString( R.string.config_customResolverActivity); if (TextUtils.isEmpty(customResolverActivity)) &#123; customResolverActivity = null; &#125; else &#123; mCustomResolverComponentName = ComponentName.unflattenFromString( customResolverActivity); &#125; ... ... ... ...// 见，第二阶段 下面我们来逐一分析这个阶段的过程： 1 Settings首先，创建了 Settings 对象：！ 参数传递： Object lock：mPackage 对象！ 1234Settings(Object lock) &#123; // 调用第二个构造器！ this(Environment.getDataDirectory(), lock);&#125; 接着调用第二个构造函数：1234567891011121314151617181920212223242526272829Settings(File dataDir, Object lock) &#123; mLock = lock; // 用于处理运行时权限相关的操作！ mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock); // 创建 /data/system 目录，并设置该目录的权限！ mSystemDir = new File(dataDir, \"system\"); mSystemDir.mkdirs(); FileUtils.setPermissions(mSystemDir.toString(), FileUtils.S_IRWXU|FileUtils.S_IRWXG |FileUtils.S_IROTH|FileUtils.S_IXOTH, -1, -1); // 创建 packages.xml 和 packages-backup.xml 文件对象 mSettingsFilename = new File(mSystemDir, \"packages.xml\"); mBackupSettingsFilename = new File(mSystemDir, \"packages-backup.xml\"); // 创建 packages.list 文件对象，并设置权限信息！ mPackageListFilename = new File(mSystemDir, \"packages.list\"); FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID); // 创建 sdcardfs 文件对象！ final File kernelDir = new File(\"/config/sdcardfs\"); mKernelMappingFilename = kernelDir.exists() ? kernelDir : null; // 创建 packages-stopped.xml 和 packages-stopped-backup.xml 文件对象！ mStoppedPackagesFilename = new File(mSystemDir, \"packages-stopped.xml\"); mBackupStoppedPackagesFilename = new File(mSystemDir, \"packages-stopped-backup.xml\");&#125; Settings 对象的构造器很简单，这里要重点说明一下； packages.xml 和 packages-backup.xml 文件是一组，用于描述系统中所安装的所有 Package 信息，PMS 会先把数据写入 packages-backup.xml，信息写成功后，再改名为 packages.xml ！ packages.list 文件同样保存了系统中所有的应用的信息！ packages-stopped.xml 和 packages-stopped-backup.xml 文件是一组，用于描述被强行停止运行的 package 信息！ 1com.android.settings 1000 0 /data/user_de/0/com.android.settings platform:privapp 2001,3009,3002,1023,1015,3003,3001,1004,2002,1007,3006,3188 1.1 new RuntimePermissionPersistence创建运行时权限管理对象！ 1.2 Settings.addSharedUserLPw接着调用了 addSharedUserLPw 方法，添加了几个系统共享用户，参数传递： String name：共享用户名，下面是传入的用户名： android.uid.system android.uid.phone android.uid.log android.uid.nfc android.uid.bluetooth android.uid.shell int uid：共享用户 id，下面的用户名和上面的 id 一一对应！ Process.SYSTEM_UID RADIO_UID LOG_UID NFC_UID BLUETOOTH_UID SHELL_UID int pkgFlags： ApplicationInfo.FLAG_SYSTEM int pkgPrivateFlags： ApplicationInfo.PRIVATE_FLAG_PRIVILEGED 1234567891011121314151617181920212223SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) &#123; SharedUserSetting s = mSharedUsers.get(name); if (s != null) &#123; if (s.userId == uid) &#123; return s; &#125; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate shared user, keeping first: \" + name); return null; &#125; //【1.1.1】创建 SharedUserSetting 对象，封装 SharedUserId！ s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags); s.userId = uid; //【1.1.2】根据 uid 的范围，保存到到 mUserIds 或 mOtherUserIds 中！ if (addUserIdLPw(uid, s, name)) &#123; //【1.1.2.1】添加到 mSharedUsers 中！ mSharedUsers.put(name, s); return s; &#125; return null;&#125; 1.2.1 SharedUserSetting我们来看看 SharedUserSetting 这个对象： 1234567891011121314151617181920212223242526272829final class SharedUserSetting extends SettingBase &#123; // 共享 uid 的名称 final String name; // uid 值 int userId; // 和这个 sharedUserId 相关的 flags int uidFlags; // 取值为 ApplicationInfo.FLAG_SYSTEM int uidPrivateFlags; // 取值为 ApplicationInfo.FLAG_SYSTEM // 使用这个共享 uid 的所有应用程序 package！ final ArraySet&lt;PackageSetting&gt; packages = new ArraySet&lt;PackageSetting&gt;(); final PackageSignatures signatures = new PackageSignatures(); SharedUserSetting(String _name, int _pkgFlags, int _pkgPrivateFlags) &#123; super(_pkgFlags, _pkgPrivateFlags); uidFlags = _pkgFlags; uidPrivateFlags = _pkgPrivateFlags; name = _name; &#125; @Override public String toString() &#123; return \"SharedUserSetting&#123;\" + Integer.toHexString(System.identityHashCode(this)) + \" \" + name + \"/\" + userId + \"&#125;\"; &#125; ... ... ...&#125; 代码很简单，这里就不多说了！ 1.2.2 Settings.addUserIdLPwaddUserIdLPw 用于将创建的 sharedUserId 对象根据其 uid 是系统 uid 还是非系统 uid ，添加到指定的集合中！ 12345678910111213141516171819202122232425262728293031323334private boolean addUserIdLPw(int uid, Object obj, Object name) &#123; // uid 不能超过限制！ if (uid &gt; Process.LAST_APPLICATION_UID) &#123; return false; &#125; //【1】如果 uid 属于非系统应用，将其加入到 mUserIds 集合中！ if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; int N = mUserIds.size(); final int index = uid - Process.FIRST_APPLICATION_UID; while (index &gt;= N) &#123; mUserIds.add(null); N++; &#125; if (mUserIds.get(index) != null) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate user id: \" + uid + \" name=\" + name); return false; &#125; mUserIds.set(index, obj); &#125; else &#123; //【2】如果 uid 属于系统应用，将其加入到 mOtherUserIds 集合中！ if (mOtherUserIds.get(uid) != null) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate shared id: \" + uid + \" name=\" + name); return false; &#125; mOtherUserIds.put(uid, obj); &#125; return true;&#125; 这里来说明一下： 涉及的常量 Process.FIRST_APPLICATION_UID：取值 10000，用来区分系统应用 uid 和非系统应用的 uid。非系统应用的 uid 大于等于 10000，小于等于 19999，系统应用的 uid 小于 10000； Process.LAST_APPLICATION_UID：取值 19999，表示应用程序的 uid 最大为 19999！ 总结 mSharedUsers 集合用来保存所有的共享用户id！ mUserIds 集合中会保存非系统应用的 uid，包括共享和非共享！ mOtherUserIds 集合中会保存系统应用的 uid，包括共享和非共享！ 2 PackageDexOptimizerPackageDexOptimizer 用于进行 odex 优化，我们来先简单的看看代码，参数传递： Installer installer：installer 对象，用于安装程序； Object installLock：Object() 锁对象！ Context context：系统进程上下文实例！ String wakeLockTag：传入”dexopt“ 123456789101112131415161718192021222324252627282930313233class PackageDexOptimizer &#123; private static final String TAG = \"PackageManager.DexOptimizer\"; static final String OAT_DIR_NAME = \"oat\"; // TODO b/19550105 Remove error codes and use exceptions static final int DEX_OPT_SKIPPED = 0; static final int DEX_OPT_PERFORMED = 1; static final int DEX_OPT_FAILED = -1; private final Installer mInstaller; private final Object mInstallLock; private final PowerManager.WakeLock mDexoptWakeLock; private volatile boolean mSystemReady; // 调用的这个构造器！ PackageDexOptimizer(Installer installer, Object installLock, Context context, String wakeLockTag) &#123; this.mInstaller = installer; this.mInstallLock = installLock; PowerManager powerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE); mDexoptWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, wakeLockTag); &#125; protected PackageDexOptimizer(PackageDexOptimizer from) &#123; this.mInstaller = from.mInstaller; this.mInstallLock = from.mInstallLock; this.mDexoptWakeLock = from.mDexoptWakeLock; this.mSystemReady = from.mSystemReady; &#125; ... ... ... ...&#125; 这里创建了 PackageDexOptimizer 对象，后续执行 odex 优化会用到！ 3 MoveCallbacks用于监听 package 的 move 操作！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private static class MoveCallbacks extends Handler &#123; private static final int MSG_CREATED = 1; private static final int MSG_STATUS_CHANGED = 2; private final RemoteCallbackList&lt;IPackageMoveObserver&gt; mCallbacks = new RemoteCallbackList&lt;&gt;(); private final SparseIntArray mLastStatus = new SparseIntArray(); public MoveCallbacks(Looper looper) &#123; super(looper); &#125; public void register(IPackageMoveObserver callback) &#123; mCallbacks.register(callback); &#125; public void unregister(IPackageMoveObserver callback) &#123; mCallbacks.unregister(callback); &#125; @Override public void handleMessage(Message msg) &#123; final SomeArgs args = (SomeArgs) msg.obj; final int n = mCallbacks.beginBroadcast(); for (int i = 0; i &lt; n; i++) &#123; final IPackageMoveObserver callback = mCallbacks.getBroadcastItem(i); try &#123; invokeCallback(callback, msg.what, args); &#125; catch (RemoteException ignored) &#123; &#125; &#125; mCallbacks.finishBroadcast(); args.recycle(); &#125; private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException &#123; switch (what) &#123; case MSG_CREATED: &#123; callback.onCreated(args.argi1, (Bundle) args.arg2); break; &#125; case MSG_STATUS_CHANGED: &#123; callback.onStatusChanged(args.argi1, args.argi2, (long) args.arg3); break; &#125; &#125; &#125; private void notifyCreated(int moveId, Bundle extras) &#123; Slog.v(TAG, \"Move \" + moveId + \" created \" + extras.toString()); final SomeArgs args = SomeArgs.obtain(); args.argi1 = moveId; args.arg2 = extras; obtainMessage(MSG_CREATED, args).sendToTarget(); &#125; private void notifyStatusChanged(int moveId, int status) &#123; notifyStatusChanged(moveId, status, -1); &#125; private void notifyStatusChanged(int moveId, int status, long estMillis) &#123; Slog.v(TAG, \"Move \" + moveId + \" status \" + status); final SomeArgs args = SomeArgs.obtain(); args.argi1 = moveId; args.argi2 = status; args.arg3 = estMillis; obtainMessage(MSG_STATUS_CHANGED, args).sendToTarget(); synchronized (mLastStatus) &#123; mLastStatus.put(moveId, status); &#125; &#125;&#125; 4 OnPermissionChangeListeners创建 OnPermissionChangeListeners 对象！123// 创建 OnPermissionChangeListeners 对象，用于监听权限改变！mOnPermissionChangeListeners = new OnPermissionChangeListeners( FgThread.get().getLooper()); OnPermissionChangeListeners 用于监听权限的改变： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private final static class OnPermissionChangeListeners extends Handler &#123; private static final int MSG_ON_PERMISSIONS_CHANGED = 1; private final RemoteCallbackList&lt;IOnPermissionsChangeListener&gt; mPermissionListeners = new RemoteCallbackList&lt;&gt;(); public OnPermissionChangeListeners(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //【2】处理 MSG_ON_PERMISSIONS_CHANGED 消息！ case MSG_ON_PERMISSIONS_CHANGED: &#123; final int uid = msg.arg1; handleOnPermissionsChanged(uid); &#125; break; &#125; &#125; // 添加权限改变监听器！ public void addListenerLocked(IOnPermissionsChangeListener listener) &#123; mPermissionListeners.register(listener); &#125; // 移除权限改变监听器！ public void removeListenerLocked(IOnPermissionsChangeListener listener) &#123; mPermissionListeners.unregister(listener); &#125; public void onPermissionsChanged(int uid) &#123; //【1】uid 的权限改变后，会触发这个方法，发送 MSG_ON_PERMISSIONS_CHANGED 消息！ if (mPermissionListeners.getRegisteredCallbackCount() &gt; 0) &#123; obtainMessage(MSG_ON_PERMISSIONS_CHANGED, uid, 0).sendToTarget(); &#125; &#125; //【3】uid 对应的应用程序的权限发生了变化！ private void handleOnPermissionsChanged(int uid) &#123; final int count = mPermissionListeners.beginBroadcast(); try &#123; for (int i = 0; i &lt; count; i++) &#123; IOnPermissionsChangeListener callback = mPermissionListeners .getBroadcastItem(i); try &#123; callback.onPermissionsChanged(uid); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"Permission listener is dead\", e); &#125; &#125; &#125; finally &#123; mPermissionListeners.finishBroadcast(); &#125; &#125;&#125; 当指定 uid 的权限发生变化后，会调用 IOnPermissionsChangeListener 的 onPermissionsChanged 方法，通过 Binder 机制，最终会调用 ApplicationPackageManager 的 OnPermissionsChangeListenerDelegate 中的 onPermissionsChanged 方法！1234567891011121314151617181920212223242526272829303132public class OnPermissionsChangeListenerDelegate extends IOnPermissionsChangeListener.Stub implements Handler.Callback&#123; private static final int MSG_PERMISSIONS_CHANGED = 1; private final OnPermissionsChangedListener mListener; private final Handler mHandler; public OnPermissionsChangeListenerDelegate(OnPermissionsChangedListener listener, Looper looper) &#123; mListener = listener; mHandler = new Handler(looper, this); &#125; @Override public void onPermissionsChanged(int uid) &#123; mHandler.obtainMessage(MSG_PERMISSIONS_CHANGED, uid, 0).sendToTarget(); &#125; @Override public boolean handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_PERMISSIONS_CHANGED: &#123; final int uid = msg.arg1; // 最后调用 OnPermissionsChangedListener 的 onPermissionsChanged 方法！ mListener.onPermissionsChanged(uid); return true; &#125; &#125; return false; &#125;&#125; OnPermissionsChangedListener 是一个接口，定义在 PackageManager 中：123456789@SystemApipublic interface OnPermissionsChangedListener &#123; /** * Called when the permissions for a UID change. * @param uid The UID with a change. */ public void onPermissionsChanged(int uid);&#125; 具体的实现是在 LocationManagerService 中：123456789101112131415161718192021public void systemRunning() &#123; synchronized (mLock) &#123; if (D) Log.d(TAG, \"systemRunning()\"); ... ... ... ... // 这里创建了一个 OnPermissionsChangedListener 对象，并添加到 PackageManagerervice 中！ PackageManager.OnPermissionsChangedListener permissionListener = new PackageManager.OnPermissionsChangedListener() &#123; @Override public void onPermissionsChanged(final int uid) &#123; synchronized (mLock) &#123; applyAllProviderRequirementsLocked(); &#125; &#125; &#125;; mPackageManager.addOnPermissionsChangeListener(permissionListener); ... ... ... &#125; 进入 PackageManagerService 中：123456789101112@Overridepublic void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) &#123; mContext.enforceCallingOrSelfPermission( Manifest.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS, \"addOnPermissionsChangeListener\"); synchronized (mPackages) &#123; // 添加到 mOnPermissionChangeListeners 内部的集合中！ mOnPermissionChangeListeners.addListenerLocked(listener); &#125;&#125; 这里先看到这里吧！ 5 SystemConfigSystemConfig 是用来存储系统全局的配置信息的数据结构，有系统配置信息，权限信息，Gid 等等！123456789// 单例模式！public static SystemConfig getInstance() &#123; synchronized (SystemConfig.class) &#123; if (sInstance == null) &#123; sInstance = new SystemConfig(); &#125; return sInstance; &#125;&#125; 下面我们来看看 SystemConfig 构造器中的相关方法：1234567891011121314151617181920212223// 其构造器会调用方法读取系统配置信息！SystemConfig() &#123; // 读取配置信息：/etc/sysconfig readPermissions(Environment.buildPath( Environment.getRootDirectory(), \"etc\", \"sysconfig\"), ALLOW_ALL); // 读取配置信息：/etc/permissions readPermissions(Environment.buildPath( Environment.getRootDirectory(), \"etc\", \"permissions\"), ALLOW_ALL); // 读取配置信息：/odm/etc/sysconfig，/odm/etc/permissions int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS; readPermissions(Environment.buildPath( Environment.getOdmDirectory(), \"etc\", \"sysconfig\"), odmPermissionFlag); readPermissions(Environment.buildPath( Environment.getOdmDirectory(), \"etc\", \"permissions\"), odmPermissionFlag); // 读取配置信息：/oem/etc/sysconfig，/oem/etc/permissions readPermissions(Environment.buildPath( Environment.getOemDirectory(), \"etc\", \"sysconfig\"), ALLOW_FEATURES); readPermissions(Environment.buildPath( Environment.getOemDirectory(), \"etc\", \"permissions\"), ALLOW_FEATURES);&#125; 第一个参数，表示可以访问的目录，这些目录包括： /etc/sysconfig：ALLOW_ALL /etc/permissions：ALLOW_ALL /odm/etc/sysconfig：ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS /odm/etc/permissions：ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS /oem/etc/sysconfig：ALLOW_FEATURES /oem/etc/permissions：ALLOW_FEATURES 第二个参数，表示这个目录可以设置的配置信息的类型，同样的，PMS 在解析时，也只会解析和读取参数指定的配置属性： oem：只能设置 features！ odm：只能设置 libs，features 和 app configs！ /system/etc/sysconfig，/system/etc/permissions：可以设置所有的配置，libs，permissions，features，app configs 等等！ 下面是 flag 的取值：12345private static final int ALLOW_FEATURES = 0x01;private static final int ALLOW_LIBS = 0x02;private static final int ALLOW_PERMISSIONS = 0x04;private static final int ALLOW_APP_CONFIGS = 0x08;private static final int ALLOW_ALL = ~0; 继续看！ 2.1 SystemConfig.readPermissions我们来看看读取的过程：12345678910111213141516171819202122232425262728293031323334353637383940void readPermissions(File libraryDir, int permissionFlag) &#123; // 校验目录可读性！ if (!libraryDir.exists() || !libraryDir.isDirectory()) &#123; if (permissionFlag == ALLOW_ALL) &#123; Slog.w(TAG, \"No directory \" + libraryDir + \", skipping\"); &#125; return; &#125; if (!libraryDir.canRead()) &#123; Slog.w(TAG, \"Directory \" + libraryDir + \" cannot be read\"); return; &#125; // 遍历解析目录下的所有 .xml 文件！ File platformFile = null; for (File f : libraryDir.listFiles()) &#123; //【1】对于 etc/permissions/platform.xml 文件，最后再处理！ if (f.getPath().endsWith(\"etc/permissions/platform.xml\")) &#123; platformFile = f; continue; &#125; if (!f.getPath().endsWith(\".xml\")) &#123; Slog.i(TAG, \"Non-xml file \" + f + \" in \" + libraryDir + \" directory, ignoring\"); continue; &#125; if (!f.canRead()) &#123; Slog.w(TAG, \"Permissions library file \" + f + \" cannot be read\"); continue; &#125; //【2】进一步解析文件！ readPermissionsFromXml(f, permissionFlag); &#125; //【3】读取和解析 platform.xml 文件！ if (platformFile != null) &#123; readPermissionsFromXml(platformFile, permissionFlag); &#125;&#125; 这个方法的主要过程是： 先解析该目录下的其他的 xml 文件； 最后解析 etc/permissions/platform.xml 文件（如果有）； 2.2 SystemConfig.readPermissionsFromXml继续调用 readPermissionsFromXml 方法，这里我们重点看一些 tag：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321private void readPermissionsFromXml(File permFile, int permissionFlag) &#123; FileReader permReader = null; try &#123; permReader = new FileReader(permFile); &#125; catch (FileNotFoundException e) &#123; Slog.w(TAG, \"Couldn't find or open permissions file \" + permFile); return; &#125; //【1】判读设备是否是低内存！ final boolean lowRam = ActivityManager.isLowRamDeviceStatic(); try &#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(permReader); int type; while ((type=parser.next()) != parser.START_TAG &amp;&amp; type != parser.END_DOCUMENT) &#123; ; &#125; if (type != parser.START_TAG) &#123; throw new XmlPullParserException(\"No start tag found\"); &#125; if (!parser.getName().equals(\"permissions\") &amp;&amp; !parser.getName().equals(\"config\")) &#123; throw new XmlPullParserException(\"Unexpected start tag in \" + permFile + \": found \" + parser.getName() + \", expected 'permissions' or 'config'\"); &#125; //【2】解析 Flag，指定二进制位为 1 ，即表示该条件满足，如果 flag 是 ALLOW_ALL， // 那么其他的条件均满足！ boolean allowAll = permissionFlag == ALLOW_ALL; boolean allowLibs = (permissionFlag &amp; ALLOW_LIBS) != 0; boolean allowFeatures = (permissionFlag &amp; ALLOW_FEATURES) != 0; boolean allowPermissions = (permissionFlag &amp; ALLOW_PERMISSIONS) != 0; boolean allowAppConfigs = (permissionFlag &amp; ALLOW_APP_CONFIGS) != 0; while (true) &#123; // 解析下一个标签！ XmlUtils.nextElement(parser); if (parser.getEventType() == XmlPullParser.END_DOCUMENT) &#123; break; &#125; String name = parser.getName(); if (\"group\".equals(name) &amp;&amp; allowAll) &#123; //【1】allowAll 为 true，解析 \"group\" 标签； // 解析系统中所有的 Gid 信息！ String gidStr = parser.getAttributeValue(null, \"gid\"); if (gidStr != null) &#123; int gid = android.os.Process.getGidForName(gidStr); mGlobalGids = appendInt(mGlobalGids, gid); &#125; else &#123; Slog.w(TAG, \"&lt;group&gt; without gid in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"permission\".equals(name) &amp;&amp; allowPermissions) &#123; //【2】allowPermissions 为 true，解析 \"permission\" 标签 // 解析系统中所有权限和其所属 gid 的信息！ String perm = parser.getAttributeValue(null, \"name\"); if (perm == null) &#123; Slog.w(TAG, \"&lt;permission&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; perm = perm.intern(); readPermission(parser, perm); // 调用 readPermission 继续解析权限 &#125; else if (\"assign-permission\".equals(name) &amp;&amp; allowPermissions) &#123; //【3】如果 allowPermissions 为 true，解析 \"assign-permission\" 标签 // 解析系统中 uid 和其所持有的权限的关系！ String perm = parser.getAttributeValue(null, \"name\"); // 权限名 if (perm == null) &#123; Slog.w(TAG, \"&lt;assign-permission&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; String uidStr = parser.getAttributeValue(null, \"uid\"); // 拥有该权限的 uid if (uidStr == null) &#123; Slog.w(TAG, \"&lt;assign-permission&gt; without uid in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; int uid = Process.getUidForName(uidStr); // 将 uid 转为 int 值！ if (uid &lt; 0) &#123; Slog.w(TAG, \"&lt;assign-permission&gt; with unknown uid \\\"\" + uidStr + \" in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; perm = perm.intern(); ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid); if (perms == null) &#123; perms = new ArraySet&lt;String&gt;(); mSystemPermissions.put(uid, perms); &#125; perms.add(perm); XmlUtils.skipCurrentTag(parser); &#125; else if (\"library\".equals(name) &amp;&amp; allowLibs) &#123; //【4】如果 allowLibs 为 true，解析 \"library\" 标签 // 获得系统中所有共享库的信息！ String lname = parser.getAttributeValue(null, \"name\"); String lfile = parser.getAttributeValue(null, \"file\"); if (lname == null) &#123; Slog.w(TAG, \"&lt;library&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else if (lfile == null) &#123; Slog.w(TAG, \"&lt;library&gt; without file in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; //Log.i(TAG, \"Got library \" + lname + \" in \" + lfile); mSharedLibraries.put(lname, lfile); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"feature\".equals(name) &amp;&amp; allowFeatures) &#123; //【5】如果 allowFeatures 为 true，解析 \"feature\" 标签 // 获得系统中所有可用特性的信息！ String fname = parser.getAttributeValue(null, \"name\"); int fversion = XmlUtils.readIntAttribute(parser, \"version\", 0); boolean allowed; if (!lowRam) &#123; allowed = true; &#125; else &#123; // 内存不足时，配置了 notLowRam 的 feature 不会在加载！ String notLowRam = parser.getAttributeValue(null, \"notLowRam\"); allowed = !\"true\".equals(notLowRam); &#125; if (fname == null) &#123; Slog.w(TAG, \"&lt;feature&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else if (allowed) &#123; // 将 feature 构造成 featureInfo，加入到 mAvailableFeatures 对象中！ addFeature(fname, fversion); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"unavailable-feature\".equals(name) &amp;&amp; allowFeatures) &#123; //【6】如果 allowFeatures 为 true，解析 \"unavailable-feature\" 标签 // 获得系统中所有不可用特性的信息！ String fname = parser.getAttributeValue(null, \"name\"); if (fname == null) &#123; Slog.w(TAG, \"&lt;unavailable-feature&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mUnavailableFeatures.add(fname); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"allow-in-power-save-except-idle\".equals(name) &amp;&amp; allowAll) &#123; //【7】解析 \"allow-in-power-save-except-idle\" 标签 // 用于获得系统中处于省电模式白名单，而没有在 idle 模式白名单中的应用信息！ // 这些应用可以在后台运行！ String pkgname = parser.getAttributeValue(null, \"package\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;allow-in-power-save-except-idle&gt; without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mAllowInPowerSaveExceptIdle.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"allow-in-power-save\".equals(name) &amp;&amp; allowAll) &#123; //【8】解析 \"allow-in-power-save\" 标签 // 获得哪些处于 doze 模式白名单中的应用信息！ String pkgname = parser.getAttributeValue(null, \"package\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;allow-in-power-save&gt; without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mAllowInPowerSave.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"allow-in-data-usage-save\".equals(name) &amp;&amp; allowAll) &#123; //【9】解析 \"allow-in-data-usage-save\" 标签， // 获得哪些处于流量节省模式白名单中的应用的信息，在白名单中的应用，当系统处于 // 流量节省模式时，可以在后台运行！ String pkgname = parser.getAttributeValue(null, \"package\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;allow-in-data-usage-save&gt; without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mAllowInDataUsageSave.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); continue; &#125; else if (\"app-link\".equals(name) &amp;&amp; allowAppConfigs) &#123; //【10】解析 \"app-link\" 标签 String pkgname = parser.getAttributeValue(null, \"package\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;app-link&gt; without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mLinkedApps.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (\"system-user-whitelisted-app\".equals(name) &amp;&amp; allowAppConfigs) &#123; //【11】解析 \"system-user-whitelisted-app\" 标签 // 获得哪些在 system user 下可以运行的应用信息！ String pkgname = parser.getAttributeValue(null, \"package\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;system-user-whitelisted-app&gt; without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mSystemUserWhitelistedApps.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (\"system-user-blacklisted-app\".equals(name) &amp;&amp; allowAppConfigs) &#123; //【12】解析 \"system-user-blacklisted-app\" 标签 // 获得哪些在 system user 下不可以运行的应用信息！ String pkgname = parser.getAttributeValue(null, \"package\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;system-user-blacklisted-app without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mSystemUserBlacklistedApps.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (\"default-enabled-vr-app\".equals(name) &amp;&amp; allowAppConfigs) &#123; //【13】解析 \"default-enabled-vr-app\" 标签 String pkgname = parser.getAttributeValue(null, \"package\"); String clsname = parser.getAttributeValue(null, \"class\"); if (pkgname == null) &#123; Slog.w(TAG, \"&lt;default-enabled-vr-app without package in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else if (clsname == null) &#123; Slog.w(TAG, \"&lt;default-enabled-vr-app without class in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mDefaultVrComponents.add(new ComponentName(pkgname, clsname)); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (\"backup-transport-whitelisted-service\".equals(name) &amp;&amp; allowFeatures) &#123; //【14】解析 \"backup-transport-whitelisted-service\" 标签 String serviceName = parser.getAttributeValue(null, \"service\"); if (serviceName == null) &#123; Slog.w(TAG, \"&lt;backup-transport-whitelisted-service&gt; without service in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; ComponentName cn = ComponentName.unflattenFromString(serviceName); if (cn == null) &#123; Slog.w(TAG, \"&lt;backup-transport-whitelisted-service&gt; with invalid service name \" + serviceName + \" in \"+ permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mBackupTransportWhitelist.add(cn); &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125; else if (\"disabled-until-used-preinstalled-carrier-associated-app\".equals(name) &amp;&amp; allowAppConfigs) &#123; //【15】解析 \"disabled-until-used-preinstalled-carrier-associated-app\" 标签 String pkgname = parser.getAttributeValue(null, \"package\"); String carrierPkgname = parser.getAttributeValue(null, \"carrierAppPackage\"); if (pkgname == null || carrierPkgname == null) &#123; Slog.w(TAG, \"&lt;disabled-until-used-preinstalled-carrier-associated-app\" + \" without package or carrierAppPackage in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; List&lt;String&gt; associatedPkgs = mDisabledUntilUsedPreinstalledCarrierAssociatedApps.get( carrierPkgname); if (associatedPkgs == null) &#123; associatedPkgs = new ArrayList&lt;&gt;(); mDisabledUntilUsedPreinstalledCarrierAssociatedApps.put( carrierPkgname, associatedPkgs); &#125; associatedPkgs.add(pkgname); &#125; XmlUtils.skipCurrentTag(parser); &#125; else &#123; XmlUtils.skipCurrentTag(parser); continue; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; Slog.w(TAG, \"Got exception parsing permissions.\", e); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Got exception parsing permissions.\", e); &#125; finally &#123; IoUtils.closeQuietly(permReader); &#125; // Some devices can be field-converted to FBE, so offer to splice in // those features if not already defined by the static config // 加密相关的 feature! if (StorageManager.isFileEncryptedNativeOnly()) &#123; addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION, 0); addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS, 0); &#125; // 从 mAvailableFeatures 移除不支持的 feature！ for (String featureName : mUnavailableFeatures) &#123; removeFeature(featureName); &#125;&#125; 这个方法的流程如下： 解析 “group” 标签； 解析 “permission” 标签； 解析 “assign-permission” 标签； 解析 “library” 标签 解析 “feature” 标签 解析 “unavailable-feature” 标签 解析 “allow-in-power-save-except-idle” 标签 解析 “allow-in-power-save” 标签 解析 “allow-in-data-usage-save” 标签 解析 “app-link” 标签 解析 “system-user-whitelisted-app” 标签 解析 “system-user-blacklisted-app” 标签 解析 “default-enabled-vr-app” 标签 解析 “backup-transport-whitelisted-service” 标签 解析 “disabled-until-used-preinstalled-carrier-associated-app” 标签 这些解析后的数据都会保存到下面的集合中： 12345678910111213141516171819202122232425262728293031323334public class SystemConfig &#123; // 系统定义的所有的 gid！ int[] mGlobalGids; // 保存了 uid 和其所有的权限信息的映射关系！ final SparseArray&lt;ArraySet&lt;String&gt;&gt; mSystemPermissions = new SparseArray&lt;&gt;(); // 系统所有的共享库信息，key 是 lib name，value 是 lib path！ final ArrayMap&lt;String, String&gt; mSharedLibraries = new ArrayMap&lt;&gt;(); // 系统中可用的 feature！ final ArrayMap&lt;String, FeatureInfo&gt; mAvailableFeatures = new ArrayMap&lt;&gt;(); // 系统中不可用的 feature！ final ArraySet&lt;String&gt; mUnavailableFeatures = new ArraySet&lt;&gt;(); // 保存了 gid 和其所拥有的权限的映射关系！ final ArrayMap&lt;String, PermissionEntry&gt; mPermissions = new ArrayMap&lt;&gt;(); final ArraySet&lt;String&gt; mAllowInPowerSaveExceptIdle = new ArraySet&lt;&gt;(); final ArraySet&lt;String&gt; mAllowInPowerSave = new ArraySet&lt;&gt;(); final ArraySet&lt;String&gt; mAllowInDataUsageSave = new ArraySet&lt;&gt;(); final ArraySet&lt;String&gt; mLinkedApps = new ArraySet&lt;&gt;(); final ArraySet&lt;String&gt; mSystemUserWhitelistedApps = new ArraySet&lt;&gt;(); final ArraySet&lt;String&gt; mSystemUserBlacklistedApps = new ArraySet&lt;&gt;(); // 默认的 VR 组件信息！ final ArraySet&lt;ComponentName&gt; mDefaultVrComponents = new ArraySet&lt;&gt;(); final ArraySet&lt;ComponentName&gt; mBackupTransportWhitelist = new ArraySet&lt;&gt;(); final ArrayMap&lt;String, List&lt;String&gt;&gt; mDisabledUntilUsedPreinstalledCarrierAssociatedApps = new ArrayMap&lt;&gt;();&#125; 下面，我们重点分析几个配置解析，以 /system/etc/permissions 为例，该目录所有的 xml 文件的根节点都是：123&lt;permissions&gt;&lt;/permissions&gt; 下面我们继续来看： 2.2.1 解析 “group” - 获得系统中的所有 gid和 “group” 相关的 xml 内容如下，可以看到 “group” 并不是单独存在的，而是和 “permission” 一起配合使用！ 123456&lt;permissions&gt; &lt;permission name=\"android.permission.BLUETOOTH_ADMIN\" &gt; &lt;!--解析 group 标签--&gt; &lt;group gid=\"net_bt_admin\" /&gt; &lt;/permission&gt;&lt;/permissions&gt; 下面是解析过程：1234567891011121314if (\"group\".equals(name) &amp;&amp; allowAll) &#123; //【1】解析 \"group\" 标签 String gidStr = parser.getAttributeValue(null, \"gid\"); if (gidStr != null) &#123; // 将 Gid 从字符串形式转为对应的 int 形式！ int gid = android.os.Process.getGidForName(gidStr); mGlobalGids = appendInt(mGlobalGids, gid); &#125; else &#123; Slog.w(TAG, \"&lt;group&gt; without gid in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; XmlUtils.skipCurrentTag(parser); continue;&#125; 根据组名称，调用 android.os.Process.getGidForName 转为 gid，保存到 mGlobalGids！ 2.2.2 解析 “permission” - 获得系统权限和所属的 gidxml 信息如下：12345678910&lt;permissions&gt; &lt;!--解析 permission 标签--&gt; &lt;permission name=\"android.permission.BLUETOOTH_ADMIN\" &gt; &lt;group gid=\"net_bt_admin\" /&gt; &lt;/permission&gt; &lt;permission name=\"android.permission.BLUETOOTH\" &gt; &lt;group gid=\"net_bt\" /&gt; &lt;/permission&gt;&lt;/permissions&gt; 下面是解析过程：12345678910111213141516 &#125; else if (\"permission\".equals(name) &amp;&amp; allowPermissions) &#123; //【1】解析 \"permission\" 标签，获得权限的名称 perm！ String perm = parser.getAttributeValue(null, \"name\"); if (perm == null) &#123; Slog.w(TAG, \"&lt;permission&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; perm = perm.intern(); //【2】调用 readPermission 继续解析权限 readPermission(parser, perm);&#125; 进一步调用 readPermission 方法：12345678910111213141516171819202122232425262728293031323334353637383940void readPermission(XmlPullParser parser, String name) throws IOException, XmlPullParserException &#123; //【1】如果 mPermissions 已经包含这个权限，解析冲突！ if (mPermissions.containsKey(name)) &#123; throw new IllegalStateException(\"Duplicate permission definition for \" + name); &#125; //【2】perUser 表示该权限的 gid 是否针对设备用户 id 进行调整，默认为 false！ final boolean perUser = XmlUtils.readBooleanAttribute(parser, \"perUser\", false); //【3】创建 PermissionEntry，并添加到 mPermissions 中！ final PermissionEntry perm = new PermissionEntry(name, perUser); mPermissions.put(name, perm); int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); //【4】解析内部 \"group\" 标签，获得权限所属的 gid，将其添加到 PermissionEntry 的 gids 数组中！ if (\"group\".equals(tagName)) &#123; String gidStr = parser.getAttributeValue(null, \"gid\"); if (gidStr != null) &#123; int gid = Process.getGidForName(gidStr); perm.gids = appendInt(perm.gids, gid); &#125; else &#123; Slog.w(TAG, \"&lt;group&gt; without gid at \" + parser.getPositionDescription()); &#125; &#125; XmlUtils.skipCurrentTag(parser); &#125;&#125; 可以看到，解析 “permission” 标签以及其内部的标签 “group”，获得了 gid 和权限的映射关系，保存到了 mPermissions 中，一个权限可以对应多个 gid！ 2.2.3 解析 “assign-permission” - 给指定的 uid 分配权限“assign-permission” 的 xml 内容如下：123&lt;assign-permission name=\"android.permission.MODIFY_AUDIO_SETTINGS\" uid=\"media\" /&gt;&lt;assign-permission name=\"android.permission.ACCESS_SURFACE_FLINGER\" uid=\"media\" /&gt;&lt;assign-permission name=\"android.permission.WAKE_LOCK\" uid=\"media\" /&gt; 下面是解析过程：1234567891011121314151617181920212223242526272829303132333435363738&#125; else if (\"assign-permission\".equals(name) &amp;&amp; allowPermissions) &#123; //【1】解析 \"name\" 属性，获得权限的名称！ String perm = parser.getAttributeValue(null, \"name\"); if (perm == null) &#123; Slog.w(TAG, \"&lt;assign-permission&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; //【2】获得权限所属用户的名称！ String uidStr = parser.getAttributeValue(null, \"uid\"); if (uidStr == null) &#123; Slog.w(TAG, \"&lt;assign-permission&gt; without uid in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; //【3】获得用户 uid！ int uid = Process.getUidForName(uidStr); if (uid &lt; 0) &#123; Slog.w(TAG, \"&lt;assign-permission&gt; with unknown uid \\\"\" + uidStr + \" in \" + permFile + \" at \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; perm = perm.intern(); ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid); if (perms == null) &#123; perms = new ArraySet&lt;String&gt;(); mSystemPermissions.put(uid, perms); &#125; perms.add(perm); XmlUtils.skipCurrentTag(parser);&#125; 可以看到，解析 “assign-permission” 标签，获得了 uid 和权限的映射关系，保存到了 mSystemPermissions 中，一个 uid 可以对应多个权限！ 2.2.4 解析 “library” - 获得共享库信息xml 信息如下：123456&lt;library name=\"android.test.runner\" file=\"/system/framework/android.test.runner.jar\" /&gt;&lt;library name=\"javax.obex\" file=\"/system/framework/javax.obex.jar\" /&gt;&lt;library name=\"org.apache.http.legacy\" file=\"/system/framework/org.apache.http.legacy.jar\" /&gt; 下面是解析过程： 123456789101112131415161718&#125; else if (\"library\".equals(name) &amp;&amp; allowLibs) &#123; //【1】解析 \"library\" 标签 String lname = parser.getAttributeValue(null, \"name\"); String lfile = parser.getAttributeValue(null, \"file\"); if (lname == null) &#123; Slog.w(TAG, \"&lt;library&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else if (lfile == null) &#123; Slog.w(TAG, \"&lt;library&gt; without file in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; //Log.i(TAG, \"Got library \" + lname + \" in \" + lfile); mSharedLibraries.put(lname, lfile); &#125; XmlUtils.skipCurrentTag(parser); continue;&#125; 解析共享库信息，保存到 mSharedLibraries 中，key 为 共享库名称，value 为共享库路径！ 2.2.5 解析 “feature” - 获得系统特性配置信息“feature” 的 xml 内容如下：123&lt;permissions&gt; &lt;feature name=\"android.hardware.bluetooth\" /&gt;&lt;/permissions&gt; 下面是解析过程：123456789101112131415161718192021222324252627282930313233343536&#125; else if (\"feature\".equals(name) &amp;&amp; allowFeatures) &#123; //【1】解析 \"feature\" 标签 // 获得 feature 的名称和版本号 String fname = parser.getAttributeValue(null, \"name\"); int fversion = XmlUtils.readIntAttribute(parser, \"version\", 0); boolean allowed; if (!lowRam) &#123; allowed = true; &#125; else &#123; String notLowRam = parser.getAttributeValue(null, \"notLowRam\"); allowed = !\"true\".equals(notLowRam); &#125; if (fname == null) &#123; Slog.w(TAG, \"&lt;feature&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else if (allowed) &#123; addFeature(fname, fversion); &#125; XmlUtils.skipCurrentTag(parser); continue;&#125; else if (\"unavailable-feature\".equals(name) &amp;&amp; allowFeatures) &#123; //【2】解析 \"unavailable-feature\" 标签 String fname = parser.getAttributeValue(null, \"name\"); if (fname == null) &#123; Slog.w(TAG, \"&lt;unavailable-feature&gt; without name in \" + permFile + \" at \" + parser.getPositionDescription()); &#125; else &#123; mUnavailableFeatures.add(fname); &#125; XmlUtils.skipCurrentTag(parser); continue;&#125; 上面会把配置文件中的 feature 解析出来，可用 feature 会被添加到 mAvailableFeatures 中，不可用 feature 会被添加到 mUnavailableFeatures 中！ 2.2.6 解析其他的标签其他的标签有如下几个: 解析 “allow-in-power-save-except-idle”，这个是省电模式的白名单，该白名单不包括 idle 白名单！ mAllowInPowerSaveExceptIdle.add(pkgname); 解析 “allow-in-power-save”，这个是省电模式的白名单！ mAllowInPowerSave.add(pkgname); 解析 “allow-in-data-usage-save” mAllowInDataUsageSave.add(pkgname); 解析 “app-link” mLinkedApps.add(pkgname); 解析 “system-user-whitelisted-app” mSystemUserWhitelistedApps.add(pkgname); 解析 “default-enabled-vr-app” mDefaultVrComponents.add(new ComponentName(pkgname, clsname)); 解析 “backup-transport-whitelisted-service” ComponentName cn = ComponentName.unflattenFromString(serviceName); mBackupTransportWhitelist.add(cn); 解析 “disabled-until-used-preinstalled-carrier-associated-app” associatedPkgs = new ArrayList&lt;&gt;(); mDisabledUntilUsedPreinstalledCarrierAssociatedApps.put(carrierPkgname, associatedPkgs); associatedPkgs.add(pkgname); SystemConfig 内部的数据关系图： 2.3 PMS 对于 SystemConfig 的后续处理然后，回到 PMS 的构造器中：将 SystemConfig 中的 mGlobalGids，mSystemPermissions 和 mAvailableFeatures 拷贝一份保存到 PMS 中！1234//【1】保存到 PMS 中！mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures(); 接着，处理权限信息和共享库信息，将解析出来的 mPermissions 信息保存到 Setting 的 mPermissions 中，权限所属的包名为 android ! 因为 SystemConfig.mPermissions 保存的是系统中定义的权限和对应的 Gid 的关系！！1234567891011121314151617181920212223242526//【2】从获得 SystemConfig 加载的系统权限集合 mPermissions！ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions();for (int i = 0; i &lt; permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); //【2】加入到 Settings 的 mPermissions 中，SystemConfig 解析的权限的包名都为 “android”！ if (bp == null) &#123; // BasePermission.TYPE_BUILTIN 表示的是在编译时期就确定好的，系统要提供的权限！ bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; // 如果系统权限有所属的 gids，将其添加到 BasePermission 对象中！ if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125;&#125;//【3】处理共享库，将共享库信息也保存一份在 PMS 中！ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();for (int i=0; i&lt;libConfig.size(); i++) &#123; mSharedLibraries.put(libConfig.keyAt(i), new SharedLibraryEntry(libConfig.valueAt(i), null));&#125; 创建了一个 BasePermission 对象，封装系统权限！！1234567BasePermission(String _name, String _sourcePackage, int _type) &#123; name = _name; // 权限名； sourcePackage = _sourcePackage; // 定义权限的包名； type = _type; // 权限类型！ // Default to most conservative protection level. protectionLevel = PermissionInfo.PROTECTION_SIGNATURE; // 权限界别！&#125; 同时设置系统权限的 gid：1234public void setGids(int[] gids, boolean perUser) &#123; this.gids = gids; // 设置 gids this.perUser = perUser;&#125; 可以看到，SystemConfig 保存的均是和系统相关的属性信息，比如系统权限，系统特性， Gid 等等，而 Settings 中则保存的系统和和应用所有的信息，所以，这里需要将 SystemConfig 中的权限信息保存过来！ 这里就先分析到这里，后面会继续补充！ 2.4 阶段总结我们来总结一下，SystemConfig、Settings 以及 PackageManagerService 之间的数据关系： 通过 SystemConfig 解析，我们可以系统定义的一些配置信息： 系统定义的一些 gid； 系统定义的权限和 uid 的映射关系； 系统定义的权限和 gid 的映射关系； 系统共享库和feature； 我们继续看！ 6 PackageHandler123456// 建立并启动一个名为 “PackageManager” 的 ServiceThread，用于处理一些耗时的操作！mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);mHandlerThread.start();// 创建一个 PackageHandler 对象，绑定前面创建的 HandlerThread！mHandler = new PackageHandler(mHandlerThread.getLooper()); 这里的 ServiceThread 继承了 HandlerThread，专门为系统服务定义的！ PackageHandler 处理的 msg 有如下：123456789101112131415161718static final int SEND_PENDING_BROADCAST = 1;static final int MCS_BOUND = 3;static final int END_COPY = 4;static final int INIT_COPY = 5;static final int MCS_UNBIND = 6;static final int START_CLEANING_PACKAGE = 7; // 清楚 packagestatic final int FIND_INSTALL_LOC = 8;static final int POST_INSTALL = 9; // 安装 packagestatic final int MCS_RECONNECT = 10;static final int MCS_GIVE_UP = 11;static final int UPDATED_MEDIA_STATUS = 12;static final int WRITE_SETTINGS = 13;static final int WRITE_PACKAGE_RESTRICTIONS = 14;static final int PACKAGE_VERIFIED = 15; // 校验 packagestatic final int CHECK_PENDING_VERIFICATION = 16;static final int START_INTENT_FILTER_VERIFICATIONS = 17;static final int INTENT_FILTER_VERIFIED = 18;static final int WRITE_PACKAGE_LIST = 19; 一些耗时的操作，pms 都会交给 PackageHandler 去做，比如安装应用，卸载应用等等的操作，这个以后再分析！ 7 SELinuxMMAC.readInstallPolicy调用 SELinuxMMAC.readInstallPolicy 读取 /etc/security/mac_permissions.xml 文件中的 selinux 配置，设置应用程序的安全上下文！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static boolean readInstallPolicy() &#123; // Temp structure to hold the rules while we parse the xml file List&lt;Policy&gt; policies = new ArrayList&lt;&gt;(); FileReader policyFile = null; XmlPullParser parser = Xml.newPullParser(); try &#123; //【1】获得 /etc/security/mac_permissions.xml 文件引用！ policyFile = new FileReader(MAC_PERMISSIONS); Slog.d(TAG, \"Using policy file \" + MAC_PERMISSIONS); parser.setInput(policyFile); parser.nextTag(); parser.require(XmlPullParser.START_TAG, null, \"policy\"); while (parser.next() != XmlPullParser.END_TAG) &#123; if (parser.getEventType() != XmlPullParser.START_TAG) &#123; continue; &#125; switch (parser.getName()) &#123; case \"signer\": //【7.1】解析 \"signer\" 标签的内容，返回一个 Policy 对象！！ policies.add(readSignerOrThrow(parser)); break; default: skip(parser); &#125; &#125; &#125; catch (IllegalStateException | IllegalArgumentException | XmlPullParserException ex) &#123; ... ... ... ... return false; &#125; catch (IOException ioe) &#123; Slog.w(TAG, \"Exception parsing \" + MAC_PERMISSIONS, ioe); return false; &#125; finally &#123; IoUtils.closeQuietly(policyFile); &#125; //【3】使用比较器对其进行排序！ PolicyComparator policySort = new PolicyComparator(); Collections.sort(policies, policySort); if (policySort.foundDuplicate()) &#123; Slog.w(TAG, \"ERROR! Duplicate entries found parsing \" + MAC_PERMISSIONS); return false; &#125; synchronized (sPolicies) &#123; sPolicies = policies; if (DEBUG_POLICY_ORDER) &#123; for (Policy policy : sPolicies) &#123; Slog.d(TAG, \"Policy: \" + policy.toString()); &#125; &#125; &#125; return true;&#125; 这里用到了一个文件对象！12private static final File MAC_PERMISSIONS = new File(Environment.getRootDirectory(), \"/etc/security/mac_permissions.xml\"); 我们来看下该文件的内容；1234567891011&lt;policy&gt; &lt;!-- Platform dev key in AOSP --&gt; &lt;signer signature=\"@PLATFORM\" &gt; &lt;seinfo value=\"platform\" /&gt; &lt;/signer&gt; &lt;!-- Media key in AOSP --&gt; &lt;signer signature=\"@MEDIA\" &gt; &lt;seinfo value=\"media\" /&gt; &lt;/signer&gt;&lt;/policy&gt; 在 Android 引入 SeLinux 以后，Android 会为每个文件打上 SE Label，对于 APK 而言，打 SE Label 的准则就是签名，即根据签名信息打上不同的 SE Label。 Android 将签名分类成为 platform，testkey，media等，签名与类别的映射关系就存在一个叫 mac_permission.xml 的文件中。 所以，需要读取该文件的内容。 根据 mac_permissions.xml 的定义，如果 App 是在 Android 源码编译环境下，其 Android.mk 中指定了 LOCAL_CERTIFICATE : = platform 的话，它的 seinfo 就是 platform。如果 Android.mk 中不进行对应的设置，setinfo 为默认值 default。 对于第三方 APK，其 seinfo 值通常为 default。 当 mac_permissions.xml 编译进 system/etc 目录时，@PLATFORM 将被实际的签名信息替换： 12345678910&lt;?xml version=\"1.0\" encoding=\"iso-8859-1\"?&gt;&lt;!-- AUTOGENERATED FILE DO NOT MODIFY --&gt;&lt;policy&gt; &lt;signer signature=\"308204......232e4fe9bd961394c6300e5138e3cfd285e6e4e483538cb8b1b357\"&gt; &lt;seinfo value=\"platform\"/&gt; &lt;/signer&gt; &lt;default&gt; &lt;seinfo value=\"default\"/&gt; &lt;/default&gt;&lt;/policy&gt; 这里不多说了。 7.1 SELinuxMMAC.readSignerOrThrow123456789101112131415161718192021222324252627282930313233private static Policy readSignerOrThrow(XmlPullParser parser) throws IOException, XmlPullParserException &#123; parser.require(XmlPullParser.START_TAG, null, \"signer\"); Policy.PolicyBuilder pb = new Policy.PolicyBuilder(); //【1】解析 signature 属性 String cert = parser.getAttributeValue(null, \"signature\"); if (cert != null) &#123; pb.addSignature(cert); &#125; while (parser.next() != XmlPullParser.END_TAG) &#123; if (parser.getEventType() != XmlPullParser.START_TAG) &#123; continue; &#125; String tagName = parser.getName(); if (\"seinfo\".equals(tagName)) &#123; //【2】解析子标签 seinfo！ String seinfo = parser.getAttributeValue(null, \"value\"); pb.setGlobalSeinfoOrThrow(seinfo); readSeinfo(parser); &#125; else if (\"package\".equals(tagName)) &#123; //【3】解析子标签 package！ readPackageOrThrow(parser, pb); &#125; else if (\"cert\".equals(tagName)) &#123; //【4】解析子标签 cert！ String sig = parser.getAttributeValue(null, \"signature\"); pb.addSignature(sig); readCert(parser); &#125; else &#123; skip(parser); &#125; &#125; return pb.build();&#125; 可以看到，readSignerOrThrow 方法会解析 signer 标签和其子标签，然后将结果通过 buidler 模式，封装成一个 Policy 对象返回！ 8 Settings.readLPw继续看：1mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false)); 这个方法用来恢复上一次安装的信息，参数传递： List users：当前是设备用户 id！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280boolean readLPw(@NonNull List&lt;UserInfo&gt; users) &#123; FileInputStream str = null; //【1】如果 packages-backup.xml 存在，就从 packages-backup.xml 中读取 if (mBackupSettingsFilename.exists()) &#123; try &#123; str = new FileInputStream(mBackupSettingsFilename); mReadMessages.append(\"Reading from backup settings file\\n\"); PackageManagerService.reportSettingsProblem(Log.INFO, \"Need to read from backup settings file\"); // 如果 packages.xml 存在，删除！ if (mSettingsFilename.exists()) &#123; Slog.w(PackageManagerService.TAG, \"Cleaning up settings file \" + mSettingsFilename); mSettingsFilename.delete(); &#125; &#125; catch (java.io.IOException e) &#123; &#125; &#125; // 清空一些集合，防止异常问题！ mPendingPackages.clear(); mPastSignatures.clear(); mKeySetRefs.clear(); mInstallerPackages.clear(); try &#123; //【2】如果 packages-backup.xml 不存在，就从 packages.xml 中读取！ if (str == null) &#123; if (!mSettingsFilename.exists()) &#123; mReadMessages.append(\"No settings file found\\n\"); PackageManagerService.reportSettingsProblem(Log.INFO, \"No settings file; creating initial state\"); // It's enough to just touch version details to create them // with default values findOrCreateVersion(StorageManager.UUID_PRIVATE_INTERNAL); findOrCreateVersion(StorageManager.UUID_PRIMARY_PHYSICAL); return false; &#125; str = new FileInputStream(mSettingsFilename); &#125; XmlPullParser parser = Xml.newPullParser(); parser.setInput(str, StandardCharsets.UTF_8.name()); int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; ; &#125; if (type != XmlPullParser.START_TAG) &#123; mReadMessages.append(\"No start tag found in settings file\\n\"); PackageManagerService.reportSettingsProblem(Log.WARN, \"No start tag found in package manager settings\"); Slog.wtf(PackageManagerService.TAG, \"No start tag found in package manager settings\"); return false; &#125; int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"package\")) &#123; //【2.1】解析 \"package\" readPackageLPw(parser); &#125; else if (tagName.equals(\"permissions\")) &#123; //【2.2】解析 \"permissions\" readPermissionsLPw(mPermissions, parser); &#125; else if (tagName.equals(\"permission-trees\")) &#123; //【2.3】解析 \"permission-trees\" readPermissionsLPw(mPermissionTrees, parser); &#125; else if (tagName.equals(\"shared-user\")) &#123; //【2.4】解析 \"shared-user\" readSharedUserLPw(parser); &#125; else if (tagName.equals(\"preferred-packages\")) &#123; // no longer used. &#125; else if (tagName.equals(\"preferred-activities\")) &#123; //【2.5】解析 \"preferred-activities\" readPreferredActivitiesLPw(parser, 0); &#125; else if (tagName.equals(TAG_PERSISTENT_PREFERRED_ACTIVITIES)) &#123; // 解析 \"persistent-preferred-activities\" // Android 7.1.1 的默认应用已经不在 packages.xml 中定义了！ // 而是在 package-restrictions 文件中定义，这里是为了兼容以前的版本！ readPersistentPreferredActivitiesLPw(parser, 0); &#125; else if (tagName.equals(TAG_CROSS_PROFILE_INTENT_FILTERS)) &#123; // 解析 \"crossProfile-intent-filters\" readCrossProfileIntentFiltersLPw(parser, 0); &#125; else if (tagName.equals(TAG_DEFAULT_BROWSER)) &#123; //【2.6】解析 \"default-browser\" readDefaultAppsLPw(parser, 0); &#125; else if (tagName.equals(\"updated-package\")) &#123; //【2.7】解析 \"updated-package\" readDisabledSysPackageLPw(parser); &#125; else if (tagName.equals(\"cleaning-package\")) &#123; //【2.8】解析 \"cleaning-package\" String name = parser.getAttributeValue(null, ATTR_NAME); String userStr = parser.getAttributeValue(null, ATTR_USER); String codeStr = parser.getAttributeValue(null, ATTR_CODE); if (name != null) &#123; int userId = UserHandle.USER_SYSTEM; boolean andCode = true; try &#123; if (userStr != null) &#123; userId = Integer.parseInt(userStr); &#125; &#125; catch (NumberFormatException e) &#123; &#125; if (codeStr != null) &#123; andCode = Boolean.parseBoolean(codeStr); &#125; addPackageToCleanLPw(new PackageCleanItem(userId, name, andCode)); &#125; &#125; else if (tagName.equals(\"renamed-package\")) &#123; //【2.9】解析 \"renamed-package\" String nname = parser.getAttributeValue(null, \"new\"); String oname = parser.getAttributeValue(null, \"old\"); if (nname != null &amp;&amp; oname != null) &#123; mRenamedPackages.put(nname, oname); &#125; &#125; else if (tagName.equals(\"restored-ivi\")) &#123; // 解析 \"restored-ivi\" readRestoredIntentFilterVerifications(parser); &#125; else if (tagName.equals(\"last-platform-version\")) &#123; // 解析 \"last-platform-version\" // Upgrade from older XML schema final VersionInfo internal = findOrCreateVersion( StorageManager.UUID_PRIVATE_INTERNAL); final VersionInfo external = findOrCreateVersion( StorageManager.UUID_PRIMARY_PHYSICAL); internal.sdkVersion = XmlUtils.readIntAttribute(parser, \"internal\", 0); external.sdkVersion = XmlUtils.readIntAttribute(parser, \"external\", 0); internal.fingerprint = external.fingerprint = XmlUtils.readStringAttribute(parser, \"fingerprint\"); &#125; else if (tagName.equals(\"database-version\")) &#123; // 解析 \"database-version\" // Upgrade from older XML schema final VersionInfo internal = findOrCreateVersion( StorageManager.UUID_PRIVATE_INTERNAL); final VersionInfo external = findOrCreateVersion( StorageManager.UUID_PRIMARY_PHYSICAL); internal.databaseVersion = XmlUtils.readIntAttribute(parser, \"internal\", 0); external.databaseVersion = XmlUtils.readIntAttribute(parser, \"external\", 0); &#125; else if (tagName.equals(\"verifier\")) &#123; // 解析 \"verifier\" final String deviceIdentity = parser.getAttributeValue(null, \"device\"); try &#123; mVerifierDeviceIdentity = VerifierDeviceIdentity.parse(deviceIdentity); &#125; catch (IllegalArgumentException e) &#123; Slog.w(PackageManagerService.TAG, \"Discard invalid verifier device id: \" + e.getMessage()); &#125; &#125; else if (TAG_READ_EXTERNAL_STORAGE.equals(tagName)) &#123; // 解析 \"read-external-storage\" final String enforcement = parser.getAttributeValue(null, ATTR_ENFORCEMENT); mReadExternalStorageEnforced = \"1\".equals(enforcement); &#125; else if (tagName.equals(\"keyset-settings\")) &#123; // 解析 \"keyset-settings\" mKeySetManagerService.readKeySetsLPw(parser, mKeySetRefs); &#125; else if (TAG_VERSION.equals(tagName)) &#123; // 解析 \"version\" final String volumeUuid = XmlUtils.readStringAttribute(parser, ATTR_VOLUME_UUID); final VersionInfo ver = findOrCreateVersion(volumeUuid); ver.sdkVersion = XmlUtils.readIntAttribute(parser, ATTR_SDK_VERSION); ver.databaseVersion = XmlUtils.readIntAttribute(parser, ATTR_SDK_VERSION); ver.fingerprint = XmlUtils.readStringAttribute(parser, ATTR_FINGERPRINT); &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;packages&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; str.close(); &#125; catch (XmlPullParserException e) &#123; ... ... &#125; catch (java.io.IOException e) &#123; ... ... &#125; //【3】If the build is setup to drop runtime permissions // on update drop the files before loading them. if (PackageManagerService.CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE) &#123; final VersionInfo internal = getInternalVersion(); if (!Build.FINGERPRINT.equals(internal.fingerprint)) &#123; for (UserInfo user : users) &#123; mRuntimePermissionsPersistence.deleteUserRuntimePermissionsFile(user.id); &#125; &#125; &#125; //【4】接着，对 mPendingPackages 集合中的需要验证共享用户 id 有效性的 package，进行共享用户 id 有效性的验证! final int N = mPendingPackages.size(); for (int i = 0; i &lt; N; i++) &#123; final PendingPackage pp = mPendingPackages.get(i); // 看 sharedId 是否能对应找到一个 ShardUserSetting 对象! Object idObj = getUserIdLPr(pp.sharedId); if (idObj != null &amp;&amp; idObj instanceof SharedUserSetting) &#123; // 能找到，说明共享用户 ID 是有效的! PackageSetting p = getPackageLPw(pp.name, null, pp.realName, (SharedUserSetting) idObj, pp.codePath, pp.resourcePath, pp.legacyNativeLibraryPathString, pp.primaryCpuAbiString, pp.secondaryCpuAbiString, pp.versionCode, pp.pkgFlags, pp.pkgPrivateFlags, null, true /* add */, false /* allowInstall */, pp.parentPackageName, pp.childPackageNames); if (p == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unable to create application package for \" + pp.name); continue; &#125; p.copyFrom(pp); // 保存到 Settings.mPackages 对象中，表明 ID 有效，已经分配 ID 了！ &#125; else if (idObj != null) &#123; ... ... ... &#125; else &#123; ... ... ... &#125; &#125; mPendingPackages.clear(); // 清空 //【8.3】读取 packages-stopped-backup.xml 和 packages_stopped.xml 文件 ！ if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) &#123; //【8.3.1】如果 packages_stopped.xml 存在，我们先会读取文件数据，然后删除 packages_stopped.xml 相关文件！ readStoppedLPw(); mBackupStoppedPackagesFilename.delete(); mStoppedPackagesFilename.delete(); //【8.3.2】然后用最新的数据更新偏好设置！ writePackageRestrictionsLPr(UserHandle.USER_SYSTEM); &#125; else &#123; //【8.3.3】否则，我们直接读取已有的偏好设置，更新上次安装的信息！ for (UserInfo user : users) &#123; readPackageRestrictionsLPr(user.id); &#125; &#125; //【8.4】读取每个 user 下的运行是权限信息！ for (UserInfo user : users) &#123; mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id); &#125; // mDisabledSysPackages 里面保存着所有被替换的 Package 信息，如果这些 package 之前配置的是共享用户 uid // 那这里要建立 package 和 共享用户 id 的关联！ final Iterator&lt;PackageSetting&gt; disabledIt = mDisabledSysPackages.values().iterator(); while (disabledIt.hasNext()) &#123; final PackageSetting disabledPs = disabledIt.next(); final Object id = getUserIdLPr(disabledPs.appId); if (id != null &amp;&amp; id instanceof SharedUserSetting) &#123; disabledPs.sharedUser = (SharedUserSetting) id; &#125; &#125; mReadMessages.append(\"Read completed successfully: \" + mPackages.size() + \" packages, \" + mSharedUsers.size() + \" shared uids\\n\"); writeKernelMappingLPr(); return true;&#125; 这个方法的主要流程是： 读取 packages-backup.xml 或者 packages.xml 文件中的数据并解析，获得上一次应用的安装和使用信息！ 校验共享用户id 的应用程序包的 uid 的有效性！ 读取 packages-stopped-backup.xml 和 packages_stopped.xml 文件中的数据并解析！ 处理被替换的系统应用的共享用户 id 和自身的关系！ 下面我们来看下重要的属性的解析： 8.1 读取 pacakges.xml 文件这个流程主要会解析如下的标签： 标签 标签解释 “package” 系统中所有应用程序包的信息 “permissions” 系统中定义的所有的权限 “permission-trees” 系统中定义的权限树 “shared-user” 系统中定义的共享用户 “preferred-activities” 系统默认应用相关 “persistent-preferred-activities” 系统默认应用相关 “crossProfile-intent-filters” “default-browser” 默认的浏览器 “updated-package” 系统中被更新的应用程序包 “cleaning-package” 系统中被清除掉的应用程序包 “renamed-package” 系统中被重命名的应用程序包 “restored-ivi” “last-platform-version” 系统升级之前的版本 “database-version” 数据库版本 “verifier” “read-external-storage” “keyset-settings” “version” 当前系统的版本 我们重点分析和 package、permission，shared-user 相关的内容，其他的内容我们后续接触到在分析！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;packages&gt; &lt;version sdkVersion=\"27\" databaseVersion=\"3\" fingerprint=\"../release-keys\" /&gt; &lt;version volumeUuid=\"primary_physical\" sdkVersion=\"27\" databaseVersion=\"27\" fingerprint=\".../release-keys\" /&gt; &lt;permission-trees /&gt; &lt;permissions&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" package=\"android\" protection=\"18\" /&gt; &lt;!-- ... ... ...--&gt; &lt;/permissions&gt; &lt;package name=\"com.android.providers.calendar\" codePath=\"/system/priv-app/CalendarProvider\" nativeLibraryPath=\"/system/priv-app/CalendarProvider/lib\" primaryCpuAbi=\"armeabi-v7a\" publicFlags=\"940064325\" privateFlags=\"8\" ft=\"1624a4dcee0\" it=\"1624a4dcee0\" ut=\"1624a4dcee0\" version=\"0\" sharedUserId=\"10006\" isOrphaned=\"true\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"0\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.WRITE_SETTINGS\" granted=\"true\" flags=\"0\" /&gt; &lt;!-- ... ... ...--&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=\"1\" /&gt; &lt;/package&gt; &lt;updated-package name=\"com.coolqi.papapa\" codePath=\"/system/app/papapa\" ft=\"1624a6f0ab0\" it=\"1624a6f0ab0\" ut=\"1624a6f0ab0\" version=\"5023\" nativeLibraryPath=\"/system/app/papapa/lib\" primaryCpuAbi=\"arm64-v8a\" sharedUserId=\"1000\" /&gt; &lt;shared-user name=\"android.uid.bluetooth\" userId=\"1002\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"0\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" granted=\"true\" flags=\"0\" /&gt; &lt;!-- ... ... --&gt; &lt;/perms&gt; &lt;/shared-user&gt; &lt;keyset-settings version=\"1\"&gt; &lt;keys&gt; &lt;public-key identifier=\"1\" value=\"MIIBIjjYLv....uhfiUDQIDAQAB\" /&gt; &lt;!-- ... ... --&gt; &lt;/keys&gt; &lt;keysets&gt; &lt;keyset identifier=\"1\"&gt; &lt;key-id identifier=\"1\" /&gt; &lt;/keyset&gt; &lt;!-- ... ... --&gt; &lt;/keysets&gt; &lt;lastIssuedKeyId value=\"16\" /&gt; &lt;lastIssuedKeySetId value=\"16\" /&gt; &lt;/keyset-settings&gt;&lt;/packages&gt; 上面是 pacakges.xml 的主要内容！ 8.1.1 解析 “package” 标签和 “package” 相关内容如下：123456789101112131415&lt;package name=\"com.qualcomm.qti.haven.telemetry.service\" codePath=\"/system/app/TelemetryService\" nativeLibraryPath=\"/system/app/TelemetryService/lib\" publicFlags=\"940097093\" privateFlags=\"0\" ft=\"11e8dc5d800\" it=\"11e8dc5d800\" ut=\"11e8dc5d800\" version=\"25\" userId=\"10091\" isOrphaned=\"true\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"0\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.INTERNET\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_NETWORK_STATE\" granted=\"true\" flags=\"0\" /&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=\"1\" /&gt;&lt;/package&gt; 接下来，看看具体的解析过程： 123if (tagName.equals(\"package\")) &#123; readPackageLPw(parser); &#125; 8.1.1.1 Settings.readPackageLPw调用 readPackageLPw 方法！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358private void readPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException &#123; // 需要解析的属性 String name = null; String realName = null; String idStr = null; String sharedIdStr = null; String codePathStr = null; String resourcePathStr = null; String legacyCpuAbiString = null; String legacyNativeLibraryPathStr = null; String primaryCpuAbiString = null; String secondaryCpuAbiString = null; String cpuAbiOverrideString = null; String systemStr = null; String installerPackageName = null; String isOrphaned = null; String volumeUuid = null; String uidError = null; int pkgFlags = 0; int pkgPrivateFlags = 0; long timeStamp = 0; long firstInstallTime = 0; long lastUpdateTime = 0; PackageSettingBase packageSetting = null; String version = null; int versionCode = 0; String parentPackageName; try &#123; //【1】获得应用的 name！ name = parser.getAttributeValue(null, ATTR_NAME); realName = parser.getAttributeValue(null, \"realName\"); //【2】获得 userId 和 sharedId 的名称, userId 和 sharedIdStr 不能同时存在！ idStr = parser.getAttributeValue(null, \"userId\"); uidError = parser.getAttributeValue(null, \"uidError\"); sharedIdStr = parser.getAttributeValue(null, \"sharedUserId\"); //【3】获得应用程序包的路径，例如：/system/priv-app/CalendarProvider！ codePathStr = parser.getAttributeValue(null, \"codePath\"); resourcePathStr = parser.getAttributeValue(null, \"resourcePath\"); legacyCpuAbiString = parser.getAttributeValue(null, \"requiredCpuAbi\"); parentPackageName = parser.getAttributeValue(null, \"parentPackageName\"); legacyNativeLibraryPathStr = parser.getAttributeValue(null, \"nativeLibraryPath\"); primaryCpuAbiString = parser.getAttributeValue(null, \"primaryCpuAbi\"); secondaryCpuAbiString = parser.getAttributeValue(null, \"secondaryCpuAbi\"); cpuAbiOverrideString = parser.getAttributeValue(null, \"cpuAbiOverride\"); if (primaryCpuAbiString == null &amp;&amp; legacyCpuAbiString != null) &#123; primaryCpuAbiString = legacyCpuAbiString; &#125; //【4】获得版本号！ version = parser.getAttributeValue(null, \"version\"); if (version != null) &#123; try &#123; versionCode = Integer.parseInt(version); &#125; catch (NumberFormatException e) &#123; &#125; &#125; // 获得安装器的名称！ installerPackageName = parser.getAttributeValue(null, \"installer\"); isOrphaned = parser.getAttributeValue(null, \"isOrphaned\"); volumeUuid = parser.getAttributeValue(null, \"volumeUuid\"); //【5】获得flags相关信息，读取顺序为：publicFlags 和 privateFlags、flags、system; systemStr = parser.getAttributeValue(null, \"publicFlags\"); if (systemStr != null) &#123; try &#123; pkgFlags = Integer.parseInt(systemStr); &#125; catch (NumberFormatException e) &#123; &#125; systemStr = parser.getAttributeValue(null, \"privateFlags\"); if (systemStr != null) &#123; try &#123; pkgPrivateFlags = Integer.parseInt(systemStr); &#125; catch (NumberFormatException e) &#123; &#125; &#125; &#125; else &#123; // 在 Android M 之前，是没有 publicFlags 和 privateFlags 之分的，所有的标志位都存放在 flags 中！ systemStr = parser.getAttributeValue(null, \"flags\"); if (systemStr != null) &#123; try &#123; pkgFlags = Integer.parseInt(systemStr); &#125; catch (NumberFormatException e) &#123; &#125; if ((pkgFlags &amp; PRE_M_APP_INFO_FLAG_HIDDEN) != 0) &#123; pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_HIDDEN; &#125; if ((pkgFlags &amp; PRE_M_APP_INFO_FLAG_CANT_SAVE_STATE) != 0) &#123; pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE; &#125; if ((pkgFlags &amp; PRE_M_APP_INFO_FLAG_FORWARD_LOCK) != 0) &#123; pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_FORWARD_LOCK; &#125; if ((pkgFlags &amp; PRE_M_APP_INFO_FLAG_PRIVILEGED) != 0) &#123; pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; pkgFlags &amp;= ~(PRE_M_APP_INFO_FLAG_HIDDEN | PRE_M_APP_INFO_FLAG_CANT_SAVE_STATE | PRE_M_APP_INFO_FLAG_FORWARD_LOCK | PRE_M_APP_INFO_FLAG_PRIVILEGED); &#125; else &#123; // For backward compatibility systemStr = parser.getAttributeValue(null, \"system\"); if (systemStr != null) &#123; pkgFlags |= (\"true\".equalsIgnoreCase(systemStr)) ? ApplicationInfo.FLAG_SYSTEM : 0; &#125; else &#123; // Old settings that don't specify system... just treat // them as system, good enough. pkgFlags |= ApplicationInfo.FLAG_SYSTEM; &#125; &#125; &#125; // 获得时间戳！ String timeStampStr = parser.getAttributeValue(null, \"ft\"); if (timeStampStr != null) &#123; try &#123; timeStamp = Long.parseLong(timeStampStr, 16); &#125; catch (NumberFormatException e) &#123; &#125; &#125; else &#123; timeStampStr = parser.getAttributeValue(null, \"ts\"); if (timeStampStr != null) &#123; try &#123; timeStamp = Long.parseLong(timeStampStr); &#125; catch (NumberFormatException e) &#123; &#125; &#125; &#125; //【6】获得第一次安装时间 timeStampStr = parser.getAttributeValue(null, \"it\"); if (timeStampStr != null) &#123; try &#123; firstInstallTime = Long.parseLong(timeStampStr, 16); &#125; catch (NumberFormatException e) &#123; &#125; &#125; //【7】获得最近更新时间！ timeStampStr = parser.getAttributeValue(null, \"ut\"); if (timeStampStr != null) &#123; try &#123; lastUpdateTime = Long.parseLong(timeStampStr, 16); &#125; catch (NumberFormatException e) &#123; &#125; &#125; if (PackageManagerService.DEBUG_SETTINGS) Log.v(PackageManagerService.TAG, \"Reading package: \" + name + \" userId=\" + idStr + \" sharedUserId=\" + sharedIdStr); //【8】获得 userId 的 int 值，如果 AndroidManifest.xml 有设置 android:sharedUserId 属性， // 那么应用的 userId 就为 0！！ int userId = idStr != null ? Integer.parseInt(idStr) : 0; if (resourcePathStr == null) &#123; resourcePathStr = codePathStr; &#125; if (realName != null) &#123; realName = realName.intern(); &#125; if (name == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;package&gt; has no name at \" + parser.getPositionDescription()); &#125; else if (codePathStr == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;package&gt; has no codePath at \" + parser.getPositionDescription()); &#125; else if (userId &gt; 0) &#123; //【8.1】如果 userId 大于0，说明 package 是独立用户 id // 调用 addPackageLPw 方法保存这个有独立的 Linux 用户 ID 的 Package! packageSetting = addPackageLPw(name.intern(), realName, new File(codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags, pkgPrivateFlags, parentPackageName, null); if (PackageManagerService.DEBUG_SETTINGS) Log.i(PackageManagerService.TAG, \"Reading package \" + name + \": userId=\" + userId + \" pkg=\" + packageSetting); if (packageSetting == null) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Failure adding uid \" + userId + \" while parsing settings at \" + parser.getPositionDescription()); &#125; else &#123; // 设置时间戳，第一次安装时间，最近更新时间 packageSetting.setTimeStamp(timeStamp); packageSetting.firstInstallTime = firstInstallTime; packageSetting.lastUpdateTime = lastUpdateTime; &#125; &#125; else if (sharedIdStr != null) &#123; //【8.2】sharedIdStr 不为 null，说明 package 设置了共享用户 id！ userId = sharedIdStr != null ? Integer.parseInt(sharedIdStr) : 0; if (userId &gt; 0) &#123; // 对于共享用户 ID 这种情况，还需要验证其有效性! // 创建一个 PendingPackage 对象，来封装这个有共享用户 ID 的 package 的信息! packageSetting = new PendingPackage(name.intern(), realName, new File( codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags, pkgPrivateFlags, parentPackageName, null); // 设置时间戳，第一次安装时间，最近更新时间！ packageSetting.setTimeStamp(timeStamp); packageSetting.firstInstallTime = firstInstallTime; packageSetting.lastUpdateTime = lastUpdateTime; //【8.2.1】添加到 mPendingPackages 中，因为后续需要确定 shareUserId 的有效性！ mPendingPackages.add((PendingPackage) packageSetting); if (PackageManagerService.DEBUG_SETTINGS) Log.i(PackageManagerService.TAG, \"Reading package \" + name + \": sharedUserId=\" + userId + \" pkg=\" + packageSetting); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad sharedId \" + sharedIdStr + \" at \" + parser.getPositionDescription()); &#125; &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; &#125; catch (NumberFormatException e) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; //【9】接下来设置其他的属性值。 if (packageSetting != null) &#123; packageSetting.uidError = \"true\".equals(uidError); packageSetting.installerPackageName = installerPackageName; packageSetting.isOrphaned = \"true\".equals(isOrphaned); packageSetting.volumeUuid = volumeUuid; packageSetting.legacyNativeLibraryPathString = legacyNativeLibraryPathStr; packageSetting.primaryCpuAbiString = primaryCpuAbiString; packageSetting.secondaryCpuAbiString = secondaryCpuAbiString; // Handle legacy string here for single-user mode final String enabledStr = parser.getAttributeValue(null, ATTR_ENABLED); if (enabledStr != null) &#123; try &#123; packageSetting.setEnabled(Integer.parseInt(enabledStr), 0 /* userId */, null); &#125; catch (NumberFormatException e) &#123; if (enabledStr.equalsIgnoreCase(\"true\")) &#123; packageSetting.setEnabled(COMPONENT_ENABLED_STATE_ENABLED, 0, null); &#125; else if (enabledStr.equalsIgnoreCase(\"false\")) &#123; packageSetting.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, 0, null); &#125; else if (enabledStr.equalsIgnoreCase(\"default\")) &#123; packageSetting.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, 0, null); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad enabled value: \" + idStr + \" at \" + parser.getPositionDescription()); &#125; &#125; &#125; else &#123; packageSetting.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, 0, null); &#125; if (installerPackageName != null) &#123; mInstallerPackages.add(installerPackageName); &#125; // package 安装状态！ final String installStatusStr = parser.getAttributeValue(null, \"installStatus\"); if (installStatusStr != null) &#123; if (installStatusStr.equalsIgnoreCase(\"false\")) &#123; packageSetting.installStatus = PackageSettingBase.PKG_INSTALL_INCOMPLETE; &#125; else &#123; packageSetting.installStatus = PackageSettingBase.PKG_INSTALL_COMPLETE; &#125; &#125; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); // Legacy if (tagName.equals(TAG_DISABLED_COMPONENTS)) &#123; //【8.1.1.3】解析 \"disabled-components\" readDisabledComponentsLPw(packageSetting, parser, 0); &#125; else if (tagName.equals(TAG_ENABLED_COMPONENTS)) &#123; //【8.1.1.3】解析 \"enabled-components\" readEnabledComponentsLPw(packageSetting, parser, 0); &#125; else if (tagName.equals(\"sigs\")) &#123; // 解析 \"sigs\" packageSetting.signatures.readXml(parser, mPastSignatures); &#125; else if (tagName.equals(TAG_PERMISSIONS)) &#123; // 解析 perms //【8.1.1.4】解析 \"perms\" 获得这个 package 的权限管理对象！ readInstallPermissionsLPr(parser, packageSetting.getPermissionsState()); packageSetting.installPermissionsFixed = true; &#125; else if (tagName.equals(\"proper-signing-keyset\")) &#123; long id = Long.parseLong(parser.getAttributeValue(null, \"identifier\")); Integer refCt = mKeySetRefs.get(id); if (refCt != null) &#123; mKeySetRefs.put(id, refCt + 1); &#125; else &#123; mKeySetRefs.put(id, 1); &#125; packageSetting.keySetData.setProperSigningKeySet(id); &#125; else if (tagName.equals(\"signing-keyset\")) &#123; // from v1 of keysetmanagerservice - no longer used &#125; else if (tagName.equals(\"upgrade-keyset\")) &#123; long id = Long.parseLong(parser.getAttributeValue(null, \"identifier\")); packageSetting.keySetData.addUpgradeKeySetById(id); &#125; else if (tagName.equals(\"defined-keyset\")) &#123; long id = Long.parseLong(parser.getAttributeValue(null, \"identifier\")); String alias = parser.getAttributeValue(null, \"alias\"); Integer refCt = mKeySetRefs.get(id); if (refCt != null) &#123; mKeySetRefs.put(id, refCt + 1); &#125; else &#123; mKeySetRefs.put(id, 1); &#125; packageSetting.keySetData.addDefinedKeySet(id, alias); &#125; else if (tagName.equals(TAG_DOMAIN_VERIFICATION)) &#123; // 解析 \"domain-verification\" readDomainVerificationLPw(parser, packageSetting); &#125; else if (tagName.equals(TAG_CHILD_PACKAGE)) &#123; // 解析 \"child-package\" String childPackageName = parser.getAttributeValue(null, ATTR_NAME); if (packageSetting.childPackageNames == null) &#123; packageSetting.childPackageNames = new ArrayList&lt;&gt;(); &#125; packageSetting.childPackageNames.add(childPackageName); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;package&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; &#125; else &#123; XmlUtils.skipCurrentTag(parser); &#125;&#125; 流程总结： 对于分配了独立的 uid 的 package，创建 PackageSetting 对象，添加到 mPackage 中，并且将自身和 uid 的引用关心保存到 mUsersId 或者 mOthersId 中； 对于分配了共享的 uid 的 package，创建 PendingPackage 对象，添加到 mPendingPackages 中，后续会对其共享 uid 的有效性进行校验！ 8.1.1.2 Settings.addPackageLPw123456789101112131415161718192021222324252627282930313233343536PackageSetting addPackageLPw(String name, String realName, File codePath, File resourcePath, String legacyNativeLibraryPathString, String primaryCpuAbiString, String secondaryCpuAbiString, String cpuAbiOverrideString, int uid, int vc, int pkgFlags, int pkgPrivateFlags, String parentPackageName, List&lt;String&gt; childPackageNames) &#123; //【1】根据 name 值从 mPackage 集合中查询 name 对应的 PackageSettings 对象。 PackageSetting p = mPackages.get(name); if (p != null) &#123; // 如果能得到，且两个 uid 相等，说明已经创建过了，那就直接返回！ if (p.appId == uid) &#123; return p; &#125; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate package, keeping first: \" + name); // 如果发现 uid 变化了，那就不会读取上一次的安装信息！ return null; &#125; //【2】否则，就创建一个 PackageSettings 对象来封装这个应用程序的信息。 p = new PackageSetting(name, realName, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, vc, pkgFlags, pkgPrivateFlags, parentPackageName, childPackageNames); //【3】他的 appid p.appId = uid; //【8.1.1.2.1】在系统中保留值为 uid 的 Linux 用户 ID，添加到 mUserIds 或者 mOtherUserIds 中！ if (addUserIdLPw(uid, p, name)) &#123; //【4.1】将这个 PackageSettings 对象保存在 Settings.mPackages 中！！ mPackages.put(name, p); return p; &#125; return null;&#125; 这里会调用 addUserIdLPw 方法，将 package 的 uid 进行封装，根据其范围，将其添加到 mUserIds 或者 mOtherUserIds 中！ 8.1.1.2.1 Settings.addUserIdLPw1234567891011121314151617181920212223242526272829303132333435363738394041private boolean addUserIdLPw(int uid, Object obj, Object name) &#123; //【1】当 uid &gt; Process.LAST_APPLICATION_UID 时，超过了系统给应用程序分配的 uid 的最大值，这是非法的 uid if (uid &gt; Process.LAST_APPLICATION_UID) &#123; return false; &#125; //【2】当 uid 介于 Process.FIRST_APPLICATION_UID 和 Process.LAST_APPLICATION_UID 之间时， // 说明这是保留给应用程序使用的。 if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; int N = mUserIds.size(); //【2.1】根据 uid 来计算在 idex！ final int index = uid - Process.FIRST_APPLICATION_UID; while (index &gt;= N) &#123; mUserIds.add(null); N++; &#125; if (mUserIds.get(index) != null) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate user id: \" + uid + \" name=\" + name); return false; &#125; //【2.2】把这个应用程序 PackageSettings 对象保存在这个列表中 mUserIds.set(index, obj); &#125; else &#123; //【2.3】当 uid &lt; Process.FIRST_APPLICATION_UID，说明是给系统使用的用户 id。 if (mOtherUserIds.get(uid) != null) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate shared id: \" + uid + \" name=\" + name); return false; &#125; //【2.4】同理 mOtherUserIds.put(uid, obj); &#125; return true;&#125; 到这里，我们解析 /data/system/packages.xml 里 “package” 标签对应的 xml 元素，对于 “package” 标签的子标签 “perms”，我们最后在再分析！ 8.1.1.3 解析 “disabled-components” / “enabled-component 子标签下面是解析可用和不可用组件的过程： 8.1.1.3.1 Settings.readDisabledComponentsLPw123456789101112131415161718192021222324252627private void readDisabledComponentsLPw(PackageSettingBase packageSetting, XmlPullParser parser, int userId) throws IOException, XmlPullParserException &#123; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // item 标签 String name = parser.getAttributeValue(null, ATTR_NAME); // 解析 name 属性 if (name != null) &#123; packageSetting.addDisabledComponent(name.intern(), userId); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;disabled-components&gt; has\" + \" no name at \" + parser.getPositionDescription()); &#125; &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;disabled-components&gt;: \" + parser.getName()); &#125; XmlUtils.skipCurrentTag(parser); &#125;&#125; 这里调用了 PackageSettingBase 的 addDisabledComponent 方法！123void addDisabledComponent(String componentClassName, int userId) &#123; modifyUserStateComponents(userId, true, false).disabledComponents.add(componentClassName);&#125; 这里要看下 PackageSettingBase 的 modifyUserStateComponents 方法！ 1234567891011PackageUserState modifyUserStateComponents(int userId, boolean disabled, boolean enabled) &#123; //【1】创建该 package 在当前 userId 下的 PackageUserState 对象！ PackageUserState state = modifyUserState(userId); if (disabled &amp;&amp; state.disabledComponents == null) &#123; state.disabledComponents = new ArraySet&lt;String&gt;(1); &#125; if (enabled &amp;&amp; state.enabledComponents == null) &#123; state.enabledComponents = new ArraySet&lt;String&gt;(1); &#125; return state;&#125; PackageSettingBase 有一个 userState 成员变量，用于保存该 package 在不同 userId 下的使用情况！1private final SparseArray&lt;PackageUserState&gt; userState = new SparseArray&lt;PackageUserState&gt;(); PackageSettingBase.modifyUserState 返回 userId 下该 package 的 PackageUserState 对象，若没还有就会创建新的！12345678private PackageUserState modifyUserState(int userId) &#123; PackageUserState state = userState.get(userId); if (state == null) &#123; state = new PackageUserState(); userState.put(userId, state); &#125; return state;&#125; PackageUserState 的属性如下，调用了默认的构造器，这里先不多说！1234567891011121314151617181920212223242526public class PackageUserState &#123; public long ceDataInode; public boolean installed; public boolean stopped; public boolean notLaunched; public boolean hidden; // Is the app restricted by owner / admin public boolean suspended; public boolean blockUninstall; public int enabled; public String lastDisableAppCaller; public int domainVerificationStatus; public int appLinkGeneration; public ArraySet&lt;String&gt; disabledComponents; // 保存不可用的组件 public ArraySet&lt;String&gt; enabledComponents; // 保存可用组件！ public PackageUserState() &#123; installed = true; hidden = false; suspended = false; enabled = COMPONENT_ENABLED_STATE_DEFAULT; domainVerificationStatus = PackageManager.INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED; &#125; ... ... ... ...&#125; 解析不可用组件的过程到这里就结束了！ 8.1.1.3.2 Settings.readEnabledComponentsLPw123456789101112131415161718192021222324252627private void readEnabledComponentsLPw(PackageSettingBase packageSetting, XmlPullParser parser, int userId) throws IOException, XmlPullParserException &#123; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // item 标签 String name = parser.getAttributeValue(null, ATTR_NAME); // 解析 name 属性 if (name != null) &#123; packageSetting.addEnabledComponent(name.intern(), userId); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;enabled-components&gt; has\" + \" no name at \" + parser.getPositionDescription()); &#125; &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;enabled-components&gt;: \" + parser.getName()); &#125; XmlUtils.skipCurrentTag(parser); &#125;&#125; 同样的，这里调用了 PackageSettingBase 的 addEnabledComponent 方法： 123void addEnabledComponent(String componentClassName, int userId) &#123; modifyUserStateComponents(userId, false, true).enabledComponents.add(componentClassName);&#125; 这里就不在分析了！ 8.1.1.4 解析 “perms” 子标签 - 解析安装时权限授予情况123456&lt;perms&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.INTERNET\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_NETWORK_STATE\" granted=\"true\" flags=\"0\" /&gt;&lt;/perms&gt; 对于 PackageSetting 和 SharedUserSetting 都有自己的权限管理对象 PermissionsState，用于保存和管理 package 和 SharedUser 所有的权限，其权限通过解析子标签 “perms” 获得，具体的解析方法是 readInstallPermissionsLPr！ 这里会涉及到一个对象，每一个 PackageSetting 对象都有一个 PermissionsState 对象，用于管理 package 的权限！1234567891011public class PermissionsState &#123; public static final int PERMISSION_OPERATION_FAILURE = -1; // 返回值：权限操作失败 public static final int PERMISSION_OPERATION_SUCCESS = 0; // 返回值：权限操作成功，gid 没有改变！ public static final int PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED = 1; // 返回值：权限操作成功，gid 改变！ private ArrayMap&lt;String, PermissionData&gt; mPermissions; // 用于封装这个应用程序的所有权限！ private int[] mGlobalGids = NO_GIDS; ... ... ...&#125; 我们继续分析： 8.1.1.4.1 Setting.readInstallPermissionsLPr参数传递： XmlPullParser parser：xml解析类对象，指向子标签 “perms” PermissionsState permissionsState：PackageSetting.getPermissionsState 或者 SharedUserSetting.getPermissionsState! 接着，调用了 readInstallPermissionsLPr 来解析 package 所使用的权限和其授予情况！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void readInstallPermissionsLPr(XmlPullParser parser, PermissionsState permissionsState) throws IOException, XmlPullParserException &#123; int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // 解析 \"item\" String name = parser.getAttributeValue(null, ATTR_NAME); // 接续 \"name\"，权限名称！ //【1】从之前解析的 Settings.mPermissions 获得对应的权限； BasePermission bp = mPermissions.get(name); if (bp == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown permission: \" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【2】解析 \"granted\" 标签，获得授予情况，如果没有该属性或者设置为 true，那么表示授予！ String grantedStr = parser.getAttributeValue(null, ATTR_GRANTED); final boolean granted = grantedStr == null || Boolean.parseBoolean(grantedStr); //【3】解析 \"flags\"标签 String flagsStr = parser.getAttributeValue(null, ATTR_FLAGS); final int flags = (flagsStr != null) ? Integer.parseInt(flagsStr, 16) : 0; //【4】处理权限授予情况！ if (granted) &#123; //【9.1】默认授予的情况！ if (permissionsState.grantInstallPermission(bp) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; Slog.w(PackageManagerService.TAG, \"Permission already added: \" + name); XmlUtils.skipCurrentTag(parser); &#125; else &#123; permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; else &#123; //【9.2】默认不授予的情况！ if (permissionsState.revokeInstallPermission(bp) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; Slog.w(PackageManagerService.TAG, \"Permission already added: \" + name); XmlUtils.skipCurrentTag(parser); &#125; else &#123; //【9.3】更新权限标志位！ permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;permissions&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; Settings.mPermissions 中保存的权限来自两部分，一个是 SystemConfig.mPermissions 中解析到了系统定义的权限，还有一部分，来自继续 packages.xml 中获得的权限信息！ 这里要简答的说下 flags 属性，其可以取一下的几个或者多个值： 1234567891011121314151617181920@SystemApipublic static final int FLAG_PERMISSION_USER_SET = 1 &lt;&lt; 0;@SystemApipublic static final int FLAG_PERMISSION_USER_FIXED = 1 &lt;&lt; 1;@SystemApipublic static final int FLAG_PERMISSION_POLICY_FIXED = 1 &lt;&lt; 2;@SystemApipublic static final int FLAG_PERMISSION_REVOKE_ON_UPGRADE = 1 &lt;&lt; 3;@SystemApipublic static final int FLAG_PERMISSION_SYSTEM_FIXED = 1 &lt;&lt; 4;@SystemApipublic static final int FLAG_PERMISSION_GRANTED_BY_DEFAULT = 1 &lt;&lt; 5;@SystemApipublic static final int FLAG_PERMISSION_REVIEW_REQUIRED = 1 &lt;&lt; 6; 这里简单的解释下这个这些 flags 的作用！ 8.1.2 解析 “permissions” “permission-trees” 标签我们先来看看 “permissions” 标签的内容，可以看到该标签的内容是：权限和定义权限的包名12345678910&lt;permissions&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" package=\"android\" protection=\"18\" /&gt; &lt;item name=\"android.permission.SEND_RECEIVE_STK_INTENT\" package=\"com.android.stk\" protection=\"2\" /&gt; &lt;item name=\"android.permission.ACCESS_CACHE_FILESYSTEM\" package=\"android\" protection=\"18\" /&gt; &lt;item name=\"android.permission.REMOTE_AUDIO_PLAYBACK\" package=\"android\" protection=\"2\" /&gt; &lt;item name=\"android.permission.DOWNLOAD_WITHOUT_NOTIFICATION\" package=\"com.android.providers.downloads\" /&gt; &lt;item name=\"android.permission.REGISTER_WINDOW_MANAGER_LISTENERS\" package=\"android\" protection=\"2\" /&gt; &lt;!----&gt;&lt;/permissions&gt; 下面是具体的解析过程，注意 “permissions” 的内容是最先解析的！ 对于 “permission-trees” 和 “permissions” 解析的方法都是 readPermissionsLPw，但是 permissions 的解析结果，会保存到 mPermissions 中，而 permission-trees 的解析结果，会保存到 mPermissionTrees 中； 8.1.2.1 Settings.readPermissionsLPw这里的 ArrayMap&lt;String, BasePermission&gt; out 分别是 Settings.permissions 和 Settings.mPermissionTrees： 12final ArrayMap&lt;String, BasePermission&gt; mPermissions = new ArrayMap&lt;String, BasePermission&gt;();final ArrayMap&lt;String, BasePermission&gt; mPermissionTrees = new ArrayMap&lt;String, BasePermission&gt;(); 下面我们来看看 readPermissionsLPw 方法的逻辑：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void readPermissionsLPw(ArrayMap&lt;String, BasePermission&gt; out, XmlPullParser parser) throws IOException, XmlPullParserException &#123; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; final String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // 解析 item 标签 final String name = parser.getAttributeValue(null, ATTR_NAME); // 获得 permission 的名称！ final String sourcePackage = parser.getAttributeValue(null, \"package\"); // 获得定义 permission 包名! final String ptype = parser.getAttributeValue(null, \"type\"); // 解析 type 类型！ if (name != null &amp;&amp; sourcePackage != null) &#123; final boolean dynamic = \"dynamic\".equals(ptype); //【1】尝试从 Settings 对应集合中获得权限 bp！ BasePermission bp = out.get(name); //【2】如果 bp 为 null 或者 // bp 不为 null 且其类型不是 BasePermission.TYPE_BUILTIN，就创建一个新的！ // BasePermission.TYPE_BUILTIN 类型的权限是系统权限，前面已经解析过！ // BasePermission.TYPE_DYNAMIC 类型是针对于权限树的类型的！ if (bp == null || bp.type != BasePermission.TYPE_BUILTIN) &#123; bp = new BasePermission(name.intern(), sourcePackage, dynamic ? BasePermission.TYPE_DYNAMIC : BasePermission.TYPE_NORMAL); &#125; //【3】获得定义 permission 的级别，默认为 PROTECTION_NORMAL，然后对保护级别修正! bp.protectionLevel = readInt(parser, null, \"protection\", PermissionInfo.PROTECTION_NORMAL); bp.protectionLevel = PermissionInfo.fixProtectionLevel(bp.protectionLevel); if (dynamic) &#123; //【3.1】如果是动态权限，进一步处理，动态权限会封装为 PermissionInfo！ // 动态权限是可以动态添加和移除的权限！通过权限树指定！ PermissionInfo pi = new PermissionInfo(); pi.packageName = sourcePackage.intern(); pi.name = name.intern(); pi.icon = readInt(parser, null, \"icon\", 0); pi.nonLocalizedLabel = parser.getAttributeValue(null, \"label\"); pi.protectionLevel = bp.protectionLevel; bp.pendingInfo = pi; &#125; //【4】封装成 BasePermission 保存到 mPermissions 集合中! out.put(bp.name, bp); &#125; else &#123; ... ... ... ... &#125; &#125; else &#123; ... ... ... ... &#125; XmlUtils.skipCurrentTag(parser); &#125;&#125; 所有的非动态权限信息最终都会被解析保存到 Setting.mPermissions 中了！！ 而动态权限信息会被保存在 Setting.mPermissionTrees 中了！！ 8.1.3 解析 “shared-user” 标签共享用户相关数据如下：1234567891011121314151617181920&lt;shared-user name=\"android.media\" userId=\"10014\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"3\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.WRITE_SETTINGS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.WRITE_MEDIA_STORAGE\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.INTERNET\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.MANAGE_USB\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.MANAGE_USERS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_NETWORK_STATE\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_MTP\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.READ_LOGS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.INTERACT_ACROSS_USERS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_WIFI_STATE\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"oppo.permission.OPPO_COMPONENT_SAFE\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.WAKE_LOCK\" granted=\"true\" flags=\"0\" /&gt; &lt;/perms&gt;&lt;/shared-user&gt; 8.1.3.1 Settings.readSharedUserLPw解析系统定义的共享用户 id：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private void readSharedUserLPw(XmlPullParser parser) throws XmlPullParserException,IOException &#123; String name = null; String idStr = null; int pkgFlags = 0; int pkgPrivateFlags = 0; SharedUserSetting su = null; try &#123; name = parser.getAttributeValue(null, ATTR_NAME); // 获得共享用户的名称 idStr = parser.getAttributeValue(null, \"userId\"); // 获得共享用户的id int userId = idStr != null ? Integer.parseInt(idStr) : 0; if (\"true\".equals(parser.getAttributeValue(null, \"system\"))) &#123; // 是否是系统的用户 id！ pkgFlags |= ApplicationInfo.FLAG_SYSTEM; &#125; if (name == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;shared-user&gt; has no name at \" + parser.getPositionDescription()); &#125; else if (userId == 0) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: shared-user \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; else &#123; //【8.1.3.2】调用 addSharedUserLPw 方法，将这个共享用户和对应的 uid 保存下来！ if ((su = addSharedUserLPw(name.intern(), userId, pkgFlags, pkgPrivateFlags)) == null) &#123; PackageManagerService .reportSettingsProblem(Log.ERROR, \"Occurred while parsing settings at \" + parser.getPositionDescription()); &#125; &#125; &#125; catch (NumberFormatException e) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; if (su != null) &#123; // 解析子标签！ int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"sigs\")) &#123; su.signatures.readXml(parser, mPastSignatures); &#125; else if (tagName.equals(\"perms\")) &#123; // 解析 \"perms\" 标签 //【8.1.1.3.1】解析共享用户的权限信息！ readInstallPermissionsLPr(parser, su.getPermissionsState()); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;shared-user&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; &#125; else &#123; XmlUtils.skipCurrentTag(parser); &#125;&#125; 8.1.3.2 Settings.addSharedUserLPw12345678910111213141516171819202122SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) &#123; // 创建共享用户对应的 SharedUserSetting 对象！ SharedUserSetting s = mSharedUsers.get(name); if (s != null) &#123; if (s.userId == uid) &#123; return s; &#125; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate shared user, keeping first: \" + name); return null; &#125; s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags); s.userId = uid; //【8.1.1.2.1】根据 uid 的范围，保存到 mUsersId 和 mOthersId 中！ if (addUserIdLPw(uid, s, name)) &#123; // 将其添加到 mSharedUsers 集合中！ mSharedUsers.put(name, s); return s; &#125; return null;&#125; 流程总结： 解析 “shared-user” ，将其分装成 SharedUserSetting 对象，保存到 mSharedUsers，并根据 uid 的取值将其保存到 mUserIds 或者 mOtherIds 中！ 解析 “shared-user” 子标签 “perm” 等等，解析共享用户的权限，每个权限对应一个 PermissionData 对象，保存进入 PermisssionState 中，用于管理共享用户的权限！ 8.1.4 解析 “preferred-activities” 相关标签8.1.4.1 Settings.readPreferredActivitiesLPw123456789101112131415161718192021222324252627282930void readPreferredActivitiesLPw(XmlPullParser parser, int userId) throws XmlPullParserException, IOException &#123; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // 创建 PreferredActivity 对象！ PreferredActivity pa = new PreferredActivity(parser); if (pa.mPref.getParseError() == null) &#123; editPreferredActivitiesLPw(userId).addFilter(pa); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;preferred-activity&gt; \" + pa.mPref.getParseError() + \" at \" + parser.getPositionDescription()); &#125; &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;preferred-activities&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 8.1.4.2 Settings.readPersistentPreferredActivitiesLPw1234567891011121314151617181920212223 private void readPersistentPreferredActivitiesLPw(XmlPullParser parser, int userId) throws XmlPullParserException, IOException &#123; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; //【1】创建 PersistentPreferredActivity 对象！ PersistentPreferredActivity ppa = new PersistentPreferredActivity(parser); editPersistentPreferredActivitiesLPw(userId).addFilter(ppa); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;\" + TAG_PERSISTENT_PREFERRED_ACTIVITIES + \"&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 不多说了！！ 8.1.5 解析 “updated-package” 标签我们来看看这个标签的内容，进行对比：1234567891011121314151617181920&lt;package name=\"com.android.xxxx\" codePath=\"/data/app/com.android.xxxx-1\" nativeLibraryPath=\"/data/app/com.android.xxxx-2/lib\" publicFlags=\"944258757\" privateFlags=\"0\" ft=\"15920cea638\" it=\"15920cea638\" ut=\"15920cea638\" version=\"1000\" userId=\"10053\" installer=\"com.android.packageinstaller\"&gt; &lt;perms&gt; &lt;!----&gt; &lt;/perms&gt;&lt;/package&gt;&lt;updated-package name=\"com.android.xxxx\" codePath=\"/data/app/com.android.xxxx-1\" ft=\"158ff005268\" it=\"158ff005268\" ut=\"158ff005268\" version=\"845\" nativeLibraryPath=\"/data/app/com.android.xxxx-1/lib\" userId=\"10053\"&gt; &lt;perms&gt; &lt;!----&gt; &lt;/perms&gt;&lt;/updated-package&gt; 接下里，我们去看看解析过程： 8.1.5.1 Settings.readDisabledSysPackageLPw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485private void readDisabledSysPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException &#123; String name = parser.getAttributeValue(null, ATTR_NAME); String realName = parser.getAttributeValue(null, \"realName\"); String codePathStr = parser.getAttributeValue(null, \"codePath\"); String resourcePathStr = parser.getAttributeValue(null, \"resourcePath\"); String legacyCpuAbiStr = parser.getAttributeValue(null, \"requiredCpuAbi\"); String legacyNativeLibraryPathStr = parser.getAttributeValue(null, \"nativeLibraryPath\"); String parentPackageName = parser.getAttributeValue(null, \"parentPackageName\"); String primaryCpuAbiStr = parser.getAttributeValue(null, \"primaryCpuAbi\"); String secondaryCpuAbiStr = parser.getAttributeValue(null, \"secondaryCpuAbi\"); String cpuAbiOverrideStr = parser.getAttributeValue(null, \"cpuAbiOverride\"); if (primaryCpuAbiStr == null &amp;&amp; legacyCpuAbiStr != null) &#123; primaryCpuAbiStr = legacyCpuAbiStr; &#125; if (resourcePathStr == null) &#123; resourcePathStr = codePathStr; &#125; String version = parser.getAttributeValue(null, \"version\"); int versionCode = 0; if (version != null) &#123; try &#123; versionCode = Integer.parseInt(version); &#125; catch (NumberFormatException e) &#123; &#125; &#125; int pkgFlags = 0; int pkgPrivateFlags = 0; pkgFlags |= ApplicationInfo.FLAG_SYSTEM; final File codePathFile = new File(codePathStr); if (PackageManagerService.locationIsPrivileged(codePathFile)) &#123; pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; // 封装成 PackageSetting 对象 PackageSetting ps = new PackageSetting(name, realName, codePathFile, new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiStr, secondaryCpuAbiStr, cpuAbiOverrideStr, versionCode, pkgFlags, pkgPrivateFlags, parentPackageName, null); // 获得时间戳，第一次安装时间，最后一次更新时间，省略！ ... ... ... ... // 处理其独立 uid 或者共享 uid 信息！ String idStr = parser.getAttributeValue(null, \"userId\"); ps.appId = idStr != null ? Integer.parseInt(idStr) : 0; if (ps.appId &lt;= 0) &#123; String sharedIdStr = parser.getAttributeValue(null, \"sharedUserId\"); ps.appId = sharedIdStr != null ? Integer.parseInt(sharedIdStr) : 0; &#125; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (parser.getName().equals(TAG_PERMISSIONS)) &#123; // 解析 \"perms\" 标签！ // ps.getPermissionsState() 是 package 的权限管理对象！ readInstallPermissionsLPr(parser, ps.getPermissionsState()); &#125; else if (parser.getName().equals(TAG_CHILD_PACKAGE)) &#123; String childPackageName = parser.getAttributeValue(null, ATTR_NAME); if (ps.childPackageNames == null) &#123; ps.childPackageNames = new ArrayList&lt;&gt;(); &#125; ps.childPackageNames.add(childPackageName); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;updated-package&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; //【1】保存到 mDisabledSysPackages 中！ mDisabledSysPackages.put(name, ps);&#125; 8.1.6 解析 “cleaning-package” 标签1234567891011121314151617181920&#125; else if (tagName.equals(\"cleaning-package\")) &#123; String name = parser.getAttributeValue(null, ATTR_NAME); String userStr = parser.getAttributeValue(null, ATTR_USER); String codeStr = parser.getAttributeValue(null, ATTR_CODE); if (name != null) &#123; int userId = UserHandle.USER_SYSTEM; boolean andCode = true; try &#123; if (userStr != null) &#123; userId = Integer.parseInt(userStr); &#125; &#125; catch (NumberFormatException e) &#123; &#125; if (codeStr != null) &#123; andCode = Boolean.parseBoolean(codeStr); &#125; // 创建一个 PackageCleanItem 对象！ addPackageToCleanLPw(new PackageCleanItem(userId, name, andCode)); &#125;&#125; 调用 addPackageToCleanLPw 方法；1234567void addPackageToCleanLPw(PackageCleanItem pkg) &#123; if (!mPackagesToBeCleaned.contains(pkg)) &#123; //【1】添加到 mPackagesToBeCleaned！ mPackagesToBeCleaned.add(pkg); &#125;&#125; 这个方法很简单！ 8.1.7 解析 “renamed-package” 标签1234567else if (tagName.equals(\"renamed-package\")) &#123; String nname = parser.getAttributeValue(null, \"new\"); String oname = parser.getAttributeValue(null, \"old\"); if (nname != null &amp;&amp; oname != null) &#123; mRenamedPackages.put(nname, oname); &#125;&#125; 代码很简单，将重新命名的应用的数据，key 为 新名字。value 为旧名字，添加到 mRenamedPackages 中！ 8.1.8 阶段总结我们来用一张图总结一下，PermissionsState 和 PackageSetting，SharedUserSetting 的关系！![未命名文件.png-59.5kB][3] 如果 pacakge 是共享用户 id，那么所有 uid 为共享用户 id 的 package，其权限是一样的，都是共享用户的权限; 如果 pacakge 是独立用户 id，那么这个 package 有自己独立的权限！ 8.2 确定共享 uid 有效性主要逻辑如下：1234567891011121314151617181920212223242526272829303132333435363738394041//【1】对 mPendingPackages 集合中的需要验证共享用户 id 有效性的 package，进行共享用户 id 有效性的验证!final int N = mPendingPackages.size();for (int i = 0; i &lt; N; i++) &#123; final PendingPackage pp = mPendingPackages.get(i); //【8.2.1】看 sharedId 是否能对应找到一个 ShardUserSetting 对象! Object idObj = getUserIdLPr(pp.sharedId); if (idObj != null &amp;&amp; idObj instanceof SharedUserSetting) &#123; // 能找到，说明共享用户 ID 是有效的! //【8.2.2】创建 PackageSetting！ PackageSetting p = getPackageLPw(pp.name, null, pp.realName, (SharedUserSetting) idObj, pp.codePath, pp.resourcePath, pp.legacyNativeLibraryPathString, pp.primaryCpuAbiString, pp.secondaryCpuAbiString, pp.versionCode, pp.pkgFlags, pp.pkgPrivateFlags, null, true /* add */, false /* allowInstall */, pp.parentPackageName, pp.childPackageNames); if (p == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unable to create application package for \" + pp.name); continue; &#125; // 将 PendingPackage 的其他数据拷贝到 PackageSetting 中！ p.copyFrom(pp); &#125; else if (idObj != null) &#123; String msg = \"Bad package setting: package \" + pp.name + \" has shared uid \" + pp.sharedId + \" that is not a shared uid\\n\"; mReadMessages.append(msg); PackageManagerService.reportSettingsProblem(Log.ERROR, msg); &#125; else &#123; String msg = \"Bad package setting: package \" + pp.name + \" has shared uid \" + pp.sharedId + \" that is not defined\\n\"; mReadMessages.append(msg); PackageManagerService.reportSettingsProblem(Log.ERROR, msg); &#125;&#125;mPendingPackages.clear(); // 清空 mPendingPackages 这里调用 getUserIdLPr 来从 mUserIds 或 mOtherUserIds 中获得一个共享用户对象！ 8.2.1 Settings.getUserIdLPr获得指定 uid 对应的 Object，可能是一个 PackageSetting 或者是 SharedUserSetting！1234567891011public Object getUserIdLPr(int uid) &#123; if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; final int N = mUserIds.size(); final int index = uid - Process.FIRST_APPLICATION_UID; return index &lt; N ? mUserIds.get(index) : null; &#125; else &#123; return mOtherUserIds.get(uid); &#125;&#125; 之前在分析解析 “shared-user” 的时候，就知道 SharedUserSetting 会被保存到这两个几个当中的，这里就不多说了！ 接着，调用 getPackageLPw 方法来创建这个 PendingPackage 对应的 PackageSetting 对象！ 8.2.2 Settings.getPackageLPw参数传递： PackageSetting origPackage：表示源包，传入 null； SharedUserSetting sharedUser：共享 uid 对象，这里是不为 null！ UserHandle installUser：为 null； add：true； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798private PackageSetting getPackageLPw(String name, PackageSetting origPackage, String realName, SharedUserSetting sharedUser, File codePath, File resourcePath, String legacyNativeLibraryPathString, String primaryCpuAbiString, String secondaryCpuAbiString, int vc, int pkgFlags, int pkgPrivateFlags, UserHandle installUser, boolean add, boolean allowInstall, String parentPackage, List&lt;String&gt; childPackageNames) &#123; PackageSetting p = mPackages.get(name); //【1】看是否之前有添加过这个包！ UserManagerService userManager = UserManagerService.getInstance(); if (p != null) &#123; ... ... ...// 如果已经添加了，这显然是不可能的，这里不会走这个分支！ &#125; if (p == null) &#123; //【2】之前没有添加过，那就需要创建新的 PackageSetting 对象! if (origPackage != null) &#123; ... ... ... ... ...// 如果有原包的话，这里不进入这个发分支！ &#125; else &#123; //【3】如果这个 package 没有原包的话，就以参数 name 为包名，创建 PackageSetting 对象。 p = new PackageSetting(name, realName, codePath, resourcePath, legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString, null /* cpuAbiOverrideString */, vc, pkgFlags, pkgPrivateFlags, parentPackage, childPackageNames); p.setTimeStamp(codePath.lastModified()); //【4】设置其 sharedUser 属性，因为它是共享 uid 的！ p.sharedUser = sharedUser; //【5】如果是非系统的应用，设置他在每个设备用户下的安装状态！ if ((pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; if (DEBUG_STOPPED) &#123; RuntimeException e = new RuntimeException(\"here\"); e.fillInStackTrace(); Slog.i(PackageManagerService.TAG, \"Stopping package \" + name, e); &#125; List&lt;UserInfo&gt; users = getAllUsers(); final int installUserId = installUser != null ? installUser.getIdentifier() : 0; if (users != null &amp;&amp; allowInstall) &#123; for (UserInfo user : users) &#123; final boolean installed = installUser == null || (installUserId == UserHandle.USER_ALL &amp;&amp; !isAdbInstallDisallowed(userManager, user.id)) || installUserId == user.id; p.setUserState(user.id, 0, COMPONENT_ENABLED_STATE_DEFAULT, installed, true, // stopped, true, // notLaunched false, // hidden false, // suspended null, null, null, false, // blockUninstall INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0); writePackageRestrictionsLPr(user.id); &#125; &#125; &#125; //【6】设置他的 appId，在默认设备用户下，appId 等于 uid！ if (sharedUser != null) &#123; p.appId = sharedUser.userId; &#125; else &#123; ... ... ... ...// 根据前面的分析，显然 sharedUser 不为 null，不进入这个分支！ &#125; &#125; if (p.appId &lt; 0) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Package \" + name + \" could not be assigned a valid uid\"); return null; &#125; if (add) &#123; //【7】add 为 true，进入这个分支： // 将确定了共享用户 id 的 PackageSetting 对象，添加到 mPackages 中！ addPackageSettingLPw(p, name, sharedUser); &#125; &#125; else &#123; ... ... ... // 这个分支也不走！ &#125; return p;&#125; 继续看： 8.2.2.1 Settings.addPackageSettingLPw将确定了共享用户 id 的 PackageSetting 对象，添加到 mPackages 中！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void addPackageSettingLPw(PackageSetting p, String name, SharedUserSetting sharedUser) &#123; //【1】添加到 mPackages 中！ mPackages.put(name, p); if (sharedUser != null) &#123; // 进入这里！ if (p.sharedUser != null &amp;&amp; p.sharedUser != sharedUser) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Package \" + p.name + \" was user \" + p.sharedUser + \" but is now \" + sharedUser + \"; I am not changing its files so it will probably fail!\"); p.sharedUser.removePackage(p); &#125; else if (p.appId != sharedUser.userId) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Package \" + p.name + \" was user id \" + p.appId + \" but is now user \" + sharedUser + \" with id \" + sharedUser.userId + \"; I am not changing its files so it will probably fail!\"); &#125; // 确保 sharedUser 和 PackageSetting 相互引用正确！ sharedUser.addPackage(p); p.sharedUser = sharedUser; p.appId = sharedUser.userId; &#125; //【2】获得这个 package 对应的 SharedUserSetting 对象！ Object userIdPs = getUserIdLPr(p.appId); if (sharedUser == null) &#123; //【2.1】如果 sharedUser 为 null，说明共享用户无效，那就将创建的 PackageSetting 添加进来！ if (userIdPs != null &amp;&amp; userIdPs != p) &#123; replaceUserIdLPw(p.appId, p); &#125; &#125; else &#123; //【2.2】进入这个分支： if (userIdPs != null &amp;&amp; userIdPs != sharedUser) &#123; // 更新 uid 和 SharedUserSetting 的关系！ replaceUserIdLPw(p.appId, sharedUser); &#125; &#125; IntentFilterVerificationInfo ivi = mRestoredIntentFilterVerifications.get(name); if (ivi != null) &#123; if (DEBUG_DOMAIN_VERIFICATION) &#123; Slog.i(TAG, \"Applying restored IVI for \" + name + \" : \" + ivi.getStatusString()); &#125; mRestoredIntentFilterVerifications.remove(name); p.setIntentFilterVerificationInfo(ivi); &#125;&#125; 下面是 replaceUserIdLPw 方法：1234567891011 private void replaceUserIdLPw(int uid, Object obj) &#123; if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; final int N = mUserIds.size(); final int index = uid - Process.FIRST_APPLICATION_UID; if (index &lt; N) mUserIds.set(index, obj); &#125; else &#123; mOtherUserIds.put(uid, obj); &#125;&#125; 8.3 读取 packages_stopped.xml 文件，偏好设置代码段如下： 12345678910111213if (mBackupStoppedPackagesFilename.exists() || mStoppedPackagesFilename.exists()) &#123; // Read old file readStoppedLPw(); mBackupStoppedPackagesFilename.delete(); mStoppedPackagesFilename.delete(); // Migrate to new file format writePackageRestrictionsLPr(UserHandle.USER_SYSTEM);&#125; else &#123; for (UserInfo user : users) &#123; readPackageRestrictionsLPr(user.id); &#125;&#125; 读取 packages_stopped.xml 文件调用的是 readStoppedLPw 方法： 8.3.1 Settings.readStoppedLPw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899void readStoppedLPw() &#123; FileInputStream str = null; //【1】如果 packages-stopped-backup.xml 文件存在，就读取它！ if (mBackupStoppedPackagesFilename.exists()) &#123; try &#123; str = new FileInputStream(mBackupStoppedPackagesFilename); mReadMessages.append(\"Reading from backup stopped packages file\\n\"); PackageManagerService.reportSettingsProblem(Log.INFO, \"Need to read from backup stopped packages file\"); if (mSettingsFilename.exists()) &#123; Slog.w(PackageManagerService.TAG, \"Cleaning up stopped packages file \" + mStoppedPackagesFilename); //【1.1】如果，两个文件都存在，使用 back_up 文件，删掉 packages-stopped.xml 文件！ mStoppedPackagesFilename.delete(); &#125; &#125; catch (java.io.IOException e) &#123; // We'll try for the normal settings file. &#125; &#125; //【2】如果 packages-stopped-backup.xml 文件不存在，就读取 packages-stopped.xml 文件！ try &#123; if (str == null) &#123; if (!mStoppedPackagesFilename.exists()) &#123; ... ... ...// log //【2.1】如果 packages-stopped.xml 也不存在，说明没有 package 处于 stop 状态； // 同时，第一次开机，所有的 package 也都不会处于 stop 状态！ for (PackageSetting pkg : mPackages.values()) &#123; pkg.setStopped(false, 0); // 没有被 stop！ pkg.setNotLaunched(false, 0); // 也没有被启动过！ &#125; return; &#125; str = new FileInputStream(mStoppedPackagesFilename); &#125; final XmlPullParser parser = Xml.newPullParser(); parser.setInput(str, null); int type; while ((type=parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; ; &#125; if (type != XmlPullParser.START_TAG) &#123; mReadMessages.append(\"No start tag found in stopped packages file\\n\"); PackageManagerService.reportSettingsProblem(Log.WARN, \"No start tag found in package manager stopped packages\"); return; &#125; //【3】开始解析！ int outerDepth = parser.getDepth(); while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); //【3.1】解析 stop 的 package 数据！ if (tagName.equals(TAG_PACKAGE)) &#123; String name = parser.getAttributeValue(null, ATTR_NAME); // 解析 \"name\" 标签 // 从之前安装的 mPackages 中，获得包名为 name 的 package 数据！ PackageSetting ps = mPackages.get(name); if (ps != null) &#123; //【3.1.1】设置 stopped 属性！ ps.setStopped(true, 0); if (\"1\".equals(parser.getAttributeValue(null, ATTR_NOT_LAUNCHED))) &#123; // 解析 \"nl\" 标签 //【3.1.2】设置 notLaunched 属性！ ps.setNotLaunched(true, 0); &#125; &#125; else &#123; Slog.w(PackageManagerService.TAG, \"No package known for stopped package \" + name); &#125; XmlUtils.skipCurrentTag(parser); &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;stopped-packages&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; str.close(); &#125; catch (XmlPullParserException e) &#123; ... ... ... ... &#125; catch (java.io.IOException e) &#123; ... ... ... ... &#125;&#125; 这个过程很简单，解析 packages-stopped-backup.xml 或 packages-stopped.xml 文件，设置 package 的 stopped 和 notLaunched 属性！ 8.3.2 Settings.writePackageRestrictionsLPrwritePackageRestrictionsLPr 方法用户保存用户对于系统应用的一些偏好设置，通过获得 package 在指定用户下的状态信息，我们就知道那些应用被 stop，那些应用被 hidden 等等！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141void writePackageRestrictionsLPr(int userId) &#123; if (DEBUG_MU) &#123; Log.i(TAG, \"Writing package restrictions for user=\" + userId); &#125; // 获得 data/system/users/0/package-restrictions.xml 文件对象！ File userPackagesStateFile = getUserPackagesStateFile(userId); // 获得 data/system/users/0/package-restrictions-backup.xml 文件对象！ File backupFile = getUserPackagesStateBackupFile(userId); new File(userPackagesStateFile.getParent()).mkdirs(); // 如果备份文件不存在的话，那么我们会现将 package-restrictions.xml 备份再操作！ if (userPackagesStateFile.exists()) &#123; if (!backupFile.exists()) &#123; if (!userPackagesStateFile.renameTo(backupFile)) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to backup user packages state file, \" + \"current changes will be lost at reboot\"); return; &#125; &#125; else &#123; userPackagesStateFile.delete(); Slog.w(PackageManagerService.TAG, \"Preserving older stopped packages backup\"); &#125; &#125; // 开始解析 xml 文件！ try &#123; final FileOutputStream fstr = new FileOutputStream(userPackagesStateFile); final BufferedOutputStream str = new BufferedOutputStream(fstr); final XmlSerializer serializer = new FastXmlSerializer(); serializer.setOutput(str, StandardCharsets.UTF_8.name()); serializer.startDocument(null, true); serializer.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); serializer.startTag(null, TAG_PACKAGE_RESTRICTIONS); // \"package-restrictions\" 标签 for (final PackageSetting pkg : mPackages.values()) &#123; final PackageUserState ustate = pkg.readUserState(userId); if (DEBUG_MU) Log.i(TAG, \" pkg=\" + pkg.name + \", state=\" + ustate.enabled); serializer.startTag(null, TAG_PACKAGE); // pkg 标签 serializer.attribute(null, ATTR_NAME, pkg.name); // name 属性 if (ustate.ceDataInode != 0) &#123; XmlUtils.writeLongAttribute(serializer, ATTR_CE_DATA_INODE, ustate.ceDataInode); &#125; if (!ustate.installed) &#123; serializer.attribute(null, ATTR_INSTALLED, \"false\"); // inst 属性 &#125; if (ustate.stopped) &#123; serializer.attribute(null, ATTR_STOPPED, \"true\"); // stopped 属性 &#125; if (ustate.notLaunched) &#123; serializer.attribute(null, ATTR_NOT_LAUNCHED, \"true\"); // nl 属性 &#125; if (ustate.hidden) &#123; serializer.attribute(null, ATTR_HIDDEN, \"true\"); // hidden 属性 &#125; if (ustate.suspended) &#123; serializer.attribute(null, ATTR_SUSPENDED, \"true\"); // suspended 属性 &#125; if (ustate.blockUninstall) &#123; serializer.attribute(null, ATTR_BLOCK_UNINSTALL, \"true\"); // blockUninstall 属性 &#125; if (ustate.enabled != COMPONENT_ENABLED_STATE_DEFAULT) &#123; // 包默认是否可用 serializer.attribute(null, ATTR_ENABLED, // enabled 属性 Integer.toString(ustate.enabled)); if (ustate.lastDisableAppCaller != null) &#123; serializer.attribute(null, ATTR_ENABLED_CALLER, // enabledCaller 属性 ustate.lastDisableAppCaller); &#125; &#125; if (ustate.domainVerificationStatus != PackageManager.INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED) &#123; XmlUtils.writeIntAttribute(serializer, ATTR_DOMAIN_VERIFICATON_STATE, ustate.domainVerificationStatus); &#125; if (ustate.appLinkGeneration != 0) &#123; XmlUtils.writeIntAttribute(serializer, ATTR_APP_LINK_GENERATION, ustate.appLinkGeneration); &#125; if (!ArrayUtils.isEmpty(ustate.enabledComponents)) &#123; // 可用组件 serializer.startTag(null, TAG_ENABLED_COMPONENTS); for (final String name : ustate.enabledComponents) &#123; serializer.startTag(null, TAG_ITEM); serializer.attribute(null, ATTR_NAME, name); serializer.endTag(null, TAG_ITEM); &#125; serializer.endTag(null, TAG_ENABLED_COMPONENTS); &#125; if (!ArrayUtils.isEmpty(ustate.disabledComponents)) &#123; // 不可用组件 serializer.startTag(null, TAG_DISABLED_COMPONENTS); for (final String name : ustate.disabledComponents) &#123; serializer.startTag(null, TAG_ITEM); serializer.attribute(null, ATTR_NAME, name); serializer.endTag(null, TAG_ITEM); &#125; serializer.endTag(null, TAG_DISABLED_COMPONENTS); &#125; serializer.endTag(null, TAG_PACKAGE); &#125; // 接下来会处理默认应用的处理，这里先不看！ writePreferredActivitiesLPr(serializer, userId, true); writePersistentPreferredActivitiesLPr(serializer, userId); writeCrossProfileIntentFiltersLPr(serializer, userId); writeDefaultAppsLPr(serializer, userId); serializer.endTag(null, TAG_PACKAGE_RESTRICTIONS); serializer.endDocument(); str.flush(); FileUtils.sync(fstr); str.close(); // 删除备份文件，并设置主文件的权限！ backupFile.delete(); FileUtils.setPermissions(userPackagesStateFile.toString(), FileUtils.S_IRUSR|FileUtils.S_IWUSR |FileUtils.S_IRGRP|FileUtils.S_IWGRP, -1, -1); // Done, all is good! return; &#125; catch(java.io.IOException e) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to write package manager user packages state, \" + \" current changes will be lost at reboot\", e); &#125; // 异常情况，清除偏好设置文件！ if (userPackagesStateFile.exists()) &#123; if (!userPackagesStateFile.delete()) &#123; Log.i(PackageManagerService.TAG, \"Failed to clean up mangled file: \" + mStoppedPackagesFilename); &#125; &#125;&#125; 我们来看下偏好设置的 xml 的内容！ 123456789101112131415161718192021222324&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;package-restrictions&gt; &lt;pkg name=\"com.papapa.activation\" ceDataInode=\"3940\"&gt; &lt;disabled-components&gt; &lt;item name=\"com.papapa.activation.BootReceiver\" /&gt; &lt;/disabled-components&gt; &lt;/pkg&gt; &lt;preferred-activities&gt; &lt;item name=\"com.android.mms/.ui.ComposeMessageActivity\" match=\"200000\" always=\"true\" set=\"1\"&gt; &lt;set name=\"com.android.mms/.ui.ComposeMessageActivity\" /&gt; &lt;filter&gt; &lt;action name=\"android.intent.action.SENDTO\" /&gt; &lt;cat name=\"android.intent.category.DEFAULT\" /&gt; &lt;scheme name=\"mmsto\" /&gt; &lt;/filter&gt; &lt;/item&gt; &lt;/preferred-activities&gt; &lt;persistent-preferred-activities /&gt; &lt;crossProfile-intent-filters /&gt; &lt;default-apps&gt; &lt;default-dialer packageName=\"com.android.contacts\" /&gt; &lt;/default-apps&gt;&lt;/package-restrictions&gt; 这里只列出了一部分的内容，其他的很类似，不再多说！ 8.3.3 Settings.readPackageRestrictionsLPr该方法用于读取已有的偏好设置，更新 package 安装的信息！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180void readPackageRestrictionsLPr(int userId) &#123; if (DEBUG_MU) &#123; Log.i(TAG, \"Reading package restrictions for user=\" + userId); &#125; FileInputStream str = null; // 同样的，获得 data/system/users/0/package-restrictions.xml 和 // data/system/users/0/package-restrictions-backup.xml 文件对象！ File userPackagesStateFile = getUserPackagesStateFile(userId); File backupFile = getUserPackagesStateBackupFile(userId); // 优先从 backupFile 读取，如果两个文件都存在，那就会删除非备份文件！ if (backupFile.exists()) &#123; try &#123; str = new FileInputStream(backupFile); mReadMessages.append(\"Reading from backup stopped packages file\\n\"); PackageManagerService.reportSettingsProblem(Log.INFO, \"Need to read from backup stopped packages file\"); if (userPackagesStateFile.exists()) &#123; Slog.w(PackageManagerService.TAG, \"Cleaning up stopped packages file \" + userPackagesStateFile); userPackagesStateFile.delete(); &#125; &#125; catch (java.io.IOException e) &#123; // We'll try for the normal settings file. &#125; &#125; try &#123; if (str == null) &#123; if (!userPackagesStateFile.exists()) &#123; mReadMessages.append(\"No stopped packages file found\\n\"); PackageManagerService.reportSettingsProblem(Log.INFO, \"No stopped packages file; \" + \"assuming all started\"); // 对于第一次启动，这里会初始化操作，并返回！！ for (PackageSetting pkg : mPackages.values()) &#123; pkg.setUserState(userId, 0, COMPONENT_ENABLED_STATE_DEFAULT, true, // installed false, // stopped false, // notLaunched false, // hidden false, // suspended null, null, null, false, // blockUninstall INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED, 0); &#125; return; &#125; str = new FileInputStream(userPackagesStateFile); &#125; final XmlPullParser parser = Xml.newPullParser(); parser.setInput(str, StandardCharsets.UTF_8.name()); int type; while ((type=parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; ; &#125; if (type != XmlPullParser.START_TAG) &#123; mReadMessages.append(\"No start tag found in package restrictions file\\n\"); PackageManagerService.reportSettingsProblem(Log.WARN, \"No start tag found in package manager stopped packages\"); return; &#125; int maxAppLinkGeneration = 0; int outerDepth = parser.getDepth(); PackageSetting ps = null; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; //【1】解析 pkg 标签的属性！ String tagName = parser.getName(); if (tagName.equals(TAG_PACKAGE)) &#123; String name = parser.getAttributeValue(null, ATTR_NAME); ps = mPackages.get(name); if (ps == null) &#123; Slog.w(PackageManagerService.TAG, \"No package known for stopped package \" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; final long ceDataInode = XmlUtils.readLongAttribute(parser, ATTR_CE_DATA_INODE, 0); final boolean installed = XmlUtils.readBooleanAttribute(parser, ATTR_INSTALLED, true); final boolean stopped = XmlUtils.readBooleanAttribute(parser, ATTR_STOPPED, false); final boolean notLaunched = XmlUtils.readBooleanAttribute(parser, ATTR_NOT_LAUNCHED, false); // For backwards compatibility with the previous name of \"blocked\", which // now means hidden, read the old attribute as well. final String blockedStr = parser.getAttributeValue(null, ATTR_BLOCKED); boolean hidden = blockedStr == null ? false : Boolean.parseBoolean(blockedStr); final String hiddenStr = parser.getAttributeValue(null, ATTR_HIDDEN); hidden = hiddenStr == null ? hidden : Boolean.parseBoolean(hiddenStr); final boolean suspended = XmlUtils.readBooleanAttribute(parser, ATTR_SUSPENDED, false); final boolean blockUninstall = XmlUtils.readBooleanAttribute(parser, ATTR_BLOCK_UNINSTALL, false); final int enabled = XmlUtils.readIntAttribute(parser, ATTR_ENABLED, COMPONENT_ENABLED_STATE_DEFAULT); final String enabledCaller = parser.getAttributeValue(null, ATTR_ENABLED_CALLER); final int verifState = XmlUtils.readIntAttribute(parser, ATTR_DOMAIN_VERIFICATON_STATE, PackageManager.INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_UNDEFINED); final int linkGeneration = XmlUtils.readIntAttribute(parser, ATTR_APP_LINK_GENERATION, 0); if (linkGeneration &gt; maxAppLinkGeneration) &#123; maxAppLinkGeneration = linkGeneration; &#125; ArraySet&lt;String&gt; enabledComponents = null; ArraySet&lt;String&gt; disabledComponents = null; int packageDepth = parser.getDepth(); while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; packageDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; tagName = parser.getName(); if (tagName.equals(TAG_ENABLED_COMPONENTS)) &#123; enabledComponents = readComponentsLPr(parser); &#125; else if (tagName.equals(TAG_DISABLED_COMPONENTS)) &#123; disabledComponents = readComponentsLPr(parser); &#125; &#125; //【2】通过解析到的偏好设置，来更新安装的 package 的信息！ ps.setUserState(userId, ceDataInode, enabled, installed, stopped, notLaunched, hidden, suspended, enabledCaller, enabledComponents, disabledComponents, blockUninstall, verifState, linkGeneration); &#125; else if (tagName.equals(\"preferred-activities\")) &#123; // 解析默认应用的属性！ readPreferredActivitiesLPw(parser, userId); &#125; else if (tagName.equals(TAG_PERSISTENT_PREFERRED_ACTIVITIES)) &#123; readPersistentPreferredActivitiesLPw(parser, userId); &#125; else if (tagName.equals(TAG_CROSS_PROFILE_INTENT_FILTERS)) &#123; readCrossProfileIntentFiltersLPw(parser, userId); &#125; else if (tagName.equals(TAG_DEFAULT_APPS)) &#123; readDefaultAppsLPw(parser, userId); &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;stopped-packages&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; str.close(); mNextAppLinkGeneration.put(userId, maxAppLinkGeneration + 1); &#125; catch (XmlPullParserException e) &#123; mReadMessages.append(\"Error reading: \" + e.toString()); PackageManagerService.reportSettingsProblem(Log.ERROR, \"Error reading stopped packages: \" + e); Slog.wtf(PackageManagerService.TAG, \"Error reading package manager stopped packages\", e); &#125; catch (java.io.IOException e) &#123; mReadMessages.append(\"Error reading: \" + e.toString()); PackageManagerService.reportSettingsProblem(Log.ERROR, \"Error reading settings: \" + e); Slog.wtf(PackageManagerService.TAG, \"Error reading package manager stopped packages\", e); &#125;&#125; 逻辑很简单，我们就不多说了！ 8.4 读取运行时权限信息，并处理授予情况！1234//【8.4】读取每个 user 下的运行是权限信息！for (UserInfo user : users) &#123; mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id);&#125; mRuntimePermissionsPersistence 对象我们前面介绍过，其专门用于处理运行时权限！ 8.4.1 RuntimePermissionsPersistence.readStateForUserSyncLPr该方法会读取指定的 userId 下的运行时权限信息！ 12345678910111213141516171819202122232425262728public void readStateForUserSyncLPr(int userId) &#123; //【1】获得运行时权限文件对象！ File permissionsFile = getUserRuntimePermissionsFile(userId); if (!permissionsFile.exists()) &#123; return; &#125; FileInputStream in; try &#123; in = new AtomicFile(permissionsFile).openRead(); &#125; catch (FileNotFoundException fnfe) &#123; Slog.i(PackageManagerService.TAG, \"No permissions state\"); return; &#125; try &#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(in, null); // 解析运行时权限数据！ parseRuntimePermissionsLPr(parser, userId); &#125; catch (XmlPullParserException | IOException e) &#123; throw new IllegalStateException(\"Failed parsing permissions file: \" + permissionsFile , e); &#125; finally &#123; IoUtils.closeQuietly(in); &#125;&#125; 首先，会获得保存了运行时权限的文件对象！1234private File getUserRuntimePermissionsFile(int userId) &#123; File userDir = new File(new File(mSystemDir, \"users\"), Integer.toString(userId)); return new File(userDir, RUNTIME_PERMISSIONS_FILE_NAME);&#125; 该文件位于 /data/system/users/0/runtime-permissions.xml，和偏好设置的文件位于同一个目录下，我们来简单的看下该文件的具体内容： 123456789101112131415&lt;?xml version='1.0' encoding='UTF-8' standalone='yes' ?&gt;&lt;runtime-permissions fingerprint=\"OPPO/R11s/R11s:8.1.0/OPM1.171019.011/1519198279:user/release-keys\"&gt; &lt;pkg name=\"com.sohu.inputmethod.sogouoem\"&gt; &lt;item name=\"android.permission.ACCESS_FINE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.READ_EXTERNAL_STORAGE\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.ACCESS_COARSE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; ... ... ... &lt;/pkg&gt; &lt;shared-user name=\"android.uid.calendar\"&gt; &lt;item name=\"android.permission.READ_CALENDAR\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.ACCESS_FINE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.READ_EXTERNAL_STORAGE\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.ACCESS_COARSE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; ... ... ...&lt;/runtime-permissions&gt; 8.4.2 Settings.parseRuntimePermissionsLPr用于解析运行时权限文件，获得运行时权限相关的信息！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void parseRuntimePermissionsLPr(XmlPullParser parser, int userId) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; switch (parser.getName()) &#123; case TAG_RUNTIME_PERMISSIONS: &#123; // runtime-permissions 标签 String fingerprint = parser.getAttributeValue(null, ATTR_FINGERPRINT); // fingerprint 属性 mFingerprints.put(userId, fingerprint); // 保存 fingerprint 到 mFingerprints 中！ // 然后判断是否对该设备用户授予默认的权限，添加到 mDefaultPermissionsGranted 中！ final boolean defaultsGranted = Build.FINGERPRINT.equals(fingerprint); mDefaultPermissionsGranted.put(userId, defaultsGranted); &#125; break; case TAG_PACKAGE: &#123; //【1】pkg 标签 String name = parser.getAttributeValue(null, ATTR_NAME); PackageSetting ps = mPackages.get(name); if (ps == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown package:\" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【8.4.2.1】解析并处理 package 的运行时权限授予情况！ parsePermissionsLPr(parser, ps.getPermissionsState(), userId); &#125; break; case TAG_SHARED_USER: &#123; //【2】shared-user 标签 String name = parser.getAttributeValue(null, ATTR_NAME); SharedUserSetting sus = mSharedUsers.get(name); if (sus == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown shared user:\" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【8.4.2.1】解析并处理 shared-user 的运行时权限授予情况！ parsePermissionsLPr(parser, sus.getPermissionsState(), userId); &#125; break; case TAG_RESTORED_RUNTIME_PERMISSIONS: &#123; //【3】restored-perms 标签 //【3.1】解析要被恢复的权限所属的应用包名！ final String pkgName = parser.getAttributeValue(null, ATTR_PACKAGE_NAME); //【8.4.2.2】解析 restored-perms! parseRestoredRuntimePermissionsLPr(parser, pkgName, userId); &#125; break; &#125; &#125;&#125; 这个过程主要工作： 解析并处理 package 的运行时权限授予情况； 解析并处理 shared-user 的运行时权限授予情况； 8.4.2.1 Settings.parsePermissionsLPr我们来看下 parsePermissionsLPr 是如何解析和处理运行时权限的！1234567891011121314151617181920212223242526272829303132333435363738394041424344private void parsePermissionsLPr(XmlPullParser parser, PermissionsState permissionsState, int userId) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; switch (parser.getName()) &#123; case TAG_ITEM: &#123; String name = parser.getAttributeValue(null, ATTR_NAME); // name 属性！ BasePermission bp = mPermissions.get(name); if (bp == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown permission:\" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; String grantedStr = parser.getAttributeValue(null, ATTR_GRANTED); // granted 属性！ final boolean granted = grantedStr == null || Boolean.parseBoolean(grantedStr); String flagsStr = parser.getAttributeValue(null, ATTR_FLAGS); // flags 属性！ final int flags = (flagsStr != null) ? Integer.parseInt(flagsStr, 16) : 0; //【8.4.2.1.1】处理运行时权限的授予情况，这里和处理安装时权限很类似！ if (granted) &#123; // 如果上次安装时，该运行时权限处于授予状态，接着更新 flags！ permissionsState.grantRuntimePermission(bp, userId); permissionsState.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; else &#123; // 如果上次安装时，该运行时权限处于未授予状态，只更新 flags！ permissionsState.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; break; &#125; &#125;&#125; 我们看到，对于运行时权限已授予的情况，我们会先进行一次运行时权限授予，然后更新权限的 flags；对于运行时权限未授予的情况，只是更新 flags 即可！ 8.4.2.1.1 Permissions.grantRuntimePermission处理运行时权限的授予！ 123456789public int grantRuntimePermission(BasePermission permission, int userId) &#123; enforceValidUserId(userId); //【1】可以看到，对于运行时权限，userId 只能为当前设备用户，不能为 USER_ALL if (userId == UserHandle.USER_ALL) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【2】接下来，就和处理安装时权限一样了！ return grantPermission(permission, userId);&#125; 这里不多说！ 8.4.2.2 Settings.parseRestoredRuntimePermissionsLPr解析那些需要恢复的权限信息： 1234567891011121314151617181920212223242526272829303132333435363738private void parseRestoredRuntimePermissionsLPr(XmlPullParser parser, final String pkgName, final int userId) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; switch (parser.getName()) &#123; //【1】解析 perm 标签！ case TAG_PERMISSION_ENTRY: &#123; //【1.1】解析 name 属性，获得权限的名称； final String permName = parser.getAttributeValue(null, ATTR_NAME); //【1.2】解析 granted 属性，获得权限的授予情况； final boolean isGranted = \"true\".equals( parser.getAttributeValue(null, ATTR_GRANTED)); //【1.3】解析获得权限的 flags 设置！ int permBits = 0; if (\"true\".equals(parser.getAttributeValue(null, ATTR_USER_SET))) &#123; permBits |= FLAG_PERMISSION_USER_SET; &#125; if (\"true\".equals(parser.getAttributeValue(null, ATTR_USER_FIXED))) &#123; permBits |= FLAG_PERMISSION_USER_FIXED; &#125; if (\"true\".equals(parser.getAttributeValue(null, ATTR_REVOKE_ON_UPGRADE))) &#123; permBits |= FLAG_PERMISSION_REVOKE_ON_UPGRADE; &#125; if (isGranted || permBits != 0) &#123; //【8.4.2.2.1】如果权限是授予状态，或者其 flags 不为 null！ // 那么我们会将其记录到内充中！ rememberRestoredUserGrantLPr(pkgName, permName, isGranted, permBits, userId); &#125; &#125; break; &#125; &#125;&#125; 如果权限是被授予的状态，或者其 flags 不为 null，那么会调用 rememberRestoredUserGrantLPr 方法，保存到 Settings.mRestoredUserGrants 中！ #####8.4.2.2.1 Settings.rememberRestoredUserGrantLPr123456789101112131415161718192021public void rememberRestoredUserGrantLPr(String pkgName, String permission, boolean isGranted, int restoredFlagSet, int userId) &#123; //【1】获得该 userId 下的 restore perms 数据集合，是一个 Map！ // 如果为 null，就初始化！ ArrayMap&lt;String, ArraySet&lt;RestoredPermissionGrant&gt;&gt; grantsByPackage = mRestoredUserGrants.get(userId); if (grantsByPackage == null) &#123; grantsByPackage = new ArrayMap&lt;String, ArraySet&lt;RestoredPermissionGrant&gt;&gt;(); mRestoredUserGrants.put(userId, grantsByPackage); &#125; //【2】获得该 package 的 restore perms 数据集合，如果为 null，就初始化！ ArraySet&lt;RestoredPermissionGrant&gt; grants = grantsByPackage.get(pkgName); if (grants == null) &#123; grants = new ArraySet&lt;RestoredPermissionGrant&gt;(); grantsByPackage.put(pkgName, grants); &#125; //【3】将 retore 的权限封装成一个 RestoredPermissionGrant，添加到集合中！ RestoredPermissionGrant grant = new RestoredPermissionGrant(permission, isGranted, restoredFlagSet); grants.add(grant);&#125; Settings 内部有一个 SparseArray：123private final SparseArray&lt;ArrayMap&lt;String, ArraySet&lt;RestoredPermissionGrant&gt;&gt;&gt; mRestoredUserGrants = new SparseArray&lt;ArrayMap&lt;String, ArraySet&lt;RestoredPermissionGrant&gt;&gt;&gt;(); 下标是 userId，值是一个 ArrayMap&lt;String, ArraySet&gt;，封装了该 userId 下所有 package的 retore perms！ 1234567891011final class RestoredPermissionGrant &#123; String permissionName; boolean granted; int grantBits; RestoredPermissionGrant(String name, boolean isGranted, int theGrantBits) &#123; permissionName = name; granted = isGranted; grantBits = theGrantBits; &#125;&#125; RestoredPermissionGrant 内部的结构很简单，不多说了！！ 9 安装时权限处理过程分析 - 接 8.1.1.4markdown 只支持 6 级标题，所以这里接 8.1.1.4 继续分析！ 下面来较为深入的分析下解析 “perms” 标签，并通过解析结果授予安装时权限的过程： 123456&lt;perms&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.INTERNET\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_NETWORK_STATE\" granted=\"true\" flags=\"0\" /&gt;&lt;/perms&gt; 回顾一下，Settings.readInstallPermissionsLPr 的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void readInstallPermissionsLPr(XmlPullParser parser, PermissionsState permissionsState) throws IOException, XmlPullParserException &#123; int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // 解析 \"item\" String name = parser.getAttributeValue(null, ATTR_NAME); // 接续 \"name\"，权限名称！ //【1】从之前解析的 Settings.mPermissions 获得对应的权限； BasePermission bp = mPermissions.get(name); if (bp == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown permission: \" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【2】解析 \"granted\" 标签，获得授予情况！ String grantedStr = parser.getAttributeValue(null, ATTR_GRANTED); final boolean granted = grantedStr == null || Boolean.parseBoolean(grantedStr); // 解析 \"flags\"标签 String flagsStr = parser.getAttributeValue(null, ATTR_FLAGS); final int flags = (flagsStr != null) ? Integer.parseInt(flagsStr, 16) : 0; //【3】处理权限授予的操作！ if (granted) &#123; //【9.1】处理默认授予的情况！ if (permissionsState.grantInstallPermission(bp) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; Slog.w(PackageManagerService.TAG, \"Permission already added: \" + name); XmlUtils.skipCurrentTag(parser); &#125; else &#123; permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; else &#123; //【9.2】处理默认不授予的情况！ if (permissionsState.revokeInstallPermission(bp) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; Slog.w(PackageManagerService.TAG, \"Permission already added: \" + name); XmlUtils.skipCurrentTag(parser); &#125; else &#123; //【9.3】更新应用权限信息！ permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;permissions&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 接下来，我们看一看，这个流程是如何处理权限的： 这里有涉及到 permissionsState 对象，每一个 PackageSetting 和 SharedUserSetting 都有一个 permissionsState 对象，用来保存其权限的状态信息！ 在创建 PackageSetting 和 SharedUserSetting 的时候，都会默认创建一个 PermissionsState 对象！ PermissionsState 内部有一个 ArrayMap&lt;String, PermissionData&gt; mPermissions 用来保存权限名和其对应权限信息数据！ 下面为了简化分析过程，PermissionsState 统一化为 PermissionsS 9.1 PermissionsS.grantInstallPermission - 处理授予情况1234// 授予一个安装时权限，可以看到，安装时权限是对所有用户都默认授予的！public int grantInstallPermission(BasePermission permission) &#123; return grantPermission(permission, UserHandle.USER_ALL);&#125; 我们继续看，参数传入： BasePermission permission：权限封装对象 int userId：设备用户，因为是安装时权限，所以对所有设备用户都是一样，这里传入 UserHandle.USER_ALL！12345678910111213141516171819202122232425262728293031private int grantPermission(BasePermission permission, int userId) &#123; //【9.1.1】如果之前有权限，本次授予失败！ if (hasPermission(permission.name, userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【9.1.2】判断权限 BasePermission 在 userId 下是否有映射 gid，如果有，那 hasGids 为 true！ final boolean hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId)); //【9.1.3】如果权限 BasePermission 有映射的 gid，那就计算下该 package 的所属的 Gid 组！ final int[] oldGids = hasGids ? computeGids(userId) : NO_GIDS; //【9.1.4】创建权限的 permissionData 对象，并添加到 PermissionState.mPermissions 中！ PermissionData permissionData = ensurePermissionData(permission); //【9.1.5】授予权限！ if (!permissionData.grant(userId)) &#123; // 授权失败，就返回 PERMISSION_OPERATION_FAILURE！ return PERMISSION_OPERATION_FAILURE; &#125; // 如果权限有映射的 gid，在授予权限后，再次计算该 package 的所有映射的 gid！ // 比较授权前后，gid 组是否发生了变化，如果有，返回 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED！ if (hasGids) &#123; final int[] newGids = computeGids(userId); if (oldGids.length != newGids.length) &#123; return PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED; &#125; &#125; return PERMISSION_OPERATION_SUCCESS; // 返回 PERMISSION_OPERATION_SUCCESS！&#125; 方法逻辑如下： 如果已经授予权限，那就不处理，返回 PERMISSION_OPERATION_FAILURE； 如果授予权限失败，那就不处理，返回 PERMISSION_OPERATION_FAILURE； 如果授予权限成功，但是发现权限所属的 gid 发生了变化，返回 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED； 如果授予权限成功，但是发现权限所属的 gid 没有发生变化，返回 PERMISSION_OPERATION_SUCCESS； 9.1.1 PermissionsS.hasPermissionhasPermission 用来判断是否已经授予的该权限！1234567891011public boolean hasPermission(String name, int userId) &#123; // 校验 uid 的有效性！ enforceValidUserId(userId); if (mPermissions == null) &#123; return false; &#125; //【1】获得该权限对应的 permissionData 对象！ PermissionData permissionData = mPermissions.get(name); //【9.1.1.1】判断是否已经授予了该权限！ return permissionData != null &amp;&amp; permissionData.isGranted(userId);&#125; 授予该权限的条件是，其对应的 PermissionData 不为 null，同时该权限属于已经授予的状态； 9.1.1.1 PermissionData.isGrantedPermissionData 的 isGranted 用于判断该权限在 userId 所在的设备用户下是否是授予状态！123456789101112public boolean isGranted(int userId) &#123; if (isInstallPermission()) &#123; // 如果是安装时权限，userId 即 key 为 USER_ALL！ userId = UserHandle.USER_ALL; &#125; PermissionState userState = mUserStates.get(userId); if (userState == null) &#123; return false; &#125; return userState.mGranted; // 返回是否授予！&#125; isInstallPermission 方法用来判断，该权限是否是一个安装时的权限：1234private boolean isInstallPermission() &#123; return mUserStates.size() == 1 &amp;&amp; mUserStates.get(UserHandle.USER_ALL) != null;&#125; 判断依据很简单，对于安装时权限，所有的设备用户都一样，所以 mUserStates 大小为 1，且 key 为 UserHandle.USER_ALL！ 9.1.2 BasePermission.computeGidsBasePermission 的 computeGids 方法用于通过 userId 来调整该权限所映射的 gids！ 1234567891011public int[] computeGids(int userId) &#123; if (perUser) &#123; final int[] userGids = new int[gids.length]; for (int i = 0; i &lt; gids.length; i++) &#123; userGids[i] = UserHandle.getUid(userId, gids[i]); &#125; return userGids; &#125; else &#123; return gids; &#125;&#125; 如果 perUser 为 true，表示需要根据当前应用所在的 userId，调整映射的 gid，那么会通过 UserHandle.getUid 方法计算出当前 userId 下的该权限所映射的 gid！ 如果 perUser 为 false，那么该权限在所有的设备用户下映射的 gid 是一样的！ 9.1.3 PermissionsS.computeGids返回指定设备用户 id 下，该 package 当前被授予的所有权限映射的 gid 数组！！1234567891011121314151617181920212223242526public int[] computeGids(int userId) &#123; enforceValidUserId(userId); int[] gids = mGlobalGids; if (mPermissions != null) &#123; final int permissionCount = mPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; //【1】遍历该 package 的已经被授予的所有权限！ // 没有授予就跳过！ String permission = mPermissions.keyAt(i); if (!hasPermission(permission, userId)) &#123; continue; &#125; PermissionData permissionData = mPermissions.valueAt(i); //【9.1.3.1】计算该权限在当前设备用户下的 gid，将其添加到 gids！ final int[] permGids = permissionData.computeGids(userId); if (permGids != NO_GIDS) &#123; gids = appendInts(gids, permGids); &#125; &#125; &#125; // 并返回 gids！！ return gids;&#125; mGlobalGids 是 PermissionsState 的成员变量，默认取值为：12private static final int[] NO_GIDS = &#123;&#125;;private int[] mGlobalGids = NO_GIDS; 9.1.3.1 PermissionData.computeGids1234567private static final class PermissionData &#123; private final BasePermission mPerm; ... ... ... public int[] computeGids(int userId) &#123; // 计算该权限所属的 gid！ return mPerm.computeGids(userId); &#125; PermissionData.computeGids 方法最后调用的是 BasePermission.computeGids 方法，这里不多说了。 9.1.4 PermissionsS.ensurePermissionData创建 PermissionData，并添加到 PermissionsState 内部的 mPermissions 集合中！123456789101112private PermissionData ensurePermissionData(BasePermission permission) &#123; if (mPermissions == null) &#123; mPermissions = new ArrayMap&lt;&gt;(); &#125; //【9.1.2.1】创建权限对应的 PermissionData 对象！ PermissionData permissionData = mPermissions.get(permission.name); if (permissionData == null) &#123; permissionData = new PermissionData(permission); mPermissions.put(permission.name, permissionData); &#125; return permissionData;&#125; 可以看到，在 PermissionsState 中有一个 mPermissions 表，保存了 permission.name 和 PermissionData 的映射关系，如果是第一次创建某个权限的 PermissionData，会创建 PermissionData 实例！ 9.1.4.1 new PermissionData创建 PermissionData 对象！ 12345678910private static final class PermissionData &#123; private final BasePermission mPerm; //【1】用于保存该权限在不同 userId 下的授予情况！ private SparseArray&lt;PermissionState&gt; mUserStates = new SparseArray&lt;&gt;(); public PermissionData(BasePermission perm) &#123; mPerm = perm; &#125; ... ... ... ...&#125; 创建 PermissionData 对象！ mUserStates 是以 userId 为下标，存储了每个设备用户下该应用的这个权限的状态信息！ 9.1.5 PermissionData.grant下面我们来看看具体的权限授予过程！1234567891011121314151617181920public boolean grant(int userId) &#123; if (!isCompatibleUserId(userId)) &#123; return false; &#125; if (isGranted(userId)) &#123; // 如果已经授予，那就返回 false！ return false; &#125; // 获得该权限对应在 userId 下对应的 PermissionState 对象，没有的话就创建新的！ PermissionState userState = mUserStates.get(userId); if (userState == null) &#123; userState = new PermissionState(mPerm.name); mUserStates.put(userId, userState); &#125; // 设置在该 userId 下的权限状态为 true！ userState.mGranted = true; return true;&#125; 首先，判断 userId 的兼容性！ 123private boolean isCompatibleUserId(int userId) &#123; return isDefault() || !(isInstallPermission() ^ isInstallPermissionKey(userId));&#125; userId 要满足兼容性要求，需要至少满足其中之一条件： PermissionData.mUserStates 的大小 &lt;= 0，意味着该权限还没有初始化在该 userId 下的状态！ 123public boolean isDefault() &#123; return mUserStates.size() &lt;= 0;&#125; 要么，该权限是安装时权限，同时 userId 只能为 UserHandle.USER_ALL; 要么，该权限不是安装时权限，同时 userId 不能为 UserHandle.USER_ALL; 123public static boolean isInstallPermissionKey(int userId) &#123; return userId == UserHandle.USER_ALL;&#125; 对于 isInstallPermission 方法，前面已经分析了，不多说了！ 9.2 PermissionsS.revokeInstallPermission - 处理不授予情况123public int revokeInstallPermission(BasePermission permission) &#123; return revokePermission(permission, UserHandle.USER_ALL);&#125; 我们继续看，参数传入; BasePermission permission：权限封装对象 int userId：设备用户，因为是安装时权限，所以对所有设备用户都是一样，这里传入：UserHandle.USER_ALL 12345678910111213141516171819202122232425262728293031323334private int revokePermission(BasePermission permission, int userId) &#123; //【1】如果没有授予该权限，那就返回 PERMISSION_OPERATION_FAILURE！ if (!hasPermission(permission.name, userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【2】同样，计算该权限是否有映射 gid，如果有 gid，计算当前 package 持有的权限映射的所有 gid！ // 保存到 oldGids 中！ final boolean hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId)); final int[] oldGids = hasGids ? computeGids(userId) : NO_GIDS; PermissionData permissionData = mPermissions.get(permission.name); //【9.2.1】取消权限的授予！ if (!permissionData.revoke(userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【9.2.2】如果该权限在所有设备用户下均没有授予该 package，即 mUserStates.size() &lt;= 0； // 那么我们要移除该权限！ if (permissionData.isDefault()) &#123; ensureNoPermissionData(permission.name); &#125; //【3】这里是比较，在撤销安装时权限后，该 package 所持有的 gid 是否发生变化！ if (hasGids) &#123; final int[] newGids = computeGids(userId); if (oldGids.length != newGids.length) &#123; return PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED; &#125; &#125; return PERMISSION_OPERATION_SUCCESS;&#125; 撤销安装时权限的过程，和授予有很多类似的地方，我们重点看那些不同的地方！ 9.2.1 PermissionData.revoke接下来看看安装时权限撤销的过程！12345678910111213141516171819public boolean revoke(int userId) &#123; if (!isCompatibleUserId(userId)) &#123; return false; &#125; // 如果权限还没有被授予，无法撤销！ if (!isGranted(userId)) &#123; return false; &#125; //【1】将权限在该 userId 下的状态设置为非授予的情况！ PermissionState userState = mUserStates.get(userId); userState.mGranted = false; // 如果该权限恢复了默认状态，从 mUserStates 中移除掉它！ if (userState.isDefault()) &#123; mUserStates.remove(userId); &#125; return true;&#125; 9.2.2 PermissionsS.ensureNoPermissionData123456789private void ensureNoPermissionData(String name) &#123; if (mPermissions == null) &#123; return; &#125; mPermissions.remove(name); if (mPermissions.isEmpty()) &#123; mPermissions = null; &#125;&#125; ensureNoPermissionData 用于从当前的 package 中移除该权限数据！ 9.3 PermissionsS.updatePermissionFlags - 更新权限标志位当 revokeInstallPermission 或者 grantInstallPermission 方法返回的是 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED 或者 PERMISSION_OPERATION_SUCCESS 的时候，我们需要更新权限的标志位！ 参数传递： userId 传入的是 UserHandle.USER_ALL； flagMask 传入的是 PackageManager.MASK_PERMISSION_FLAGS，取值为 0xFF，转为二进制就是 11111 flagValues 则是解析上次安装信息时，解析该 package 的 perms 标签时，每一个权限的 flags！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public boolean updatePermissionFlags(BasePermission permission, int userId, int flagMask, int flagValues) &#123; enforceValidUserId(userId); final boolean mayChangeFlags = flagValues != 0 || flagMask != 0; //【1】如果 mPermissions 为 null，且需要更新 flags，那么会初始化 mPermissions，将 permission 添加进入！ if (mPermissions == null) &#123; if (!mayChangeFlags) &#123; return false; &#125; ensurePermissionData(permission); &#125; //【2】如果该权限 permission 没有对应的 PermissionData，且需要更新 flags，那么我们会创建 PermissionData 添加！ PermissionData permissionData = mPermissions.get(permission.name); if (permissionData == null) &#123; if (!mayChangeFlags) &#123; return false; &#125; permissionData = ensurePermissionData(permission); &#125; //【3】获得该权限的旧的 flags，用于后续对比！ final int oldFlags = permissionData.getFlags(userId); //【9.3.1】更新权限标志位！ final boolean updated = permissionData.updateFlags(userId, flagMask, flagValues); //【4】如果权限的状态发生了变化，那就判断是否需要重新申请！ if (updated) &#123; final int newFlags = permissionData.getFlags(userId); if ((oldFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) == 0 &amp;&amp; (newFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0) &#123; if (mPermissionReviewRequired == null) &#123; mPermissionReviewRequired = new SparseBooleanArray(); &#125; //【4.1】如果在该 userId 下需要重新申请，那么就将其添加到 mPermissionReviewRequired 中！ mPermissionReviewRequired.put(userId, true); &#125; else if ((oldFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0 &amp;&amp; (newFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) == 0) &#123; //【4.2】如果在该 userId 下不需要重新申请，那么就将其从 mPermissionReviewRequired 中移除！ if (mPermissionReviewRequired != null) &#123; mPermissionReviewRequired.delete(userId); if (mPermissionReviewRequired.size() &lt;= 0) &#123; mPermissionReviewRequired = null; &#125; &#125; &#125; &#125; return updated;&#125; 对于 mayChangeFlags，由于我们 flagMask 传入的是 PackageManager.MASK_PERMISSION_FLAGS，那就意味了需要更新 flags！ 可以看到，如果 mayChangeFlags 为 true 的话，即使没有权限对应的 PermissionData 也会创建，因为这次会更新 flags！ PermissionData.getFlags 方法会获得权限旧的 flags！ 重点的操作在 PermissionData.updateFlag 方法中： 9.3.1 PermissionData.updateFlags更新指定权限的 flags，flagValues 是本次解析获得的 flags！！ 12345678910111213141516171819202122232425262728293031public boolean updateFlags(int userId, int flagMask, int flagValues) &#123; if (isInstallPermission()) &#123; // 如果是安装时权限，那么 userId 为 UserHandle.USER_ALL; userId = UserHandle.USER_ALL; &#125; if (!isCompatibleUserId(userId)) &#123; // 如果 userId 不兼容，那么会直接返回！ return false; &#125; //【1】这里进行 &amp; 操作，保留了 flagValues 和 flagMask 相同的位！ final int newFlags = flagValues &amp; flagMask; //【2】获得该 userId 下的权限状态值！ PermissionState userState = mUserStates.get(userId); if (userState != null) &#123; final int oldFlags = userState.mFlags; // 取消旧的 flags，设置新的 flags！ userState.mFlags = (userState.mFlags &amp; ~flagMask) | newFlags; if (userState.isDefault()) &#123; mUserStates.remove(userId); &#125; // 判断 flags 是否发生变化，如果发生了变化，那就返回 true！ return userState.mFlags != oldFlags; &#125; else if (newFlags != 0) &#123; // 如果该权限在该 userId 下没有状态信息，那就创建状态信息，直接设置新的 flags，返回 true！ userState = new PermissionState(mPerm.name); userState.mFlags = newFlags; mUserStates.put(userId, userState); return true; &#125; return false;&#125; 这里有一个操作： 首先，进行 &amp; 操作，保留了 flagValues 和 flagMask 相同的位，为 newFlags； 接着，userState.mFlags 表示旧的 flags，这里在 userState.mFlags 和 ~flagMask 中做了 &amp; 操作，等价于取了 userState.mFlags 和 flagMask 不同的位，然后加上 newFlags，作为新的 flags！ 10 阶段总结在这个阶段，PMS 主要完成了如下了几个过程： 一、解析 SystemConfig 系统配置，主要会解析一下系统属性： 1、group：系统中定义的 gid，保存到了 SystemConfig.mGlobalGids 中！ 2、permission：系统权限，每一个权限都创建一个 PermissionEntry，保存到 SystemConfig.mPermissions 中； PermissionEntry 有如下属性：name 权限名：perUser：表示该权限的 gid 是否针对不同的 userId 做调整；gids：该权限所属 gid 3、assign-permission：系统 uid 和其具有的权限，保存到了 SystemConfig.mSystemPermissions 中！每一个 uid 都对应一个或多个权限； 4、library：共享库信息，保存到了 SystemConfig.mSharedLibraries 中！ 5、feature：特性信息，保存到了 SystemConfig.mAvailableFeatures 和 SystemConfig.mUnavailableFeatures 中！ 这里我们重点看一些属性的解析，其他的属性我们先不关注！ 然后将 SystemConfig 中的一些解析结果保存到 Settings 中： Settings.mGlobalGids = systemConfig.getGlobalGids();Settings.mSystemPermissions = systemConfig.getSystemPermissions();Settings.mAvailableFeatures = systemConfig.getAvailableFeatures(); 接着处理 SystemConfig.mPermissions 中解析到的系统权限！ 对于每一个 PermissionEntry 创建一个 BasePermission 对象： 在创建时会设置 BasePermission.name 为权限名； 设置 BasePermission.sourcePackage 为定义权限的源包，因为是系统权限，所以为 android； 设置 BasePermission.type 权限类型为 BasePermission.TYPE_BUILTIN； 设置 BasePermission.protectionLevel 权限级别默认为 PermissionInfo.PROTECTION_SIGNATURE; 同时会设置 BasePermission.perUser 为 PermissionEntry.perUser；同时会设置 BasePermission.gids 为 PermissionEntry.gids； 最后新创建的 BasePermission，会添加到 Settings.mPermissions 集合中！ 二、读取上一次的安装信息！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"PMS 第 1 篇 - PackageManagerService 初始化","slug":"PMS1-PackageManagerServiceInit","date":"2018-01-02T16:00:00.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2018/01/03/PMS1-PackageManagerServiceInit/","link":"","permalink":"https://coolqi.top/2018/01/03/PMS1-PackageManagerServiceInit/","excerpt":"","text":"[toc] 本文基于 Android 7.1.1 系统源码，分析 PackageManagerService 的架构和主要业务实现，本文是作者原创，转载请说明出处！ 前言PMS 用来管理所有的 package 信息，包括安装、卸载、更新以及解析 AndroidManifest.xml 以组织相应的数据结构，这些数据结构将会被 其他 service 和 application 使用到。 1 PMS 的启动先来看 SystemServer 中 PackageManagerService 的启动代码：12345// 这里的 installer 也是一个系统服务mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);mFirstBoot = mPackageManagerService.isFirstBoot();mPackageManager = mSystemContext.getPackageManager(); main 函数很简单，只有短短几行代码，执行时间却较长，主要原因是 PKMS 在其构造函数中做了很多“重体力活”，这也是 Android 启动速度慢的主要原因之一。 123456789101112// 先来看看PackageManangerService的main方法：public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(\"package\", m); return m;&#125; 首先构造一个 PMS 对象，然后调用 ServiceManager 的 addService 注册 PackageManagerService 服务。 构造函数有如下 4 个参数： 第一个参数：系统进程的上下文实例； 第二个参数：Installer 对象，用于和 Installd 通信使用，我们后面分析 Installd 再来介绍； 第三个参数：factoryTest 为出厂测试，默认为 false； 第四个参数：onlyCore 表示是否只加载核心的应用，默认也为 false。 2 PMS 的初始化PackageManagerService 的构造器代码结构如下： 12345678910111213141516171819202122232425262728293031323334353637public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis()); ... synchronized (mInstallLock) &#123; synchronized (mPackages) &#123; ... EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime); ... if (!mOnlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis()); &#125; ... EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis()); ... EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis()); ... &#125; &#125; Runtime.getRuntime().gc(); LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());&#125; 我们根据 EventLog 可以将 PMS 的初始化分为以下几个过程： 阶段1：BOOT_PROGRESS_PMS_START 阶段2：BOOT_PROGRESS_PMS_SYSTEM_SCAN_START 阶段3：BOOT_PROGRESS_PMS_DATA_SCAN_START 阶段4：BOOT_PROGRESS_PMS_SCAN_END 阶段5：BOOT_PROGRESS_PMS_READY 下面，来看看 PackageManangerService 的构造器方法代码，为了便于分析，我们把 PackageManagerService 构造器的代码分为如下几个部分： 2.1 PMS_START这个的阶段的代码，如下 ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis()); if (mSdkVersion &lt;= 0) &#123; //【1】mSdkVersion 是 PKMS 的成员变量，定义的时候进行赋值， // 其值取自系统属性“ro.build.version.sdk”，即编译的 SDK 版本。 Slog.w(TAG, \"**** ro.build.version.sdk not set!\"); &#125; mContext = context; mFactoryTest = factoryTest; // 默认为 false，即运行在非工厂模式下 mOnlyCore = onlyCore; // 默认为 false,标记是否是只加载核心服务 //【2】用于存储与显示屏相关的一些属性，例如屏幕的宽 / 高尺寸，分辨率等信息。 mMetrics = new DisplayMetrics(); //【3】在 Settings 中，创建 packages.xml、packages-backup.xml、packages.list 等文件对象 // 并添加 system, phone, log, nfc, bluetooth, shell 这六种 shareUserId 到 mSettings，后面扫描和安装有用！ mSettings = new Settings(mPackages); mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); String separateProcesses = SystemProperties.get(\"debug.separate_processes\"); if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123; if (\"*\".equals(separateProcesses)) &#123; mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES; mSeparateProcesses = null; Slog.w(TAG, \"Running with debug.separate_processes: * (ALL)\"); &#125; else &#123; mDefParseFlags = 0; mSeparateProcesses = separateProcesses.split(\",\"); Slog.w(TAG, \"Running with debug.separate_processes: \" + separateProcesses); &#125; &#125; else &#123; mDefParseFlags = 0; mSeparateProcesses = null; &#125; //【3】初始化 mInstaller 对象，installer 对象和 Native 进程 installd 交互！ mInstaller = installer; //【4】创建 PackageDexOptimizer 对象，用于 dex 优化！ mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context, \"*dexopt*\"); //【5】创建 MoveCallbacks 对象，用于操作回滚！ mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper()); //【6】创建 OnPermissionChangeListeners 对象，用于监听权限改变！ mOnPermissionChangeListeners = new OnPermissionChangeListeners( FgThread.get().getLooper()); getDefaultDisplayMetrics(context, mMetrics); // 获得默认的显示 //【7】创建 SystemConfig 对象，用于获取系统配置信息 // 主要有 /system/etc/ 目录和 /system/etc/sysconfig 目录下的 sysconfig 和 permissions 文件夹xml文件 SystemConfig systemConfig = SystemConfig.getInstance(); mGlobalGids = systemConfig.getGlobalGids(); mSystemPermissions = systemConfig.getSystemPermissions(); mAvailableFeatures = systemConfig.getAvailableFeatures(); mProtectedPackages = new ProtectedPackages(mContext); synchronized (mInstallLock) &#123; // writer synchronized (mPackages) &#123; //【8】建立并启动一个名为 “PackageManager” 的 HandlerThread，类型是 ServiceThread，处理安装卸载的消息！ mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/); mHandlerThread.start(); //【9】创建一个 PackageHandler 对象，绑定前面创建的 HandlerThread！ mHandler = new PackageHandler(mHandlerThread.getLooper()); mProcessLoggingHandler = new ProcessLoggingHandler(); Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT); //【10】创建 DefaultPermissionGrantPolicy 对象，用于给某些预制的apk，给予权限,也可以撤销 mDefaultPermissionPolicy = new DefaultPermissionGrantPolicy(this); //【11】创建需要扫描检测的目录文件对象，为扫描做准备！ File dataDir = Environment.getDataDirectory(); mAppInstallDir = new File(dataDir, \"app\"); // 目录 /data/data，存放应用程序的数据； mAppLib32InstallDir = new File(dataDir, \"app-lib\"); // 目录 /data/app-lib； mEphemeralInstallDir = new File(dataDir, \"app-ephemeral\"); // 目录 /data/app-ephemeral； mAsecInternalPath = new File(dataDir, \"app-asec\").getPath(); // 目录 /data/app-asec； mDrmAppPrivateInstallDir = new File(dataDir, \"app-private\"); // 目录 /data/app-private，私有应用程序！ //【11】创建用户管理服务！ sUserManager = new UserManagerService(context, this, mPackages); //【12】获得权限信息！ ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions(); for (int i=0; i &lt; permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123; bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125; &#125; //【13】处理共享库！ ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries(); for (int i=0; i&lt;libConfig.size(); i++) &#123; mSharedLibraries.put(libConfig.keyAt(i), new SharedLibraryEntry(libConfig.valueAt(i), null)); &#125; mFoundPolicyFile = SELinuxMMAC.readInstallPolicy(); // 判断是否是第一次开机！ // 并获得上一次的安装信息！ mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false)); // 移除哪些 codePath 无效的 Package，恢复处于 system 目录下的同名 package final int packageSettingCount = mSettings.mPackages.size(); for (int i = packageSettingCount - 1; i &gt;= 0; i--) &#123; PackageSetting ps = mSettings.mPackages.valueAt(i); if (!isExternal(ps) &amp;&amp; (ps.codePath == null || !ps.codePath.exists()) &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != null) &#123; mSettings.mPackages.removeAt(i); mSettings.enableSystemPackageLPw(ps.name); &#125; &#125; if (mFirstBoot) &#123; // 如果是第一次开机，从另外一个系统拷贝 odex 文件到当前系统的 data 分区 // Android 7.1 引进了 AB 升级，这个是 AB 升级的特性，可以先不看！ requestCopyPreoptedFiles(); &#125; String customResolverActivity = Resources.getSystem().getString( R.string.config_customResolverActivity); if (TextUtils.isEmpty(customResolverActivity)) &#123; customResolverActivity = null; &#125; else &#123; mCustomResolverComponentName = ComponentName.unflattenFromString( customResolverActivity); &#125; ... ... ... ...// 见，第二阶段 第一阶段，主要是做一些初始化工作，为后续的扫描做准备！ 1.2.1 主要流程 创建 Settings 对象，创建 packages.xml、packages-backup.xml、packages.list 等文件对象并添加 system, phone, log, nfc, bluetooth, shell 这六种 shareUserId 到 mSettings，后面扫描和安装有用； 初始化 mInstaller 对象，用于和 installed 交互； 创建 PackageDexOptimizer 对象，用于 dex 优化； 创建 OnPermissionChangeListeners 对象，用于监听权限改变； 创建 SystemConfig 对象，用于获取系统配置信息； 创建用户管理服务！ 获得权限信息！ 获得系统共享库！ 2.2 PMS_SYSTEM_SCAN_START下面是系统扫描阶段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231... ... ... ...// 接上面long startTime = SystemClock.uptimeMillis(); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);// Set flag to monitor and not change apk file paths when// scanning install directories.// 设置扫描参数！final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;// 获得环境变量：BOOTCLASSPATH 和 SYSTEMSERVERCLASSPATH！final String bootClassPath = System.getenv(\"BOOTCLASSPATH\");final String systemServerClassPath = System.getenv(\"SYSTEMSERVERCLASSPATH\");if (bootClassPath == null) &#123; Slog.w(TAG, \"No BOOTCLASSPATH found!\");&#125;if (systemServerClassPath == null) &#123; Slog.w(TAG, \"No SYSTEMSERVERCLASSPATH found!\");&#125;// 获得系统指令集合！final List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();final String[] dexCodeInstructionSets = getDexCodeInstructionSets( allInstructionSets.toArray(new String[allInstructionSets.size()]));// 对所有的共享库执行 odex 操作！if (mSharedLibraries.size() &gt; 0) &#123; // NOTE: For now, we're compiling these system \"shared libraries\" // (and framework jars) into all available architectures. It's possible // to compile them only when we come across an app that uses them (there's // already logic for that in scanPackageLI) but that adds some complexity. for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123; final String lib = libEntry.path; if (lib == null) &#123; continue; &#125; try &#123; // Shared libraries do not have profiles so we perform a full // AOT compilation (if needed). int dexoptNeeded = DexFile.getDexOptNeeded( lib, dexCodeInstructionSet, getCompilerFilterForReason(REASON_SHARED_APK), false /* newProfile */); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/, getCompilerFilterForReason(REASON_SHARED_APK), StorageManager.UUID_PRIVATE_INTERNAL, SKIP_SHARED_LIBRARY_CHECK); &#125; &#125; catch (FileNotFoundException e) &#123; Slog.w(TAG, \"Library not found: \" + lib); &#125; catch (IOException | InstallerException e) &#123; Slog.w(TAG, \"Cannot dexopt \" + lib + \"; is it an APK or JAR? \" + e.getMessage()); &#125; &#125; &#125;&#125;// 获得目录 /system/framework，对其目录下的文件进行优化 !File frameworkDir = new File(Environment.getRootDirectory(), \"framework\");// 获得系统版本信息final VersionInfo ver = mSettings.getInternalVersion();// 判断是否是 OTA 升级！mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);// 判断是否是从 Android 6.0 升级过来的，如果是就需要把系统 app 的权限从安装时提高到运行时mPromoteSystemApps = mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;// When upgrading from pre-N, we need to handle package extraction like first boot,// as there is no profiling data available.// 判断是否是从 Android 7.0 升级过来的！mIsPreNUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N;mIsPreNMR1Upgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N_MR1;// save off the names of pre-existing system packages prior to scanning; we don't// want to automatically grant runtime permissions for new system apps// 保存从 Android 6.0 升级前已经存在的系统应用包，并对他们进行优先扫描！if (mPromoteSystemApps) &#123; Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator(); while (pkgSettingIter.hasNext()) &#123; PackageSetting ps = pkgSettingIter.next(); if (isSystemApp(ps)) &#123; mExistingSystemPackages.add(ps.name); &#125; &#125;&#125;// Collect vendor overlay packages.// (Do this before scanning any apps.)// For security and version matching reason, only consider// overlay packages if they reside in VENDOR_OVERLAY_DIR.// 扫描收集目录 /vendor/overlay 下的供应商应用包！File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR); scanDirTracedLI(vendorOverlayDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);// Find base frameworks (resource packages without code).// 扫描收集目录 /system/framework 下的应用包！ scanDirTracedLI(frameworkDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0);// 扫描收集目录 /system/priv-app 下的应用包！ final File privilegedAppDir = new File(Environment.getRootDirectory(), \"priv-app\");scanDirTracedLI(privilegedAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);// 扫描收集目录 /system/app 下的应用包！ final File systemAppDir = new File(Environment.getRootDirectory(), \"app\");scanDirTracedLI(systemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);// 扫描收集目录 /vendor/app 下的应用包！ File vendorAppDir = new File(\"/vendor/app\");try &#123; vendorAppDir = vendorAppDir.getCanonicalFile();&#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one&#125;scanDirTracedLI(vendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);// 扫描收集目录 /oem/app 下的应用包！ final File oemAppDir = new File(Environment.getOemDirectory(), \"app\");scanDirTracedLI(oemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);// 删除已经不存在的系统应用包！final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();if (!mOnlyCore) &#123; Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); while (psit.hasNext()) &#123; PackageSetting ps = psit.next(); // 如果不是系统应用，跳过！ if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; continue; &#125; // 如果系统应用包已经被扫描到了（scannedPkg ！= null），就不会被删掉！ final PackageParser.Package scannedPkg = mPackages.get(ps.name); if (scannedPkg != null) &#123; /* * If the system app is both scanned and in the * disabled packages list, then it must have been * added via OTA. Remove it from the currently * scanned package so the previously user-installed * application can be scanned. */ // 如果系统应用包不仅被扫描过（在mPackages中），并且在不可用列表中！ // 说明一定是通过覆盖安装的，移除之前扫描的结果，保证之前用户安装的应用能够被扫描！ if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; logCriticalInfo(Log.WARN, \"Expecting better updated system app for \" + ps.name + \"; removing system app. Last known codePath=\" + ps.codePathString + \", installStatus=\" + ps.installStatus + \", versionCode=\" + ps.versionCode + \"; scanned versionCode=\" + scannedPkg.mVersionCode); // 将之前的扫描结果移除！ removePackageLI(scannedPkg, true); // 将这包添加到 mExpectingBetter 列表中！ mExpectingBetter.put(ps.name, ps.codePath); &#125; // 跳出循环，确保不会被删掉！ continue; &#125; // 如果系统应用包没有被扫描，并且他也不在不可用的列表中，移除它，这个包不存在！ if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; psit.remove(); logCriticalInfo(Log.WARN, \"System package \" + ps.name + \" no longer exists; it's data will be wiped\"); // Actual deletion of code and data will be handled by later // reconciliation step &#125; else &#123; // 如果系统应用包没有被扫描，却在不可用的列表中，就将他加入到 // possiblyDeletedUpdatedSystemApps 集合中，需要被删除！ final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name); if (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123; possiblyDeletedUpdatedSystemApps.add(ps.name); &#125; &#125; &#125;&#125;// 清理所有安装不完全的应用包！ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();for (int i = 0; i &lt; deletePkgsList.size(); i++) &#123; // Actual deletion of code and data will be handled by later // reconciliation step final String packageName = deletePkgsList.get(i).name; logCriticalInfo(Log.WARN, \"Cleaning up incompletely installed app: \" + packageName); synchronized (mPackages) &#123; mSettings.removePackageLPw(packageName); &#125;&#125;// 移除临时文件deleteTempPackageFiles();// 移除没有和应用程序包相关联的共享用户 id！mSettings.pruneSharedUsersLPw(); ... ... ... ...// 见，第三阶段 总结一下第二阶段： 2.2.1 主要流程 获得环境变量：BOOTCLASSPATH 和 SYSTEMSERVERCLASSPATH！ 对共享库进行 odex 优化操作！ 判断是否是通过 OTA 升级的 如果是从 6.0 升级过来的，保存从 Android 6.0 升级前已经存在的系统应用包，并对他们进行优先扫描！ 扫描收集以下目录中的供应商应用包！ /vendor/overlay /system/framework /system/priv-app /system/app /vendor/app /oem/app 删除已经不存在的系统应用包！ 清理所有安装不完全的应用包！ 移除临时文件 移除没有和应用程序包相关联的共享用户 id 2.2.2 细节分析2.2.2.1 环境变量我们可以通过 adb shell env 来查看系统所有的环境变量及相应值。也可通过命令：adb shell echo $var 来看指定的环境变量的值！ SYSTEMSERVERCLASSPATH： 主要是系统服务 jar 包的路径！ 主要文件如下：- /system/framework/services.jar - /system/framework/ethernet-service.jar - /system/framework/wifi-service.jar BOOTCLASSPATH： 该环境变量内容较多，第三方定制的系统可能有所不同，原生内容包含 /system/framework目录下的framework.jar，ext.jar，core-libart.jar，telephony-common.jar，ims-common.jar，core-junit.jar等文件！ 主要文件如下：- /system/framework/core-libart.jar - /system/framework/conscrypt.jar - /system/framework/okhttp.jar - /system/framework/core-junit.jar - /system/framework/bouncycastle.jar - /system/framework/ext.jar - /system/framework/framework.jar - /system/framework/telephony-common.jar - /system/framework/voip-common.jar - /system/framework/ims-common.jar - /system/framework/apache-xml.jar - /system/framework/org.apache.http.legacy.boot.jar - /system/framework/ifaamanager.jar - /system/framework/tcmiface.jar - /system/framework/WfdCommon.jar - /system/framework/com.qti.dpmframework.jar - /system/framework/dpmapi.jar - /system/framework/com.qti.location.sdk.jar - /system/framework/qcom.fmradio.jar - /system/framework/qcmediaplayer.jar 2.2.2.2 dexopt 优化执行 dex 优化操作的文件有以下几类： mSharedLibraries：该共享库下的所有文件，是由 SystemConfig 构造函数中赋值的； /system/framework：该目录的所有 apk 和 jar 文件； 2.2.2.3 scanDirLI 扫描系统目录扫描指定目录下的 apk 文件，最终调用 PackageParser.parseBaseApk 来完成 AndroidManifest.xml 文件的解析，生成 Application，activity，service，broadcast，provider 等信息。 /vendor/overlay /system/framework /system/priv-app /system/app /vendor/app /oem/app 2.3 PMS_DATA_SCAN_START接下来，进入第三阶段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138... ... ... ...// 第三阶段if (!mOnlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis()); // 同理，扫描 /data/app 目录和 /data/app-private 目录！ scanDirTracedLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirTracedLI(mDrmAppPrivateInstallDir, mDefParseFlags | PackageParser.PARSE_FORWARD_LOCK, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirLI(mEphemeralInstallDir, mDefParseFlags | PackageParser.PARSE_IS_EPHEMERAL, scanFlags | SCAN_REQUIRE_KNOWN, 0); /** * Remove disable package settings for any updated system * apps that were removed via an OTA. If they're not a * previously-updated app, remove them completely. * Otherwise, just revoke their system-level permissions. */ for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123; PackageParser.Package deletedPkg = mPackages.get(deletedAppName); mSettings.removeDisabledSystemPackageLPw(deletedAppName); String msg; if (deletedPkg == null) &#123; msg = \"Updated system package \" + deletedAppName + \" no longer exists; it's data will be wiped\"; // Actual deletion of code and data will be handled by later // reconciliation step &#125; else &#123; msg = \"Updated system app + \" + deletedAppName + \" no longer present; removing system privileges for \" + deletedAppName; deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM; PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName); deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM; &#125; logCriticalInfo(Log.WARN, msg); &#125; // 确保所有在用户 data 分区的应用都显示出来了，如果无法显示 // 那就回滚，显示 system 分区的！ for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123; final String packageName = mExpectingBetter.keyAt(i); if (!mPackages.containsKey(packageName)) &#123; final File scanFile = mExpectingBetter.valueAt(i); logCriticalInfo(Log.WARN, \"Expected better \" + packageName + \" but never showed up; reverting to system\"); // 设置扫描参数，不同的目录，扫描参数不同！ int reparseFlags = mDefParseFlags; if (FileUtils.contains(privilegedAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED; &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else &#123; Slog.e(TAG, \"Ignoring unexpected fallback path \" + scanFile); continue; &#125; // 设置系统 package 可用！ mSettings.enableSystemPackageLPw(packageName); // 重新解析 system 分区的 package！ try &#123; scanPackageTracedLI(scanFile, reparseFlags, scanFlags, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, \"Failed to parse original system package: \" + e.getMessage()); &#125; &#125; &#125;&#125;mExpectingBetter.clear(); // 清空 mExpectingBetter 列表！// Resolve the storage manager.mStorageManagerPackage = getStorageManagerPackageName();// Resolve protected action filters. Only the setup wizard is allowed to// have a high priority filter for these actions.mSetupWizardPackage = getSetupWizardPackageName();if (mProtectedFilters.size() &gt; 0) &#123; if (DEBUG_FILTERS &amp;&amp; mSetupWizardPackage == null) &#123; Slog.i(TAG, \"No setup wizard;\" + \" All protected intents capped to priority 0\"); &#125; for (ActivityIntentInfo filter : mProtectedFilters) &#123; if (filter.activity.info.packageName.equals(mSetupWizardPackage)) &#123; if (DEBUG_FILTERS) &#123; Slog.i(TAG, \"Found setup wizard;\" + \" allow priority \" + filter.getPriority() + \";\" + \" package: \" + filter.activity.info.packageName + \" activity: \" + filter.activity.className + \" priority: \" + filter.getPriority()); &#125; // skip setup wizard; allow it to keep the high priority filter continue; &#125; Slog.w(TAG, \"Protected action; cap priority to 0;\" + \" package: \" + filter.activity.info.packageName + \" activity: \" + filter.activity.className + \" origPrio: \" + filter.getPriority()); filter.setPriority(0); &#125;&#125;mDeferProtectedFilters = false;mProtectedFilters.clear();// 这里，我们已经找到了所有的共享库文件！// 我们需要更新所有的应用，保证他们有正确的共享库路径。updateAllSharedLibrariesLPw();for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; // NOTE: We ignore potential failures here during a system scan (like // the rest of the commands above) because there's precious little we // can do about it. A settings error is reported, though. adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */, false /* boot complete */);&#125;// 到这里，系统中所有的 package 都被扫描刀了，这里是更新他们上一次的使用信息！mPackageUsage.read(mPackages);mCompilerStats.read();... ... ... ...// 见，第四阶段 当mOnlyCore = false时，则 scanDirLI 还会收集如下目录中的 apk 的信息！ /data/app /data/app-private 2.3.1 主要流程2.4 PMS_SCAN_END下面是第四阶段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120... ... ... ...// 第四阶段EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());Slog.i(TAG, \"Time to scan packages: \" + ((SystemClock.uptimeMillis()-startTime)/1000f) + \" seconds\");// If the platform SDK has changed since the last time we booted,// we need to re-grant app permission to catch any new ones that// appear. This is really a hack, and means that apps can in some// cases get permissions that the user didn't initially explicitly// allow... it would be nice to have some better way to handle// this situation.// 如果从我们上次启动，SDK 平台被改变了，我们需要重新授予应用程序权限。int updateFlags = UPDATE_PERMISSIONS_ALL;if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \" + mSdkVersion + \"; regranting permissions for internal storage\"); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;&#125;// 赋予 package 相应请求的权限 updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);ver.sdkVersion = mSdkVersion;// If this is the first boot or an update from pre-M, and it is a normal// boot, then we need to initialize the default preferred apps across// all defined users.// 如果这是第一次开机或前-M的更新，这是一个正常的启动，然后我们需要初始化默认的首选应用程序给所有已经定义的用户。if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123; for (UserInfo user : sUserManager.getUsers(true)) &#123; mSettings.applyDefaultPreferredAppsLPw(this, user.id); applyFactoryDefaultBrowserLPw(user.id); primeDomainVerificationsLPw(user.id); &#125;&#125;// Prepare storage for system user really early during boot,// since core system apps like SettingsProvider and SystemUI// can't wait for user to startfinal int storageFlags;if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123; storageFlags = StorageManager.FLAG_STORAGE_DE;&#125; else &#123; storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;&#125;reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM, storageFlags);// If this is first boot after an OTA, and a normal boot, then// we need to clear code cache directories.// Note that we do *not* clear the application profiles. These remain valid// across OTAs and are used to drive profile verification (post OTA) and// profile compilation (without waiting to collect a fresh set of profiles).// 如果这是在OTA升级后第一启动，这是正常的启动，然后我们需要清除代码缓存目录。if (mIsUpgrade &amp;&amp; !onlyCore) &#123; Slog.i(TAG, \"Build fingerprint changed; clearing code caches\"); for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123; final PackageSetting ps = mSettings.mPackages.valueAt(i); if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123; // No apps are running this early, so no need to freeze clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); &#125; &#125; ver.fingerprint = Build.FINGERPRINT;&#125;checkDefaultBrowser();// clear only after permissions and other defaults have been updated// 当权限和其他默认设置被更新后，执行清除操作。mExistingSystemPackages.clear();mPromoteSystemApps = false;// All the changes are done during package scanning.ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;// can downgrade to reader// 信息写回 packages.xml 文件mSettings.writeLPr();// Perform dexopt on all apps that mark themselves as coreApps. We do this pretty// early on (before the package manager declares itself as early) because other// components in the system server might ask for package contexts for these apps.//// Note that \"onlyCore\" in this context means the system is encrypted or encrypting// (i.e, that the data partition is unavailable).if ((isFirstBoot() || isUpgrade() || VMRuntime.didPruneDalvikCache()) &amp;&amp; !onlyCore) &#123; long start = System.nanoTime(); List&lt;PackageParser.Package&gt; coreApps = new ArrayList&lt;&gt;(); for (PackageParser.Package pkg : mPackages.values()) &#123; if (pkg.coreApp) &#123; coreApps.add(pkg); &#125; &#125; int[] stats = performDexOptUpgrade(coreApps, false, getCompilerFilterForReason(REASON_CORE_APP)); final int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start); MetricsLogger.histogram(mContext, \"opt_coreapps_time_s\", elapsedTimeSeconds); if (DEBUG_DEXOPT) &#123; Slog.i(TAG, \"Dex-opt core apps took : \" + elapsedTimeSeconds + \" seconds (\" + stats[0] + \", \" + stats[1] + \", \" + stats[2] + \")\"); &#125; // TODO: Should we log these stats to tron too ? // MetricsLogger.histogram(mContext, \"opt_coreapps_num_dexopted\", stats[0]); // MetricsLogger.histogram(mContext, \"opt_coreapps_num_skipped\", stats[1]); // MetricsLogger.histogram(mContext, \"opt_coreapps_num_failed\", stats[2]); // MetricsLogger.histogram(mContext, \"opt_coreapps_num_total\", coreApps.size());&#125;... ... ... ...// 见，第五阶段 暂时先写到这里！ 2.4.1 主要流程2.5 PMS_READY1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 ... ... ... ...// 第五阶段 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis()); if (!mOnlyCore) &#123; mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr(); mRequiredInstallerPackage = getRequiredInstallerLPr(); mRequiredUninstallerPackage = getRequiredUninstallerLPr(); mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr(); mIntentFilterVerifier = new IntentVerifierProxy(mContext, mIntentFilterVerifierComponent); mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES); mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SHARED); &#125; else &#123; mRequiredVerifierPackage = null; mRequiredInstallerPackage = null; mRequiredUninstallerPackage = null; mIntentFilterVerifierComponent = null; mIntentFilterVerifier = null; mServicesSystemSharedLibraryPackageName = null; mSharedSystemSharedLibraryPackageName = null; &#125; // 建立 PackageInstallerService 服务对象 mInstallerService = new PackageInstallerService(context, this); final ComponentName ephemeralResolverComponent = getEphemeralResolverLPr(); final ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr(); // both the installer and resolver must be present to enable ephemeral if (ephemeralInstallerComponent != null &amp;&amp; ephemeralResolverComponent != null) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.i(TAG, \"Ephemeral activated; resolver: \" + ephemeralResolverComponent + \" installer:\" + ephemeralInstallerComponent); &#125; mEphemeralResolverComponent = ephemeralResolverComponent; mEphemeralInstallerComponent = ephemeralInstallerComponent; setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent); mEphemeralResolverConnection = new EphemeralResolverConnection(mContext, mEphemeralResolverComponent); &#125; else &#123; if (DEBUG_EPHEMERAL) &#123; final String missingComponent = (ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? \"resolver and installer\" : \"resolver\" : \"installer\"; Slog.i(TAG, \"Ephemeral deactivated; missing \" + missingComponent); &#125; mEphemeralResolverComponent = null; mEphemeralInstallerComponent = null; mEphemeralResolverConnection = null; &#125; mEphemeralApplicationRegistry = new EphemeralApplicationRegistry(this); &#125; // synchronized (mPackages) &#125; // synchronized (mInstallLock) // Now after opening every single application zip, make sure they // are all flushed. Not really needed, but keeps things nice and // tidy. Runtime.getRuntime().gc(); // The initial scanning above does many calls into installd while // holding the mPackages lock, but we're mostly interested in yelling // once we have a booted system. mInstaller.setWarnIfHeld(mPackages); // Expose private service for system components to use. LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); &#125; PKMS 初始化完成阶段，还会创建一个 PackageInstaller 服务。 3 总结PackageManagerService 的初始化工作都是在它的构造函数中完成的，主要完成一下任务： 1、 添加一些用户 id，如 system、phone 等；2、 解析 /system/etc/permission 下的 xml 文件，主要 是 platform.xml，建立 permission 和 gid 之间的关系，可以指定一个权限与几个组对应，当一个 apk 被授予这个权限时它也同时属于这几个组，readPermission(parser， perm)； 给一些底层用户分配一些权限，如 shell 授予各种 permission，把一个权限赋予一个 uid，当 apk 使用这个 uid 运行时，就具备了这个权限系统增加的一些应用需要 link 的扩展的 jar 库，系统每增加一个硬件，都要添加相应的 featrue，将解析结果放入 mAvailableFeatures;3、 建立并启动 PackageHandler 消息循环，用于处理 apk 安装请求如 adb install，package installer 安装 apk 时就会发送消息；4、 检查 /data/system/packages.xml 是否存在，里面记录了系统的 permission，以及每个apk的 name，codePath，flags，ts，version，userid 等，这些信息主要是通过 apk 安装的时候解析 AndroidManifest.xml 获取到的，解析完 apk 后将更新信息写入这个文件并保存到 flash，下次开机直接从里面读取相关信息添加到内存相关列表中，当有 apk 安装，升级，删除时会更新这个文件；5、 检查 BootClassPath，mSharedLibraries 及 /system/framework 下的jar是否需要 dexopt ，需要则通过 dexopt 进行优化，这里面主要是调用 mInstaller.dexopt 进行相应的优化；6、 建立 java 层的 installer 与 c 层的 installd 的 socket 联接，使得在上层的 install，remove，dexopt 等功能最终由 installd 在底层实现；7、 启动 AppDirObserver 线程往中监测 /system/framework，/system/app，/data/app/data/app-private 目录的事件，主要监听 add 和 remove 事件，对于目录监听底层通过 inotify 机制实现，inotify 是一种文件系统的变化通知机制如文件增加、删除等事件可以立刻让用户态得知，它为用户态监视文件系统的变化提供了强大的支持，当有 add event 时调用 scanPackageLI(File，in，int) 处理，当有 remove event 时调用 removePackageLI 处理；8、 调用 scanDirLI 启动 apk 解析，解析目录包括：/system/framework、/system/app、/vendor/app、/data/app、/data/app-private；9、 移除临时文件；10、 赋予 package 相应请求的权限；11、 将解析出的 Package 的相关信息保存到相关全局变量，还有文件。 后面我们会分析每个阶段的主要流程，不要着急！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"PackageManager包管理","slug":"AndroidFramework源码分析/PackageManager包管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/PackageManager包管理/"}],"tags":[{"name":"PackageManager包管理","slug":"PackageManager包管理","permalink":"https://coolqi.top/tags/PackageManager包管理/"}]},{"title":"Doze模式第 2 篇 - DeviceIdleController 动态机制","slug":"Doze2-deviceIdleControllerDynamic","date":"2017-11-25T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/11/25/Doze2-deviceIdleControllerDynamic/","link":"","permalink":"https://coolqi.top/2017/11/25/Doze2-deviceIdleControllerDynamic/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，分析 doze 模式的原理！ 0 综述在 doze 模式下，应用会受到以下限制： 暂停访问 network。 系统将忽略 wake locks。 标准 AlarmManager 闹铃（包括 setExact() 和 setWindow()）推迟到 doze 模式的下一个 maintenance window 时间窗。 如果您需要设置在低电耗模式下触发的闹铃，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。 一般情况下，使用 setAlarmClock() 设置的闹铃将继续触发，但系统会在这些闹铃触发之前不久退出低电耗模式。 系统不执行 Wi-Fi 扫描。 系统不允许运行 同步适配器。 系统不允许运行 JobScheduler。 下面先分析下 doze 模式内部机制是如何调控的： 1 动态监听机制1.1 monitor display1.1.1 updateDisplayLocked监控屏幕状态： 1234567891011121314151617private final DisplayManager.DisplayListener mDisplayListener = new DisplayManager.DisplayListener() &#123; @Override public void onDisplayAdded(int displayId) &#123; &#125; @Override public void onDisplayRemoved(int displayId) &#123; &#125; @Override public void onDisplayChanged(int displayId) &#123; if (displayId == Display.DEFAULT_DISPLAY) &#123; synchronized (DeviceIdleController.this) &#123; //【1】当屏幕状态发生变化后，会触发该方法！ updateDisplayLocked(); &#125; &#125; &#125;&#125;; 我们去看看 DeviceIdleController.updateDisplayLocked 方法！ updateDisplayLocked 用于更新屏幕的状态！ 123456789101112131415161718192021void updateDisplayLocked() &#123; //【1】获取屏幕当前的状态，并判断是否是亮屏状态！ mCurDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY); boolean screenOn = mCurDisplay.getState() == Display.STATE_ON; if (DEBUG) Slog.d(TAG, \"updateDisplayLocked: screenOn=\" + screenOn); if (!screenOn &amp;&amp; mScreenOn) &#123; //【2.1】如果是从亮屏转为熄屏，设置 mScreenOn 为 false！ // 同时，尝试进入 Doze 模式； mScreenOn = false; if (!mForceIdle) &#123; becomeInactiveIfAppropriateLocked(); &#125; &#125; else if (screenOn) &#123; //【2.2】如果是从熄屏转亮屏，设置 mScreenOn 为 true！ // 同时，退出 Doze 模式； mScreenOn = true; if (!mForceIdle) &#123; becomeActiveLocked(\"screen\", Process.myUid()); &#125; &#125;&#125; mForceIdle 表示是否强制进入 idle 状态，默认为 false 的，目前唯一的开启方式是通过 adb shell，执行 dumpsys 命令，触发 force-idle，force-inactive 相关指令，强制进入 idle 状态！！ 这里看到： 当熄屏后，设置 mScreenOn 为 false，会调用 becomeInactiveIfAppropriateLocked 方法，进入 doze 模式； 当亮屏后，设置 mScreenOn 为 true，会调用 becomeActiveLocked 方法，退出 doze 模式； 1.2 monitor battey1.2.1 updateChargingLocked监控电池状态：1234567891011121314private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; switch (intent.getAction()) &#123; ... ... ... case Intent.ACTION_BATTERY_CHANGED: &#123; synchronized (DeviceIdleController.this) &#123; int plugged = intent.getIntExtra(\"plugged\", 0); updateChargingLocked(plugged != 0); //【1】电量变化 &#125; &#125; break; ... ... ... &#125; &#125;&#125;; 我们继续看 DeviceIdleController.updateChargingLocked 方法！123456789101112131415161718void updateChargingLocked(boolean charging) &#123; if (DEBUG) Slog.i(TAG, \"updateChargingLocked: charging=\" + charging); if (!charging &amp;&amp; mCharging) &#123; //【1】结束充电！ mCharging = false; if (!mForceIdle) &#123; //【2.1】尝试进入 doze 模式！ becomeInactiveIfAppropriateLocked(); &#125; &#125; else if (charging) &#123; //【2】开始充电！ mCharging = charging; if (!mForceIdle) &#123; //【2.2】退出 doze 模式！ becomeActiveLocked(\"charging\", Process.myUid()); &#125; &#125;&#125; 这里看到： 当结束充电后，设置 mCharging 为 false，会调用 becomeInactiveIfAppropriateLocked 方法，进入 doze 模式； 当开始充电后，设置 mCharging 为 true，会调用 becomeActiveLocked 方法，退出 doze 模式； 1.3 monitor connectivity1.3.1 updateConnectivityState监控网络连接状态：1234567891011private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; switch (intent.getAction()) &#123; case ConnectivityManager.CONNECTIVITY_ACTION: &#123; //【1】更新网络连接状态！ updateConnectivityState(intent); &#125; break; ... ... ... &#125; &#125;&#125;; 我们继续看 DeviceIdleController.updateConnectivityState 方法！123456789101112131415161718192021222324252627282930313233343536373839void updateConnectivityState(Intent connIntent) &#123; ConnectivityService cm; synchronized (this) &#123; cm = mConnectivityService; &#125; if (cm == null) &#123; return; &#125; NetworkInfo ni = cm.getActiveNetworkInfo(); synchronized (this) &#123; boolean conn; if (ni == null) &#123; conn = false; //【1】网络断开，conn 为 false； &#125; else &#123; //【2】获得网络的连接状态； if (connIntent == null) &#123; conn = ni.isConnected(); &#125; else &#123; final int networkType = connIntent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE); if (ni.getType() != networkType) &#123; return; &#125; conn = !connIntent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false); &#125; &#125; //【3】处理连接状态，如果当前状态和之前的状态发生了变化，更新 mNetworkConnected 的值！ if (conn != mNetworkConnected) &#123; mNetworkConnected = conn; if (conn &amp;&amp; mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123; //【2.3】如果本次状态是处于连接中，并且 mLightState 值为 LIGHT_STATE_WAITING_FOR_NETWORK！ // 调用 stepLightIdleStateLocked 方法！ stepLightIdleStateLocked(\"network\"); &#125; &#125; &#125;&#125; mNetworkConnected 表示之前的网络连接！ 1.4 monitor Motion1.4.1 startMonitoringMotionLocked监听设备的运动： 123456void startMonitoringMotionLocked() &#123; if (DEBUG) Slog.d(TAG, \"startMonitoringMotionLocked()\"); if (mMotionSensor != null &amp;&amp; !mMotionListener.active) &#123; mMotionListener.registerLocked(); &#125;&#125; DeviceIdleController 内部有一个 mMotionListener 对象，用于监听传感器的变化！ 1private final MotionListener mMotionListener = new MotionListener(); 我们来看下 MotionListener 中的方法！ 1.4.1.1 mMotionListener.registerLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private final class MotionListener extends TriggerEventListener implements SensorEventListener &#123; boolean active = false; // 表示 MotionListener 是否被注册！ //【1】当传感器的被触发后，会调用 onTrigger() @Override public void onTrigger(TriggerEvent event) &#123; synchronized (DeviceIdleController.this) &#123; active = false; //【1.4.1.2】调用 motionLocked 方法！ motionLocked(); &#125; &#125; //【2】当传感器的值发生变化时，会调用 OnSensorChanged() @Override public void onSensorChanged(SensorEvent event) &#123; synchronized (DeviceIdleController.this) &#123; mSensorManager.unregisterListener(this, mMotionSensor); active = false; //【1.4.1.2】调用 motionLocked 方法！ motionLocked(); &#125; &#125; // 当传感器的精度发生变化时会调用 OnAccuracyChanged() 方法! @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;&#125; //【3】注册 MotionListener！ public boolean registerLocked() &#123; boolean success; //【1.1】调用了 mSensorManager 的相关方法注册监听器！ if (mMotionSensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) &#123; success = mSensorManager.requestTriggerSensor(mMotionListener, mMotionSensor); &#125; else &#123; success = mSensorManager.registerListener( mMotionListener, mMotionSensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; if (success) &#123; active = true; //【1.2】设置监听器为活跃状态！ &#125; else &#123; Slog.e(TAG, \"Unable to register for \" + mMotionSensor); &#125; return success; &#125; //【4】解除注册 MotionListener！ public void unregisterLocked() &#123; if (mMotionSensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) &#123; mSensorManager.cancelTriggerSensor(mMotionListener, mMotionSensor); &#125; else &#123; mSensorManager.unregisterListener(mMotionListener); &#125; active = false; &#125;&#125; 继续看： 1.4.1.2 DeviceIdleC.motionLocked12345void motionLocked() &#123; if (DEBUG) Slog.d(TAG, \"motionLocked()\"); //【1.4.1.3】调用 handleMotionDetectedLocked 处理传感器变化！ handleMotionDetectedLocked(mConstants.MOTION_INACTIVE_TIMEOUT, \"motion\");&#125; 1.4.1.3 DeviceIdleC.handleMotionDetectedLocked由于此时传感器被触发或者值发生了变化，那么此时我们不能进入 doze 模式，需要回退到 active 状态！！ 1234567891011121314151617181920212223242526272829void handleMotionDetectedLocked(long timeout, String type) &#123; boolean becomeInactive = false; //【1】处理 deep idle 模式的退出！！ if (mState != STATE_ACTIVE) &#123; //【2.2.1】调用了 scheduleReportActiveLocked，退出 doze 模式，恢复 active 状态！ scheduleReportActiveLocked(type, Process.myUid()); mState = STATE_ACTIVE; mInactiveTimeout = timeout; mCurIdleBudget = 0; mMaintenanceStartTime = 0; EventLogTags.writeDeviceIdle(mState, type); addEvent(EVENT_NORMAL); becomeInactive = true; &#125; //【1】处理 light idle 模式的退出，我们只有在退出 deep idle 时才会同时退出 light idle！！ if (mLightState == LIGHT_STATE_OVERRIDE) &#123; mLightState = STATE_ACTIVE; EventLogTags.writeDeviceIdleLight(mLightState, type); becomeInactive = true; &#125; //【2.1】这里 becomeInactive 为 true 时，会重新调用 becomeInactiveIfAppropriateLocked 方法 // 重新开始了阶段条件的判断！ if (becomeInactive) &#123; becomeInactiveIfAppropriateLocked(); &#125;&#125; 这里就先分析到这里！ 1.5 monitor Angle1.5.1 AnyMotionDetector.checkForAnyMotion监听设备的角度变化，我们在 onStart 方法中有创建一个 AnyMotionDetector 实例，用于监听设备的角度变化是否超过阈值！ 1234567//【1】获得角度阈值；float angleThreshold = getContext().getResources().getInteger( com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;//【2】创建角度变化监听器；mAnyMotionDetector = new AnyMotionDetector( (PowerManager) getContext().getSystemService(Context.POWER_SERVICE), mHandler, mSensorManager, this, angleThreshold); 这里面最关键的一个参数是 AnyMotionDetector 的倒数第二个参数：DeviceIdleCallback callback，这里传入的是 DeviceIdleController，因为 DeviceIdleController 实现了 AnyMotionDetector.DeviceIdleCallback！ 1234567public class AnyMotionDetector &#123; interface DeviceIdleCallback &#123; //【1.5.2】onAnyMotionResult 处理角度的变化； public void onAnyMotionResult(int result); &#125; ... ... ...&#125; 当角度发生变化后，会触发 onAnyMotionResult 回调！ 1.5.2 DeviceIdleC.onAnyMotionResult我们来看看 onAnyMotionResult 方法！1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void onAnyMotionResult(int result) &#123; if (DEBUG) Slog.d(TAG, \"onAnyMotionResult(\" + result + \")\"); //【1】正常情况，首先取消 mSensingTimeoutAlarmListener； if (result != AnyMotionDetector.RESULT_UNKNOWN) &#123; synchronized (this) &#123; //【1.1.1.1.2】调用 cancelSensingTimeoutAlarmLocked 取消； cancelSensingTimeoutAlarmLocked(); &#125; &#125; //【2】当 result 为 RESULT_MOVED，说明角度变化超过了阈值； if ((result == AnyMotionDetector.RESULT_MOVED) || (result == AnyMotionDetector.RESULT_UNKNOWN)) &#123; synchronized (this) &#123; //【1.4.3】不处于静止状态，又调用了 handleMotionDetectedLocked 方法，恢复 active 状态； handleMotionDetectedLocked(mConstants.INACTIVE_TIMEOUT, \"non_stationary\"); &#125; &#125; else if (result == AnyMotionDetector.RESULT_STATIONARY) &#123; //【3】当 result 为 RESULT_STATIONARY，说明角度并没有发生超过阈值的变化； if (mState == STATE_SENSING) &#123; //【3.1】当 mState 是 STATE_SENSING，那么我们会进入下一阶段； synchronized (this) &#123; // 设置 STATE_SENSING 为 true！ mNotMoving = true; stepIdleStateLocked(\"s:stationary\"); &#125; &#125; else if (mState == STATE_LOCATING) &#123; //【3.1】当 mState 是 STATE_LOCATING，那么我们同样会进入下一阶段； synchronized (this) &#123; mNotMoving = true; if (mLocated) &#123; stepIdleStateLocked(\"s:stationary\"); &#125; &#125; &#125; &#125;&#125; 1.6 monitor Location - 监听位置监控定位： 1234567891011121314151617181920//【1】监听网络定位 network location provider！if (mLocationManager != null &amp;&amp; mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) &#123; mLocationManager.requestLocationUpdates(mLocationRequest, mGenericLocationListener, mHandler.getLooper()); //【1.6.1】 mLocating = true;&#125; else &#123; mHasNetworkLocation = false;&#125;//【2】监听 GPS location provider！if (mLocationManager != null &amp;&amp; mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) &#123; mHasGps = true; mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000, 5, mGpsLocationListener, mHandler.getLooper()); //【1.6.2】 mLocating = true;&#125; else &#123; mHasGps = false;&#125; 我们看到，这里向 LocationManager 中注册了两个监听器：mGenericLocationListener 和 mGpsLocationListener！ 1.6.1 mGenericLocationListener.onLocationChanged12345678910private final LocationListener mGenericLocationListener = new LocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; synchronized (DeviceIdleController.this) &#123; //【1.6.1.1】处理定位的变化！ receivedGenericLocationLocked(location); &#125; &#125; ... ... ... ... // 省去无需关注！&#125;; 当定位发生变化后，onLocationChanged 触发！ 1.6.1.1 DeviceIdleC.receivedGenericLocationLocked1234567891011121314151617181920void receivedGenericLocationLocked(Location location) &#123; //【1】判断下 mState，如果不是 STATE_LOCATING，就调用 cancelLocatingLocked，取消定位监听！ if (mState != STATE_LOCATING) &#123; cancelLocatingLocked(); return; &#125; if (DEBUG) Slog.d(TAG, \"Generic location: \" + location); //【2】将定位信息保存到 mLastGenericLocation 中，用于 dumpsys！ mLastGenericLocation = new Location(location); // 如果定位精度超过 mConstants.LOCATION_ACCURACY(20meter)，直接返回，不进入下一阶段； if (location.getAccuracy() &gt; mConstants.LOCATION_ACCURACY &amp;&amp; mHasGps) &#123; return; &#125; //【3】设置 mLocated 为 true，表示定位完成！ mLocated = true; if (mNotMoving) &#123; //【3.1】如果此时手机没有发生移动，调用 stepIdleStateLocked 处理 STATE_LOCATING 状态！ stepIdleStateLocked(\"s:location\"); &#125;&#125; 不多说！ 1.6.2 mGpsLocationListener.onLocationChanged12345678910private final LocationListener mGpsLocationListener = new LocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; synchronized (DeviceIdleController.this) &#123; //【1.6.2.1】处理定位的变化！ receivedGpsLocationLocked(location); &#125; &#125; ... ... ... ... ... // 省去无需关注！&#125;; 当定位发生变化后，onLocationChanged 触发！ 1.6.2.1 DeviceIdleC.receivedGpsLocationLocked1234567891011121314151617181920void receivedGpsLocationLocked(Location location) &#123; //【1】判断下 mState，如果不是 STATE_LOCATING，就调用 cancelLocatingLocked，取消定位监听！ if (mState != STATE_LOCATING) &#123; cancelLocatingLocked(); return; &#125; if (DEBUG) Slog.d(TAG, \"GPS location: \" + location); //【2】将定位信息保存到 mLastGpsLocation 中，用于 dumpsys！ mLastGpsLocation = new Location(location); // 如果定位精度超过 mConstants.LOCATION_ACCURACY(20meter)，直接返回，不进入下一阶段； if (location.getAccuracy() &gt; mConstants.LOCATION_ACCURACY) &#123; return; &#125; //【3】设置 mLocated 为 true，表示定位完成！ mLocated = true; if (mNotMoving) &#123; //【3.1】如果此时手机没有发生移动，调用 stepIdleStateLocked 处理 STATE_LOCATING 状态！ stepIdleStateLocked(\"s:gps\"); &#125;&#125; 不多说！ 2 核心逻辑分析2.1 DeviceIdleC.becomeInactiveIfAppropriateLocked尝试进入 doze 模式，这里会对 doze 模式第一阶段的条件做一个处理！！12345678910111213141516171819202122232425262728void becomeInactiveIfAppropriateLocked() &#123; if (DEBUG) Slog.d(TAG, \"becomeInactiveIfAppropriateLocked()\"); //【1】如果是熄屏并且没有充电的充电的情况下，或者是强制进入 idle 状态下！ if ((!mScreenOn &amp;&amp; !mCharging) || mForceIdle) &#123; //【1.1】处理 deep idle 模式逻辑！！ if (mState == STATE_ACTIVE &amp;&amp; mDeepEnabled) &#123; mState = STATE_INACTIVE; if (DEBUG) Slog.d(TAG, \"Moved from STATE_ACTIVE to STATE_INACTIVE\"); //【5.1】重置相关变量！！ resetIdleManagementLocked(); //【2.1.1.1】设置 alarm，用于进入下一阶段！！ scheduleAlarmLocked(mInactiveTimeout, false); EventLogTags.writeDeviceIdle(mState, \"no activity\"); &#125; //【1.2】处理 light idle 模式逻辑！！ if (mLightState == LIGHT_STATE_ACTIVE &amp;&amp; mLightEnabled) &#123; mLightState = LIGHT_STATE_INACTIVE; if (DEBUG) Slog.d(TAG, \"Moved from LIGHT_STATE_ACTIVE to LIGHT_STATE_INACTIVE\"); //【5.2】重置相关变量！！ resetLightIdleManagementLocked(); //【2.1.2.1】设置 alarm！！ scheduleLightAlarmLocked(mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT); EventLogTags.writeDeviceIdleLight(mLightState, \"no activity\"); &#125; &#125;&#125; 首先判断了条件： 如果是熄屏并且没有充电的充电的情况下，或者是强制进入 idle 状态下！ 然后针对 deep idle 和 light idle 两种模式，做了不同的处理！ 2.1.1 deep idle 逻辑首先，设置 mState 从 STATE_ACTIVE 为 STATE_INACTIVE； 然后，重置 deep idle 逻辑相关的变量，取消 Alarm 和监控器！！ 最后，设置 deep idle 的 Alarm： 2.1.1.1 scheduleAlarmLocked设置 deep idle 的 Alarm： 参数传递： long delay 传入的是 mInactiveTimeout，mInactiveTimeout 在 onStat 方法中被初始化为 mConstants.INACTIVE_TIMEOUT 为 30 mins; boolean idleUntil 传入的是 false，因为还没有进入 idle 状态！ 1234567891011121314151617void scheduleAlarmLocked(long delay, boolean idleUntil) &#123; if (DEBUG) Slog.d(TAG, \"scheduleAlarmLocked(\" + delay + \", \" + idleUntil + \")\"); if (mMotionSensor == null) &#123; //【1】如果当前设备没有运动传感器，那就不会设置 alarm，因为无法判断设备是否移动！ return; &#125; //【2】计算 alarm 的触发时间！ mNextAlarmTime = SystemClock.elapsedRealtime() + delay; if (idleUntil) &#123; mAlarmManager.setIdleUntil(AlarmManager.ELAPSED_REALTIME_WAKEUP, mNextAlarmTime, \"DeviceIdleController.deep\", mDeepAlarmListener, mHandler); &#125; else &#123; //【2.1.1.2】idleUntil 为 false，设置一个 delay 时间间隔后的 Alarm！ mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mNextAlarmTime, \"DeviceIdleController.deep\", mDeepAlarmListener, mHandler); &#125;&#125; 在 delay 时间间隔后会触发 mDeepAlarmListener，在 mHandler 所在的线程执行！ 2.1.1.2 mDeepAlarmListener.onAlarm1234567891011private final AlarmManager.OnAlarmListener mDeepAlarmListener = new AlarmManager.OnAlarmListener() &#123; @Override public void onAlarm() &#123; synchronized (DeviceIdleController.this) &#123; //【2.3】第一阶段条件满足！ stepIdleStateLocked(\"s:alarm\"); &#125; &#125;&#125;; 当设备处于熄屏并且未充电 30 mins 以后，DeepAlarmListener 会被触发，这时 deep idle 模式的第一阶段条件满足，执行 stepIdleStateLocked 方法！ 2.1.2 light idle 逻辑回顾下流程： 首先，设置 mLightState 从 LIGHT_STATE_ACTIVE 变为 LIGHT_STATE_INACTIVE； 然后，同样的重置相关变量； 最后，设置 light idle 的 alarm； 2.1.2.1 scheduleLightAlarmLocked设置 light idle 的 Alarm，参数 long delay 传入：mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT 为 5 mins！12345678void scheduleLightAlarmLocked(long delay) &#123; if (DEBUG) Slog.d(TAG, \"scheduleLightAlarmLocked(\" + delay + \")\"); mNextLightAlarmTime = SystemClock.elapsedRealtime() + delay; //【2.1.2.2】设置一个时间间隔为 delay 后的 alarm，用于触发 mLightAlarmListener！ mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mNextLightAlarmTime, \"DeviceIdleController.light\", mLightAlarmListener, mHandler);&#125; 设置一个时间间隔为 delay 后的 alarm，用于触发 mLightAlarmListener！ 2.1.2.2 mLightAlarmListener.onAlarm12345678910private final AlarmManager.OnAlarmListener mLightAlarmListener = new AlarmManager.OnAlarmListener() &#123; @Override public void onAlarm() &#123; synchronized (DeviceIdleController.this) &#123; //【3.2】进入 light idle 模式的第一阶段条件满足！ stepLightIdleStateLocked(\"s:alarm\"); &#125; &#125;&#125;; 当设备处于熄屏并且未充电 5 mins 以后，mLightAlarmListener.onAlarm 会被触发，这时 light idle 模式的第一阶段条件满足，执行 stepIdleStateLocked 方法！ 2.2 DeviceIdleC.becomeActiveLocked - 退出 doze 模式退出 doze 模式！ 123456789101112131415161718192021222324void becomeActiveLocked(String activeReason, int activeUid) &#123; if (DEBUG) Slog.i(TAG, \"becomeActiveLocked, reason = \" + activeReason); //【1】如果 mState 不等于 STATE_ACTIVE 或者 mLightState 不等于 STATE_ACTIVE！ if (mState != STATE_ACTIVE || mLightState != STATE_ACTIVE) &#123; EventLogTags.writeDeviceIdle(STATE_ACTIVE, activeReason); EventLogTags.writeDeviceIdleLight(LIGHT_STATE_ACTIVE, activeReason); //【2.2.1】调用了 scheduleReportActiveLocked，退出 doze 模式，恢复 active 状态！ scheduleReportActiveLocked(activeReason, activeUid); // 重置关键变量！ mState = STATE_ACTIVE; mLightState = LIGHT_STATE_ACTIVE; mInactiveTimeout = mConstants.INACTIVE_TIMEOUT; mCurIdleBudget = 0; mMaintenanceStartTime = 0; //【5.1】重置 deep idle 模式 resetIdleManagementLocked(); //【5.2】重置 light idle 模式 resetLightIdleManagementLocked(); addEvent(EVENT_NORMAL); &#125;&#125; 首先判断了下状态： 如果 mState 不等于 STATE_ACTIVE 或者 mLightState 不等于 STATE_ACTIVE，执行退出操作！ 设置 mState 为 STATE_ACTIVE； 设置 mLightState 为 LIGHT_STATE_ACTIVE； 2.2.1 scheduleReportActiveLocked12345void scheduleReportActiveLocked(String activeReason, int activeUid) &#123; //【4.4】发送 MSG_REPORT_ACTIVE 给 MyHandler，退出 doze 模式！ Message msg = mHandler.obtainMessage(MSG_REPORT_ACTIVE, activeUid, 0, activeReason); mHandler.sendMessage(msg);&#125; 3 Doze 模式状态处理3.1 DeviceIdleC.stepIdleStateLocked对于 deep idle 模式来说，是通过 stepIdleStateLocked 方法处理每个阶段的状态的！ 1234567891011121314151617181920212223242526272829303132333435void stepIdleStateLocked(String reason) &#123; if (DEBUG) Slog.d(TAG, \"stepIdleStateLocked: mState=\" + mState); EventLogTags.writeDeviceIdleStep(); final long now = SystemClock.elapsedRealtime(); //【1】如果在 1 小时之内有会在 idle 状态下唤醒设备的 Alarm，那么我们不会进入 idle 状态！ if ((now + mConstants.MIN_TIME_TO_ALARM) &gt; mAlarmManager.getNextWakeFromIdleTime()) &#123; if (mState != STATE_ACTIVE) &#123; //【1.1】退出 doze 模式！ becomeActiveLocked(\"alarm\", Process.myUid()); //【2.1】再次调用 becomeInactiveIfAppropriateLocked 重新从第一阶段开始处理！ becomeInactiveIfAppropriateLocked(); &#125; return; &#125; //【2】下面进入状态的判断！ switch (mState) &#123; case STATE_INACTIVE: break; case STATE_IDLE_PENDING: break; case STATE_SENSING: case STATE_LOCATING: case STATE_IDLE_MAINTENANCE: break; case STATE_IDLE: break; &#125;&#125; 我们来重点看看，deep idle 状态处理如下： 3.1.1 状态：STATE_INACTIVE此时，设备已经在熄屏且为充电的状态下 30mins 了，这个时候，准备进入第二阶段： 1234567891011//【1.4】启动传感器监听，判断设备是否有移动！startMonitoringMotionLocked();//【2.1.1.2】启动下一个阶段的 alarm 触发！scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT, false);// Reset the upcoming idle delays.mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT;mNextIdleDelay = mConstants.IDLE_TIMEOUT;// 设置状态为 STATE_IDLE_PENDINGmState = STATE_IDLE_PENDING; 流程分析： 通过 startMonitoringMotionLocked 启动了传感器监听，监听设备是否运动！ 又设置了一个时间间隔为 mConstants.IDLE_AFTER_INACTIVE_TIMEOUT 30mins 的 Alarm，触发的仍然是 mDeepAlarmListener！ mState 状态被设置为了 STATE_IDLE_PENDING！ 第二阶段条件： 这里我们看到了第二阶段条件：熄屏且不充电，同时设备不移动 30mins 后！ 条件满足后，依然会调用 stepIdleStateLocked 方法！ 3.1.2 状态：STATE_IDLE_PENDING此时，设备熄屏且不充电 60mins，同时设备不移动 30mins 了，这个时候，准备进入第三阶段： 1234567891011121314151617181920case STATE_IDLE_PENDING: //【2.2】熄屏且不充电 60mins，设备不移动 30mins 后，第二阶段条件满足，mState 为 STATE_IDLE_PENDING， // 那么我们会进入第三阶段！ mState = STATE_SENSING; if (DEBUG) Slog.d(TAG, \"Moved from STATE_IDLE_PENDING to STATE_SENSING.\"); EventLogTags.writeDeviceIdle(mState, reason); //【3.1.2.1】启动角度监听！ scheduleSensingTimeoutAlarmLocked(mConstants.SENSING_TIMEOUT); //【1.1.1.1.3】取消定位监听，因为定位是下一个阶段的！ cancelLocatingLocked(); // 初始化一些变量！ mNotMoving = false; mLocated = false; mLastGenericLocation = null; mLastGpsLocation = null; //【1.5】启动角度变化监听！ mAnyMotionDetector.checkForAnyMotion(); break; 流程分析： 通过 startMonitoringMotionLocked 启动了传感器监听，监听设备是否运动！ 又设置了一个时间间隔为 mConstants.IDLE_AFTER_INACTIVE_TIMEOUT 30mins 的 Alarm，触发的仍然是 mDeepAlarmListener！ mState 状态被设置为了 STATE_SENSING！ 第三阶段条件： 熄屏且不充电，设备不移动，设备没发生角度变化 4 mins，以后！ 3.1.2.1 DeviceIdleC.scheduleSensingTimeoutAlarmLocked接着设置第三阶段的 Alarm，参数传入的是 mConstants.SENSING_TIMEOUT 4mins：12345678void scheduleSensingTimeoutAlarmLocked(long delay) &#123; if (DEBUG) Slog.d(TAG, \"scheduleSensingAlarmLocked(\" + delay + \")\"); mNextSensingTimeoutAlarmTime = SystemClock.elapsedRealtime() + delay; //【3.1.2.2】4mins 后触发 mSensingTimeoutAlarmListener！ mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mNextSensingTimeoutAlarmTime, \"DeviceIdleController.sensing\", mSensingTimeoutAlarmListener, mHandler);&#125; 接着，设置了一个新的 Alarm，Alarm 触发后，会执行 mSensingTimeoutAlarmListener.onAlarm 方法！ 3.1.2.2 mSensingTimeoutAlarmListener.onAlarm123456789101112private final AlarmManager.OnAlarmListener mSensingTimeoutAlarmListener = new AlarmManager.OnAlarmListener() &#123; @Override public void onAlarm() &#123; if (mState == STATE_SENSING) &#123; synchronized (DeviceIdleController.this) &#123; //【2.1】进入下一个阶段！ becomeInactiveIfAppropriateLocked(); &#125; &#125; &#125;&#125;; 当 mSensingTimeoutAlarmListener 触发后，继续进入了 becomeInactiveIfAppropriateLocked 方法！ 3.1.3 状态：STATE_SENSING and STATE_LOCATING and STATE_IDLE_MAINTENANCE接下来，我们把 STATE_SENSING 和 STATE_LOCATING 和 STATE_IDLE_MAINTENANCE 放在一起看，因为这几个有关联！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283case STATE_SENSING: //【2.3】熄屏且不充电，设备不移动，没发生角度变化 4 mins 后，第三阶段条件满足， // 此时 mState 为 STATE_SENSING， // 那么我们会进入第四阶段！ //【1.1.1.1.2】取消 mSensingTimeoutAlarmListener！ cancelSensingTimeoutAlarmLocked(); // 设置 mState 为 STATE_LOCATING！ mState = STATE_LOCATING; if (DEBUG) Slog.d(TAG, \"Moved from STATE_SENSING to STATE_LOCATING.\"); EventLogTags.writeDeviceIdle(mState, reason); //【2.1.1.2】设置该阶段的 Alarm，时间间隔为 mConstants.LOCATING_TIMEOUT 30s！ scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT, false); // 注册定位监听器，如果注册成功，mLocating 为 true！ if (mLocationManager != null &amp;&amp; mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) &#123; mLocationManager.requestLocationUpdates(mLocationRequest, mGenericLocationListener, mHandler.getLooper()); mLocating = true; &#125; else &#123; mHasNetworkLocation = false; &#125; if (mLocationManager != null &amp;&amp; mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) &#123; mHasGps = true; mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000, 5, mGpsLocationListener, mHandler.getLooper()); mLocating = true; &#125; else &#123; mHasGps = false; &#125; // 如果注册成功， mLocating 为 true，那么就等定位的结果返回 // 如果注册失败，系统中没有 location provider，那就直接进入 STATE_LOCATING 状态！ if (mLocating) &#123; break; &#125;case STATE_LOCATING: //【2.4】处理状态 STATE_LOCATING，这里会取消 Alarm，然后会直接进入 STATE_IDLE_MAINTENANCE //【5.1.1】取消 mDeepAlarmListener； cancelAlarmLocked(); //【5.1.3】取消 mGenericLocationListener，mGpsLocationListener； cancelLocatingLocked(); // 停止监听角度变化！ mAnyMotionDetector.stop();case STATE_IDLE_MAINTENANCE: //【2.5】处理状态 STATE_IDLE_MAINTENANCE，这里设置新的 Alarm，用于进入下一个 STATE_IDLE_MAINTENANCE； // 时间检测是 mNextIdleDelay，注意这里第二个参数是 true，会触发 mAlarmManager.setIdleUntil 方法！ scheduleAlarmLocked(mNextIdleDelay, true); if (DEBUG) Slog.d(TAG, \"Moved to STATE_IDLE. Next alarm in \" + mNextIdleDelay + \" ms.\"); // 计算下一个 mNextIdleDelay 时间间隔，在当前的 mNextIdleDelay 基础上，乘以时间因子！ // 然后在 mNextIdleDelay 和 mConstants.MAX_IDLE_TIMEOUT(6h) 中选择最小的值 // 最后，在 mNextIdleDelay 和 mConstants.IDLE_TIMEOUT(60min) 中选择最大值 mNextIdleDelay = (long)(mNextIdleDelay * mConstants.IDLE_FACTOR); if (DEBUG) Slog.d(TAG, \"Setting mNextIdleDelay = \" + mNextIdleDelay); mNextIdleDelay = Math.min(mNextIdleDelay, mConstants.MAX_IDLE_TIMEOUT); if (mNextIdleDelay &lt; mConstants.IDLE_TIMEOUT) &#123; mNextIdleDelay = mConstants.IDLE_TIMEOUT; &#125; // 同时，设置状态为 STATE_IDLE mState = STATE_IDLE; // 如果此时 light idle 的状态，不为 LIGHT_STATE_OVERRIDE，由于现在要进入 deep idle 状态了 // 所以 light idle 会失效，这里会取消 light idle 的 Alarm！ if (mLightState != LIGHT_STATE_OVERRIDE) &#123; mLightState = LIGHT_STATE_OVERRIDE; cancelLightAlarmLocked(); &#125; EventLogTags.writeDeviceIdle(mState, reason); addEvent(EVENT_DEEP_IDLE); //【4.1】进入 idle 状态！ mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON); break; 1. STATE_SENSING 当熄屏且不充电，设备不移动，没发生角度变化 4 mins 后，就会进入 STATE_SENSING 阶段！ 接着，会设置 mState 为 STATE_LOCATING，然后设置一个 30s 的 Alarm，如果在 30s 内，条件没有发生变化，那么会进入 STATE_LOCATING 阶段！ 接着会注册定位监听器，如果注册成功，那就等待 30s 的 Alarm 触发；如果注册失败，那就直接进入 STATE_LOCATING； 所以该阶段设置的条件是： 熄屏且不充电，设备不移动，没发生角度变化后，开始定位，保持 30s 以后； 熄屏且不充电，设备不移动，没发生角度变化后，直接进入下一个条件； 2. STATE_LOCATING 该状态会直接取消 mDeepAlarmListener，mGenericLocationListener，mGpsLocationListener，同时停止监听角度变化！ 然后会立刻进入 STATE_IDLE_MAINTENANCE 状态！ 3. STATE_IDLE_MAINTENANCE 进入该阶段后，我们就即将进入 deep idle 状态了，接下来，如果所有条件都满足，那么，设备的状态将会在 STATE_IDLE_MAINTENANCE 和 STATE_IDLE 直接切换！ 在 STATE_IDLE_MAINTENANCE 阶段，我们设置了一个 Alarm，时间间隔是 mNextIdleDelay, 在 STATE_INACTIVE 阶段 mNextIdleDelay 初始化为了 mConstants.IDLE_TIMEOUT(60mins) 第一次进入 STATE_IDLE_MAINTENANCE 阶段，我们的 Alarm 的时间间隔为 mConstants.IDLE_TIMEOUT(60mins)，接着对时间间隔 mNextIdleDelay 进行了调整，用于下一次设置 Alarm！ 计算下一个 mNextIdleDelay 时间间隔，在当前的 mNextIdleDelay 基础上，乘以时间因子；然后在 mNextIdleDelay 和 mConstants.MAX_IDLE_TIMEOUT(6h) 中选择最小的值；在 mNextIdleDelay 和 mConstants.IDLE_TIMEOUT(60min) 中选择最大值12345mNextIdleDelay = (long)(mNextIdleDelay * mConstants.IDLE_FACTOR);mNextIdleDelay = Math.min(mNextIdleDelay, mConstants.MAX_IDLE_TIMEOUT);if (mNextIdleDelay &lt; mConstants.IDLE_TIMEOUT) &#123; mNextIdleDelay = mConstants.IDLE_TIMEOUT;&#125; 那么，这个时间间隔为 mNextIdleDelay 的 Alarm 作用是什么呢？我们知道，当设备进入 doze 模式后，隔一段时间后，会进入一个 maintenance window 时间窗，这时，设备会从 idle 状态暂时恢复，集中处理任务！ 所以这个时间间隔 mNextIdleDelay，既是 doze 模式的时间间隔，又是进入 maintenance window 的时间间隔！ 设置 mState 为 STATE_IDLE！ 此时，设备已经进入了 idle 状态！ 如果此时 light idle 的状态，不为 LIGHT_STATE_OVERRIDE，由于现在要进入 deep idle 状态了，所以 light idle 会失效，这里会取消 light idle 的 Alarm！ 最后发送 MSG_REPORT_IDLE_ON 给 MyHandler，通知其他服务，设备进入了 idle 状态！ 注意这里会调用 scheduleAlarmLocked 方法，但是第二个参数传入的是 true： 1234567void scheduleAlarmLocked(long delay, boolean idleUntil) &#123; if (idleUntil) &#123; //【1】执行 setIdleUntil 方法！ mAlarmManager.setIdleUntil(AlarmManager.ELAPSED_REALTIME_WAKEUP, mNextAlarmTime, \"DeviceIdleController.deep\", mDeepAlarmListener, mHandler); &#125;&#125; 分析 AlarmManagerService 的时候，我们又说过 setIdleUntil，该方法会让 AlarmManagerService 进入 doze 模式，直到该 Alarm 触发！该 Alarm 触发后，状态会变为 STATE_IDLE_MAINTENANCE，也就是进入时间窗，同时 Alarm 恢复了！ 3.1.4 状态：STATE_IDLE当 mNextIdleDelay 时间间隔的 Alarm 触发后，设备会暂时退出 doze 模式，进入 maintenance window，集中处理任务！ 123456789101112131415161718192021222324252627case STATE_IDLE: //【2.5】处理状态 STATE_IDLE，这里会设置新的 Alarm，用于进入下一次 STATE_IDLE 状态！ // 同时更新状态为 STATE_IDLE_MAINTENANCE，进入 maintenance window！ mActiveIdleOpCount = 1; // 计数设置为 1； mActiveIdleWakeLock.acquire(); scheduleAlarmLocked(mNextIdlePendingDelay, false); if (DEBUG) Slog.d(TAG, \"Moved from STATE_IDLE to STATE_IDLE_MAINTENANCE. \" + \"Next alarm in \" + mNextIdlePendingDelay + \" ms.\"); //【1】计算进入 maintenance window 的时间点！ mMaintenanceStartTime = SystemClock.elapsedRealtime(); //【2】计算下一次进入 deep idle 状态的 Alarm 时间间隔！ mNextIdlePendingDelay = Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT, (long)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR)); if (mNextIdlePendingDelay &lt; mConstants.IDLE_PENDING_TIMEOUT) &#123; mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT; &#125; //【3】设置状态为 STATE_IDLE_MAINTENANCE！ mState = STATE_IDLE_MAINTENANCE; EventLogTags.writeDeviceIdle(mState, reason); addEvent(EVENT_DEEP_MAINTENANCE); //【4.1】退出 idle 状态！ mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF); break; 进入该阶段后，我们就即将进入 maintenance window 了！ mActiveIdleOpCount 用于统计进入 maintenance window 的次数！ 在 STATE_IDLE 阶段，我们再次设置了一个 Alarm，时间间隔是 mNextIdlePendingDelay, 在 STATE_INACTIVE 阶段 mNextIdleDelay 初始化为了 mConstants.IDLE_TIMEOUT(60mins) 第一次进入 STATE_IDLE_MAINTENANCE 阶段，我们的 Alarm 的时间间隔为 mConstants.IDLE_PENDING_TIMEOUT(5mins)，接着对时间间隔 mNextIdlePendingDelay 进行了调整，用于下一次设置 Alarm！ 计算下一个 mNextIdlePendingDelay 时间间隔： 在当前的 mNextIdlePendingDelay 基础上，乘以时间因子；然后在 mNextIdlePendingDelay 和 mConstants.MAX_IDLE_PENDING_TIMEOUT(10mins) 中选择最小的值；在 mNextIdlePendingDelay 和 mConstants.IDLE_PENDING_TIMEOUT(5mins) 中选择最大值：12345mNextIdlePendingDelay = Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT, (long)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));if (mNextIdlePendingDelay &lt; mConstants.IDLE_PENDING_TIMEOUT) &#123; mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT;&#125; 那么，这个时间间隔为 mNextIdlePendingDelay 的 Alarm 作用是什么呢？ 我们知道，当设备进入 maintenance window 时间窗后，会退出 idle 状态，这时，设备会集中处理任务，但是设备在 maintenance window 时间窗结束后，又要进入 deep idle 状态的！ 所以这个时间间隔 mNextIdlePendingDelay，既是 deep idle 模式的maintenance window 时间窗长度，又是再次进入 idle 的时间间隔！ 最后发送 MSG_REPORT_IDLE_OFF 给 MyHandler，同时其他服务，设备退出了 idle 状态！ 3.2 DeviceIdleC.stepLightIdleStateLocked看完了 deep idle 的状态调度，我们来看看 light idle 的状态调度！ 123456789101112131415161718192021222324void stepLightIdleStateLocked(String reason) &#123; //【1】如果 mLightState 为 LIGHT_STATE_OVERRIDE，说明我们已经处于 deep idle 状态了！ // 那么忽略 light idle！ if (mLightState == LIGHT_STATE_OVERRIDE) &#123; return; &#125; if (DEBUG) Slog.d(TAG, \"stepLightIdleStateLocked: mLightState=\" + mLightState); EventLogTags.writeDeviceIdleLightStep(); //【2】处理 mLightState 的状态！ switch (mLightState) &#123; case LIGHT_STATE_INACTIVE: ... ... ... case LIGHT_STATE_PRE_IDLE: case LIGHT_STATE_IDLE_MAINTENANCE: ... ... ... break; case LIGHT_STATE_IDLE: case LIGHT_STATE_WAITING_FOR_NETWORK: ... ... ... break; &#125;&#125; 继续看！ 3.1.1 状态：LIGHT_STATE_INACTIVE如果是熄屏并且没有充电的充电的情况下，或者是强制进入 idle 状态下，mLightState 会从 LIGHT_STATE_ACTIVE 变为 LIGHT_STATE_INACTIVE 同时会设置一个 Alarm，时间间隔为 mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT 为(5 mins)，Alarm 触发后 mLightAlarmListener.onAlarm 方法会被回调，进入 stepLightIdleStateLocked！ 我们来看看 LIGHT_STATE_INACTIVE 状态的处理！123456789101112131415161718192021case LIGHT_STATE_INACTIVE: mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET; //【1】重置了 mNextLightIdleDelay 和 mMaintenanceStartTime // 后面设置时间窗会用到！ mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT; mMaintenanceStartTime = 0; //【2】判断当前设备是否还有任务和操作要执行！ if (!isOpsInactiveLocked()) &#123; // 如果还有任务要执行，那就不能直接进入 LIGHT_STATE_PRE_IDLE 状态 // 而是设置了一个 Alarm，等待任务执行完！ //【2.1】设置 mLightState 为 LIGHT_STATE_PRE_IDLE！ mLightState = LIGHT_STATE_PRE_IDLE; EventLogTags.writeDeviceIdleLight(mLightState, reason); //【2.1.2.1】设置 Alarm！ scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT); break; &#125; //【3】没有任务在做，直接进入下一阶段！case LIGHT_STATE_PRE_IDLE: 这里调用了 isOpsInactiveLocked 方法，用于判断当前设备是否还有任务和操作要执行！ 当其返回 false 时，说明当前设备还有任务和操作要执行！ 那么就不能直接进入 LIGHT_STATE_IDLE 状态，这里先设置为 LIGHT_STATE_PRE_IDLE，可以看作是 idle 前的一个临时状态！ 同时 scheduleLightAlarmLocked 设置了一个时间间隔为 mConstants.LIGHT_PRE_IDLE_TIMEOUT(10mins) 的 Alarm，等待那些要执行的工作执行完成，然后进入下一个阶段的处理！ 当其返回 true 时，说明当前设备没有任务和操作要执行了！ 那么这种情况，直接进入 idle 状态，具体的逻辑处理是在 3.1.2 LIGHT_STATE_PRE_IDLE/LIGHT_STATE_IDLE_MAINTENANCE 里！ 3.1.2 状态：LIGHT_STATE_PRE_IDLE and LIGHT_STATE_IDLE_MAINTENANCE进入该阶段有两种情况： 设备没有任务和操作要执行，从 LIGHT_STATE_INACTIVE 直接进入； 设备没有任务和操作要执行，Alarm 触发后，从 LIGHT_STATE_PRE_IDLE 进入； 123456789101112131415161718192021222324252627282930313233343536// Nothing active, fall through to immediately idle.case LIGHT_STATE_PRE_IDLE:case LIGHT_STATE_IDLE_MAINTENANCE: //【1】根据 mMaintenanceStartTime 调整 mCurIdleBudget！ if (mMaintenanceStartTime != 0) &#123; long duration = SystemClock.elapsedRealtime() - mMaintenanceStartTime; if (duration &lt; mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) &#123; // We didn't use up all of our minimum budget; add this to the reserve. mCurIdleBudget += (mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET-duration); &#125; else &#123; // We used more than our minimum budget; this comes out of the reserve. mCurIdleBudget -= (duration-mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET); &#125; &#125; mMaintenanceStartTime = 0; //【2】设置一个新的 Alarm，时间间隔为 mNextLightIdleDelay，mNextLightIdleDelay 默认为 // mConstants.LIGHT_IDLE_TIMEOUT(5mins) scheduleLightAlarmLocked(mNextLightIdleDelay); //【3】计算下一次 Alarm 的时间间隔！ mNextLightIdleDelay = Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT, (long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR)); if (mNextLightIdleDelay &lt; mConstants.LIGHT_IDLE_TIMEOUT) &#123; mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT; &#125; if (DEBUG) Slog.d(TAG, \"Moved to LIGHT_STATE_IDLE.\"); //【4】设置 mLightState 为 LIGHT_STATE_IDLE，进入 light idle 状态！ mLightState = LIGHT_STATE_IDLE; EventLogTags.writeDeviceIdleLight(mLightState, reason); addEvent(EVENT_LIGHT_IDLE); //【4.2】发送 MSG_REPORT_IDLE_ON_LIGHT 给 MyHandler，进入 light idle 状态！ mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT); break; 该阶段，我们将 mLightState 设置为了 LIGHT_STATE_IDLE，表示已经进入了 light idle 状态！ 接着，设置一个 Alarm，时间间隔为 mNextLightIdleDelay，第一次设置的时候 mNextLightIdleDelay 使用的默认值 mConstants.LIGHT_IDLE_TIMEOUT(5mins)！ 然后计算下一个 mNextLightIdleDelay 时间间隔： 在当前的 mNextLightIdleDelay 基础上，乘以时间因子； 然后在 mNextLightIdleDelay 和 mConstants.LIGHT_MAX_IDLE_TIMEOUT(15mins) 中选择最小的值； 在 mNextIdleDelay 和 mConstants.LIGHT_IDLE_TIMEOUT(5mins) 中选择最大值： 12345mNextLightIdleDelay = Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT, (long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));if (mNextLightIdleDelay &lt; mConstants.LIGHT_IDLE_TIMEOUT) &#123; mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT;&#125; 这个时间间隔 mNextLightIdleDelay，既是 light idle 模式的 idle 状态时间间隔，又是进入 maintenance window 的时间间隔！ 等待 alarm 触发，进入下一阶段！ 3.1.3 状态：LIGHT_STATE_IDLE and LIGHT_STATE_WAITING_FOR_NETWORK接着我们来看下对于 LIGHT_STATE_IDLE 和 LIGHT_STATE_WAITING_FOR_NETWORK 的处理，当 light idle 时间间隔过去后，会进入 maintenance window，执行任务！123456789101112131415161718192021222324252627282930313233343536373839404142434445case LIGHT_STATE_IDLE:case LIGHT_STATE_WAITING_FOR_NETWORK: if (mNetworkConnected || mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123; //【1】如果此时网络连接，或者 mLightState 的状态为 LIGHT_STATE_WAITING_FOR_NETWORK // 此时 Alarm 已经触发，进入 maintenance window 时间窗，执行任务！ mActiveIdleOpCount = 1; // mActiveIdleOpCount 置为 1； mActiveIdleWakeLock.acquire(); //【2】计算当前的 maintenance window 的开始时间 mMaintenanceStartTime = SystemClock.elapsedRealtime(); if (mCurIdleBudget &lt; mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) &#123; mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET; &#125; else if (mCurIdleBudget &gt; mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) &#123; mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET; &#125; //【3】再次设置 Alarm，时间间隔为 mCurIdleBudget，该 Alarm 用于再次进入 idle 状态！ scheduleLightAlarmLocked(mCurIdleBudget); if (DEBUG) Slog.d(TAG, \"Moved from LIGHT_STATE_IDLE to LIGHT_STATE_IDLE_MAINTENANCE.\"); // 设置 mLightState 为 LIGHT_STATE_IDLE_MAINTENANCE，表示此时处于时间窗中！ mLightState = LIGHT_STATE_IDLE_MAINTENANCE; EventLogTags.writeDeviceIdleLight(mLightState, reason); addEvent(EVENT_LIGHT_MAINTENANCE); //【4.3】发送 MSG_REPORT_IDLE_OFF 给 MyHandler，通知其他服务，退出 idle 状态！ mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF); &#125; else &#123; //【2】此时本应该进入 maintenance window，执行任务，但是由于没有网络连接，那么需要等待网络连接 // 设置一个 Alarm，时间间隔为 mNextLightIdleDelay，等待网络连接！ // 如果在 Alarm 触发之前，网络连接了，那么会再次触发 stepLightIdleStateLocked 方法！ // 如果在 Alarm 触发时，网络仍然没有连接，那就会直接进入 maintenance window 时间窗，执行任务！ scheduleLightAlarmLocked(mNextLightIdleDelay); if (DEBUG) Slog.d(TAG, \"Moved to LIGHT_WAITING_FOR_NETWORK.\"); // 设置 mLightState 为 LIGHT_STATE_WAITING_FOR_NETWORK mLightState = LIGHT_STATE_WAITING_FOR_NETWORK; EventLogTags.writeDeviceIdleLight(mLightState, reason); &#125; break; 我们分析下流程： 此时 idle 状态时间到了，需要进入时间窗执行任务，这里会对 network state 和 mLightState 进行一个判断： 如果 mNetworkConnected 为 true 或者 mLightState == LIGHT_STATE_WAITING_FOR_NETWOR： 表示当前网络已经连接，或者当前网络没有连接但是 light idle 正在等待网络，那么就进入 maintenance window 时间窗，执行任务！ 同时设置 mLightState 为 LIGHT_STATE_IDLE_MAINTENANCE； 接着设置了一个 再次设置 Alarm，时间间隔为 mCurIdleBudget，该 Alarm 用于再次进入 idle 状态！时间间隔 mCurIdleBudget 取值在 [mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET(1mins), mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET(5mins)] 之间！ 最后发送 MSG_REPORT_IDLE_OFF 给 MyHandler，通知其他服务，退出 idle 状态！！ 如果 mNetworkConnected 为 false 且 mLightState != LIGHT_STATE_WAITING_FOR_NETWOR: 那么这个时候，light idle 状态不会立刻进入 maintenance window 时间窗； 会设置一个时间间隔 mNextLightIdleDelay 的 Alarm，等待网络连接； 同时设置 mLightState 为 LIGHT_STATE_WAITING_FOR_NETWORK； 如果在 Alarm 触发之前，网络连接了，那么会再次触发 stepLightIdleStateLocked 方法，进入 if 分支！ 如果在 Alarm 触发时，网络仍然没有连接，那就会直接进入 if 分支！ 4 MyHandler 逻辑分析我们来看下 MyHandler 逻辑分析：123456789101112131415161718192021222324252627282930313233final class MyHandler extends Handler &#123; MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; if (DEBUG) Slog.d(TAG, \"handleMessage(\" + msg.what + \")\"); switch (msg.what) &#123; case MSG_WRITE_CONFIG: &#123; &#125; break; case MSG_REPORT_IDLE_ON: case MSG_REPORT_IDLE_ON_LIGHT: &#123; &#125; break; case MSG_REPORT_IDLE_OFF: &#123; &#125; break; case MSG_REPORT_ACTIVE: &#123; &#125; break; case MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123; &#125; break; case MSG_REPORT_MAINTENANCE_ACTIVITY: &#123; &#125; break; case MSG_FINISH_IDLE_OP: &#123; &#125; break; &#125; &#125;&#125; 下面分析下每个消息的具体处理！ 4.1 消息：MSG_WRITE_CONFIG更新本地持久化文件：1234case MSG_WRITE_CONFIG: &#123; //【4.1.1】持久化文件！ handleWriteConfigFile();&#125; break; 4.1.1 handleWriteConfigFile更新本地持久化文件： 123456789101112131415161718192021222324252627void handleWriteConfigFile() &#123; final ByteArrayOutputStream memStream = new ByteArrayOutputStream(); try &#123; synchronized (this) &#123; XmlSerializer out = new FastXmlSerializer(); out.setOutput(memStream, StandardCharsets.UTF_8.name()); writeConfigFileLocked(out); &#125; &#125; catch (IOException e) &#123; &#125; synchronized (mConfigFile) &#123; FileOutputStream stream = null; try &#123; stream = mConfigFile.startWrite(); memStream.writeTo(stream); stream.flush(); FileUtils.sync(stream); stream.close(); mConfigFile.finishWrite(stream); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Error writing config file\", e); mConfigFile.failWrite(stream); &#125; &#125;&#125; 最后调用 writeConfigFileLocked 方法12345678910void writeConfigFileLocked(XmlSerializer out) throws IOException &#123; out.startDocument(null, true); out.startTag(null, \"config\"); for (int i=0; i&lt;mPowerSaveWhitelistUserApps.size(); i++) &#123; String name = mPowerSaveWhitelistUserApps.keyAt(i); out.startTag(null, \"wl\"); out.attribute(null, \"n\", name); out.endTag(null, \"wl\"); &#125; out.endTag(null, \"config\"); 每一个白名单都是以 wl 标签开始和结束，n 属性为包名！ 4.2 消息：MSG_REPORT_IDLE_ON and MSG_REPORT_IDLE_ON_LIGHT进入 doze 模式，MSG_REPORT_IDLE_ON 表示的是 deep idle，而 MSG_REPORT_IDLE_ON_LIGHT 而是 light idle！ 1234567891011121314151617181920212223242526272829303132case MSG_REPORT_IDLE_ON:case MSG_REPORT_IDLE_ON_LIGHT: &#123; // 进入 idle 状态！ EventLogTags.writeDeviceIdleOnStart(); final boolean deepChanged; final boolean lightChanged; //【1】针对于 deep 和 light，PowerManager 做不同的处理！ if (msg.what == MSG_REPORT_IDLE_ON) &#123; //【1.1】进入 deep idle！ deepChanged = mLocalPowerManager.setDeviceIdleMode(true); lightChanged = mLocalPowerManager.setLightDeviceIdleMode(false); &#125; else &#123; //【1.2】进入 light idle！ deepChanged = mLocalPowerManager.setDeviceIdleMode(false); lightChanged = mLocalPowerManager.setLightDeviceIdleMode(true); &#125; //【2】NetworkPolicy 和 BatteryStats 设置不同的状态； try &#123; mNetworkPolicyManager.setDeviceIdleMode(true); mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON ? BatteryStats.DEVICE_IDLE_MODE_DEEP : BatteryStats.DEVICE_IDLE_MODE_LIGHT, null, Process.myUid()); &#125; catch (RemoteException e) &#123; &#125; //【3】发送广播，给监听 doze 模式的进程！ if (deepChanged) &#123; getContext().sendBroadcastAsUser(mIdleIntent, UserHandle.ALL); &#125; if (lightChanged) &#123; getContext().sendBroadcastAsUser(mLightIdleIntent, UserHandle.ALL); &#125; EventLogTags.writeDeviceIdleOnComplete();&#125; break; 在进入 idle 状态的时候，我们会发送相应的广播！！ 4.3 消息：MSG_REPORT_IDLE_OFFMSG_REPORT_IDLE_OFF 表示暂时退出 idle 状态，进入了时间窗，执行任务！ 1234567891011121314151617181920212223242526272829303132case MSG_REPORT_IDLE_OFF: &#123; EventLogTags.writeDeviceIdleOffStart(\"unknown\"); //【1】退出 deep idle 和 light idle 模式，更新 PowerManager 状态！ final boolean deepChanged = mLocalPowerManager.setDeviceIdleMode(false); final boolean lightChanged = mLocalPowerManager.setLightDeviceIdleMode(false); try &#123; mNetworkPolicyManager.setDeviceIdleMode(false); mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF, null, Process.myUid()); &#125; catch (RemoteException e) &#123; &#125; //【2】如果 deep idle(light idle) 状态发生了变化，那就更新 mActiveIdleOpCount 计数； // 同时有序发送通知广播，最后自身也会接受广播！ if (deepChanged) &#123; //【4.3.1】增加引用计数 mActiveIdleOpCount！ incActiveIdleOps(); //【4.3.2】自身也会监听 doze 模式变化的广播！ getContext().sendOrderedBroadcastAsUser(mIdleIntent, UserHandle.ALL, null, mIdleStartedDoneReceiver, null, 0, null, null); &#125; if (lightChanged) &#123; incActiveIdleOps(); // 同上！ getContext().sendOrderedBroadcastAsUser(mLightIdleIntent, UserHandle.ALL, null, mIdleStartedDoneReceiver, null, 0, null, null); &#125; //【4.3.3】减少 mActiveIdleOpCount 计数，尝试提前退出时间窗！ decActiveIdleOps(); EventLogTags.writeDeviceIdleOffComplete();&#125; break; 处理 MSG_REPORT_IDLE_OFF 消息比较特殊，这里我们是有序的发送广播，同时在发送 mIdleIntent 或者 mLightIdleIntent 广播的时候，我们额外传入了 mIdleStartedDoneReceiver，是最后有序队列中的最后一个接收者： 4.3.1 IdleStartedDoneReceiver123456789101112131415private final BroadcastReceiver mIdleStartedDoneReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(intent.getAction())) &#123; //【4.7】如果是 deep idle 模式发生了变化，延迟 mConstants.MIN_DEEP_MAINTENANCE_TIME(30s) // 发送 MSG_FINISH_IDLE_OP 消息！ mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP, mConstants.MIN_DEEP_MAINTENANCE_TIME); &#125; else &#123; //【4.7】如果是 light idle 模式发生了变化，延迟 mConstants.MIN_LIGHT_MAINTENANCE_TIME(5s) // 发送 MSG_FINISH_IDLE_OP 消息！ mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP, mConstants.MIN_LIGHT_MAINTENANCE_TIME); &#125; &#125;&#125;; 对于暂时退出 idle 状态来说，mIdleIntent 或者 mLightIdleIntent 广播的时候，除了要发送给其他服务，DeviceIdleController 自身作为最后一个接收者，也会接受该广播！ 当 DeviceIdleController 接收到广播后，会判断下是退出 deep idle 还是 light idle 状态！ 如果退出 deep idle，延迟延迟 mConstants.MIN_DEEP_MAINTENANCE_TIME (30s)，发送 MSG_FINISH_IDLE_OP 消息给 MyHandler； 如果退出 light idle，延迟延迟 mConstants.MIN_LIGHT_MAINTENANCE_TIME (5s)，发送 MSG_FINISH_IDLE_OP 消息给 MyHandler； MyHandler 在接收到 MSG_FINISH_IDLE_OP 消息后，会减少 mActiveIdleOpCount 计数，同时会尝试提前退出时间窗！ 4.3.2 incActiveIdleOps12345void incActiveIdleOps() &#123; synchronized (this) &#123; mActiveIdleOpCount++; &#125;&#125; incActiveIdleOps 主要是将 mActiveIdleOpCount 加 1，表示此时我们进入时间窗，执行相关的操作； 4.3.3 decActiveIdleOps12345678910void decActiveIdleOps() &#123; synchronized (this) &#123; mActiveIdleOpCount--; if (mActiveIdleOpCount &lt;= 0) &#123; //【4.3.2.1】尝试提前退出时间窗！ exitMaintenanceEarlyIfNeededLocked(); mActiveIdleWakeLock.release(); &#125; &#125;&#125; decActiveIdleOps 方法会先将 mActiveIdleOpCount 减 1；如果此时 mActiveIdleOpCount &lt;= 0，那么会尝试提前退出时间窗： 4.3.2.1 exitMaintenanceEarlyIfNeededLocked - 提前退出时间窗我们来看尝试提前退出时间窗的逻辑！12345678910111213141516171819202122232425262728void exitMaintenanceEarlyIfNeededLocked() &#123; //【1】首先，对状态做一个判断！ if (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_PRE_IDLE) &#123; //【4.3.2.2】判断时间窗内是否还有任务执行，如果返回 true，表明可以提前退出时间窗！ if (isOpsInactiveLocked()) &#123; final long now = SystemClock.elapsedRealtime(); if (DEBUG) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Exit: start=\"); TimeUtils.formatDuration(mMaintenanceStartTime, sb); sb.append(\" now=\"); TimeUtils.formatDuration(now, sb); Slog.d(TAG, sb.toString()); &#125; //【2】如果是 deep idle 模式，且状态为 STATE_IDLE_MAINTENANCE，调用 stepIdleStateLocked // 提前退出时间窗，如果是 light idle 模式，调用 stepLightIdleStateLocked 退出时间窗！ if (mState == STATE_IDLE_MAINTENANCE) &#123; stepIdleStateLocked(\"s:early\"); //【3.1】 &#125; else if (mLightState == LIGHT_STATE_PRE_IDLE) &#123; stepLightIdleStateLocked(\"s:predone\");//【3.2】 &#125; else &#123; stepLightIdleStateLocked(\"s:early\"); &#125; &#125; &#125;&#125; 提前退出时间窗的意义在于，很可能在很短的时间内，时间窗内的工作已经完成了，我们就没有必要等到时间窗结束了！ 首先对状态做了判断： deep idle 为 STATE_IDLE_MAINTENANCE；light idle 为 LIGHT_STATE_IDLE_MAINTENANCE/LIGHT_STATE_PRE_IDLE 然后调用 isOpsInactiveLocked 方法，判断此时是否没有 active op，avtive job 和 active alarm！ 4.3.2.2 isOpsInactiveLocked123boolean isOpsInactiveLocked() &#123; return mActiveIdleOpCount &lt;= 0 &amp;&amp; !mJobsActive &amp;&amp; !mAlarmsActive;&#125; 该方法用于判断时间窗内是否还有任务执行： 如果 mActiveIdleOpCount &lt;= 0，同时没有 JobService，Alarms 处于活跃状态，那么 isOpsInactiveLocked 就返回 true！ 4.4 消息：MSG_REPORT_ACTIVE当 idle 状态的条件不满足后，会退出 doze 模式，恢复 STATE_ACTIVE 状态，发送 MSG_REPORT_ACTIVE 给 MyHandler！ 1234567891011121314151617181920212223242526case MSG_REPORT_ACTIVE: &#123; String activeReason = (String)msg.obj; int activeUid = msg.arg1; EventLogTags.writeDeviceIdleOffStart( activeReason != null ? activeReason : \"unknown\"); //【1】通知 PowerManager 退出 deep idle 和 light idle 状态！ final boolean deepChanged = mLocalPowerManager.setDeviceIdleMode(false); final boolean lightChanged = mLocalPowerManager.setLightDeviceIdleMode(false); try &#123; //【2】通知 NetworkPolicy 和 BatteryStats 退出 idle 状态！ mNetworkPolicyManager.setDeviceIdleMode(false); mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF, activeReason, activeUid); &#125; catch (RemoteException e) &#123; &#125; //【3】如果是退出 deep idle，发送广播通知其他服务！ if (deepChanged) &#123; getContext().sendBroadcastAsUser(mIdleIntent, UserHandle.ALL); &#125; //【4】如果是退出 light idle，发送广播通知其他服务！ if (lightChanged) &#123; getContext().sendBroadcastAsUser(mLightIdleIntent, UserHandle.ALL); &#125; EventLogTags.writeDeviceIdleOffComplete();&#125; break; 方法很简单，不多说了！ 4.5 消息：MSG_TEMP_APP_WHITELIST_TIMEOUT我们可以将用户应用程序动态添加到 doze 模式的用户白名单中，使得应用可以在 doze 模式下运行，这种方式一旦添加，就一直生效，因为他会持久化到本地文件； 同时，我们还可以动态添加应用到临时缓存白名单中，使得该应用能够临时获得 doze 模式下的 network 和 wakelocks 访问，在添加时要指定临时的访问截至时间。时间过后，名单失效！！ 12345678910// 临时缓存白名单，在该名单中的 uid 被临时标记为在 doze 模式下允许访问网络并获取唤醒锁；// MutableLong 用于指定临时时间！private final SparseArray&lt;Pair&lt;MutableLong, String&gt;&gt; mTempWhitelistAppIdEndTimes = new SparseArray&lt;&gt;(); // 当 mTempWhitelistAppIdEndTimes 发生变化后，用于通知 NetworkPolicyManagerService 执行任务！Runnable mNetworkPolicyTempWhitelistCallback;// 用于记录缓存 mTempWhitelistAppIdEndTimes 中的所有应用的 uid；private int[] mTempWhitelistAppIdArray = new int[0]; 那么 MSG_TEMP_APP_WHITELIST_TIMEOUT 消息的所用是什么呢？就是不断的检查 mTempWhitelistAppIdEndTimes，mTempWhitelistAppIdArray，如果有过期名单，移除！ 12345case MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123; int uid = msg.arg1; //【4.5.1】调用 checkTempAppWhitelistTimeout 方法！ checkTempAppWhitelistTimeout(uid);&#125; break; 核心方法在 checkTempAppWhitelistTimeout 中！ 4.5.1 checkTempAppWhitelistTimeout检查缓存白名单中是否有应用过期！1234567891011121314151617181920212223242526272829303132333435363738394041void checkTempAppWhitelistTimeout(int uid) &#123; final long timeNow = SystemClock.elapsedRealtime(); if (DEBUG) &#123; Slog.d(TAG, \"checkTempAppWhitelistTimeout: uid=\" + uid + \", timeNow=\" + timeNow); &#125; synchronized (this) &#123; //【1】判断临时缓存白名单中是否有该 uid！ Pair&lt;MutableLong, String&gt; entry = mTempWhitelistAppIdEndTimes.get(uid); if (entry == null) &#123; return; &#125; if (timeNow &gt;= entry.first.value) &#123; //【2】当前时间 timeNow 超过了白名单中应用的有效期时间； // 将该应用从白名单中删除！ mTempWhitelistAppIdEndTimes.delete(uid); if (DEBUG) &#123; Slog.d(TAG, \"Removing UID \" + uid + \" from temp whitelist\"); &#125; //【4.5.2.1】更新 PowerManager 中缓存白名单！ updateTempWhitelistAppIdsLocked(); if (mNetworkPolicyTempWhitelistCallback != null) &#123; mHandler.post(mNetworkPolicyTempWhitelistCallback); // 更新 NetworkPolicy 内部名单！ &#125; //【4.5.2.2】通知其他服务，缓存白名单发生了变化！ reportTempWhitelistChangedLocked(); try &#123; mBatteryStats.noteEvent(BatteryStats.HistoryItem.EVENT_TEMP_WHITELIST_FINISH, entry.second, uid); &#125; catch (RemoteException e) &#123; &#125; &#125; else &#123; //【3】如果当前时间 timeNow 还没有超过白名单中应用的有效期时间； // 延迟 entry.first.value - timeNow 时间间隔再次发送 MSG_TEMP_APP_WHITELIST_TIMEOUT 消息！ if (DEBUG) &#123; Slog.d(TAG, \"Time to remove UID \" + uid + \": \" + entry.first.value); &#125; postTempActiveTimeoutMessage(uid, entry.first.value - timeNow); &#125; &#125;&#125; 4.5.2.1 updateTempWhitelistAppIdsLocked更新缓存白名单 mTempWhitelistAppIdEndTimes！123456789101112131415161718private void updateTempWhitelistAppIdsLocked() &#123; //【1】获得最新的 mTempWhitelistAppIdEndTimes 记录，更新 mTempWhitelistAppIdArray！ final int size = mTempWhitelistAppIdEndTimes.size(); if (mTempWhitelistAppIdArray.length != size) &#123; mTempWhitelistAppIdArray = new int[size]; &#125; for (int i = 0; i &lt; size; i++) &#123; mTempWhitelistAppIdArray[i] = mTempWhitelistAppIdEndTimes.keyAt(i); &#125; //【2】将最新的 mTempWhitelistAppIdArray 添加到 PowerManager 中！ if (mLocalPowerManager != null) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Setting wakelock temp whitelist to \" + Arrays.toString(mTempWhitelistAppIdArray)); &#125; mLocalPowerManager.setDeviceIdleTempWhitelist(mTempWhitelistAppIdArray); &#125;&#125; mTempWhitelistAppIdArray 数组中用来保存缓存白名单的应用的 uid，和 mTempWhitelistAppIdEndTimes 是不同的描述角度！ 4.5.2.2 reportTempWhitelistChangedLocked12345private void reportTempWhitelistChangedLocked() &#123; Intent intent = new Intent(PowerManager.ACTION_POWER_SAVE_TEMP_WHITELIST_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); getContext().sendBroadcastAsUser(intent, UserHandle.SYSTEM);&#125; 其实就是发送了 PowerManager.ACTION_POWER_SAVE_TEMP_WHITELIST_CHANGED 广播！ 4.6 消息：MSG_REPORT_MAINTENANCE_ACTIVITY当设备退出了 idle 状态后，系统中的 JobService 会开始执行，JobSchedulerService 会调用 DeviceIdleC.setJobsActive(true) 方法，将 JobService 的状态保存到 DeviceIdleController 中去！ 4.6.1 DeviceIdleC.setJobsActivesetJobsActive 用于设置 JobService 的活跃状态： 1234567891011121314void setJobsActive(boolean active) &#123; synchronized (this) &#123; //【1】将 mJobsActive 为 active 的值！ mJobsActive = active; //【4.6.1.1】JobService 的活跃状态发生了变化！ reportMaintenanceActivityIfNeededLocked(); //【2】如果 active 为 false，说明此时没有 JobService 活跃了， // 那就尝试提前退出时间窗； if (!active) &#123; exitMaintenanceEarlyIfNeededLocked(); &#125; &#125;&#125; 4.6.1.1 DeviceIdleC.reportMaintenanceActivityIfNeededLocked123456789101112void reportMaintenanceActivityIfNeededLocked() &#123; boolean active = mJobsActive; if (active == mReportedMaintenanceActivity) &#123; return; &#125; mReportedMaintenanceActivity = active; //【2】发送 MSG_REPORT_MAINTENANCE_ACTIVITY 给 MyHandler！ Message msg = mHandler.obtainMessage(MSG_REPORT_MAINTENANCE_ACTIVITY, mReportedMaintenanceActivity ? 1 : 0, 0); mHandler.sendMessage(msg);&#125; 我们来看下 MyHandler 对于 MSG_REPORT_MAINTENANCE_ACTIVITY 消息的处理：123456789101112131415case MSG_REPORT_MAINTENANCE_ACTIVITY: &#123; boolean active = (msg.arg1 == 1); final int size = mMaintenanceActivityListeners.beginBroadcast(); try &#123; for (int i = 0; i &lt; size; i++) &#123; try &#123; mMaintenanceActivityListeners.getBroadcastItem(i) .onMaintenanceActivityChanged(active); &#125; catch (RemoteException ignored) &#123; &#125; &#125; &#125; finally &#123; mMaintenanceActivityListeners.finishBroadcast(); &#125;&#125; break; 4.7 消息：MSG_FINISH_IDLE_OP对于 MSG_FINISH_IDLE_OP 消息的处理很简单，就是调用 decActiveIdleOps 减少 mActiveIdleOpCount 引用计数！ 1234case MSG_FINISH_IDLE_OP: &#123; //【4.7.1】减少 decActiveIdleOps();&#125; break; 4.7.1 decActiveIdleOps我们来看看 decActiveIdleOps 方法：1234567891011void decActiveIdleOps() &#123; synchronized (this) &#123; //【1】减少 mActiveIdleOpCount 计数； mActiveIdleOpCount--; if (mActiveIdleOpCount &lt;= 0) &#123; //【4.3.2.1】尝试提前退出时间窗！ exitMaintenanceEarlyIfNeededLocked(); mActiveIdleWakeLock.release(); &#125; &#125;&#125; 这里的逻辑我们之前见过！ 进入时间窗的时候 mActiveIdleOpCount 会被加 1，退出时间窗的时候，mActiveIdleOpCount 会被减 1； 5 重置操作对于重置操作，我们放到这里来一起分析下； 然后，重置 deep idle 逻辑相关的变量，取消 Alarm 和监控器！！ 5.1 resetIdleManagementLocked1234567891011121314void resetIdleManagementLocked() &#123; mNextIdlePendingDelay = 0; mNextIdleDelay = 0; mNextLightIdleDelay = 0; //【1.1.1.1.1】取消 mDeepAlarmListener cancelAlarmLocked(); //【1.1.1.1.2】取消 mSensingTimeoutAlarmListener cancelSensingTimeoutAlarmLocked(); //【1.1.1.1.3】取消 mGenericLocationListener，mGpsLocationListener cancelLocatingLocked(); //【1.1.1.1.4】取消 mMotionListener stopMonitoringMotionLocked(); mAnyMotionDetector.stop();&#125; 5.1.1 cancelAlarmLocked123456void cancelAlarmLocked() &#123; if (mNextAlarmTime != 0) &#123; mNextAlarmTime = 0; mAlarmManager.cancel(mDeepAlarmListener); &#125;&#125; 取消 mDeepAlarmListener！ 该 mDeepAlarmListener 触发后会执行 stepIdleStateLocked 方法！ 5.1.2 cancelSensingTimeoutAlarmLocked123456void cancelSensingTimeoutAlarmLocked() &#123; if (mNextSensingTimeoutAlarmTime != 0) &#123; mNextSensingTimeoutAlarmTime = 0; mAlarmManager.cancel(mSensingTimeoutAlarmListener); &#125;&#125; 取消 mSensingTimeoutAlarmListener！ mSensingTimeoutAlarmListener 触发后，如果 mState 为 STATE_SENSING，这时会执行 1.1：becomeInactiveIfAppropriateLocked 方法！ 5.1.3 cancelLocatingLocked1234567void cancelLocatingLocked() &#123; if (mLocating) &#123; mLocationManager.removeUpdates(mGenericLocationListener); mLocationManager.removeUpdates(mGpsLocationListener); mLocating = false; &#125;&#125; 取消 mGenericLocationListener，mGpsLocationListener！ mGenericLocationListener 触发后，会执行 receivedGenericLocationLocked 方法； mGpsLocationListener 触发后，会执行 receivedGpsLocationLocked 方法； 5.1.4 stopMonitoringMotionLocked123456void stopMonitoringMotionLocked() &#123; if (DEBUG) Slog.d(TAG, \"stopMonitoringMotionLocked()\"); if (mMotionSensor != null &amp;&amp; mMotionListener.active) &#123; mMotionListener.unregisterLocked(); &#125;&#125; 取消 mMotionListener！ 5.2 resetLightIdleManagementLocked1234void resetLightIdleManagementLocked() &#123; //【1.1.2.1.1】取消之前设置的 light idle alarm！ cancelLightAlarmLocked();&#125; light idle 模式的重置相关变量过程很简单，只是取消 mLightAlarmListener！ 5.2.1 cancelLightAlarmLocked1234567void cancelLightAlarmLocked() &#123; if (mNextLightAlarmTime != 0) &#123; mNextLightAlarmTime = 0; //【1】取消 mLightAlarmListener！ mAlarmManager.cancel(mLightAlarmListener); &#125;&#125; 取消 mLightAlarmListener！ 6 提前退出时间窗7 总结我们来看看 doze 模式下的监听器有哪些，下图是 doze 模式的所有监听器，监听不同的条件是否满足： 7.1 状态监听器下面的几张图是监听手机状态的监听器的逻辑： 7.2 deep idle我们来总结下 deep idle 状态的流程： 7.3 light idle我们来总结下 light idle 状态的流程：","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Doze假寐模式","slug":"AndroidFramework源码分析/Doze假寐模式","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Doze假寐模式/"}],"tags":[{"name":"Doze假寐模式","slug":"Doze假寐模式","permalink":"https://coolqi.top/tags/Doze假寐模式/"}]},{"title":"Doze模式第 1 篇 - DeviceIdleController 的启动","slug":"Doze1-deviceIdleControllerStartProcess","date":"2017-10-01T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/10/01/Doze1-deviceIdleControllerStartProcess/","link":"","permalink":"https://coolqi.top/2017/10/01/Doze1-deviceIdleControllerStartProcess/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，分析 doze 模式的原理！ 0 综述下面是 Android devoloper 网站对于 doze 模式的介绍： 从 Android 6.0（API 级别 23）开始，Android 引入了两个省电功能，可通过管理应用在设备未连接至电源时的行为方式为用户延长电池寿命。 低电耗模式（doze）通过在设备长时间处于闲置状态时推迟应用的后台 CPU 和网络操作来减少电池消耗。 应用待机模式可推迟用户近期未与之交互的应用的后台 Activity 的网络操作。 假设一个用户停止充电 (on battery: 利用电池供电)，关闭屏幕 (screen off)。手机处于静止状态 (stationary)。保持以上条件一段时间之后，系统就会进入 Doze 模式。一旦进入 Doze 模式。系统就降低 (延缓) 应用对网络的訪问、以及对 CPU 的占用，来节省电池电量。 这一系列的文章先来分析下低电耗模式! 在低电耗 doze 模式下，应用会受到以下限制： 暂停访问 Network。 系统将忽略 Wake Locks。 标准 AlarmManager 闹铃（包括 setExact() 和 setWindow()）推迟到 doze 模式的下一个 maintenance window 时间窗。 如果您需要设置在低电耗模式下触发的闹铃，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。 一般情况下，使用 setAlarmClock() 设置的闹铃将继续触发，但系统会在这些闹铃触发之前不久退出低电耗模式。 系统不执行 WiFi 扫描。 系统不允许运行 Sync 同步适配器。 系统不允许运行 JobScheduler。 doze 模式的核心实现在 DeviceIdleController 中，下面我们来看看 DeviceIdleController 的启动！ 123456789101112131415161718192021222324252627282930private void startOtherServices() &#123; final Context context = mSystemContext; ... ... ... if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; if (!disableNonCoreServices) &#123; traceBeginAndSlog(\"StartLockSettingsService\"); try &#123; mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS); lockSettings = ILockSettings.Stub.asInterface( ServiceManager.getService(\"lock_settings\")); &#125; catch (Throwable e) &#123; reportWtf(\"starting LockSettingsService service\", e); &#125; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(\"\")) &#123; mSystemServiceManager.startService(PersistentDataBlockService.class); &#125; //【1】启动 DeviceIdleController 服务！ mSystemServiceManager.startService(DeviceIdleController.class); // Always start the Device Policy Manager, so that the API is compatible with // API8. mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class); &#125; ... ... ... &#125; ... ... ... ...&#125; 启动 DeviceIdleController 的时机是在 SystemServer.startOtherServices 方法中！ 1 new DeviceIdleController123456public DeviceIdleController(Context context) &#123; super(context); mConfigFile = new AtomicFile(new File(getSystemDir(), \"deviceidle.xml\")); //【1.1】处理耗时操作！ mHandler = new MyHandler(BackgroundThread.getHandler().getLooper());&#125; 配置文件： 位于 /data/system/deviceidle.xml 中！ 1.1 new MyHandler12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final class MyHandler extends Handler &#123; MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; if (DEBUG) Slog.d(TAG, \"handleMessage(\" + msg.what + \")\"); switch (msg.what) &#123; case MSG_WRITE_CONFIG: &#123; //【1】更新持久化文件！ handleWriteConfigFile(); &#125; break; case MSG_REPORT_IDLE_ON: //【2】进入 device idle 状态 case MSG_REPORT_IDLE_ON_LIGHT: &#123; ... ... ... &#125; break; case MSG_REPORT_IDLE_OFF: &#123; //【3】进入时间窗 window ... ... ... &#125; break; case MSG_REPORT_ACTIVE: &#123;//【4】退出 doze 模式，处于 active 状态 ... ... ... &#125; break; case MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123; //【5】device idle 临时白名单超时移除操作！ int uid = msg.arg1; checkTempAppWhitelistTimeout(uid); &#125; break; case MSG_REPORT_MAINTENANCE_ACTIVITY: &#123; boolean active = (msg.arg1 == 1); final int size = mMaintenanceActivityListeners.beginBroadcast(); try &#123; for (int i = 0; i &lt; size; i++) &#123; try &#123; mMaintenanceActivityListeners.getBroadcastItem(i) .onMaintenanceActivityChanged(active); &#125; catch (RemoteException ignored) &#123; &#125; &#125; &#125; finally &#123; mMaintenanceActivityListeners.finishBroadcast(); &#125; &#125; break; case MSG_FINISH_IDLE_OP: &#123; decActiveIdleOps(); &#125; break; &#125; &#125;&#125; 我们看到，MyHandler 绑定到了一个后台线程，他会在后台线程中做一些比较耗时的操作！ 2 DeviceIdleController.onStart接着是进入 onStart 方法！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Overridepublic void onStart() &#123; final PackageManager pm = getContext().getPackageManager(); synchronized (this) &#123; //【1】获得 deep mode 和 light mode 的属性配置！ mLightEnabled = mDeepEnabled = getContext().getResources().getBoolean( com.android.internal.R.bool.config_enableAutoPowerModes); //【2】从 SystemConfig 中获得解析到了 doze 模式白名单！ // 获取在 power save 模式下可以运行，但在 device Idle (doze) 模式下不能运行的系统应用名单！ SystemConfig sysConfig = SystemConfig.getInstance(); ArraySet&lt;String&gt; allowPowerExceptIdle = sysConfig.getAllowInPowerSaveExceptIdle(); for (int i=0; i&lt;allowPowerExceptIdle.size(); i++) &#123; String pkg = allowPowerExceptIdle.valueAt(i); try &#123; ApplicationInfo ai = pm.getApplicationInfo(pkg, PackageManager.MATCH_SYSTEM_ONLY); int appid = UserHandle.getAppId(ai.uid); mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, appid); mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, true); &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; &#125; //【3】获取在 power save 模式下能够执行的系统应用名单！ ArraySet&lt;String&gt; allowPower = sysConfig.getAllowInPowerSave(); for (int i=0; i&lt;allowPower.size(); i++) &#123; String pkg = allowPower.valueAt(i); try &#123; ApplicationInfo ai = pm.getApplicationInfo(pkg, PackageManager.MATCH_SYSTEM_ONLY); int appid = UserHandle.getAppId(ai.uid); //【3.1】在 power save 模式下能够执行的系统应用，也不能在 doze 模式下运行， // 所以也加入了上面的集合！ mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, appid); mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, true); mPowerSaveWhitelistApps.put(ai.packageName, appid); mPowerSaveWhitelistSystemAppIds.put(appid, true); &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; &#125; //【*2.1】创建 Constants 实例，继承 ContentObserver，用于监控数据库变化， // 同时也定义了 Doze 模式中的一些时间间隔常量！ mConstants = new Constants(mHandler, getContext().getContentResolver()); //【*2.2】读取持久化的配置 deviceidle.xml，并将当中定义的 package // 增加到 mPowerSaveWhitelistUserApps 中！ readConfigFileLocked(); //【*2.3】更新名单！ updateWhitelistAppIdsLocked(); //【4】初始化状态变量！ mNetworkConnected = true; mScreenOn = true; mCharging = true; mState = STATE_ACTIVE; mLightState = LIGHT_STATE_ACTIVE; mInactiveTimeout = mConstants.INACTIVE_TIMEOUT; &#125; //【2.4】创建 BinderService 对象，作为 DeviceIdleController 服务桩对象， // 并添加到 ServiceManager 中，用于和其他进程通信！ mBinderService = new BinderService(); publishBinderService(Context.DEVICE_IDLE_CONTROLLER, mBinderService); //【2.5】创建对应的 LocalService，方便于进程内部通信！ publishLocalService(LocalService.class, new LocalService());&#125; SystemConfig 我们之前在分析 PMS 的启动的时候有涉及到，SystemConfig 会用来解析系统的配置信息！ 这里涉及到了两个内部变量！ DeviceIdleController 提供了 2 中模式： mLightEnabled 和 mDeepEnabled！ deep idle 模式：会禁止 NetWork、Wakelock，还会禁止 Alarm。 light idle 模式：会禁止 NetWork、Wakelock，但是不会禁止 Alarm。 通过 config_enableAutoPowerModes 属性进行初始化，默认是 mLightEnabled = mDeepEnabled = false！ 我们再来看下这里涉及到的重要集合： mPowerSaveWhitelistAppsExceptIdle：保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统应用名单，packageName 和 appId 的映射！ mPowerSaveWhitelistSystemAppIdsExceptIdle：保存在 power save 模式下后台运行运行，但在 doze 模式下不能后台运行的系统应用名单，appId 和 true 的映射！ mPowerSaveWhitelistApps：保存在 power save 模式下可以后台运行的系统应用程序，packageName 和 appId 的映射！ mPowerSaveWhitelistSystemAppIds：保存在 power save 模式下可以后台运行的系统应用程序，appId 和 true 的映射！ 2.1 new Constants12345678910111213public Constants(Handler handler, ContentResolver resolver) &#123; super(handler); mResolver = resolver; mHasWatch = getContext().getPackageManager().hasSystemFeature( PackageManager.FEATURE_WATCH); //【1】监控数据的变化！ mResolver.registerContentObserver(Settings.Global.getUriFor( mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH : Settings.Global.DEVICE_IDLE_CONSTANTS), false, this); //【2.1.1】更新常量值！ updateConstants();&#125; 可以看到 Constants 会监控数据库的变化，这里先做了一个 feature 的判断：PackageManager.FEATURE_WATCH，判断当前设备是否是可穿戴设备：watch！ 因为这里我们关注的是手机设备，所以 Constants 监控的数据库是：Settings.Global.DEVICE_IDLE_CONSTANTS（device_idle_constants） 2.1.1 Constants.updateConstantsupdateConstants 会从 device_idle_constants 数据库中读取属性值，初始化一些关键的常量信息，如果读取不到，会初始化为默认值！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void updateConstants() &#123; synchronized (DeviceIdleController.this) &#123; try &#123; //【1】读取数据库的值！ mParser.setString(Settings.Global.getString(mResolver, mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH : Settings.Global.DEVICE_IDLE_CONSTANTS)); &#125; catch (IllegalArgumentException e) &#123; Slog.e(TAG, \"Bad device idle settings\", e); &#125; //【2】初始化关键性常量！ LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong( KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT, !COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L); LIGHT_PRE_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT, !COMPRESS_TIME ? 10 * 60 * 1000L : 30 * 1000L); LIGHT_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT, !COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L); LIGHT_IDLE_FACTOR = mParser.getFloat(KEY_LIGHT_IDLE_FACTOR, 2f); LIGHT_MAX_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT, !COMPRESS_TIME ? 15 * 60 * 1000L : 60 * 1000L); LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = mParser.getLong( KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET, !COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L); LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = mParser.getLong( KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET, !COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L); MIN_LIGHT_MAINTENANCE_TIME = mParser.getLong( KEY_MIN_LIGHT_MAINTENANCE_TIME, !COMPRESS_TIME ? 5 * 1000L : 1 * 1000L); MIN_DEEP_MAINTENANCE_TIME = mParser.getLong( KEY_MIN_DEEP_MAINTENANCE_TIME, !COMPRESS_TIME ? 30 * 1000L : 5 * 1000L); long inactiveTimeoutDefault = (mHasWatch ? 15 : 30) * 60 * 1000L; INACTIVE_TIMEOUT = mParser.getLong(KEY_INACTIVE_TIMEOUT, !COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10)); SENSING_TIMEOUT = mParser.getLong(KEY_SENSING_TIMEOUT, !DEBUG ? 4 * 60 * 1000L : 60 * 1000L); LOCATING_TIMEOUT = mParser.getLong(KEY_LOCATING_TIMEOUT, !DEBUG ? 30 * 1000L : 15 * 1000L); LOCATION_ACCURACY = mParser.getFloat(KEY_LOCATION_ACCURACY, 20); MOTION_INACTIVE_TIMEOUT = mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT, !COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L); long idleAfterInactiveTimeout = (mHasWatch ? 15 : 30) * 60 * 1000L; IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT, !COMPRESS_TIME ? idleAfterInactiveTimeout : (idleAfterInactiveTimeout / 10)); IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_IDLE_PENDING_TIMEOUT, !COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L); MAX_IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT, !COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L); IDLE_PENDING_FACTOR = mParser.getFloat(KEY_IDLE_PENDING_FACTOR, 2f); IDLE_TIMEOUT = mParser.getLong(KEY_IDLE_TIMEOUT, !COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L); MAX_IDLE_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_TIMEOUT, !COMPRESS_TIME ? 6 * 60 * 60 * 1000L : 30 * 60 * 1000L); IDLE_FACTOR = mParser.getFloat(KEY_IDLE_FACTOR, 2f); MIN_TIME_TO_ALARM = mParser.getLong(KEY_MIN_TIME_TO_ALARM, !COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L); MAX_TEMP_APP_WHITELIST_DURATION = mParser.getLong( KEY_MAX_TEMP_APP_WHITELIST_DURATION, 5 * 60 * 1000L); MMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong( KEY_MMS_TEMP_APP_WHITELIST_DURATION, 60 * 1000L); SMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong( KEY_SMS_TEMP_APP_WHITELIST_DURATION, 20 * 1000L); NOTIFICATION_WHITELIST_DURATION = mParser.getLong( KEY_NOTIFICATION_WHITELIST_DURATION, 30 * 1000L); &#125;&#125; 这里的 COMPRESS_TIME 为 false！ 1private static final boolean COMPRESS_TIME = false; 2.1.2 Constants 常量从上面可以看到，doze 模式下涉及到很多和时间相关的值，这里我们来解释一下： 2.1.2.1 Light Idle 常量 LIGHT_IDLE_AFTER_INACTIVE_TIMEOUTlight idle 时间属性，取值为 5 mins，当设备进入灭屏不充电的状态时，需要持续的时间! 123LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong( KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT, !COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L); LIGHT_PRE_IDLE_TIMEOUTlight idle 时间属性，取值为 10 mins，在进入 LIGHT_STATE_PRE_IDLE 阶段之前，如果判断设备有活跃操作执行的话，我们会设置一个 10mins 以后的 Alarm，等待这些操作执行完成，再进入 LIGHT_STATE_PRE_IDLE 阶段的处理！ 12LIGHT_PRE_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT, !COMPRESS_TIME ? 10 * 60 * 1000L : 30 * 1000L); LIGHT_IDLE_TIMEOUTlight idle 时间属性，取值为 5 mins，表示 light idle 的最小持续时间，也是第一次进入 light idle 的持续时间！ 12LIGHT_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT, !COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L); LIGHT_IDLE_FACTORlight idle 时间属性，取值为 2f, light idle 持续时间因子！ 1LIGHT_IDLE_FACTOR = mParser.getFloat(KEY_LIGHT_IDLE_FACTOR, 2f); LIGHT_MAX_IDLE_TIMEOUTlight idle 时间属性，取值为 15 mins，表示 light idle 的最大持续时间！ 12LIGHT_MAX_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT, !COMPRESS_TIME ? 15 * 60 * 1000L : 60 * 1000L); LIGHT_IDLE_MAINTENANCE_MIN_BUDGETlight idle 时间属性，取值为 1mins, light idle 的最小时间窗！ 123LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = mParser.getLong( KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET, !COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L); LIGHT_IDLE_MAINTENANCE_MAX_BUDGETlight idle 时间属性，取值为 5mins, light idle 的最大时间窗！ 123LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = mParser.getLong( KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET, !COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L); MIN_LIGHT_MAINTENANCE_TIMElight idle 时间属性，取值为 5s, 用于判断是否提前退出时间窗！ 123MIN_LIGHT_MAINTENANCE_TIME = mParser.getLong( KEY_MIN_LIGHT_MAINTENANCE_TIME, !COMPRESS_TIME ? 5 * 1000L : 1 * 1000L); 2.1.2.2 Deep Idle 常量 MIN_DEEP_MAINTENANCE_TIMEdeep idle 时间属性，取值为 30s, 用于判断是否提前退出时间窗！ 123MIN_DEEP_MAINTENANCE_TIME = mParser.getLong( KEY_MIN_DEEP_MAINTENANCE_TIME, !COMPRESS_TIME ? 30 * 1000L : 5 * 1000L); INACTIVE_TIMEOUTdeep idle 时间属性，取值为 30 mins，当设备的角度发生变化后，会回到 STATE_ACTIVE 状态，当下次满足灭屏不充电时，需要持续该时间才能进入 STATE_INACTIVE 状态；第一次进入满足灭屏不充电时，时间值也由 INACTIVE_TIMEOUT 设置 ！！ 123long inactiveTimeoutDefault = (mHasWatch ? 15 : 30) * 60 * 1000L;INACTIVE_TIMEOUT = mParser.getLong(KEY_INACTIVE_TIMEOUT, !COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10)); SENSING_TIMEOUTdeep idle 时间属性，取值为 4 mins！12SENSING_TIMEOUT = mParser.getLong(KEY_SENSING_TIMEOUT, !DEBUG ? 4 * 60 * 1000L : 60 * 1000L); LOCATING_TIMEOUTdeep idle 时间属性，取值为 30s，当处于定位阶段时，要持续的时间！ 12LOCATING_TIMEOUT = mParser.getLong(KEY_LOCATING_TIMEOUT, !DEBUG ? 30 * 1000L : 15 * 1000L); LOCATION_ACCURACYdeep idle 定位属性，取值为 20meter，定位精度！ 1LOCATION_ACCURACY = mParser.getFloat(KEY_LOCATION_ACCURACY, 20); MOTION_INACTIVE_TIMEOUTdeep idle 时间属性，取值为 10mins，当 sensor 被触发后，会回到 STATE_ACTIVE 状态，当下次满足灭屏不充电时，持续的时间就由 30mins 缩短为 10mins！ 12MOTION_INACTIVE_TIMEOUT = mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT, !COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L); IDLE_AFTER_INACTIVE_TIMEOUTdeep idle 时间属性，取值为 30 mins，当设备在 STATE_INACTIVE 阶段是会监听设备运动，需要保持不运动 30mins 才能进入 STATE_IDLE_PENDING 阶段！! 1234long idleAfterInactiveTimeout = (mHasWatch ? 15 : 30) * 60 * 1000L;IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT, !COMPRESS_TIME ? idleAfterInactiveTimeout : (idleAfterInactiveTimeout / 10)); IDLE_PENDING_TIMEOUTdeep idle 时间属性，取值为 5 mins，在 deep idle 状态下的初始时间窗！ 12IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_IDLE_PENDING_TIMEOUT, !COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L); MAX_IDLE_PENDING_TIMEOUTdeep idle 时间属性，取值为 10 mins，在 deep idle 状态下的最大时间窗！ 12MAX_IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT, !COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L); IDLE_PENDING_FACTORdeep idle 因子属性，取值为 2f，用于调整 deep idle 的时间窗！ 12IDLE_PENDING_FACTOR = mParser.getFloat(KEY_IDLE_PENDING_FACTOR, 2f); IDLE_TIMEOUTdeep idle 时间属性，取值为 60 mins，deep idle 状态的初始持续时间！ 12IDLE_TIMEOUT = mParser.getLong(KEY_IDLE_TIMEOUT, !COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L); MAX_IDLE_TIMEOUTdeep idle 时间属性，取值为 6 hours，deep idle 状态的最大持续时间！ 12MAX_IDLE_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_TIMEOUT, !COMPRESS_TIME ? 6 * 60 * 60 * 1000L : 30 * 60 * 1000L); IDLE_FACTORdeep idle 因子属性，取值为 2f，用于调整 deep idle 的时间窗！ 1IDLE_FACTOR = mParser.getFloat(KEY_IDLE_FACTOR, 2f); MIN_TIME_TO_ALARMdeep idle 时间属性，取值为 60mins，在每次改变 deep 状态时，会判断是否有 Alarm 在该时间内触发，如果有，不会进入 deep idle 状态！ 12MIN_TIME_TO_ALARM = mParser.getLong(KEY_MIN_TIME_TO_ALARM, !COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L); 2.1.2.3 其他相关变量 MAX_TEMP_APP_WHITELIST_DURATIONdoze 模式的临时缓存白名单的最大有效时间，取值为 5mins！ 12MAX_TEMP_APP_WHITELIST_DURATION = mParser.getLong( KEY_MAX_TEMP_APP_WHITELIST_DURATION, 5 * 60 * 1000L); MMS_TEMP_APP_WHITELIST_DURATIONMMS 应用的 doze 模式的临时缓存白名单的有效时间，60s 12MMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong( KEY_MMS_TEMP_APP_WHITELIST_DURATION, 60 * 1000L); SMS_TEMP_APP_WHITELIST_DURATIONSMS 应用的 doze 模式的临时缓存白名单的有效时间，20s 12SMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong( KEY_SMS_TEMP_APP_WHITELIST_DURATION, 20 * 1000L); NOTIFICATION_WHITELIST_DURATION通知的白名单时间间隔，30s 12NOTIFICATION_WHITELIST_DURATION = mParser.getLong( KEY_NOTIFICATION_WHITELIST_DURATION, 30 * 1000L); 对于这些变量的使用，我们后续再分析！ 2.2 DeviceIdleController.readConfigFileLocked1234567891011121314151617181920212223void readConfigFileLocked() &#123; if (DEBUG) Slog.d(TAG, \"Reading config from \" + mConfigFile.getBaseFile()); //【1】清空 mPowerSaveWhitelistUserApps 集合！ mPowerSaveWhitelistUserApps.clear(); FileInputStream stream; try &#123; stream = mConfigFile.openRead(); //【2】创建 /data/system/deviceidle.xml 输入流！ &#125; catch (FileNotFoundException e) &#123; return; &#125; try &#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(stream, StandardCharsets.UTF_8.name()); //【2.2.1】读取文件！ readConfigFileLocked(parser); &#125; catch (XmlPullParserException e) &#123; &#125; finally &#123; try &#123; stream.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; 继续调用另一个 readConfigFileLocked 方法！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void readConfigFileLocked(XmlPullParser parser) &#123; final PackageManager pm = getContext().getPackageManager(); try &#123; int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; ; &#125; if (type != XmlPullParser.START_TAG) &#123; throw new IllegalStateException(\"no start tag found\"); &#125; int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"wl\")) &#123; String name = parser.getAttributeValue(null, \"n\"); if (name != null) &#123; try &#123; ApplicationInfo ai = pm.getApplicationInfo(name, PackageManager.MATCH_UNINSTALLED_PACKAGES); //【1】将用户应用程序的包名和 appId 加入到 mPowerSaveWhitelistUserApps 中； mPowerSaveWhitelistUserApps.put(ai.packageName, UserHandle.getAppId(ai.uid)); &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; &#125; &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;config&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; &#125; catch (IllegalStateException e) &#123; Slog.w(TAG, \"Failed parsing config \" + e); &#125; catch (NullPointerException e) &#123; Slog.w(TAG, \"Failed parsing config \" + e); &#125; catch (NumberFormatException e) &#123; Slog.w(TAG, \"Failed parsing config \" + e); &#125; catch (XmlPullParserException e) &#123; Slog.w(TAG, \"Failed parsing config \" + e); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Failed parsing config \" + e); &#125; catch (IndexOutOfBoundsException e) &#123; Slog.w(TAG, \"Failed parsing config \" + e); &#125;&#125; 可以看到，readConfigFileLocked 方法最终解析 /data/system/deviceidle.xml 文件。 该文件中保存的是在 device mode 模式下，能够后台运行的用户应用白名单！ 最终的解析结果，保存到了 mPowerSaveWhitelistUserApps 集合中，packageName 和 appId 的映射！ 2.3 DeviceIdleController.updateWhitelistAppIdsLocked我们先来回顾下前面涉及到的几个集合： mPowerSaveWhitelistAppsExceptIdle：保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统应用名单，packageName 和 appId 的映射！ mPowerSaveWhitelistSystemAppIdsExceptIdle：保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统应用名单，appId 和 true 的映射！ mPowerSaveWhitelistApps：保存在 power save 模式下可以后台运行的系统应用，packageName 和 appId 的映射！ mPowerSaveWhitelistSystemAppIds：保存在 power save 模式下可以后台运行的系统应用，appId 和 true 的映射！ 123456789101112131415161718192021222324252627private void updateWhitelistAppIdsLocked() &#123; //【1】合并白名单！ mPowerSaveWhitelistExceptIdleAppIdArray = buildAppIdArray(mPowerSaveWhitelistAppsExceptIdle, mPowerSaveWhitelistUserApps, mPowerSaveWhitelistExceptIdleAppIds); mPowerSaveWhitelistAllAppIdArray = buildAppIdArray(mPowerSaveWhitelistApps, mPowerSaveWhitelistUserApps, mPowerSaveWhitelistAllAppIds); mPowerSaveWhitelistUserAppIdArray = buildAppIdArray(null, mPowerSaveWhitelistUserApps, mPowerSaveWhitelistUserAppIds); //【2】将白名单设置到 PowerManager 和 AlarmManager 中！ if (mLocalPowerManager != null) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Setting wakelock whitelist to \" + Arrays.toString(mPowerSaveWhitelistAllAppIdArray)); &#125; mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray); &#125; if (mLocalAlarmManager != null) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Setting alarm whitelist to \" + Arrays.toString(mPowerSaveWhitelistUserAppIdArray)); &#125; mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray); &#125;&#125; 1、这里又设计到了几个重要集合： mPowerSaveWhitelistExceptIdleAppIds： 保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统和用户应用，packageName 和 appId 的映射； 集合来自 mPowerSaveWhitelistAppsExceptIdle 和 mPowerSaveWhitelistUserApps 的合并； mPowerSaveWhitelistExceptIdleAppIdArray： 保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统和用户应用 appId； 集合来自 mPowerSaveWhitelistAppsExceptIdle 和 mPowerSaveWhitelistUserApps 的合并； mPowerSaveWhitelistAllAppIds： 保存在 power save 模式下可以后台运行的系统和用户应用 (appId 和 true 的映射)； 集合来自 mPowerSaveWhitelistApps 和 mPowerSaveWhitelistUserApps 的合并； mPowerSaveWhitelistAllAppIdArray： 保存在 power save 模式下可以后台运行的系统和用户应用 appId； 集合来自 mPowerSaveWhitelistApps 和 mPowerSaveWhitelistUserApps 的合并； mPowerSaveWhitelistUserAppIds： 保存在 power save 模式下可以后台运行的用户应用 (appId 和 true 的映射)； 集合来自 mPowerSaveWhitelistUserApps； mPowerSaveWhitelistUserAppIdArray： 保存在 power save 模式下可以后台运行的用户应用 appId； 集合来自 mPowerSaveWhitelistUserApps； 2、传递名单 接着，将 mPowerSaveWhitelistAllAppIdArray 传递给了 PowerManagerService； 然后，将 mPowerSaveWhitelistUserAppIdArray 传递给了 AlarmManagerService； 2.3.1 DeviceIdleController.buildAppIdArray12345678910111213141516171819202122private static int[] buildAppIdArray(ArrayMap&lt;String, Integer&gt; systemApps, ArrayMap&lt;String, Integer&gt; userApps, SparseBooleanArray outAppIds) &#123; outAppIds.clear(); //【1】将 systemApps 和 userApps 合并到 outAppIds 中，appId 和 true 值的映射！ if (systemApps != null) &#123; for (int i = 0; i &lt; systemApps.size(); i++) &#123; outAppIds.put(systemApps.valueAt(i), true); &#125; &#125; if (userApps != null) &#123; for (int i = 0; i &lt; userApps.size(); i++) &#123; outAppIds.put(userApps.valueAt(i), true); &#125; &#125; //【2】将 outAppIds 中的所有 appId 保存到数组 appids 中，并返回！ int size = outAppIds.size(); int[] appids = new int[size]; for (int i = 0; i &lt; size; i++) &#123; appids[i] = outAppIds.keyAt(i); &#125; return appids;&#125; 2.4 new BinderService创建了一个 BinderService 对象，继承了 IDeviceIdleController.Stub，作为服务端桩对象，用于其它进程访问 DeviceIdleController 内部接口！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117private final class BinderService extends IDeviceIdleController.Stub &#123; //【1】添加应用到 power save 应用白名单中！ @Override public void addPowerSaveWhitelistApp(String name) &#123; getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER, null); long ident = Binder.clearCallingIdentity(); try &#123; addPowerSaveWhitelistAppInternal(name); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; //【2】移除应用从 power save 应用白名单中！ @Override public void removePowerSaveWhitelistApp(String name) &#123; getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER, null); long ident = Binder.clearCallingIdentity(); try &#123; removePowerSaveWhitelistAppInternal(name); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; //【3】获取在 power save 模式下可以后台运行但是在 device idle 状态下不能后台运行的白名单！ @Override public String[] getSystemPowerWhitelistExceptIdle() &#123; return getSystemPowerWhitelistExceptIdleInternal(); &#125; @Override public String[] getSystemPowerWhitelist() &#123; return getSystemPowerWhitelistInternal(); &#125; @Override public String[] getUserPowerWhitelist() &#123; return getUserPowerWhitelistInternal(); &#125; @Override public String[] getFullPowerWhitelistExceptIdle() &#123; return getFullPowerWhitelistExceptIdleInternal(); &#125; @Override public String[] getFullPowerWhitelist() &#123; return getFullPowerWhitelistInternal(); &#125; @Override public int[] getAppIdWhitelistExceptIdle() &#123; return getAppIdWhitelistExceptIdleInternal(); &#125; @Override public int[] getAppIdWhitelist() &#123; return getAppIdWhitelistInternal(); &#125; @Override public int[] getAppIdUserWhitelist() &#123; return getAppIdUserWhitelistInternal(); &#125; @Override public int[] getAppIdTempWhitelist() &#123; return getAppIdTempWhitelistInternal(); &#125; @Override public boolean isPowerSaveWhitelistExceptIdleApp(String name) &#123; return isPowerSaveWhitelistExceptIdleAppInternal(name); &#125; @Override public boolean isPowerSaveWhitelistApp(String name) &#123; return isPowerSaveWhitelistAppInternal(name); &#125; @Override public void addPowerSaveTempWhitelistApp(String packageName, long duration, int userId, String reason) throws RemoteException &#123; addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason); &#125; @Override public long addPowerSaveTempWhitelistAppForMms(String packageName, int userId, String reason) throws RemoteException &#123; long duration = mConstants.MMS_TEMP_APP_WHITELIST_DURATION; addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason); return duration; &#125; @Override public long addPowerSaveTempWhitelistAppForSms(String packageName, int userId, String reason) throws RemoteException &#123; long duration = mConstants.SMS_TEMP_APP_WHITELIST_DURATION; addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason); return duration; &#125; @Override public void exitIdle(String reason) &#123; getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER, null); long ident = Binder.clearCallingIdentity(); try &#123; exitIdleInternal(reason); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; @Override public boolean registerMaintenanceActivityListener( IMaintenanceActivityListener listener) &#123; return DeviceIdleController.this.registerMaintenanceActivityListener(listener); &#125; @Override public void unregisterMaintenanceActivityListener( IMaintenanceActivityListener listener) &#123; DeviceIdleController.this.unregisterMaintenanceActivityListener(listener); &#125; @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123; DeviceIdleController.this.dump(fd, pw, args); &#125; @Override public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ResultReceiver resultReceiver) &#123; (new Shell()).exec(this, in, out, err, args, resultReceiver); &#125;&#125; 这里的接口，我们先不详细看！ 最后，将桩对象注册到了 ServiceManager 中！ 1publishBinderService(Context.DEVICE_IDLE_CONTROLLER, mBinderService); 2.5 new LocalService创建了本地服务对象，方便进程内部通信！123456789101112131415161718192021222324252627public final class LocalService &#123; public void addPowerSaveTempWhitelistAppDirect(int appId, long duration, boolean sync, String reason) &#123; addPowerSaveTempWhitelistAppDirectInternal(0, appId, duration, sync, reason); &#125; public long getNotificationWhitelistDuration() &#123; return mConstants.NOTIFICATION_WHITELIST_DURATION; &#125; public void setNetworkPolicyTempWhitelistCallback(Runnable callback) &#123; setNetworkPolicyTempWhitelistCallbackInternal(callback); &#125; public void setJobsActive(boolean active) &#123; DeviceIdleController.this.setJobsActive(active); &#125; // Up-call from alarm manager. public void setAlarmsActive(boolean active) &#123; DeviceIdleController.this.setAlarmsActive(active); &#125; public int[] getPowerSaveWhitelistUserAppIds() &#123; return DeviceIdleController.this.getPowerSaveWhitelistUserAppIds(); &#125;&#125; 3 DeviceIdleController.onBootPhase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Overridepublic void onBootPhase(int phase) &#123; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; synchronized (this) &#123; //【1】获得了一些重要的系统服务：AlarmManager，BatteryStats，PowerManager，ConnectivityService // NetworkPolicyManager，DisplayManager 和 SensorManager； mAlarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE); mBatteryStats = BatteryStatsService.getService(); mLocalPowerManager = getLocalService(PowerManagerInternal.class); mPowerManager = getContext().getSystemService(PowerManager.class); mActiveIdleWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"deviceidle_maint\"); mActiveIdleWakeLock.setReferenceCounted(false); mConnectivityService = (ConnectivityService)ServiceManager.getService( Context.CONNECTIVITY_SERVICE); mLocalAlarmManager = getLocalService(AlarmManagerService.LocalService.class); mNetworkPolicyManager = INetworkPolicyManager.Stub.asInterface( ServiceManager.getService(Context.NETWORK_POLICY_SERVICE)); mDisplayManager = (DisplayManager) getContext().getSystemService( Context.DISPLAY_SERVICE); // 获得 SensorManager，用于获得系统的传感器信息！ mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE); int sigMotionSensorId = getContext().getResources().getInteger( com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor); // 获得运动传感器对象，监听手机位置变化！ if (sigMotionSensorId &gt; 0) &#123; mMotionSensor = mSensorManager.getDefaultSensor(sigMotionSensorId, true); &#125; if (mMotionSensor == null &amp;&amp; getContext().getResources().getBoolean( com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) &#123; mMotionSensor = mSensorManager.getDefaultSensor( Sensor.TYPE_WRIST_TILT_GESTURE, true); &#125; if (mMotionSensor == null) &#123; mMotionSensor = mSensorManager.getDefaultSensor( Sensor.TYPE_SIGNIFICANT_MOTION, true); &#125; if (getContext().getResources().getBoolean( com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) &#123; mLocationManager = (LocationManager) getContext().getSystemService( Context.LOCATION_SERVICE); mLocationRequest = new LocationRequest() .setQuality(LocationRequest.ACCURACY_FINE) .setInterval(0) .setFastestInterval(0) .setNumUpdates(1); &#125; // 通过配置文件。得到角度变化的阈值！ // 创建一个 AnyMotionDetector，同一时候将 DeviceIdleController 注冊到当中 // 当 AnyMotionDetector 检測到手机变化角度超过阈值时。就会回调 DeviceIdleController 的接口 float angleThreshold = getContext().getResources().getInteger( com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f; mAnyMotionDetector = new AnyMotionDetector( (PowerManager) getContext().getSystemService(Context.POWER_SERVICE), mHandler, mSensorManager, this, angleThreshold); // 创建了两个广播对象，一个用于通知 deep doze 模式变化；另一个用于通知 light doze 模式变化！ mIdleIntent = new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED); mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); mLightIdleIntent = new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED); mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); //【3.1】监听电池变化的广播！ IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_BATTERY_CHANGED); getContext().registerReceiver(mReceiver, filter); //【3】监听 package 变化的广播！ filter = new IntentFilter(); filter.addAction(Intent.ACTION_PACKAGE_REMOVED); filter.addDataScheme(\"package\"); getContext().registerReceiver(mReceiver, filter); //【4】监听网络变化的广播！ filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); getContext().registerReceiver(mReceiver, filter); //【5】再次将 mPowerSaveWhitelistAllAppIdArray 传递给了 PowerManagerService； // 将 mPowerSaveWhitelistUserAppIdArray 传递给了 AlarmManagerService； mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray); mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray); //【3.2】注册 DisplayListener 监听熄屏亮屏状态，同时更新屏幕状态！ mDisplayManager.registerDisplayListener(mDisplayListener, null); updateDisplayLocked(); &#125; //【3.3】更新网络连接状态！ updateConnectivityState(null); &#125;&#125; 这里我们来看看 DisplayListener 对象！ 3.1 new BroadcastReceiver12345678910111213141516171819202122232425private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; switch (intent.getAction()) &#123; case ConnectivityManager.CONNECTIVITY_ACTION: &#123; updateConnectivityState(intent); // 网络变化 &#125; break; case Intent.ACTION_BATTERY_CHANGED: &#123; synchronized (DeviceIdleController.this) &#123; int plugged = intent.getIntExtra(\"plugged\", 0); updateChargingLocked(plugged != 0); // 电量变化 &#125; &#125; break; case Intent.ACTION_PACKAGE_REMOVED: &#123; // 升级包移除！ if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123; //【3.1.1】更新用户应用白名单！ removePowerSaveWhitelistAppInternal(ssp); &#125; &#125; &#125; break; &#125; &#125;&#125;; 创建了一个 BroadcastReceiver 对象，监听 CONNECTIVITY_ACTION，ACTION_BATTERY_CHANGED，ACTION_PACKAGE_REMOVED 广播！ 关于监听到变化后的动态处理，这里我们先不分析！ 3.1.1 DeviceIdleController.removePowerSaveWhitelistAppInternal1234567891011121314public boolean removePowerSaveWhitelistAppInternal(String name) &#123; synchronized (this) &#123; if (mPowerSaveWhitelistUserApps.remove(name) != null) &#123; //【1】发送 ACTION_POWER_SAVE_WHITELIST_CHANGED 广播！ reportPowerSaveWhitelistChangedLocked(); //【2.3.1】更新名单列表，同时 updateWhitelistAppIdsLocked(); //【3】更新本地持久化文件！ writeConfigFileLocked(); return true; &#125; &#125; return false;&#125; reportPowerSaveWhitelistChangedLocked 方法会发送 PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED 广播！12345private void reportPowerSaveWhitelistChangedLocked() &#123; Intent intent = new Intent(PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); getContext().sendBroadcastAsUser(intent, UserHandle.SYSTEM);&#125; writeConfigFileLocked 方法会发送 MSG_WRITE_CONFIG 消息给 MyHandler。MyHandler 会处理消息，调用 handleWriteConfigFile -&gt; writeConfigFileLocked(XmlSerializer out) 方法，更新本地名单！1234void writeConfigFileLocked() &#123; mHandler.removeMessages(MSG_WRITE_CONFIG); mHandler.sendEmptyMessageDelayed(MSG_WRITE_CONFIG, 5000);&#125; 继续看！ 3.2 register DisplayListenermDisplayListener 用于监听屏幕的状态！123456789101112131415161718private final DisplayManager.DisplayListener mDisplayListener = new DisplayManager.DisplayListener() &#123; @Override public void onDisplayAdded(int displayId) &#123; &#125; @Override public void onDisplayRemoved(int displayId) &#123; &#125; @Override public void onDisplayChanged(int displayId) &#123; if (displayId == Display.DEFAULT_DISPLAY) &#123; synchronized (DeviceIdleController.this) &#123; //【3.1.1】当屏幕状态发生变化后，onDisplayChanged 方法被触发！ // 执行了 DeviceIdleController.updateDisplayLocked 方法！ updateDisplayLocked(); &#125; &#125; &#125;&#125;; 3.2.1 DeviceIdleController.updateDisplayLockedupdateDisplayLocked 用于更新屏幕的状态！1234567891011121314151617181920void updateDisplayLocked() &#123; //【1】获取屏幕当前的状态，并判断是否是亮屏状态！ mCurDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY); boolean screenOn = mCurDisplay.getState() == Display.STATE_ON; if (DEBUG) Slog.d(TAG, \"updateDisplayLocked: screenOn=\" + screenOn); if (!screenOn &amp;&amp; mScreenOn) &#123; //【2.1】如果是从亮屏转为熄屏，设置 mScreenOn 为 false！ mScreenOn = false; if (!mForceIdle) &#123; becomeInactiveIfAppropriateLocked(); // 进入 Doze 模式； &#125; &#125; else if (screenOn) &#123; //【2.2】如果是从熄屏转亮屏，设置 mScreenOn 为 true！ mScreenOn = true; if (!mForceIdle) &#123; becomeActiveLocked(\"screen\", Process.myUid()); // 退出 Doze 模式； &#125; &#125;&#125; mForceIdle 表示是否强制进入 idle 状态，默认为 false 的，目前唯一的开启方式是通过 adb shell，执行 dumpsys 命令，触发 force-idle，force-inactive 相关指令，强制进入 idle 状态！！ 这里看到，当熄屏后，会调用 becomeInactiveIfAppropriateLocked 方法，进入 doze 模式；当亮屏后，会调用 becomeActiveLocked 方法，退出 doze！ 3.3 DeviceIdleController.updateConnectivityState更新网络状态！123456789101112131415161718192021222324252627282930313233343536373839void updateConnectivityState(Intent connIntent) &#123; ConnectivityService cm; synchronized (this) &#123; cm = mConnectivityService; &#125; if (cm == null) &#123; return; &#125; NetworkInfo ni = cm.getActiveNetworkInfo(); synchronized (this) &#123; boolean conn; if (ni == null) &#123; //【1】网络断开，conn 为 false； conn = false; &#125; else &#123; //【2】获得网络的连接状态； if (connIntent == null) &#123; conn = ni.isConnected(); &#125; else &#123; final int networkType = connIntent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_NONE); if (ni.getType() != networkType) &#123; return; &#125; conn = !connIntent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false); &#125; &#125; //【3】处理连接状态，如果当前状态和之前的状态发生了变化，更新 mNetworkConnected 的值 if (conn != mNetworkConnected) &#123; mNetworkConnected = conn; //【4】如果本次状态是处于连接中，并且 light idle 正在等待网络，那就继续处理状态！！ if (conn &amp;&amp; mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123; stepLightIdleStateLocked(\"network\"); &#125; &#125; &#125;&#125; 可以看到 DeviceIdleController 的启动流程还是很简单的！ 4 启动总结我们通过一张图来看看 DeviceIdleController 的整个启动过程！ 其他优秀博客！！ https://blog.csdn.net/kc58236582/article/details/54923406https://www.cnblogs.com/gavanwanggw/p/7327832.html","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Doze假寐模式","slug":"AndroidFramework源码分析/Doze假寐模式","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Doze假寐模式/"}],"tags":[{"name":"Doze假寐模式","slug":"Doze假寐模式","permalink":"https://coolqi.top/tags/Doze假寐模式/"}]},{"title":"AlarmManager第 4 篇 - AlarmManagerService属性总结","slug":"AlarmManager4-AlarmManagerServiceAttributeSummary","date":"2017-09-27T12:46:25.000Z","updated":"2018-11-20T17:43:03.000Z","comments":true,"path":"2017/09/27/AlarmManager4-AlarmManagerServiceAttributeSummary/","link":"","permalink":"https://coolqi.top/2017/09/27/AlarmManager4-AlarmManagerServiceAttributeSummary/","excerpt":"","text":"首先我们来看看 AlarmManagerService 中的一些成员变量： 1、首先是一些二进制标志位： 1234567891011121314//【1】alarm 的类型，用二进制表示！private static final int RTC_WAKEUP_MASK = 1 &lt;&lt; RTC_WAKEUP; // 1 &lt;&lt; 0private static final int RTC_MASK = 1 &lt;&lt; RTC; // 1 &lt;&lt; 1private static final int ELAPSED_REALTIME_WAKEUP_MASK = 1 &lt;&lt; ELAPSED_REALTIME_WAKEUP; // // 1 &lt;&lt; 2private static final int ELAPSED_REALTIME_MASK = 1 &lt;&lt; ELAPSED_REALTIME; // 1 &lt;&lt; 3// 时间是否改变static final int TIME_CHANGED_MASK = 1 &lt;&lt; 16;// 该 alarm 是否是 wake up 类型的static final int IS_WAKEUP_MASK = RTC_WAKEUP_MASK|ELAPSED_REALTIME_WAKEUP_MASK;// Mask for testing whether a given alarm type is wakeup vs non-wakeupstatic final int TYPE_NONWAKEUP_MASK = 0x1; // low bit =&gt; non-wakeup RTC_WAKEUP，RTC，ELAPSED_REALTIME_WAKEUP，ELAPSED_REALTIME 定义在 AlarmManager 中，其代表了 4 种 alarm 类型！ 123456789101112131415// 这种 alarm 的时间计算方法为 System.currentTimeMillis()，不包括休眠时间！// 该 alarm 触发会唤醒设备！public static final int RTC_WAKEUP = 0;// 这种 alarm 的时间计算方法为 System.currentTimeMillis()，不包括休眠时间！// 这种类型的 alarm 不会唤醒设备，如果其在设备休眠时候触发，直到设备被唤醒后，才被被分发出去！public static final int RTC = 1;// 这种 alarm 的时间计算方法为 SystemClock.elapsedRealtime()，包括休眠时间！// 这种类型的 alarm 触发时会唤醒设备；public static final int ELAPSED_REALTIME_WAKEUP = 2;// 这种 alarm 的时间计算方法为 SystemClock.elapsedRealtime()，包括休眠时间！// 这种类型的 alarm 不会唤醒设备，如果其在设备休眠时候触发，直到设备下次被唤醒后，才被被分发出去！public static final int ELAPSED_REALTIME = 3; 2、和 debug 相关的 alarm，这里不关注！ 12345678910111213static final String TAG = \"AlarmManager\";static final boolean localLOGV = false;static final boolean DEBUG_BATCH = localLOGV || false;static final boolean DEBUG_VALIDATE = localLOGV || false;static final boolean DEBUG_ALARM_CLOCK = localLOGV || false;static final boolean DEBUG_LISTENER_CALLBACK = localLOGV || false;final LocalLog mLog = new LocalLog(TAG);boolean mLastWakeLockUnimportantForLogging;// 用于 dump wake up 状态信息！static final boolean WAKEUP_STATS = false; 3、广播以及关闭广播接受者 1234567891011121314151617181920// 后台广播，用于分发 alarm！private final Intent mBackgroundIntent = new Intent().addFlags(Intent.FLAG_FROM_BACKGROUND); // 下一个 alarm 时间发生改变的广播！private static final Intent NEXT_ALARM_CLOCK_CHANGED_INTENT = new Intent(AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED) .addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING); // 用于监听时间改变和日期改变的广播！ClockReceiver mClockReceiver;// 用于监听熄屏亮屏广播InteractiveStateReceiver mInteractiveStateReceiver;// 用于监听 package 相关的广播！private UninstallReceiver mUninstallReceiver;PendingIntent mTimeTickSender; // 时间改变的广播；PendingIntent mDateChangeSender; // 日期改变的广播； 4、时间相关 123456789101112131415161718192021222324private long mNextWakeup; // 下一个包含 wakeup 的 batch 的开始时间 private long mNextNonWakeup; // 下一个包含 no wake up 的 batch 的开始时间 private long mLastWakeupSet;private long mLastWakeup;boolean mInteractive = true; // 熄屏亮屏状态，亮屏为 truelong mNonInteractiveStartTime; // 熄灭屏幕的开始时间；long mNonInteractiveTime; // 熄灭屏幕的最长时间间隔；long mLastAlarmDeliveryTime; // 上一个 alarm 的分发时间！long mStartCurrentDelayTime; // 需要延迟执行的非 wake up 类型的 alarm 开始延迟的时间！long mNextNonWakeupDeliveryTime; // 下一次非 wake up 类型的 alarm 分发时间！long mLastTimeChangeClockTime; // 上一次时间发生改变的时间点，取值为 System.currentTimeMillis()；long mLastTimeChangeRealtime; // 上一次时间发生改变的时间点，取值为 SystemClock.elapsedRealtime()；long mAllowWhileIdleMinTime; // 可以开始执行 flag 为 ALLOW_WHILE_IDLE 的 alarm 的最小时间间隔！long mTotalDelayTime = 0;long mMaxDelayTime = 0; //int mNumTimeChanged; // 时间改变的次数！int mNumDelayedAlarms = 0; 5、集合1234567891011121314151617181920212223242526272829303132333435363738394041424344// 延迟执行的 no wake up 类型的 alarm 列表！ArrayList&lt;Alarm&gt; mPendingNonWakeupAlarms = new ArrayList&lt;&gt;();// 正在执行中的 alarm 列表！ArrayList&lt;InFlight&gt; mInFlight = new ArrayList&lt;&gt;();/** * For each uid, this is the last time we dispatched an \"allow while idle\" alarm, * used to determine the earliest we can dispatch the next such alarm. */final SparseLongArray mLastAllowWhileIdleDispatch = new SparseLongArray();final ArrayList&lt;IdleDispatchEntry&gt; mAllowWhileIdleDispatches = new ArrayList();private final SparseArray&lt;AlarmManager.AlarmClockInfo&gt; mNextAlarmClockForUser = new SparseArray&lt;&gt;(); private final SparseArray&lt;AlarmManager.AlarmClockInfo&gt; mTmpSparseAlarmClockArray = new SparseArray&lt;&gt;(); private final SparseBooleanArray mPendingSendNextAlarmClockChangedForUser = new SparseBooleanArray(); /** * The current set of user whitelisted apps for device idle mode, meaning these are allowed * to freely schedule alarms. */int[] mDeviceIdleUserWhitelist = new int[0];ArrayList&lt;Alarm&gt; mPendingWhileIdleAlarms = new ArrayList&lt;&gt;();final SparseArray&lt;ArrayMap&lt;String, BroadcastStats&gt;&gt; mBroadcastStats = new SparseArray&lt;ArrayMap&lt;String, BroadcastStats&gt;&gt;(); // May only use on mHandler's thread, locking not required.private final SparseArray&lt;AlarmManager.AlarmClockInfo&gt; mHandlerSparseAlarmClockArray = new SparseArray&lt;&gt;(); final LinkedList&lt;WakeupEvent&gt; mRecentWakeups = new LinkedList&lt;WakeupEvent&gt;();final HashMap&lt;String, PriorityClass&gt; mPriorities = new HashMap&lt;&gt;();// // alarm批处理对象列表 final ArrayList&lt;Batch&gt; mAlarmBatches = new ArrayList&lt;&gt;(); 6、比较器 1234567891011121314151617181920212223242526// 时间比较器！static final IncreasingTimeOrder sIncreasingTimeOrder = new IncreasingTimeOrder();static final BatchTimeOrder sBatchOrder = new BatchTimeOrder();final Comparator&lt;Alarm&gt; mAlarmDispatchComparator = new Comparator&lt;Alarm&gt;() &#123; @Override public int compare(Alarm lhs, Alarm rhs) &#123; // priority class trumps everything. TICK &lt; WAKEUP &lt; NORMAL if (lhs.priorityClass.priority &lt; rhs.priorityClass.priority) &#123; return -1; &#125; else if (lhs.priorityClass.priority &gt; rhs.priorityClass.priority) &#123; return 1; &#125; // within each class, sort by nominal delivery time if (lhs.whenElapsed &lt; rhs.whenElapsed) &#123; return -1; &#125; else if (lhs.whenElapsed &gt; rhs.whenElapsed) &#123; return 1; &#125; // same priority class + same target delivery time return 0; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static final boolean RECORD_ALARMS_IN_HISTORY = true; // 是否将 alarm 保存到历史信息中！static final boolean RECORD_DEVICE_IDLE_ALARMS = false;// 消息 id，AlarmHandler 处理！static final int ALARM_EVENT = 1;// 系统属性用于获取时区信息，更新 kernel 的时区信息！static final String TIMEZONE_PROPERTY = \"persist.sys.timezone\";// appOps 管理对象！AppOpsManager mAppOps;// doze 模式DeviceIdleController.LocalService mLocalDeviceIdleController;// 锁对象，访问 mConstants 的时候，必须持有锁！final Object mLock = new Object();// alarm 驱动指针！long mNativeData;// 用于标记当前正在分发处理的 alarm 个数！int mBroadcastRefCount = 0;PowerManager.WakeLock mWakeLock;final AlarmHandler mHandler = new AlarmHandler();// alarm 分发监控器final DeliveryTracker mDeliveryTracker = new DeliveryTracker();Random mRandom;/** * Broadcast options to use for FLAG_ALLOW_WHILE_IDLE. */Bundle mIdleOptions;private boolean mNextAlarmClockMayChange; // 下一个 alarm 的触发时间是否会改变！final Constants mConstants; // 常量类！// Alarm delivery ordering bookkeepingstatic final int PRIO_TICK = 0;static final int PRIO_WAKEUP = 1;static final int PRIO_NORMAL = 2;int mCurrentSeq = 0;final long RECENT_WAKEUP_PERIOD = 1000L * 60 * 60 * 24; // one day// minimum recurrence period or alarm futurity for us to be able to fuzz itstatic final long MIN_FUZZABLE_INTERVAL = 10000;// set to null if in idle mode; while in this mode, any alarms we don't want// to run during this time are placed in mPendingWhileIdleAlarmsAlarm mPendingIdleUntil = null;// 下一个请求退出 idle 模式的 alarm Alarm mNextWakeFromIdle = null; 以上的只是对主要的变量进行了解释和说明，其具体的作用，我们后续在分析 alarm manager 机制的时候会分析！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AlarmManager闹钟管理","slug":"AndroidFramework源码分析/AlarmManager闹钟管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AlarmManager闹钟管理/"}],"tags":[{"name":"AlarmManager闹钟管理","slug":"AlarmManager闹钟管理","permalink":"https://coolqi.top/tags/AlarmManager闹钟管理/"}]},{"title":"AppOps 第 3 篇 - AppOps 权限相关方法","slug":"AppOps3-AppOpsWithMethods","date":"2017-09-10T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/09/10/AppOps3-AppOpsWithMethods/","link":"","permalink":"https://coolqi.top/2017/09/10/AppOps3-AppOpsWithMethods/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，如有错误，欢迎指正，谢谢！ [toc] 0 综述前面分析了 AppOpsManager 中的一些接口，最终都会调用 AppOpservice 中的相应接口，下面我们来看下 AppOpservice 中的权限操作！ 涉及的类如下： Settings 上层应用入口： 1234packages/apps/Settings/src/com/android/settings/applications/AppOpsCategory.javapackages/apps/Settings/src/com/android/settings/applications/AppOpsDetails.javapackages/apps/Settings/src/com/android/settings/applications/AppOpsState.javapackages/apps/Settings/src/com/android/settings/applications/AppOpsSummary.java appops 的可执行文件： 位于 /system/bin/ 目录下！ 12frameworks/native/libs/binder/AppOpsManager.cppframeworks/native/include/binder/AppOpsManager.h 框架层 AppOps 核心实现类： AppOpsService 是功能具体实现；AppOpsManager 是 AppOpsService 提供给其他进程的一个入口； AppOpsPolicy大概意思是，系统出厂时预制的系统 App(System-app)和用户 app（User-app）的一些默认的权限！12frameworks/base/services/core/java/com/android/server/AppOpsService.javaframeworks/base/core/java/android/app/AppOpsManager.java 这里我们重点关注核心服务 AppOpsService 的实现，下面分析下一些核心的方法接口！ 1 AppOpsService.checkOperation - 检查操作权限checkOperation 用于检查指定 package 是否有权限执行指定操作！ 123456789101112131415161718192021222324252627282930313233343536@Overridepublic int checkOperation(int code, int uid, String packageName) &#123; //【×1.1】校验 uid 是否有 UPDATE_APP_OPS_STATS 权限； verifyIncomingUid(uid); //【×1.2】校验 op code 是否正确！ verifyIncomingOp(code); //【×1.3】处理包名！ String resolvedPackageName = resolvePackageName(uid, packageName); if (resolvedPackageName == null) &#123; return AppOpsManager.MODE_IGNORED; // 如果 package 为 null，返回 MODE_IGNORED！ &#125; synchronized (this) &#123; //【×1.4】判断该 operation 是否收到用户限制，如果有，返回 MODE_IGNORED！ if (isOpRestrictedLocked(uid, code, resolvedPackageName)) &#123; return AppOpsManager.MODE_IGNORED; &#125; //【2】获得决定 code 指定 op 的模式的 op，调用 AppOpsManager.opToSwitch 方法！ code = AppOpsManager.opToSwitch(code); //【×1.5】判断该 uid 是否允许执行该操作，如果不允许，返回已有的模式状态； UidState uidState = getUidStateLocked(uid, false); if (uidState != null &amp;&amp; uidState.opModes != null) &#123; final int uidMode = uidState.opModes.get(code); if (uidMode != AppOpsManager.MODE_ALLOWED) &#123; return uidMode; &#125; &#125; //【×1.6】如果该 uid 允许执行该操作，那就进一步判断该 package 是否允许执行该操作， // 如果没有定义，返回默认状态；否则返回已有的模式状态； Op op = getOpLocked(code, uid, resolvedPackageName, false); if (op == null) &#123; return AppOpsManager.opToDefaultMode(code); &#125; return op.mode; &#125;&#125; 其实我们知道，该方法返回值有如下几种：MODE_ALLOWED，MODE_IGNORED，MODE_ERRORED 和 MODE_DEFAULT！ 1.1 verifyIncomingUid校验 uid 是否具有 android.Manifest.permission.UPDATE_APP_OPS_STATS 权限！ 123456789101112private void verifyIncomingUid(int uid) &#123; //【1】如果是 uid 自身调用，不需要检验！ if (uid == Binder.getCallingUid()) &#123; return; &#125; //【2】如果是当前进程自己调用的，najiu if (Binder.getCallingPid() == Process.myPid()) &#123; return; &#125; mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS, Binder.getCallingPid(), Binder.getCallingUid(), null);&#125; 如果 uid 没有 android.Manifest.permission.UPDATE_APP_OPS_STATS 权限，抛出异常！ 1.2 verifyIncomingOp校验 op 是否正确！123456private void verifyIncomingOp(int op) &#123; if (op &gt;= 0 &amp;&amp; op &lt; AppOpsManager._NUM_OP) &#123; return; &#125; throw new IllegalArgumentException(\"Bad operation #\" + op);&#125; 如果 op 不在 [0， AppOpsManager._NUM_OP) 范围内，抛出异常； 1.3 resolvePackageName处理一些特殊 uid 所属包名！ 12345678910private static String resolvePackageName(int uid, String packageName) &#123; if (uid == 0) &#123; return \"root\"; &#125; else if (uid == Process.SHELL_UID) &#123; return \"com.android.shell\"; &#125; else if (uid == Process.SYSTEM_UID &amp;&amp; packageName == null) &#123; return \"android\"; &#125; return packageName;&#125; 不多说！ 1.4 isOpRestrictedLocked判断该操作是否被用户限制！12345678910111213141516171819202122232425262728private boolean isOpRestrictedLocked(int uid, int code, String packageName) &#123; //【1】获得该 uid 所属的 userId！ int userHandle = UserHandle.getUserId(uid); final int restrictionSetCount = mOpUserRestrictions.size(); for (int i = 0; i &lt; restrictionSetCount; i++) &#123; //【2】遍历每一个 ClientRestrictionState，检查该 op 是否在 uid 所在的用户下被限制，同时也检查 // 属于该 uid 的 package 是否在白名单中，如果在白名单中，那就不受限制！ ClientRestrictionState restrictionState = mOpUserRestrictions.valueAt(i); //【×1.4.1】校验该 package 的 op 在指定的 userid 下是否收到限制，如果有返回 true！ if (restrictionState.hasRestriction(code, packageName, userHandle)) &#123; //【3】如果确实在该 userId 下受到限制，那就在判断下是否允许 system/system ui 绕过限制！ if (AppOpsManager.opAllowSystemBypassRestriction(code)) &#123; synchronized (this) &#123; //【*1.4.2】获得该 package 的所有 op 操作 Ops ops = getOpsRawLocked(uid, packageName, true); if ((ops != null) &amp;&amp; ops.isPrivileged) &#123; //【3.1】如果 ops.isPrivileged 为 true，说明该 package 是特权应用，要绕过用户限制！ return false; &#125; &#125; &#125; //【3.2】受到限制但是不允许绕过！ return true; &#125; &#125; return false; // 不受限制返回 false；&#125; AppOpsService 用一个 ArrayMap 保存所有的用户限制状态信息！1private final ArrayMap&lt;IBinder, ClientRestrictionState&gt; mOpUserRestrictions = new ArrayMap&lt;&gt;(); 1.4.1 ClientRestrictionState.hasRestriction该方法用于判断指定 package 的指定 op 是否在 userId 下收到限制！1234567891011121314151617181920212223242526public boolean hasRestriction(int restriction, String packageName, int userId) &#123; //【1】如果 perUserRestrictions 为 null，不受限制！ if (perUserRestrictions == null) &#123; return false; &#125; //【2】如果在 userId 下没有限制信息，不受限制！ boolean[] restrictions = perUserRestrictions.get(userId); if (restrictions == null) &#123; return false; &#125; //【3】如果在 userId 下，restrictions[restriction] 为 false，不受限制！ if (!restrictions[restriction]) &#123; return false; &#125; //【4】如果在 userId 下，restrictions[restriction] 为 true，说明在该用户下，该 op 是受限制的 // 那就要看下 package 是否在白名单中，如果没有白名单，那么就是首先的！ if (perUserExcludedPackages == null) &#123; return true; &#125; String[] perUserExclusions = perUserExcludedPackages.get(userId); if (perUserExclusions == null) &#123; return true; &#125; //【5】如果该 package 是在白名单中，那么就是不受限的，返回 false； return !ArrayUtils.contains(perUserExclusions, packageName);&#125; 方法很简单，不多说了！ 1.4.2 getOpsRawLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private Ops getOpsRawLocked(int uid, String packageName, boolean edit) &#123; //【*1.5】获得 uid 的 UidState 对象！ UidState uidState = getUidStateLocked(uid, edit); if (uidState == null) &#123; return null; &#125; if (uidState.pkgOps == null) &#123; if (!edit) &#123; return null; &#125; uidState.pkgOps = new ArrayMap&lt;&gt;(); &#125; //【1】获得 packageName 指定的应用的 op 限制！ Ops ops = uidState.pkgOps.get(packageName); if (ops == null) &#123; if (!edit) &#123; return null; &#125; boolean isPrivileged = false; //【2】下面会判断 package 和 uid 的对应关系是否有效！ if (uid != 0) &#123; final long ident = Binder.clearCallingIdentity(); try &#123; int pkgUid = -1; try &#123; //【2.1】获得 packageName 对应的应用程序信息 ApplicationInfo！ ApplicationInfo appInfo = ActivityThread.getPackageManager() .getApplicationInfo(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getUserId(uid)); if (appInfo != null) &#123; //【2.2】获得 package 的 uid，判断其是否是特权应用； pkgUid = appInfo.uid; isPrivileged = (appInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0; &#125; else &#123; //【2.3】针对一些特殊没有安装信息的 package，这里做一个处理！ if (\"media\".equals(packageName)) &#123; pkgUid = Process.MEDIA_UID; isPrivileged = false; &#125; else if (\"audioserver\".equals(packageName)) &#123; pkgUid = Process.AUDIOSERVER_UID; isPrivileged = false; &#125; else if (\"cameraserver\".equals(packageName)) &#123; pkgUid = Process.CAMERASERVER_UID; isPrivileged = false; &#125; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Could not contact PackageManager\", e); &#125; //【2.4】判读 package 和 uid 的对应关系是否有效，如果 package 现在的 uid 不是 AppOps // 中记录的 uid，那么输出异常，并返回； if (pkgUid != uid) &#123; RuntimeException ex = new RuntimeException(\"here\"); ex.fillInStackTrace(); Slog.w(TAG, \"Bad call: specified package \" + packageName + \" under uid \" + uid + \" but it is really \" + pkgUid, ex); return null; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; //【3】对于 edit 为 true 的情况，会做初始化操作！！ ops = new Ops(packageName, uidState, isPrivileged); uidState.pkgOps.put(packageName, ops); &#125; return ops;&#125; 不多说了！ 1.5 getUidStateLocked获得 uid 的 op 管理信息： 123456789101112private UidState getUidStateLocked(int uid, boolean edit) &#123; UidState uidState = mUidStates.get(uid); if (uidState == null) &#123; if (!edit) &#123; return null; &#125; uidState = new UidState(uid); //【1】从 mUidStates 获取！ mUidStates.put(uid, uidState); &#125; return uidState;&#125; 不多说！ 1.6 getOpLockedgetOpLocked 用于获得指定 package 的特定 op 对应的 Op 对象，该 Op 对象封装了操作的模式等相关信息，参数 boolean edit 这里传入的是 true！ 123456789private Op getOpLocked(int code, int uid, String packageName, boolean edit) &#123; //【1】获得该 package 的所有的 op 信息，封装在 Ops 对象中！ Ops ops = getOpsRawLocked(uid, packageName, edit); if (ops == null) &#123; return null; &#125; //【2】返回指定 op 对应的信息！ return getOpLocked(ops, code, edit);&#125; 调用了三参数函数 getOpLocked！12345678910111213141516private Op getOpLocked(Ops ops, int code, boolean edit) &#123; //【1】获得 code 对应的 Op 对象！ Op op = ops.get(code); if (op == null) &#123; if (!edit) &#123; return null; &#125; // 如果没有，由于 edit 为 true，这里会默认初始化创建一个 Op 对象！ op = new Op(ops.uidState.uid, ops.packageName, code); ops.put(code, op); &#125; if (edit) &#123; // 同时更新本地持久化文件！ scheduleWriteLocked(); &#125; return op; // 返回！&#125; 2 AppOpsService.noteOperation - 检查操作权限检查指定的 package 是否允许执行 op 对应的操作，同时会更新 op 相关的信息！ noteOperation 用于短期权限的检查。 1234567891011@Overridepublic int noteOperation(int code, int uid, String packageName) &#123; verifyIncomingUid(uid); verifyIncomingOp(code); String resolvedPackageName = resolvePackageName(uid, packageName); if (resolvedPackageName == null) &#123; return AppOpsManager.MODE_IGNORED; &#125; //【*2.1】调用了 5 参函数！ return noteOperationUnchecked(code, uid, resolvedPackageName, 0, null);&#125; 继续分析： 2.1 noteOperationUnchecked我们去看看 5 参函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private int noteOperationUnchecked(int code, int uid, String packageName, int proxyUid, String proxyPackageName) &#123; synchronized (this) &#123; //【*1.4.2】获得该 package 的所有 Op 信息！ Ops ops = getOpsRawLocked(uid, packageName, true); if (ops == null) &#123; if (DEBUG) Log.d(TAG, \"noteOperation: no op for code \" + code + \" uid \" + uid + \" package \" + packageName); return AppOpsManager.MODE_ERRORED; &#125; //【*1.5】获得 code 指定的 Op 信息！ Op op = getOpLocked(ops, code, true); //【*1.4】如果该 op 在 uid 所在的用户下受限，返回 MODE_IGNORED ！ if (isOpRestrictedLocked(uid, code, packageName)) &#123; return AppOpsManager.MODE_IGNORED; &#125; if (op.duration == -1) &#123; Slog.w(TAG, \"Noting op not finished: uid \" + uid + \" pkg \" + packageName + \" code \" + code + \" time=\" + op.time + \" duration=\" + op.duration); &#125; op.duration = 0; //【2】获得决定 code 指定 op 模式的 switchCode，其实是另外一个 op！ final int switchCode = AppOpsManager.opToSwitch(code); //【3】获得该 package 所属 uid 的 op 限制！ UidState uidState = ops.uidState; if (uidState.opModes != null &amp;&amp; uidState.opModes.indexOfKey(switchCode) &gt;= 0) &#123; //【3.1】如果该 uid 有 switchCode，那么 uid 的 switchCode 模式优先级更高！ // 如果 uid 不允许执行该操作，返回的是该 uid 的 switchCode 模式！ final int uidMode = uidState.opModes.get(switchCode); if (uidMode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG) Log.d(TAG, \"noteOperation: reject #\" + op.mode + \" for code \" + switchCode + \" (\" + code + \") uid \" + uid + \" package \" + packageName); //【3.1.1】uid 不被允许的执行该 switchCode 在指定的操作， // 那么更新 code 对应 op 的 rejectTime 值！ op.rejectTime = System.currentTimeMillis(); return uidMode; &#125; &#125; else &#123; //【3.2】如果该 uid 没有该 switchCode，那就读取 package 的 switchCode 模式！ //【×1.6】通过 getOpLocked 获得指定的 op 信息！ final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op; if (switchOp.mode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG) Log.d(TAG, \"noteOperation: reject #\" + op.mode + \" for code \" + switchCode + \" (\" + code + \") uid \" + uid + \" package \" + packageName); //【3.2.1】package 不被允许的执行该 switchCode 在指定的操作， // 那么更新 code 对应 op 的 rejectTime 值！ return switchOp.mode; &#125; &#125; if (DEBUG) Log.d(TAG, \"noteOperation: allowing code \" + code + \" uid \" + uid + \" package \" + packageName); //【4】更新 code 对应的 op 的相关信息！ op.time = System.currentTimeMillis(); op.rejectTime = 0; op.proxyUid = proxyUid; op.proxyPackageName = proxyPackageName; return AppOpsManager.MODE_ALLOWED; &#125;&#125; 方法很简单，不多说了！ 3 AppOpsService.setUidMode - 设置 uid 的 op 模式设置指定 uid 的相应 op 的模式，如果 uid 的 op 模式发生后，那么属于该 uid 的所有 package 也会受到影响！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128@Overridepublic void setUidMode(int code, int uid, int mode) &#123; if (Binder.getCallingPid() != Process.myPid()) &#123; mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS, Binder.getCallingPid(), Binder.getCallingUid(), null); &#125; //【×1.2】校验 op 是否有效！ verifyIncomingOp(code); //【1】获得决定 code 指定 op 模式的 switchCode，其实是另外一个 op！ code = AppOpsManager.opToSwitch(code); synchronized (this) &#123; //【2】首先，获得该 op 的默认模式 defaultMode！ final int defaultMode = AppOpsManager.opToDefaultMode(code); //【×1.5】获得该 uid 对应的 UidState 对象！ UidState uidState = getUidStateLocked(uid, false); if (uidState == null) &#123; //【2.1】如果该 uid 没有相关的记录，且本次设置的模式是默认模式，不处理。直接返回！ if (mode == defaultMode) &#123; return; &#125; // 否则，创建 UidState 对象，将 code 和 mode 的关系添加进去！ uidState = new UidState(uid); uidState.opModes = new SparseIntArray(); uidState.opModes.put(code, mode); mUidStates.put(uid, uidState); // 更新本地文件； scheduleWriteLocked(); &#125; else if (uidState.opModes == null) &#123; //【2.2】如果该 uid 没有 op 相关的记录，且本次设置的模式是默认模式，不处理！ // 否则初始化 uidState.opModes，将 code 和 mode 的关系添加进去！ if (mode != defaultMode) &#123; uidState.opModes = new SparseIntArray(); uidState.opModes.put(code, mode); // 更新本地文件； scheduleWriteLocked(); &#125; &#125; else &#123; //【2.3】如果该 uid 下的 op 已有模式和本次设置的一样，不处理，直接返回！ if (uidState.opModes.get(code) == mode) &#123; return; &#125; // 如果该 uid 下的 op 已有模式不是默认模式，但是要设置为默认模式，直接从 uidState.opModes 中删除 op！ // 否则，更新 mode 的值！ if (mode == defaultMode) &#123; uidState.opModes.delete(code); if (uidState.opModes.size() &lt;= 0) &#123; uidState.opModes = null; &#125; &#125; else &#123; uidState.opModes.put(code, mode); &#125; scheduleWriteLocked(); // 更新本地文件； &#125; &#125; //【3】获得该 uid 下的所有 package！ String[] uidPackageNames = getPackagesForUid(uid); ArrayMap&lt;Callback, ArraySet&lt;String&gt;&gt; callbackSpecs = null; synchronized (this) &#123; //【3.1】收集所有监听该 uid 下该 op 模式变化的 Callback，用于触发回调！！ ArrayList&lt;Callback&gt; callbacks = mOpModeWatchers.get(code); if (callbacks != null) &#123; final int callbackCount = callbacks.size(); for (int i = 0; i &lt; callbackCount; i++) &#123; Callback callback = callbacks.get(i); ArraySet&lt;String&gt; changedPackages = new ArraySet&lt;&gt;(); //【3.1.1】将该 uid 下的所有 package 保存到 changedPackages 中，然后将 // 每个 Callback 和 changedPackages 的映射关系保存到 callbackSpecs 中！ Collections.addAll(changedPackages, uidPackageNames); callbackSpecs = new ArrayMap&lt;&gt;(); callbackSpecs.put(callback, changedPackages); &#125; &#125; //【3.2】收集所有监听该 uid 下 package 的 op 模式变化的 Callback！ for (String uidPackageName : uidPackageNames) &#123; callbacks = mPackageModeWatchers.get(uidPackageName); if (callbacks != null) &#123; if (callbackSpecs == null) &#123; callbackSpecs = new ArrayMap&lt;&gt;(); &#125; final int callbackCount = callbacks.size(); for (int i = 0; i &lt; callbackCount; i++) &#123; Callback callback = callbacks.get(i); //【3.2.1】获得之前已经添加的 packageName！！ ArraySet&lt;String&gt; changedPackages = callbackSpecs.get(callback); if (changedPackages == null) &#123; changedPackages = new ArraySet&lt;&gt;(); callbackSpecs.put(callback, changedPackages); &#125; //【3.2.2】将 package 添加到对应关系中！ changedPackages.add(uidPackageName); &#125; &#125; &#125; &#125; if (callbackSpecs == null) &#123; return; &#125; //【4】处理回调，通知该 uid 下的 op 发生了变化，如果 uid 下有 pkg，也会将 pkg 传递过去！！ final long identity = Binder.clearCallingIdentity(); try &#123; for (int i = 0; i &lt; callbackSpecs.size(); i++) &#123; Callback callback = callbackSpecs.keyAt(i); ArraySet&lt;String&gt; reportedPackageNames = callbackSpecs.valueAt(i); try &#123; if (reportedPackageNames == null) &#123; callback.mCallback.opChanged(code, uid, null); &#125; else &#123; final int reportedPackageCount = reportedPackageNames.size(); for (int j = 0; j &lt; reportedPackageCount; j++) &#123; String reportedPackageName = reportedPackageNames.valueAt(j); //【4.1】触发回调！ callback.mCallback.opChanged(code, uid, reportedPackageName); &#125; &#125; &#125; catch (RemoteException e) &#123; Log.w(TAG, \"Error dispatching op op change\", e); &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125;&#125; 设置完 uid 的 op 后，会触发那些监听 op 变化的回调！ 4 AppOpsService.setMode - 设置 package 的 op 模式设置指定 package 的指定 op 的模式值，参数 int uid 是该 package 所属的 uid！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic void setMode(int code, int uid, String packageName, int mode) &#123; //【1】校验权限，因为 setMode 方法只能是系统调用，系统是默认有 UPDATE_APP_OPS_STATS 权限的！ if (Binder.getCallingPid() != Process.myPid()) &#123; mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS, Binder.getCallingPid(), Binder.getCallingUid(), null); &#125; verifyIncomingOp(code); ArrayList&lt;Callback&gt; repCbs = null; //【2】获得决定 code 指定的 op 的模式的 op，调用 AppOpsManager.opToSwitch 方法！ code = AppOpsManager.opToSwitch(code); synchronized (this) &#123; //【3】获得 uid 对应的 UidState 对象！ UidState uidState = getUidStateLocked(uid, false); //【×1.5】获得 code（switch） 对应的 Op 对象！ Op op = getOpLocked(code, uid, packageName, true); if (op != null) &#123; //【5】如果 op 的现有模式和本次要设置的模式不同，更新模式值！ if (op.mode != mode) &#123; op.mode = mode; //【5.1】更新了模式值后，收集所有监听该 op 模式变化的观察者！ ArrayList&lt;Callback&gt; cbs = mOpModeWatchers.get(code); if (cbs != null) &#123; if (repCbs == null) &#123; repCbs = new ArrayList&lt;Callback&gt;(); &#125; repCbs.addAll(cbs); &#125; //【5.2】更新了模式值后，收集所有监听该 packageName 操作模式变化的观察者！ cbs = mPackageModeWatchers.get(packageName); if (cbs != null) &#123; if (repCbs == null) &#123; repCbs = new ArrayList&lt;Callback&gt;(); &#125; repCbs.addAll(cbs); &#125; //【×4.1】如果本次设置是恢复默认模式，那么就移除该 op； if (mode == AppOpsManager.opToDefaultMode(op.op)) &#123; pruneOp(op, uid, packageName); &#125; //【×4.2】更新本地文件； scheduleFastWriteLocked(); &#125; &#125; &#125; //【6】当 repCbs 不为 null，通知所有监听者！ if (repCbs != null) &#123; // 将远程调用者的 uid/pid 转为系统进程的 uid/pid 防止权限相关问题！ final long identity = Binder.clearCallingIdentity(); try &#123; for (int i = 0; i &lt; repCbs.size(); i++) &#123; try &#123; //【6.1】触发 callback 的 opChanged 回调！ repCbs.get(i).mCallback.opChanged(code, uid, packageName); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; &#125;&#125; 方法流程很简单，不多说了！ 4.1 pruneOp移除指定的 Op！123456789101112131415161718192021222324private void pruneOp(Op op, int uid, String packageName) &#123; if (op.time == 0 &amp;&amp; op.rejectTime == 0) &#123; //【1】返回该 uid 下该 package 的所有 Op 信息！ Ops ops = getOpsRawLocked(uid, packageName, false); if (ops != null) &#123; //【2】从中移除该 op！ ops.remove(op.op); //【3】如果该 package 已经没有任何 Op，那就从所属于的 UidState 中移除相关记录！ if (ops.size() &lt;= 0) &#123; UidState uidState = ops.uidState; ArrayMap&lt;String, Ops&gt; pkgOps = uidState.pkgOps; if (pkgOps != null) &#123; pkgOps.remove(ops.packageName); if (pkgOps.isEmpty()) &#123; uidState.pkgOps = null; &#125; if (uidState.isDefault()) &#123; mUidStates.remove(uid); &#125; &#125; &#125; &#125; &#125;&#125; 整个过程很简单，不多说了！ 4.2 scheduleFastWriteLocked12345678private void scheduleFastWriteLocked() &#123; if (!mFastWriteScheduled) &#123; mWriteScheduled = true; mFastWriteScheduled = true; mHandler.removeCallbacks(mWriteRunner); mHandler.postDelayed(mWriteRunner, 10*1000); &#125;&#125; 更新本地持久化文件，执行一个 Runnable 对象 mWriteRunner，在启动篇的时候，我们看过了，这里就不再多说了！ 5 AppOpsService.startWatchingMode - 监听 op 变化startWatchingMode 用于启动一个监听，他能够监听指定 package 的指定 op 操作的模式变化，当发生会变化后，会回调 callback！12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void startWatchingMode(int op, String packageName, IAppOpsCallback callback) &#123; if (callback == null) &#123; return; &#125; synchronized (this) &#123; //【1】获得决定 op 模式的 op 操作！ op = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op; //【3.1】将 callback 转为客户端代理，封装为一个 Callback 对象，添加到 mModeWatchers 中！ Callback cb = mModeWatchers.get(callback.asBinder()); if (cb == null) &#123; // 创建了一个 Callback 对象，用于监听远程 Binder 对象的死亡布告对象 // 这样当 IAppOpsCallback.Stub 死亡后，可以停止监听！ cb = new Callback(callback); // 将 IAppOpsCallback.Stub 和 Callback 的映射保存到 mModeWatchers 中！ mModeWatchers.put(callback.asBinder(), cb); &#125; //【3.2】将要监听的 op 操作和对应的监听回调 Callback 的映射关系保存到 mOpModeWatchers 中！ if (op != AppOpsManager.OP_NONE) &#123; ArrayList&lt;Callback&gt; cbs = mOpModeWatchers.get(op); if (cbs == null) &#123; cbs = new ArrayList&lt;Callback&gt;(); mOpModeWatchers.put(op, cbs); &#125; cbs.add(cb); &#125; //【3.3】将要监听的 package 和对应的监听回调 Callback 的映射关系保存到 mPackageModeWatchers 中！ if (packageName != null) &#123; ArrayList&lt;Callback&gt; cbs = mPackageModeWatchers.get(packageName); if (cbs == null) &#123; cbs = new ArrayList&lt;Callback&gt;(); mPackageModeWatchers.put(packageName, cbs); &#125; cbs.add(cb); &#125; &#125;&#125; AppOpsService 内部有多个集合：123//【1】用与 IBinder 作和对应的回调 Callback 的映射关系！final ArrayMap&lt;IBinder, Callback&gt; mModeWatchers = new ArrayMap&lt;IBinder, Callback&gt;(); 用于保存远程回调 IAppOpsCallback.Stub 和其对应的死亡仆告对象 Callback 的映射关系，当 IAppOpsCallback.Stub 死亡后，Callback.binderDied 会被触发！！ 123456//【2】用与保存 op 操作和对应的回调 Callback 的映射关系！final SparseArray&lt;ArrayList&lt;Callback&gt;&gt; mOpModeWatchers = new SparseArray&lt;ArrayList&lt;Callback&gt;&gt;();//【3】用与保存 package 和对应的回调 Callback 的映射关系！final ArrayMap&lt;String, ArrayList&lt;Callback&gt;&gt; mPackageModeWatchers = new ArrayMap&lt;String, ArrayList&lt;Callback&gt;&gt;(); 而 mOpModeWatchers 和 mPackageModeWatchers 则是从不同的角度来建立监听关系：mOpModeWatchers 是从具体 op 的角度，而 mPackageModeWatchers 则是从 package 的角度！ 可以看到 Callback 的作用是作为远程回调的死亡仆告对象，用于停止监听。 5.1 new Callback我们来看下 Callback 对象的创建，Callback 是一个回调对象，用于处理 op 变化后的操作；同时又是一个 DeathRecipient 对象，用来监听远程 IAppOpsCallback 桩对象是否死亡！123456789101112131415161718192021public final class Callback implements DeathRecipient &#123; final IAppOpsCallback mCallback; public Callback(IAppOpsCallback callback) &#123; mCallback = callback; try &#123; //【1】将自身注册为一个死亡仆告对象！ mCallback.asBinder().linkToDeath(this, 0); &#125; catch (RemoteException e) &#123; &#125; &#125; public void unlinkToDeath() &#123; //【2】解除注册！ mCallback.asBinder().unlinkToDeath(this, 0); &#125; @Override public void binderDied() &#123; //【1.6】当远程桩对象死亡后，停止监听！ stopWatchingMode(mCallback); &#125;&#125; 当远程的 IAppOpsCallback.Stub 死亡后，AppOpsService.stopWatchingMode 会被执行！ 6 AppOpsService.stopWatchingMode - 停止 op 监听startWatchingMode 用于停止一个监听！123456789101112131415161718192021222324252627282930@Overridepublic void stopWatchingMode(IAppOpsCallback callback) &#123; if (callback == null) &#123; return; &#125; synchronized (this) &#123; //【1】从 mModeWatchers 中移除 Callback！ Callback cb = mModeWatchers.remove(callback.asBinder()); if (cb != null) &#123; // 解除死亡仆告对象注册！ cb.unlinkToDeath(); //【2】从 mOpModeWatchers 移除该 Callback！ for (int i=mOpModeWatchers.size()-1; i&gt;=0; i--) &#123; ArrayList&lt;Callback&gt; cbs = mOpModeWatchers.valueAt(i); cbs.remove(cb); if (cbs.size() &lt;= 0) &#123; mOpModeWatchers.removeAt(i); &#125; &#125; //【3】从 mPackageModeWatchers 移除该 Callback！ for (int i=mPackageModeWatchers.size()-1; i&gt;=0; i--) &#123; ArrayList&lt;Callback&gt; cbs = mPackageModeWatchers.valueAt(i); cbs.remove(cb); if (cbs.size() &lt;= 0) &#123; mPackageModeWatchers.removeAt(i); &#125; &#125; &#125; &#125;&#125; 方法很简单，就不多说了！ 7 AppOpsService.startOperation - 开始监视操作startOperation 用于监控一些长时间工作的操作，比如 Gps，像 Vibrator 等等，可以使用 startOperation 开始监视权限，使用 finishOperation 结束监视，要监视 op 前提是被监视者有权限执行 op 操作！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Overridepublic int startOperation(IBinder token, int code, int uid, String packageName) &#123; verifyIncomingUid(uid); verifyIncomingOp(code); //【1】处理包名！ String resolvedPackageName = resolvePackageName(uid, packageName); if (resolvedPackageName == null) &#123; return AppOpsManager.MODE_IGNORED; &#125; ClientState client = (ClientState)token; synchronized (this) &#123; //【*1.4.1】获得该 package 的所有 Op 信息！ Ops ops = getOpsRawLocked(uid, resolvedPackageName, true); if (ops == null) &#123; if (DEBUG) Log.d(TAG, \"startOperation: no op for code \" + code + \" uid \" + uid + \" package \" + resolvedPackageName); return AppOpsManager.MODE_ERRORED; &#125; //【*1.5】获得 code 指定的 Op 信息！ Op op = getOpLocked(ops, code, true); //【*1.4】如果该 op 在 uid 所在的用户下受限，返回 MODE_IGNORED ！ if (isOpRestrictedLocked(uid, code, resolvedPackageName)) &#123; return AppOpsManager.MODE_IGNORED; &#125; //【2】获得决定 code 指定 op 模式的 switchCode，其实是另外一个 op！ final int switchCode = AppOpsManager.opToSwitch(code); UidState uidState = ops.uidState; if (uidState.opModes != null) &#123; //【3.1】如果该 uid 有 switchCode 对应的操作，那么 uid 的 switchCode 模式优先级更高！ // 所以，最后返回的是该 uid 的 switchCode 模式！ final int uidMode = uidState.opModes.get(switchCode); if (uidMode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG) Log.d(TAG, \"noteOperation: reject #\" + op.mode + \" for code \" + switchCode + \" (\" + code + \") uid \" + uid + \" package \" + resolvedPackageName); //【3.1.1】uid 不被允许的执行该 switchCode 指定的操作， // 那么更新 code 对应 op 的 rejectTime 值！ op.rejectTime = System.currentTimeMillis(); return uidMode; &#125; &#125; //【3.2】如果该 uid 没有该 switchCode 对应的操作，那就读取 package 的 switchCode 操作模式！ // 所以，最后返回的是该 package 的 switchCode 模式！ final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op; if (switchOp.mode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG) Log.d(TAG, \"startOperation: reject #\" + op.mode + \" for code \" + switchCode + \" (\" + code + \") uid \" + uid + \" package \" + resolvedPackageName); //【3.2.1】package 不被允许的执行该 switchCode 在指定的操作， // 那么更新 code 对应 op 的 rejectTime 值！ op.rejectTime = System.currentTimeMillis(); return switchOp.mode; &#125; if (DEBUG) Log.d(TAG, \"startOperation: allowing code \" + code + \" uid \" + uid + \" package \" + resolvedPackageName); // 进入到这里，表示该操作是被允许的，这里会更新 op 的数据，然后返回 MODE_ALLOWED！ if (op.nesting == 0) &#123; op.time = System.currentTimeMillis(); // 更新允许时间 op.rejectTime = 0; // 设置拒绝时间为 0； op.duration = -1; &#125; op.nesting++; // start 次数加 1； if (client.mStartedOps != null) &#123; client.mStartedOps.add(op); // 将 start 的 Op 添加到 ClientState.mStartedOps 中监控！ &#125; return AppOpsManager.MODE_ALLOWED; &#125;&#125; startOperation 的第一个参数是一个 IBinder token，这个 token 通过如下方式获得： 1AppOpsManager.getToken(mAppOpsService) 在 AppOpsManager 中我们有分析过这个方法，其返回的是一个 ClientState 对象！ 7.1 AppOpsManager.getToken我们来看看 getToken 方法，传入的是 mService。mService 是 AppOpsManager 的成员变量：1IAppOpsService mService; 其实 mService 就是 AppOpsService 的 Proxy 对象！ 12345678910111213141516/** @hide */public static IBinder getToken(IAppOpsService service) &#123; synchronized (AppOpsManager.class) &#123; if (sToken != null) &#123; return sToken; &#125; try &#123; //【1】这里创建了一个 new Binder 对象，同时调用 AppOpsService.getToken 方法！ // 该方法会返回一个 Binder 对象，保存到 AppOpsManager.sToken 变量中; sToken = service.getToken(new Binder()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; return sToken; &#125;&#125; 这里会创建一个 Binder 对象，表示当前进程实体！ sToken 也是一个 Binder 对象：1static IBinder sToken; 用于保存 AppOpsService 返回的 ClientState 对象！ 7.2 AppOpsService.getToken通过 Binder 通信，AppOpsManager 创建的 Binder 对象，传递到了 AppOpsService.getToken 方法中！123456789101112@Overridepublic IBinder getToken(IBinder clientToken) &#123; synchronized (this) &#123; ClientState cs = mClients.get(clientToken); if (cs == null) &#123; //【×7.2.1】创建一个 ClientState 对象，保存到 mClients 中！ cs = new ClientState(clientToken); mClients.put(clientToken, cs); &#125; return cs; &#125;&#125; 这里的 ClientToken，就是前面 new Binder 创建的实体! AppOpsService 内部有一个 mClients 变量，用于保存调用方进程的 Binder 对象和对应的 ClientState 的映射关系！1final ArrayMap&lt;IBinder, ClientState&gt; mClients = new ArrayMap&lt;IBinder, ClientState&gt;(); 这个 ClientState 会记录调用方进程的 op 状态，同时其也实现了 DeathRecipient 接口，能够监听调用方进程的 Binder 对象是否死亡！ 7.2.1 new ClientState - 被监控的实体信息我们来看下 ClientState 的结构！ 1234567891011121314151617181920212223242526272829303132333435public final class ClientState extends Binder implements DeathRecipient &#123; final IBinder mAppToken; // 调用方进程 token！ final int mPid; // 调用方进程的 pid final ArrayList&lt;Op&gt; mStartedOps; // 用于保存调用方被 start 的所有 Op 操作！ public ClientState(IBinder appToken) &#123; mAppToken = appToken; // 保存调用方的 Binder 对象！ mPid = Binder.getCallingPid(); // 获得调用方进程的 pid！ if (appToken instanceof Binder) &#123; // 如果调用方传来的 appToken 是 Binder 的实例，那说明调用方就是系统进程内部的某个 client！ // 这种中情况，无需监控被 start 的 op 操作！ mStartedOps = null; &#125; else &#123; // 如果调用方处于非系统进程，那么我们需要监控其 start 的 op 操作！ mStartedOps = new ArrayList&lt;Op&gt;(); try &#123; mAppToken.linkToDeath(this, 0); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; @Override public void binderDied() &#123; // 当远程调用进程死亡后，会调用 ClientState.binderDied 方法，该方法会 finish 掉远程进程 // 持有的所有被 start 的 op 操作！ synchronized (AppOpsService.this) &#123; for (int i=mStartedOps.size()-1; i&gt;=0; i--) &#123; //【*8.1】调用了 finishOperation 方法！ finishOperationLocked(mStartedOps.get(i)); &#125; mClients.remove(mAppToken); &#125; &#125;&#125; 对于 ClientState 的分析就到这里！ 8 AppOpsService.finishOperation - 结束监视操作finishOperation 第一个参数 IBinder token，必须是 ClientState 对象！也就是说，必须在调用了 startOperation 后，finishOperation 才有意义！ 1234567891011121314151617181920212223242526272829@Overridepublic void finishOperation(IBinder token, int code, int uid, String packageName) &#123; verifyIncomingUid(uid); verifyIncomingOp(code); String resolvedPackageName = resolvePackageName(uid, packageName); if (resolvedPackageName == null) &#123; return; &#125; if (!(token instanceof ClientState)) &#123; return; &#125; ClientState client = (ClientState) token; synchronized (this) &#123; //【×1.5】获得 uid 下该 package 的 code 操作对应的 Op 实例！ Op op = getOpLocked(code, uid, resolvedPackageName, true); if (op == null) &#123; return; &#125; //【2】从 ClientState.mStartedOps 中移除该 Op！！ if (client.mStartedOps != null) &#123; if (!client.mStartedOps.remove(op)) &#123; throw new IllegalStateException(\"Operation not started: uid\" + op.uid + \" pkg=\" + op.packageName + \" op=\" + op.op); &#125; &#125; //【×8.1】调用了 finishOperationLocked 方法，继续处理！ finishOperationLocked(op); &#125;&#125; 整个方法很简单，不所说了！ 8.1 finishOperationLockedfinishOperationLocked 方法中会对该 Op 的属性进行更新！123456789101112131415161718void finishOperationLocked(Op op) &#123; if (op.nesting &lt;= 1) &#123; if (op.nesting == 1) &#123; //【1】更新该操作的执行时长！ op.duration = (int)(System.currentTimeMillis() - op.time); //【2】更新操作 op 的最新允许时间！ op.time += op.duration; &#125; else &#123; Slog.w(TAG, \"Finishing op nesting under-run: uid \" + op.uid + \" pkg \" + op.packageName + \" code \" + op.op + \" time=\" + op.time + \" duration=\" + op.duration + \" nesting=\" + op.nesting); &#125; // 将 op.nesting 置为 0，表示 Op 的 start 操作完全结束！ op.nesting = 0; &#125; else &#123; op.nesting--; // start 次数减 1； &#125;&#125; 9 AppOpsService.setUserRestriction - 设置用户限制setUserRestriction 主要是在 UserManagerService 方法中使用！ setUserRestriction 方法用于设置用户限制，他有 2 个重载函数，第一个 setUserRestriction 方法会设置所有 op 的用户限制！ 参数 IBinder token 是一个 Binder 对象，用于表示远程调用者，UserManagerService 中直接传入的是一个 new Bindler 对象！12345678910111213141516@Overridepublic void setUserRestrictions(Bundle restrictions, IBinder token, int userHandle) &#123; checkSystemUid(\"setUserRestrictions\"); / 如果不是系统进程调用会抛出异常！ Preconditions.checkNotNull(restrictions); Preconditions.checkNotNull(token); //【1】处理定义的每一个 operation，获得其所受的用户限制！ for (int i = 0; i &lt; AppOpsManager._NUM_OP; i++) &#123; String restriction = AppOpsManager.opToRestriction(i); // 如果该 op 确实会受到用户限制，继续处理！ if (restriction != null) &#123; //【×9.1】调用了 setUserRestrictionNoCheck 方法，进一步设置用户限制！ setUserRestrictionNoCheck(i, restrictions.getBoolean(restriction, false), token, userHandle, null); &#125; &#125;&#125; 第二个 setUserRestriction 方法，第一个方法会设置指定 op 是否受到用户限制，同时额外传入了一个 String[] exceptionPackages，表示白名单，在该白名单中的 package 可以不受用户限制：1234567891011121314151617181920212223@Overridepublic void setUserRestriction(int code, boolean restricted, IBinder token, int userHandle, String[] exceptionPackages) &#123; //【1】当不是当前进程调用，强制校验是否有 MANAGE_APP_OPS_RESTRICTIONS 权限！ if (Binder.getCallingPid() != Process.myPid()) &#123; mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS, Binder.getCallingPid(), Binder.getCallingUid(), null); &#125; //【2】如果是跨用户调用，要校验是否有 INTERACT_ACROSS_USERS_FULL 和 INTERACT_ACROSS_USERS 权限！ if (userHandle != UserHandle.getCallingUserId()) &#123; if (mContext.checkCallingOrSelfPermission(Manifest.permission .INTERACT_ACROSS_USERS_FULL ) != PackageManager.PERMISSION_GRANTED &amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission .INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) &#123; throw new SecurityException(\"Need INTERACT_ACROSS_USERS_FULL or\" + \" INTERACT_ACROSS_USERS to interact cross user \"); &#125; &#125; verifyIncomingOp(code); Preconditions.checkNotNull(token); //【×9.1】调用了 setUserRestrictionNoCheck 方法，进一步设置用户限制！ setUserRestrictionNoCheck(code, restricted, token, userHandle, exceptionPackages);&#125; 9.1 setUserRestrictionNoCheck参数 boolean restricted 表示是否限制，为 true 的话，表示打开限制！ 这里的 token 来自 UserManagerService 中： 1private static final IBinder mUserRestriconToken = new Binder(); 本质上是一个 Binder 对象！！12345678910111213141516171819202122232425262728293031private void setUserRestrictionNoCheck(int code, boolean restricted, IBinder token, int userHandle, String[] exceptionPackages) &#123; boolean notifyChange = false; synchronized (AppOpsService.this) &#123; //【×9.2】从 mOpUserRestrictions 获得 IBinder 对应的 ClientRestrictionState 对象！ // 如果没有，就会创建一个新的实例，加入 mOpUserRestrictions！ ClientRestrictionState restrictionState = mOpUserRestrictions.get(token); if (restrictionState == null) &#123; try &#123; restrictionState = new ClientRestrictionState(token); &#125; catch (RemoteException e) &#123; return; &#125; mOpUserRestrictions.put(token, restrictionState); &#125; //【×9.3】设置用户限制，如果有 op 的限制发生了变化，或者不受限制白名单发生了变化！ if (restrictionState.setRestriction(code, restricted, exceptionPackages, userHandle)) &#123; notifyChange = true; &#125; //【×9.3.1】如果该 bindler 对应的 ClientRestrictionState 恢复了默认状态，那就移除！ if (restrictionState.isDefault()) &#123; mOpUserRestrictions.remove(token); restrictionState.destroy(); &#125; &#125; //【×9.4】通知所有的监听者，该操作的用户限制状态发生了变化！ if (notifyChange) &#123; notifyWatchersOfChange(code); &#125;&#125; AppOpsService 有一个 mOpUserRestrictions 的哈希表，用与保存所有的用于限制信息！1private final ArrayMap&lt;IBinder, ClientRestrictionState&gt; mOpUserRestrictions = new ArrayMap&lt;&gt;(); 9.2 new ClientRestrictionState当第一次设置用户限制时，会创建 ClientRestrictionState 对象。保存用户限制状态！12345678910111213141516171819202122232425262728293031323334353637private final class ClientRestrictionState implements DeathRecipient &#123; private final IBinder token; SparseArray&lt;boolean[]&gt; perUserRestrictions; // 见下面； SparseArray&lt;String[]&gt; perUserExcludedPackages; // 见下面； public ClientRestrictionState(IBinder token) throws RemoteException &#123; //【1】绑定远程进程的 Binder 对象！ token.linkToDeath(this, 0); this.token = token; &#125; @Override public void binderDied() &#123; synchronized (AppOpsService.this) &#123; //【2】从 mOpUserRestrictions 中该 token 相应关系，解除了用户限制！ mOpUserRestrictions.remove(token); if (perUserRestrictions == null) &#123; return; &#125; final int userCount = perUserRestrictions.size(); for (int i = 0; i &lt; userCount; i++) &#123; final boolean[] restrictions = perUserRestrictions.valueAt(i); final int restrictionCount = restrictions.length; for (int j = 0; j &lt; restrictionCount; j++) &#123; //【1】如果有 op 之前是开启了用户限制，那么需要通知所有监听 op 状态变化的回调 //【1.9.4】调用了 notifyWatchersOfChange 方法！ if (restrictions[j]) &#123; final int changedCode = j; mHandler.post(() -&gt; notifyWatchersOfChange(changedCode)); &#125; &#125; &#125; destroy(); &#125; &#125;&#125; ClientRestrictionState 实现了 DeathRecipient 接口，当和其绑定的远程 Binder 对象死亡后会触发其 binderDied 方法！ perUserRestrictions 是一个 SparseArray，下标为 userId，而 SparseArray[i] 则是一个 boolean[] 数组，该数组长度为 AppOpsManager._NUM_OP 表示在 userId 下，每个 op 的限制情况，为 true 表示限制，为 false 表示不限制！ perUserExcludedPackages 也是一个 SparseArray，下标为 userId，而 SparseArray[i] 则是一个 String[] 数组，该数字保存白名单，在该名单中的应用不会受到用户限制！ 当 token 对应的远程 Binder 对象死亡后，会触发 ClientRestrictionState.binderDied 方法 9.3 ClientRestrictionState.setRestriction设置用户限制，restricted 表示是否限制！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public boolean setRestriction(int code, boolean restricted, String[] excludedPackages, int userId) &#123; boolean changed = false; if (perUserRestrictions == null &amp;&amp; restricted) &#123; perUserRestrictions = new SparseArray&lt;&gt;(); &#125; if (perUserRestrictions != null) &#123; //【1】获得 userId 下，所有 op 的限制情况！ boolean[] userRestrictions = perUserRestrictions.get(userId); if (userRestrictions == null &amp;&amp; restricted) &#123; //【1.1】如果 userRestrictions 为 null，且当前要设置为限制，那就会初始化 userRestrictions // 为一个 AppOpsManager._NUM_OP 大小的数组，添加到 perUserRestrictions 中！ userRestrictions = new boolean[AppOpsManager._NUM_OP]; perUserRestrictions.put(userId, userRestrictions); &#125; //【2】尝试更新 userRestrictions[code] 的值，userRestrictions[code] 表示的是 op 的限制状态！ // 只有当限制状态变化时，才会更新！ if (userRestrictions != null &amp;&amp; userRestrictions[code] != restricted) &#123; // 更新 userRestrictions[code]； userRestrictions[code] = restricted; //【×9.3.1】如果本次是取消用户限制，并且 userId 下的所有的 op 都是不开启限制的！ // 那么从 perUserRestrictions 中移除该 userId 的记录！ if (!restricted &amp;&amp; isDefault(userRestrictions)) &#123; perUserRestrictions.remove(userId); userRestrictions = null; &#125; changed = true; // 表示发生了更新！ &#125; //【3】userRestrictions 不为 null，说明在该 userId 下对某些 op 进行了用户限制！ if (userRestrictions != null) &#123; final boolean noExcludedPackages = ArrayUtils.isEmpty(excludedPackages); if (perUserExcludedPackages == null &amp;&amp; !noExcludedPackages) &#123; //【3.1】如果本次指定了白名单，并且 perUserExcludedPackages 为 null // 那么会进行初始化； perUserExcludedPackages = new SparseArray&lt;&gt;(); &#125; //【3.2】本次指定的白名单 excludedPackages 和该 userId 下已有的名单不一样！ // 如果本次未指定白名单，那就移除该 userId 下已有的名单； // 如果本次指定了白名单，那就更新该 userId 下已有的名单； if (perUserExcludedPackages != null &amp;&amp; !Arrays.equals(excludedPackages, perUserExcludedPackages.get(userId))) &#123; if (noExcludedPackages) &#123; perUserExcludedPackages.remove(userId); if (perUserExcludedPackages.size() &lt;= 0) &#123; perUserExcludedPackages = null; &#125; &#125; else &#123; perUserExcludedPackages.put(userId, excludedPackages); &#125; //【3.1】名单更新了，设置 changed 为 true！ changed = true; &#125; &#125; &#125; return changed;&#125; 继续分析！ 9.3.1 ClientRestrictionState.isDefault有两个 default 方法：123public boolean isDefault() &#123; return perUserRestrictions == null || perUserRestrictions.size() &lt;= 0;&#125; 无参数 isDefault 方法用来判断该 ClientRestrictionState 对象是否是默认状态！ 1234567891011private boolean isDefault(boolean[] array) &#123; if (ArrayUtils.isEmpty(array)) &#123; return true; &#125; for (boolean value : array) &#123; if (value) &#123; return false; &#125; &#125; return true;&#125; 一参数 isDefault 方法用来判断指定 ClientRestrictionState.perUserRestrictions 中指定 userId 下的用户限制是否是默认状态！ 9.4 notifyWatchersOfChange当用户限制状态发生变化后，AppOpsService 会调用 notifyWatchersOfChange 通知所有监听 op 变化的监听者！ int code 参数表示用户限制状态发生变化的 op code！ 123456789101112131415161718192021222324252627private void notifyWatchersOfChange(int code) &#123; final ArrayList&lt;Callback&gt; clonedCallbacks; //【1】从 mOpModeWatchers 中获得该 op 变化后需要出发的回调列表！ synchronized (this) &#123; ArrayList&lt;Callback&gt; callbacks = mOpModeWatchers.get(code); if (callbacks == null) &#123; return; &#125; clonedCallbacks = new ArrayList&lt;&gt;(callbacks); &#125; final long identity = Binder.clearCallingIdentity(); try &#123; final int callbackCount = clonedCallbacks.size(); for (int i = 0; i &lt; callbackCount; i++) &#123; Callback callback = clonedCallbacks.get(i); try &#123; //【2】执行回调的 opChanged 方法！ callback.mCallback.opChanged(code, -1, null); &#125; catch (RemoteException e) &#123; Log.w(TAG, \"Error dispatching op op change\", e); &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125;&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AppOps应用操作管理","slug":"AndroidFramework源码分析/AppOps应用操作管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AppOps应用操作管理/"}],"tags":[{"name":"AppOps应用操作管理","slug":"AppOps应用操作管理","permalink":"https://coolqi.top/tags/AppOps应用操作管理/"}]},{"title":"Permission第 5 篇 - grantPermission 权限授予","slug":"Permission5-grantPermission","date":"2017-08-25T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/08/25/Permission5-grantPermission/","link":"","permalink":"https://coolqi.top/2017/08/25/Permission5-grantPermission/","excerpt":"","text":"[TOC] 0 综述基于 Android 7.1.1 源码，分析系统的权限管理机制！ 本片文章总结一下权限授予的相关接口。 对于 dangrous 权限，应用程序需要显式的弹出弹窗，让用户主动的选择。当用户撤销或者授予时，会主动的调用！ 但是对于 normal permission，siginature permission 以及 uri permission 都是无需弹窗申请的！ 那么我们来看下系统中有那些和其相关的接口！ 1 grantPermission - ContextImpl在 ContextImpl 中提供了一个 grantUriPermission 方法： 1.1 grantUriPermission该方法由于是在 ContextImpl 暴露的，所以应用程序可以通过该方法 grant uri permission 给其他应用程序： 1234567891011@Overridepublic void grantUriPermission(String toPackage, Uri uri, int modeFlags) &#123; try &#123; //【*2.1】继续授予： ActivityManagerNative.getDefault().grantUriPermission( mMainThread.getApplicationThread(), toPackage, ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri)); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 不多说了! 2 grantPermission - ActivityManagerServiceActivityManagerService 内部提供了一些和 uri permission 相关的接口： 2.1 grantUriPermission授予一个 uri permisson 给 target package，这个方法授予的 permission 是一个 global permisson； 因为其在调用 grantUriPermissionLocked 时传入的 UriPermissionOwner owner 为 null； 1234567891011121314151617181920212223242526272829@Overridepublic void grantUriPermission(IApplicationThread caller, String targetPkg, Uri uri, final int modeFlags, int userId) &#123; enforceNotIsolatedCaller(\"grantUriPermission\"); //【*2.1.1】创建了一个 GrantUri 对象！ GrantUri grantUri = new GrantUri(userId, uri, false); synchronized(this) &#123; final ProcessRecord r = getRecordForAppLocked(caller); if (r == null) &#123; throw new SecurityException(\"Unable to find app for caller \" + caller + \" when granting permission to uri \" + grantUri); &#125; if (targetPkg == null) &#123; throw new IllegalArgumentException(\"null target\"); &#125; if (grantUri == null) &#123; throw new IllegalArgumentException(\"null uri\"); &#125; //【1】强制检查下 intent 的 flags 标志位！ Preconditions.checkFlagsArgument(modeFlags, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION); //【*2.2】调用了另外一个方法！ grantUriPermissionLocked(r.uid, targetPkg, grantUri, modeFlags, null, UserHandle.getUserId(r.uid)); &#125;&#125; 2.1.1 new GrantUriGrantUri 实例是对 uri 信息的简单封装： 12345678910public static class GrantUri &#123; public final int sourceUserId; public final Uri uri; public boolean prefix; public GrantUri(int sourceUserId, Uri uri, boolean prefix) &#123; this.sourceUserId = sourceUserId; this.uri = uri; this.prefix = prefix; &#125; 2.1.2 跨进程调用ContextImpl 的 grantUriPermission 可以跨进程调用该方法： ActivityManagerProxy 123456789101112131415public void grantUriPermission(IApplicationThread caller, String targetPkg, Uri uri, int mode, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller.asBinder()); data.writeString(targetPkg); uri.writeToParcel(data, 0); data.writeInt(mode); data.writeInt(userId); mRemote.transact(GRANT_URI_PERMISSION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; ActivityManagerNative 123456789101112case GRANT_URI_PERMISSION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String targetPkg = data.readString(); Uri uri = Uri.CREATOR.createFromParcel(data); int mode = data.readInt(); int userId = data.readInt(); grantUriPermission(app, targetPkg, uri, mode, userId); reply.writeNoException(); return true;&#125; 2.2 grantUriPermissionLocked - 内部调用该方法的特点是，系统在调用时，会持有 AMS 大锁，所以此时系统进程的其他需要 AMS 大锁的线程会等待： 12345678910111213141516171819202122void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, UriPermissionOwner owner, int targetUserId) &#123; if (targetPkg == null) &#123; throw new NullPointerException(\"targetPkg\"); &#125; int targetUid; final IPackageManager pm = AppGlobals.getPackageManager(); try &#123; targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, targetUserId); &#125; catch (RemoteException ex) &#123; return; &#125; //【1】检查是否需要授予 uri 权限， targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags, targetUid); if (targetUid &lt; 0) &#123; return; &#125; //【*2.3】调用了另外一个方法！ grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags, owner);&#125; 这里调用了 checkGrantUriPermissionLocked 方法，检查是否需要授予 uri 权限！ checkGrantUriPermissionLocked 方法会判断是否已经有 uri 权限，以及发送包含 uri 的 intent 程序是否有权限访问 uri 等等！！ 只有发送方对 uri 有权限，接收者才能被授予权限！！ 2.2.1 调用时机 第二个是在 1.1 grantUriPermission 中调用的； 第二个是在 1.6 grantUriPermissionFromOwner 中调用的； 该方法也是一个内部方法！ 2.3 grantUriPermissionUncheckedLocked - 内部调用，核心接口这个方法不会做一些 check 操作，所以最好不要直接调用，默认发送方对 uri 是有权限的： 12345678910111213141516171819202122232425262728void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri, final int modeFlags, UriPermissionOwner owner) &#123; //【1】这个方法之前有讲过，判断是否设置了和 uri 下相关的标志位！ if (!Intent.isAccessUriMode(modeFlags)) &#123; return; &#125; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Granting \" + targetPkg + \"/\" + targetUid + \" permission to \" + grantUri); final String authority = grantUri.uri.getAuthority(); //【2】根据 uri 找到对应的 provider！ final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, MATCH_DEBUG_TRIAGED_MISSING); if (pi == null) &#123; Slog.w(TAG, \"No content provider found for grant: \" + grantUri.toSafeString()); return; &#125; //【3】判断是否仅仅匹配 uri 前缀！ if ((modeFlags &amp; Intent.FLAG_GRANT_PREFIX_URI_PERMISSION) != 0) &#123; grantUri.prefix = true; &#125; //【*2.3.1】找到已存在或者新建的 UriPermission 实例； final UriPermission perm = findOrCreateUriPermissionLocked( pi.packageName, targetPkg, targetUid, grantUri); //【*2.3.2】授予该权限； perm.grantModes(modeFlags, owner);&#125; 所以我们看到，对于 uri permission，其管理是在 AMS 中的！ 2.3.1 findOrCreateUriPermissionLocked找到一个已存在或者新建的 UriPermission 实例： 123456789101112131415161718private UriPermission findOrCreateUriPermissionLocked(String sourcePkg, String targetPkg, int targetUid, GrantUri grantUri) &#123; //【1】尝试找到 targetUid 被授予的所有 uri permission 集合 ArrayMap&lt;GrantUri, UriPermission&gt; targetUris = mGrantedUriPermissions.get(targetUid); //【2】如果没有的话，下面会做初始化工作！ if (targetUris == null) &#123; targetUris = Maps.newArrayMap(); mGrantedUriPermissions.put(targetUid, targetUris); &#125; //【*2.3.1.1】同理，创建一个新的 UriPermission！ UriPermission perm = targetUris.get(grantUri); if (perm == null) &#123; perm = new UriPermission(sourcePkg, targetPkg, targetUid, grantUri); targetUris.put(grantUri, perm); &#125; //【3】返回 UriPermission 实例！ return perm;&#125; 在 ActivityManagerService 内部是有一个 mGrantedUriPermissions 数组： 123//【1】用于保存所有已经被授予的 uri permissions；@GuardedBy(\"this\") mGrantedUriPermissions = new SparseArray&lt;ArrayMap&lt;GrantUri, UriPermission&gt;&gt;(); SparseArray 的下标是被授予 uri permission 的目标 uid，值是一个 ArrayMap&lt;GrantUri, UriPermission&gt;，保存了 uri 和对应的 UriPermission 的映射关系！ 2.3.1.1 new UriPermission创建一个更新的 UriPermission： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final class UriPermission &#123; private static final String TAG = \"UriPermission\"; public static final int STRENGTH_NONE = 0; public static final int STRENGTH_OWNED = 1; public static final int STRENGTH_GLOBAL = 2; public static final int STRENGTH_PERSISTABLE = 3; final int targetUserId; // 目标 userId； final String sourcePkg; // 源 pkg； final String targetPkg; // 目标 pkg； // 目标 uid，用于缓存 targetPkg 对应的 uid，不会被 persist； final int targetUid; final GrantUri uri; // 对应的 uri； // 允许模式，是其他四个 mode 的结合，所有的 uri permission 都要用该 mode 标志处理权限检查和授予； int modeFlags = 0; // 允许模式，当该模式被设置，表示该 uri permission 有非全局的显式 owner； int ownedModeFlags = 0; // 允许模式，当该模式被设置，表示该 uri permission 是全局 global 的； int globalModeFlags = 0; // 允许模式，当该模式被设置，表示该 uri permission 可能需要被持久化； int persistableModeFlags = 0; // 允许模式，当该模式被设置，表示该 uri permission 需要被持久化； int persistedModeFlags = 0; /** * Timestamp when &#123;@link #persistedModeFlags&#125; was first defined in * &#123;@link System#currentTimeMillis()&#125; time base. */ long persistedCreateTime = INVALID_TIME; private static final long INVALID_TIME = Long.MIN_VALUE; private ArraySet&lt;UriPermissionOwner&gt; mReadOwners; // 保存所有读权限的拥有者； private ArraySet&lt;UriPermissionOwner&gt; mWriteOwners; // 保存所有写权限的拥有者； private String stringName; UriPermission(String sourcePkg, String targetPkg, int targetUid, GrantUri uri) &#123; this.targetUserId = UserHandle.getUserId(targetUid); this.sourcePkg = sourcePkg; this.targetPkg = targetPkg; this.targetUid = targetUid; this.uri = uri; &#125; ... ... ... ...&#125; 上面只是简单的介绍了下 UriPermission 内部的一些主要的属性，后面我们遇到了具体的逻辑时再分析！ 2.3.2 UriPermission.grantModes授予 uri permission： 123456789101112131415161718192021222324252627282930313233void grantModes(int modeFlags, UriPermissionOwner owner) &#123; //【1】判断是否需要 persist 该权限！ final boolean persistable = (modeFlags &amp; Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION) != 0; //【2】只保留 modeFlags 中的 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION 位！ modeFlags &amp;= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); //【2】如果 intent 设置了 FLAG_GRANT_PERSISTABLE_URI_PERMISSION 标志位； // 说明该权限可能需要 persisit 所以设置 persistableModeFlags 标志位 if (persistable) &#123; persistableModeFlags |= modeFlags; &#125; //【3】如果 owner 为 null，那么该权限就是一个全局 uri permission！ // 设置 globalModeFlags 标志位； if (owner == null) &#123; globalModeFlags |= modeFlags; &#125; else &#123; //【4】如果传入了指定的 owner，那么该权限就不是一个全局 uri permission！ if ((modeFlags &amp; Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) &#123; //【*2.3.2.1】添加读权限的拥有者； addReadOwner(owner); &#125; if ((modeFlags &amp; Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) &#123; //【*2.3.2.2】添加写权限的拥有者； addWriteOwner(owner); &#125; &#125; //【*2.3.2.3】更新 modeFlags 标志位； updateModeFlags ();&#125; 方法流程： 首先，判断是否需要 persist，同时对传入的 modeFlags 作如下处理：1modeFlags &amp;= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); 只保留 modeFlags 中的这两位，也就是说，此时，modeFlags 要么择其一，要么二者都有； 如果 modeFlags 需要 persistable，那么设置 persistableModeFlags； 接着，判断是否指定 UriPermissionOwner： 如果没有，那么该权限就是 global 的，更新 globalModeFlags 标志位； 如果有，说明这是一个有指定 owner 的权限，那就添加到如下集合中： 12private ArraySet&lt;UriPermissionOwner&gt; mReadOwners; // 保存所有非全局读权限的拥有者private ArraySet&lt;UriPermissionOwner&gt; mWriteOwners; // 保存所有非全局写权限的拥有者 同时，更新 ownedModeFlags 的标志位（只有在初始化的 mReadOwners 和 mWriteOwners，第一次添加 owner 时) 最后，调用 updateModeFlags 更新 modeFlags 总结： 其实整个过程就是对传入的 modeFlags 的标志位进行一一拆解，然后保存到 ownedModeFlags | globalModeFlags | persistableModeFlags | persistedModeFlags 中，最后在 updateModeFlags 中，用这几个标志位更新 modeFlags； 2.3.2.1 addReadOwnerUriPermission 内部方法，，用于添加一个对该 uri 有非全局，读权限的拥有者；1234567891011121314private void addReadOwner(UriPermissionOwner owner) &#123; //【1】初始化 mReadOwners， if (mReadOwners == null) &#123; mReadOwners = Sets.newArraySet(); //【1.1】更新 ownedModeFlags 标志位； ownedModeFlags |= Intent.FLAG_GRANT_READ_URI_PERMISSION; //【*2.3.2.3】ownedModeFlags 变化了，更新 modeFlags； updateModeFlags(); &#125; //【2】建立相互引用关系！ if (mReadOwners.add(owner)) &#123; owner.addReadPermission(this); &#125;&#125; 因为 mReadOwners 默认为 null，所以如果有最开始要初始化 mReadOwners，我们可以看到： 只有在第一次初始化 mReadOwners 时，才会设置 ownedModeFlags 标志位； 以后在添加新的 owner 时，就不在处理了！ 2.3.2.2 addWriteOwnerUriPermission 内部方法，用于添加一个对该 uri 有非全局，写权限的拥有者； 1234567891011121314private void addWriteOwner(UriPermissionOwner owner) &#123; //【1】初始化 mWriteOwners， if (mWriteOwners == null) &#123; mWriteOwners = Sets.newArraySet(); //【1.1】更新 ownedModeFlags 标志位； ownedModeFlags |= Intent.FLAG_GRANT_WRITE_URI_PERMISSION; //【*2.3.2.3】ownedModeFlags 变化了，更新 modeFlags； updateModeFlags(); &#125; //【2】建立相互引用关系！ if (mWriteOwners.add(owner)) &#123; owner.addWritePermission(this); &#125;&#125; 因为 mWriteOwners 默认为 null，所以如果有最开始要初始化 mWriteOwners，我们可以看到： 只有在第一次初始化 mWriteOwners 时，才会设置 ownedModeFlags 标志位； 以后在添加新的 owner 时，就不在处理了！ 2.3.2.3 updateModeFlagsUriPermission 内部方法，更新 modeFlags 标志位； 12345678910111213private void updateModeFlags() &#123; final int oldModeFlags = modeFlags; //【1】可以看到，就是使用其他四个标志位更新 modeFlags！ modeFlags = ownedModeFlags | globalModeFlags | persistableModeFlags | persistedModeFlags; if (Log.isLoggable(TAG, Log.VERBOSE) &amp;&amp; (modeFlags != oldModeFlags)) &#123; Slog.d(TAG, \"Permission for \" + targetPkg + \" to \" + uri + \" is changing from 0x\" + Integer.toHexString(oldModeFlags) + \" to 0x\" + Integer.toHexString(modeFlags), new Throwable()); &#125;&#125; 不多说了！ 2.3.3 调用时机 第二个是在 1.2 grantUriPermissionLocked 中调用的； 第二个是在 1.5 grantUriPermissionUncheckedFromIntentLocked 中调用的； 可以看出，均是内部调用，因为该方法不做 check 所以，不建议直接调用； 2.4 grantUriPermissionFromIntentLocked通过 intent 授予 targetPkg uri permission，该方法会先去 check 看是否需要授予权限： 123456789101112void grantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, UriPermissionOwner owner, int targetUserId) &#123; //【1】检查是否需要授予权限； NeededUriGrants needed = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, intent, intent != null ? intent.getFlags() : 0, null, targetUserId); if (needed == null) &#123; //【1.1】如果不需要，那就返回！ return; &#125; //【*2.5】进一步授予 uri pemission； grantUriPermissionUncheckedFromIntentLocked(needed, owner);&#125; 2.4.1 调用时机我们来看下该方法的调用时机，框架中主要的调用均是在和 activity 启动，finish，已经结果返回相关的地方： 2.4.1.1 finishActivityResultsLocked - ActivityStack在退出一个 activity 的时候，如果我们要返回结果给启动者 activity 的时候： 123456789101112131415161718192021222324252627282930final void finishActivityResultsLocked(ActivityRecord r, int resultCode, Intent resultData) &#123; ActivityRecord resultTo = r.resultTo; if (resultTo != null) &#123; if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, \"Adding result to \" + resultTo + \" who=\" + r.resultWho + \" req=\" + r.requestCode + \" res=\" + resultCode + \" data=\" + resultData); if (resultTo.userId != r.userId) &#123; if (resultData != null) &#123; resultData.prepareToLeaveUser(r.userId); &#125; &#125; //【1】关键点，判断了下启动者 acitivty 的 uid 是否大于 0； if (r.info.applicationInfo.uid &gt; 0) &#123; //【*2.4】授予启动者 acitivty 访问 uri 的权限，传入的 callingUid 是被启动的 activity 的 uid； //【*2.4.1.3.1】获得 activity 对应的 UriPermissionsOwner； mService.grantUriPermissionFromIntentLocked(r.info.applicationInfo.uid, resultTo.packageName, resultData, resultTo.getUriPermissionsLocked(), resultTo.userId); &#125; resultTo.addResultLocked(r, r.resultWho, r.requestCode, resultCode, resultData); r.resultTo = null; &#125; else if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, \"No result destination from \" + r); r.results = null; r.pendingResults = null; r.newIntents = null; r.icicle = null;&#125; 2.4.1.2 sendActivityResultLocked - ActivityStack发送启动返回结果给 activity： 123456789101112131415161718192021222324252627void sendActivityResultLocked(int callingUid, ActivityRecord r, String resultWho, int requestCode, int resultCode, Intent data) &#123; if (callingUid &gt; 0) &#123; //【*2.4】授予 acitivty 访问 uri 的权限！ //【*2.4.1.3.1】获得 activity 对应的 UriPermissionsOwner； mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, data, r.getUriPermissionsLocked(), r.userId); &#125; if (DEBUG_RESULTS) Slog.v(TAG, \"Send activity result to \" + r + \" : who=\" + resultWho + \" req=\" + requestCode + \" res=\" + resultCode + \" data=\" + data); if (mResumedActivity == r &amp;&amp; r.app != null &amp;&amp; r.app.thread != null) &#123; try &#123; ArrayList&lt;ResultInfo&gt; list = new ArrayList&lt;ResultInfo&gt;(); list.add(new ResultInfo(resultWho, requestCode, resultCode, data)); //【1】发送启动结果！ r.app.thread.scheduleSendResult(r.appToken, list); return; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception thrown sending result to \" + r, e); &#125; &#125; r.addResultLocked(null, resultWho, requestCode, resultCode, data);&#125; 不多说了！ 2.4.1.3 deliverNewIntentLocked - ActivityRecord该方法会拉起一个 activity 的 onNewIntent 方法：12345678910111213141516171819202122232425262728293031final void deliverNewIntentLocked(int callingUid, Intent intent, String referrer) &#123; //【*2.4】授予要启动的 activity 访问 intent 中 uri 的权限！ //【*2.4.1.3.1】获得 activity 对应的 UriPermissionsOwner service.grantUriPermissionFromIntentLocked(callingUid, packageName, intent, getUriPermissionsLocked(), userId); final ReferrerIntent rintent = new ReferrerIntent(intent, referrer); boolean unsent = true; final ActivityStack stack = task.stack; final boolean isTopActivityInStack = stack != null &amp;&amp; stack.topRunningActivityLocked() == this; final boolean isTopActivityWhileSleeping = service.isSleepingLocked() &amp;&amp; isTopActivityInStack; if ((state == ActivityState.RESUMED || state == ActivityState.PAUSED || isTopActivityWhileSleeping) &amp;&amp; app != null &amp;&amp; app.thread != null) &#123; try &#123; ArrayList&lt;ReferrerIntent&gt; ar = new ArrayList&lt;&gt;(1); ar.add(rintent); //【1】拉起 onNewIntent 方法： app.thread.scheduleNewIntent( ar, appToken, state == ActivityState.PAUSED /* andPause */); unsent = false; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception thrown sending new intent to \" + this, e); &#125; catch (NullPointerException e) &#123; Slog.w(TAG, \"Exception thrown sending new intent to \" + this, e); &#125; &#125; if (unsent) &#123; addNewIntentLocked(rintent); &#125;&#125; 2.4.1.3.1 getUriPermissionsLocked同样的，ActivityRecord 内部也有一个 getUriPermissionsLocked 方法，用来获得其对应的 UriPermissionOwner 实例： 1234567UriPermissionOwner getUriPermissionsLocked() &#123; if (uriPermissions == null) &#123; //【*2.6.1.1】创建一个新的 UriPermissionOwner 实例！ uriPermissions = new UriPermissionOwner(service, this); &#125; return uriPermissions;&#125; 2.4.1.4 startActivityUnchecked - ActivityStarter在启动一个新的 acitivity 的时候： 1234567891011121314151617181920212223private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); computeLaunchingTaskFlags(); computeSourceStack(); mIntent.setFlags(mLaunchFlags); mReusedActivity = getReusableIntentActivity(); final int preferredLaunchStackId = (mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID; ... ... ... //【*2.4】授予要启动的 activity 访问 intent 中 uri 的权限！ //【*2.4.1.3.1】获得 activity 对应的 UriPermissionsOwner mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName, mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId); ... ... ... return START_SUCCESS;&#125; 不多说了！ 2.5 grantUriPermissionUncheckedFromIntentLocked通过 intent 授予 uri permission，但是该方法不会 check 是否需要授予权限，所以尽量不要直接调用这个函数； 1234567891011void grantUriPermissionUncheckedFromIntentLocked(NeededUriGrants needed, UriPermissionOwner owner) &#123; if (needed != null) &#123; for (int i=0; i&lt;needed.size(); i++) &#123; GrantUri grantUri = needed.get(i); //【*2.3】调用了 grantUriPermissionUncheckedLocked 方法，继续授予！ grantUriPermissionUncheckedLocked(needed.targetUid, needed.targetPkg, grantUri, needed.flags, owner); &#125; &#125;&#125; 首先遍历所有的 GrantUri，处理每一个 GrantUri 的授予！ 2.5.1 调用时机2.5.1.1 sendServiceArgsLocked在我们启动 Service 的时候，我们会将启动参数 StartItems 发送给 Service： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) throws TransactionTooLargeException &#123; final int N = r.pendingStarts.size(); if (N == 0) &#123; return; &#125; //【1】如果 Service 有等待处理的启动项目！ while (r.pendingStarts.size() &gt; 0) &#123; Exception caughtException = null; ServiceRecord.StartItem si = null; try &#123; si = r.pendingStarts.remove(0); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Sending arguments to: \" + r + \" \" + r.intent + \" args=\" + si.intent); if (si.intent == null &amp;&amp; N &gt; 1) &#123; continue; &#125; si.deliveredTime = SystemClock.uptimeMillis(); r.deliveredStarts.add(si); si.deliveryCount++; //【1】关键地方是在这里，如果启动项有 neededGrants，那么会授予被启动这 uri permission！ if (si.neededGrants != null) &#123; //【*2.5】授予 uri 权限！ //【*2.5.1.2】通过 StartItem 创建一个新的 UriPermissionOwner 实例！ mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants, si.getUriPermissionsLocked()); &#125; //【2】超时处理； bumpServiceExecutingLocked(r, execInFg, \"start\"); if (!oomAdjusted) &#123; oomAdjusted = true; mAm.updateOomAdjLocked(r.app); &#125; int flags = 0; if (si.deliveryCount &gt; 1) &#123; flags |= Service.START_FLAG_RETRY; &#125; if (si.doneExecutingCount &gt; 0) &#123; flags |= Service.START_FLAG_REDELIVERY; &#125; //【3】启动服务！ r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent); &#125; catch (TransactionTooLargeException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Transaction too large: intent=\" + si.intent); caughtException = e; &#125; catch (RemoteException e) &#123; // Remote process gone... we'll let the normal cleanup take care of this. if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Crashed while sending args: \" + r); caughtException = e; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Unexpected exception\", e); caughtException = e; &#125; ... ... ... ... &#125;&#125; 逻辑很简单，不多说了！ 2.5.1.2 StartItem.getUriPermissionsLocked1234567UriPermissionOwner getUriPermissionsLocked() &#123; if (uriPermissions == null) &#123; //【*2.6.1.1】新建一个 UriPermissionOwner 实例！ uriPermissions = new UriPermissionOwner(sr.ams, this); &#125; return uriPermissions;&#125; 2.6 grantUriPermissionFromOwner授予 UriPermissionOwner owner 访问 uri 的 permission，这里的 UriPermissionOwner 是通过 IBinder token 转换而来！ 1234567891011121314151617181920212223242526272829303132@Overridepublic void grantUriPermissionFromOwner(IBinder token, int fromUid, String targetPkg, Uri uri, final int modeFlags, int sourceUserId, int targetUserId) &#123; //【1】计算下 targetUserId！ targetUserId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), targetUserId, false, ALLOW_FULL_ONLY, \"grantUriPermissionFromOwner\", null); synchronized(this) &#123; //【*2.6.1.3】通过 token 找到对应的 UriPermissionOwner，如果没有就会抛出异常！ UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token); if (owner == null) &#123; throw new IllegalArgumentException(\"Unknown owner: \" + token); &#125; //【1.1】fromUid 表示该 grant 操作来自哪个 uid； // Binder.getCallingUid() 表示调用该方法的 uid，一般情况 fromUid 和 callingUid 应该是一样的； // 如果不一样，callingUid 必须是 system uid！ if (fromUid != Binder.getCallingUid()) &#123; if (Binder.getCallingUid() != Process.myUid()) &#123; throw new SecurityException(\"nice try\"); &#125; &#125; if (targetPkg == null) &#123; throw new IllegalArgumentException(\"null target\"); &#125; if (uri == null) &#123; throw new IllegalArgumentException(\"null uri\"); &#125; //【*2.2】继续处理 grant 操作！ grantUriPermissionLocked(fromUid, targetPkg, new GrantUri(sourceUserId, uri, false), modeFlags, owner, targetUserId); &#125;&#125; 可以看到，grantUriPermissionFromOwner 可以提供跨进程的支持，也就是说应用程序可以通过 grantUriPermissionFromOwner 来授予其他应用 uri 权限； 同时，我们还看到要调用该方法，必须要存在一个 UriPermissionOwner，我们去看下如何创建一个 UriPermissionOwner： 2.6.1 newUriPermissionOwner同样的，AMS 提供了一个 newUriPermissionOwner 方法，来实现创建一个新的 UriPermissionOwner，其支持跨进程调用： 12345678910@Overridepublic IBinder newUriPermissionOwner(String name) &#123; enforceNotIsolatedCaller(\"newUriPermissionOwner\"); synchronized(this) &#123; //【*2.6.1.1】创建一个新的 UriPermissionOwner； UriPermissionOwner owner = new UriPermissionOwner(this, name); //【*2.6.1.2】返回一个新的 return owner.getExternalTokenLocked(); &#125;&#125; 2.6.1.1 new UriPermissionOwner新建一个 UriPermissionOwner 实例： 1234567891011121314151617181920final class UriPermissionOwner &#123; final ActivityManagerService service; // ams 对象！ final Object owner; // 用于表示所有者， Binder externalToken; // 用于 token，跨进程的表示同一个 owner private ArraySet&lt;UriPermission&gt; mReadPerms; // 该 owner 持有的所有的 read uri permission private ArraySet&lt;UriPermission&gt; mWritePerms; // 该 owner 持有的所有的 write uri permission // 内部类，用于初始化 externalToken！ class ExternalToken extends Binder &#123; UriPermissionOwner getOwner() &#123; return UriPermissionOwner.this; &#125; &#125; UriPermissionOwner(ActivityManagerService service, Object owner) &#123; this.service = service; this.owner = owner; &#125; 2.6.1.2 getExternalTokenLocked返回 UriPermissionOwner 的 Binder 对象 token： 123456Binder getExternalTokenLocked() &#123; if (externalToken == null) &#123; externalToken = new ExternalToken(); &#125; return externalToken;&#125; 不多说了！ 2.6.1.3 fromExternalTokenUriPermissionOwner 有一个方法，通过 token 找到对应的 UriPermissionOwner 实例：123456static UriPermissionOwner fromExternalToken(IBinder token) &#123; if (token instanceof ExternalToken) &#123; return ((ExternalToken)token).getOwner(); &#125; return null;&#125; 不多说了！ 2.6.2 调用时机我们来看下该方法的具体调用，用 VoiceInteraction 举个例子！ 2.6.2.1 new VoiceInteractionSessionConnection首先，在创建 VoiceInteractionSessionConnection 时，我们为这个 ComponentName component 对应的组件创建了一个 UriPermissionOwner，并返回了其 Binder token！ 1234567891011121314151617181920212223public VoiceInteractionSessionConnection(Object lock, ComponentName component, int user, Context context, Callback callback, int callingUid, Handler handler) &#123; mLock = lock; mSessionComponentName = component; mUser = user; mContext = context; mCallback = callback; mCallingUid = callingUid; mHandler = handler; mAm = ActivityManagerNative.getDefault(); ... ... ... IBinder permOwner = null; try &#123; //【1】为这个 ComponentName component 对应的组件创建了一个 UriPermissionOwner， // 并返回了其 Binder token！ permOwner = mAm.newUriPermissionOwner(\"voicesession:\" + component.flattenToShortString()); &#125; catch (RemoteException e) &#123; Slog.w(\"voicesession\", \"AM dead\", e); &#125; mPermissionOwner = permOwner; ... ... ...&#125; 2.6.2.2 deliverSessionDataLocked - VoiceInteractionSessionConnection在 VoiceInteractionSessionConnection 的 deliverSessionDataLocked 分发语音事务是，会授予 uri permission！ 1234567891011121314151617181920212223242526272829303132private void deliverSessionDataLocked(AssistDataForActivity assistDataForActivity) &#123; Bundle assistData = assistDataForActivity.data.getBundle( VoiceInteractionSession.KEY_DATA); AssistStructure structure = assistDataForActivity.data.getParcelable( VoiceInteractionSession.KEY_STRUCTURE); AssistContent content = assistDataForActivity.data.getParcelable( VoiceInteractionSession.KEY_CONTENT); int uid = assistDataForActivity.data.getInt(Intent.EXTRA_ASSIST_UID, -1); if (uid &gt;= 0 &amp;&amp; content != null) &#123; Intent intent = content.getIntent(); if (intent != null) &#123; ClipData data = intent.getClipData(); if (data != null &amp;&amp; Intent.isAccessUriMode(intent.getFlags())) &#123; //【1】授予权限！ grantClipDataPermissions(data, intent.getFlags(), uid, mCallingUid, mSessionComponentName.getPackageName()); &#125; &#125; ClipData data = content.getClipData(); if (data != null) &#123; //【1】授予权限！ grantClipDataPermissions(data, Intent.FLAG_GRANT_READ_URI_PERMISSION, uid, mCallingUid, mSessionComponentName.getPackageName()); &#125; &#125; try &#123; mSession.handleAssist(assistData, structure, content, assistDataForActivity.activityIndex, assistDataForActivity.activityCount); &#125; catch (RemoteException e) &#123; &#125;&#125; 这里我们省略掉中间过程，大家可以请自去看源码： 1grantClipDataPermissions(...) -&gt; grantClipDataItemPermission(...) -&gt; grantUriPermission(...) 2.6.2.3 grantUriPermission - VoiceInteractionSessionConnectiongrant 指定的 uid uri permission：12345678910111213141516171819202122232425void grantUriPermission(Uri uri, int mode, int srcUid, int destUid, String destPkg) &#123; if (!\"content\".equals(uri.getScheme())) &#123; return; &#125; long ident = Binder.clearCallingIdentity(); try &#123; //【1】这里首先检查了 srcUid 是否已经有权限，这里我们在 check 的时候有讲过！ // 如果该方法不抛出异常，那就可以 grant！ mAm.checkGrantUriPermission(srcUid, null, ContentProvider.getUriWithoutUserId(uri), mode, ContentProvider.getUserIdFromUri(uri, UserHandle.getUserId(srcUid))); int sourceUserId = ContentProvider.getUserIdFromUri(uri, mUser); uri = ContentProvider.getUriWithoutUserId(uri); //【*1.6】授予 uri 权限！ mAm.grantUriPermissionFromOwner(mPermissionOwner, srcUid, destPkg, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION, sourceUserId, mUser); &#125; catch (RemoteException e) &#123; &#125; catch (SecurityException e) &#123; Slog.w(TAG, \"Can't propagate permission\", e); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 这里传入的 mPermissionOwner 是我们前面创建的 Binder token！ 2.6.3 跨进程通信ActivityManagerProxy 中提供了相关的接口： ActivityManagerProxy 123456789101112131415161718public void grantUriPermissionFromOwner(IBinder owner, int fromUid, String targetPkg, Uri uri, int mode, int sourceUserId, int targetUserId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(owner); data.writeInt(fromUid); data.writeString(targetPkg); uri.writeToParcel(data, 0); data.writeInt(mode); data.writeInt(sourceUserId); data.writeInt(targetUserId); //【1】这里我改正了错误： mRemote.transact(GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 7.1.1 的源码有一个问题： 1GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION 被写成了 GRANT_URI_PERMISSION_TRANSACTION 我个人觉得是一个错误！ ActivityManagerNative 1234567891011121314case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder owner = data.readStrongBinder(); int fromUid = data.readInt(); String targetPkg = data.readString(); Uri uri = Uri.CREATOR.createFromParcel(data); int mode = data.readInt(); int sourceUserId = data.readInt(); int targetUserId = data.readInt(); grantUriPermissionFromOwner(owner, fromUid, targetPkg, uri, mode, sourceUserId, targetUserId); reply.writeNoException(); return true;&#125; 3 grantPermission - PackageManagerService权限的授予核心接口是在 PackageManagerService 中，包括运行时和安装时权限： 3.1 grantPermissionsLPw - 权限更新时调用重新授予在更新过权限后，会再次授予应用权限，因为可能有些权限已经失效并且被移除！ 这里的 replace 为 true，由于我们是更新所有的 pacakge，所以 packageOfInterest 均为 null，参数 pkg 是需要更新权限授予信息的应用！ 该方法主要是在 updatePermissionsLPw 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace, String packageOfInterest) &#123; //【1】如果该应用的 PackageSetting 没有，那么不处理！ final PackageSetting ps = (PackageSetting) pkg.mExtras; if (ps == null) &#123; return; &#125; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"grantPermissions\"); //【2】获得该 package 的权限管理对象，此时这个权限管理对象是解析上次安装信息时恢复的！ // 我们将其保存到 origPermissions 中，作为原始数据！ PermissionsState permissionsState = ps.getPermissionsState(); PermissionsState origPermissions = permissionsState; final int[] currentUserIds = UserManagerService.getInstance().getUserIds(); boolean runtimePermissionsRevoked = false; int[] changedRuntimePermissionUserIds = EMPTY_INT_ARRAY; boolean changedInstallPermission = false; //【3】如果 replace 的值为 true，进入这里！ if (replace) &#123; // 设置 installPermissionsFixed 为 true，因为下面会对权限信息调整！ ps.installPermissionsFixed = false; if (!ps.isSharedUser()) &#123; //【3.1】如果该 package 不是共享 uid 的，那就重置 permissionsState，但是会将 // 原始信息 copy到 origPermissions 中！ origPermissions = new PermissionsState(permissionsState); permissionsState.reset(); &#125; else &#123; //【3.2】如果该 package 是共享 uid 的，那么我们会拒绝那些不用的共享 uid 相关权限信息！ changedRuntimePermissionUserIds = revokeUnusedSharedUserPermissionsLPw( ps.sharedUser, UserManagerService.getInstance().getUserIds()); if (!ArrayUtils.isEmpty(changedRuntimePermissionUserIds)) &#123; runtimePermissionsRevoked = true; &#125; &#125; &#125; permissionsState.setGlobalGids(mGlobalGids); //【4】处理该 package 请求的所有权限！ final int N = pkg.requestedPermissions.size(); for (int i=0; i &lt; N; i++) &#123; final String name = pkg.requestedPermissions.get(i); final BasePermission bp = mSettings.mPermissions.get(name); if (DEBUG_INSTALL) &#123; Log.i(TAG, \"Package \" + pkg.packageName + \" checking \" + name + \": \" + bp); &#125; //【4.1】如果该权限没有定义，那么跳过！！ if (bp == null || bp.packageSetting == null) &#123; if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Unknown permission \" + name + \" in package \" + pkg.packageName); &#125; continue; &#125; final String perm = bp.name; boolean allowedSig = false; int grant = GRANT_DENIED; // 用于保存每个权限的授予情况！ //【4.2】如果申请的权限设置了 PROTECTION_FLAG_APPOP 标志位， // 我们会将其添加到 mAppOpPermissionPackages 进行监控！ if ((bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; ArraySet&lt;String&gt; pkgs = mAppOpPermissionPackages.get(bp.name); if (pkgs == null) &#123; pkgs = new ArraySet&lt;&gt;(); mAppOpPermissionPackages.put(bp.name, pkgs); &#125; pkgs.add(pkg.packageName); &#125; //【4.3】计算权限的基本类型，并判断应用是否支持运行时权限！！！ final int level = bp.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE; final boolean appSupportsRuntimePermissions = pkg.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.M; //【4.4】根据权限的基本类型，判断权限的授予情况！！ switch (level) &#123; case PermissionInfo.PROTECTION_NORMAL: &#123; //【4.4.1】基本类型为 normal，为安装时权限，默认授予！ grant = GRANT_INSTALL; &#125; break; case PermissionInfo.PROTECTION_DANGEROUS: &#123; //【4.4.2】基本类型为 dangerous，那么我们要分不同的情况！！ if (!appSupportsRuntimePermissions &amp;&amp; !Build.PERMISSIONS_REVIEW_REQUIRED) &#123; //【4.4.2.1】如果 legacy apps，同时也不需要在组件启动之前重新 review 权限 // 说明应用的 targetSDKVersion &lt; 23 是 legacy apps，那么运行时权限视为安装时权限； grant = GRANT_INSTALL; &#125; else if (origPermissions.hasInstallPermission(bp.name)) &#123; //【4.4.2.2】如果应用支持安装是权限，或者需要在组件启动之前重新 review 权限 // 并且该运行时权限之前是属于安装时权限，那么就要升级为运行时权限（系统升级会出现） grant = GRANT_UPGRADE; &#125; else if (mPromoteSystemApps &amp;&amp; isSystemApp(ps) &amp;&amp; mExistingSystemPackages.contains(ps.name)) &#123; //【4.4.2.3】如果是从 API 22 升级上来的话，对于 Promote System Apps， // 那么安装时权限就要升级为运行时权限； grant = GRANT_UPGRADE; &#125; else &#123; //【4.4.2.4】其他情况，直接视为安装时权限！ grant = GRANT_RUNTIME; &#125; &#125; break; case PermissionInfo.PROTECTION_SIGNATURE: &#123; //【4.4.3】基本类型为 signature 的权限，需要校验签名！！ //【*1.2.2-important】校验签名是否匹配，如果是的话，是为安装时权限！ allowedSig = grantSignaturePermission(perm, pkg, bp, origPermissions); if (allowedSig) &#123; // 如果签名校验通过，直接视为安装时权限！ grant = GRANT_INSTALL; &#125; &#125; break; &#125; if (DEBUG_INSTALL) &#123; Log.i(TAG, \"Package \" + pkg.packageName + \" granting \" + perm); &#125; //【4.5】处理授予情况，如果授予情况不是拒绝 GRANT_DENIED，进入 IF 分支； // 如果授予情况是拒绝 GRANT_DENIED，进入 ELSE 分支！ if (grant != GRANT_DENIED) &#123; if (!isSystemApp(ps) &amp;&amp; ps.installPermissionsFixed) &#123; //【4.5.1】如果这是一个已经被安装了的非系统的应用，同时本次申请的权限之前不属于安装时权限 // 除非该权限属于 new platform permission 不然的话，我们是不会授予他这个权限的； if (!allowedSig &amp;&amp; !origPermissions.hasInstallPermission(perm)) &#123; if (!isNewPlatformPermissionForPackage(perm, pkg)) &#123; grant = GRANT_DENIED; &#125; &#125; &#125; //【4.5.2】处理权限的授予状态！ switch (grant) &#123; case GRANT_INSTALL: &#123; // 处理安装时权限； //【4.5.2.1.1】首先，判断该权限之前是否是运行时权限，如果是的话，那就要撤销之前的授予！ for (int userId : UserManagerService.getInstance().getUserIds()) &#123; if (origPermissions.getRuntimePermissionState( bp.name, userId) != null) &#123; // 撤销权限，并取消所有的标志位； origPermissions.revokeRuntimePermission(bp, userId); origPermissions.updatePermissionFlags(bp, userId, PackageManager.MASK_PERMISSION_FLAGS, 0); // 将运行时权限授予状态发生变化的 userId 记录下来，后面用于持久化数据！ changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; //【4.5.2.1.2】授予安装时权限； if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; changedInstallPermission = true; &#125; &#125; break; case GRANT_RUNTIME: &#123; // 处理运行时权限； //【4.5.2.1.3】授予之前被授予的运行时权限； for (int userId : UserManagerService.getInstance().getUserIds()) &#123; //【4.5.2.1.3.1】获得每个 userId 下的该运行时权限对象和其 flags； PermissionState permissionState = origPermissions .getRuntimePermissionState(bp.name, userId); int flags = permissionState != null ? permissionState.getFlags() : 0; //【4.5.2.1.3.2】如果本次授予的权限是已经申请的，那么我们就再次授予！ if (origPermissions.hasRuntimePermission(bp.name, userId)) &#123; //【4.5.2.1.3.2.1】授予运行时权限，如果失败的话，意味着本次无法授予，那就更新 // changedRuntimePermissionUserIds 列表； if (permissionsState.grantRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; //【4.5.2.1.3.2.2】如果应用支持运行时权限，该权限之前是需要 review 的 // 那么这里会取消 review 的标志位！ if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; appSupportsRuntimePermissions &amp;&amp; (flags &amp; PackageManager .FLAG_PERMISSION_REVIEW_REQUIRED) != 0) &#123; flags &amp;= ~PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED; // 标志位变了，那就更新 changedRuntimePermissionUserIds 列表； changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; else if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; !appSupportsRuntimePermissions) &#123; //【4.5.2.1.3.2】如果应用不支持运行时权限，但是系统需要权限 review // 每一个被授予的新的运行时权限，都要被 review！ // 如果是系统权限，强制增加 FLAG_PERMISSION_REVIEW_REQUIRED 标志位 if (PLATFORM_PACKAGE_NAME.equals(bp.sourcePackage)) &#123; if ((flags &amp; FLAG_PERMISSION_REVIEW_REQUIRED) == 0) &#123; flags |= FLAG_PERMISSION_REVIEW_REQUIRED; // 标志位变了，那就更新 changedRuntimePermissionUserIds 列表； changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; // 授予这个新的运行时权限，如果授予失败，更新 changedRuntimePermissionUserIds 列表； if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; //【4.5.2.1.3.2.1】更新权限的 flags！ permissionsState.updatePermissionFlags(bp, userId, flags, flags); &#125; &#125; break; case GRANT_UPGRADE: &#123; // 处理安装时权限升级为运行时权限 //【4.5.2.1.4】授予安装时升级为运行时的权限； // 获得权限管理对象和 flags； PermissionState permissionState = origPermissions .getInstallPermissionState(bp.name); final int flags = permissionState != null ? permissionState.getFlags() : 0; //【4.5.2.1.4.1】撤销之前的安装时权限，并清空 flags； if (origPermissions.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; origPermissions.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0); changedInstallPermission = true; &#125; //【4.5.2.1.4.2】如果该权限没有设置 FLAG_PERMISSION_REVOKE_ON_UPGRADE， // 表示在升级后可以授予，那么我们就授予运行时权限； if ((flags &amp; PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) &#123; for (int userId : currentUserIds) &#123; if (permissionsState.grantRuntimePermission(bp, userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; // 将旧的 flags 更新到运行时权限； permissionsState.updatePermissionFlags(bp, userId, flags, flags); // 标志位变了，那就更新 changedRuntimePermissionUserIds 列表； changedRuntimePermissionUserIds = ArrayUtils.appendInt( changedRuntimePermissionUserIds, userId); &#125; &#125; &#125; &#125; break; default: &#123; if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Not granting permission \" + perm + \" to package \" + pkg.packageName + \" because it was previously installed without\"); &#125; &#125; break; &#125; &#125; else &#123; //【4.6】处理撤销情况，撤销该权限，同时清空所有的标志位； if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; // 清空标志位； permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, 0); changedInstallPermission = true; Slog.i(TAG, \"Un-granting permission \" + perm + \" from package \" + pkg.packageName + \" (protectionLevel=\" + bp.protectionLevel + \" flags=0x\" + Integer.toHexString(pkg.applicationInfo.flags) + \")\"); &#125; else if ((bp.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) == 0) &#123; //【4.6.1】如果撤销失败，但是该权限和一个 appOp 相关联，这种情况可以不处理。因为 // 对于这类权限，我们不处理，因为我们会通过 appOps 进行控制，通过 ui 给用户选择； if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, \"Not granting permission \" + perm + \" to package \" + pkg.packageName + \" (protectionLevel=\" + bp.protectionLevel + \" flags=0x\" + Integer.toHexString(pkg.applicationInfo.flags) + \")\"); &#125; &#125; &#125; &#125; if ((changedInstallPermission || replace) &amp;&amp; !ps.installPermissionsFixed &amp;&amp; !isSystemApp(ps) || isUpdatedSystemApp(ps))&#123; // 这是我们第一次听说过这个包，所以我们现在选择的权限是固定的，直到明确更改为止。 // 没看懂这段逻辑... ps.installPermissionsFixed = true; &#125; //【5】持久化变化调整后的运行时权限数据！ for (int userId : changedRuntimePermissionUserIds) &#123; mSettings.writeRuntimePermissionsForUserLPr(userId, runtimePermissionsRevoked); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);&#125; 3.2.1 grantSignaturePermission - Signature 权限授予核心接口grantSignaturePermission 方法用于判断签名是否能校验通过，我们在这里先忽略掉签名校验的过程，假设要么校验成功，要么校验失败！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private boolean grantSignaturePermission(String perm, PackageParser.Package pkg, BasePermission bp, PermissionsState origPermissions) &#123; boolean allowed; //【1】判断应用的签名和权限定义者签名或者平台签名是否匹配！ allowed = (compareSignatures( bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH) || (compareSignatures(mPlatformPackage.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH); //【2】如果和权限定义者签名或者平台签名不匹配，并且该权限是 PRIVILEGED 的，进行进一步的判断！ if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) &#123; if (isSystemApp(pkg)) &#123; // 对于 PRIVILEGED 类型的权限，首先必须是系统应用！ //【2.1】如果该应用是一个被更新过的系统应用，那么只有更新前的旧 apk 被授予了这个权限， // 新的 apk 才能被授予这个权限！ if (pkg.isUpdatedSystemApp()) &#123; // 获得更新前的安装数据(system)！ final PackageSetting sysPs = mSettings .getDisabledSystemPkgLPr(pkg.packageName); if (sysPs != null &amp;&amp; sysPs.getPermissionsState().hasInstallPermission(perm)) &#123; //【2.1.1】如果更新前，其已经被授予了该权限，并且其是一个特权应用， // 那么本次也允许授予！！ if (sysPs.isPrivileged()) &#123; allowed = true; &#125; &#125; else &#123; //【2.1.2】如果更新前，并没有被授予该权限，该权限是更新后新申请的权限！ // 那就要看之前是否有请求该权限，只有请求了该权限，才允许授予； if (sysPs != null &amp;&amp; sysPs.pkg != null &amp;&amp; sysPs.isPrivileged()) &#123; for (int j = 0; j &lt; sysPs.pkg.requestedPermissions.size(); j++) &#123; if (perm.equals(sysPs.pkg.requestedPermissions.get(j))) &#123; allowed = true; break; &#125; &#125; &#125; // 此外，如果系统映像上的特权父包或其父包任何子代请求特权权限，则更新的子包也可以获得该许可。 if (pkg.parentPackage != null) &#123; final PackageSetting disabledSysParentPs = mSettings .getDisabledSystemPkgLPr(pkg.parentPackage.packageName); if (disabledSysParentPs != null &amp;&amp; disabledSysParentPs.pkg != null &amp;&amp; disabledSysParentPs.isPrivileged()) &#123; if (isPackageRequestingPermission(disabledSysParentPs.pkg, perm)) &#123; allowed = true; &#125; else if (disabledSysParentPs.pkg.childPackages != null) &#123; final int count = disabledSysParentPs.pkg.childPackages.size(); for (int i = 0; i &lt; count; i++) &#123; PackageParser.Package disabledSysChildPkg = disabledSysParentPs.pkg.childPackages.get(i); if (isPackageRequestingPermission(disabledSysChildPkg, perm)) &#123; allowed = true; break; &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; //【2.2】如果该应用是一个没有被更新过的系统应用，那就要判读其是否是特权应用！ allowed = isPrivilegedApp(pkg); &#125; &#125; &#125; //【3】经过了上面的判断，依然不允许，接着进行下一步的判断，下面会根据额外的标志位继续判断！ if (!allowed) &#123; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_PRE23) != 0 &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123; //【3.1】PROTECTION_FLAG_PRE23 指定此权限会自动授予低于 M（在引入运行时权限之前）的 API 级别的应用程序。 // 如果应用的 targetSdkVersion 是小于 M 的，那么我们授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0 &amp;&amp; pkg.packageName.equals(mRequiredInstallerPackage)) &#123; //【3.2】PROTECTION_FLAG_INSTALLER 指定此权限可以自动授予包软件应用程序。 // 而此时的 apk 就是 packageInstaller，那么授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0 &amp;&amp; pkg.packageName.equals(mRequiredVerifierPackage)) &#123; //【3.3】PROTECTION_FLAG_INSTALLER 指定此权限可以被自动授予给验证软件包的系统应用程序。 // 而此时的 apk 就是 VerifierPackage，那么授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0 &amp;&amp; isSystemApp(pkg)) &#123; //【3.4】PROTECTION_FLAG_PREINSTALLED 指定此权限可以自动授予 system 分区预先安装的任何应用程序 // 而此时的 apk 就是 system app，那么授予他签名权限！ allowed = true; &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) &#123; //【3.4】PROTECTION_FLAG_DEVELOPMENT 指定此权限可以授予（可选）给开发应用程序 // 而上一次应用是被授予了这个权限，那么一次也不被授予 allowed = origPermissions.hasInstallPermission(perm); &#125; if (!allowed &amp;&amp; (bp.protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_SETUP) != 0 &amp;&amp; pkg.packageName.equals(mSetupWizardPackage)) &#123; //【3.5】PROTECTION_FLAG_SETUP 指定此权限可以被自动授予给开机向导应用程序 // 而此时的 apk 就是开机向导，那么授予他签名权限！. allowed = true; &#125; &#125; return allowed;&#125; 可以看到，这里对 Signature 类型的权限做了详细的处理！ 3.2 grantRuntimePermission - 运行时权限授予核心接口授予运行时权限，其主要是在应用运行的时候，显示一个伪弹窗的 acitivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@Overridepublic void grantRuntimePermission(String packageName, String name, final int userId) &#123; if (!sUserManager.exists(userId)) &#123; //【1】校验用户是否存在！ Log.e(TAG, \"No such user:\" + userId); return; &#125; mContext.enforceCallingOrSelfPermission( //【2】校验调用者是否有相应权限； android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS, \"grantRuntimePermission\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, true /* checkShell */, \"grantRuntimePermission\"); final int uid; final SettingBase sb; synchronized (mPackages) &#123; final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; //【3】package 不存在，异常！ throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; //【4】权限不存在，异常！ throw new IllegalArgumentException(\"Unknown permission: \" + name); &#125; enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp); //【5】如果 targetSdkVersion 小于 M，那么是不支持运行时权限的，我们在安装的时候会自动授予运行时权限！ if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M &amp;&amp; bp.isRuntime()) &#123; return; &#125; uid = UserHandle.getUid(userId, pkg.applicationInfo.uid); sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; //【6】升级包未安装过，异常！ throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; final PermissionsState permissionsState = sb.getPermissionsState(); //【7】获得权限的 flags 标志位，如果该权限是被 system fix 的，我们不能操作这样的权限！ final int flags = permissionsState.getPermissionFlags(name, userId); if ((flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) &#123; throw new SecurityException(\"Cannot grant system fixed permission \" + name + \" for package \" + packageName); &#125; //【8】如果该权限是开发者权限，特殊处理，作为安装时权限，立刻授予！ // 授予成功，会触发 Settings.writeLPr 方法，该方法会更新多个文件 // 包括 pacakges.xml，pacakges.list，runtime-permissions.xml 等文件！ if (bp.isDevelopment()) &#123; if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; scheduleWriteSettingsLocked(); &#125; return; &#125; if (pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123; Slog.w(TAG, \"Cannot grant runtime permission to a legacy app\"); return; &#125; //【9】授予权限，并处理授予结果！！ final int result = permissionsState.grantRuntimePermission(bp, userId); switch (result) &#123; case PermissionsState.PERMISSION_OPERATION_FAILURE: &#123; //【9.1】授予失败，可能应用已经被授予权限了！ return; &#125; case PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED: &#123; //【9.2】授予成功，但是应用映射的 gids 变化了！ final int appId = UserHandle.getAppId(pkg.applicationInfo.uid); mHandler.post(new Runnable() &#123; @Override public void run() &#123; //【9.2.1】杀掉应用的进程，应用后续会重启！ killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED); &#125; &#125;); &#125; break; &#125; mOnPermissionChangeListeners.onPermissionsChanged(uid); //【10】更新 runtime-permissions.xml 文件！ mSettings.writeRuntimePermissionsForUserLPr(userId, false); &#125; // Only need to do this if user is initialized. Otherwise it's a new user // and there are no processes running as the user yet and there's no need // to make an expensive call to remount processes for the changed permissions. if (READ_EXTERNAL_STORAGE.equals(name) || WRITE_EXTERNAL_STORAGE.equals(name)) &#123; final long token = Binder.clearCallingIdentity(); try &#123; if (sUserManager.isInitialized(userId)) &#123; MountServiceInternal mountServiceInternal = LocalServices.getService( MountServiceInternal.class); mountServiceInternal.onExternalStoragePolicyChanged(uid, packageName); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125;&#125; 3.3 grantRequestedRuntimePermissions - 安装时授予运行时权限在签名分析 pkg install 的时候，我们有看 handlePackagePostInstall 方法： 123456789101112131415private void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, String[] grantedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) &#123; if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; // Send the removed broadcasts if (res.removedInfo != null) &#123; res.removedInfo.sendPackageRemovedBroadcasts(killApp); &#125; //【1】如果我们指定了在安装时授予其运行时权限，那么就会调用 grantRequestedRuntimePermissions 方法： if (grantPermissions &amp;&amp; res.pkg.applicationInfo.targetSdkVersion &gt;= Build.VERSION_CODES.M) &#123; grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions); &#125; 继续来分析： 123456789101112private void grantRequestedRuntimePermissions(PackageParser.Package pkg, int[] userIds, String[] grantedPermissions) &#123; //【3.3.1】授予每个设备用户下的运行时权限！ for (int userId : userIds) &#123; grantRequestedRuntimePermissionsForUser(pkg, userId, grantedPermissions); &#125; // We could have touched GID membership, so flush out packages.list synchronized (mPackages) &#123; mSettings.writePackageListLPr(); &#125;&#125; 继续跟踪： 3.3.1 grantRequestedRuntimePermissionsForUser下面的代码很简单： 123456789101112131415161718192021222324252627282930private void grantRequestedRuntimePermissionsForUser(PackageParser.Package pkg, int userId, String[] grantedPermissions) &#123; SettingBase sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; return; &#125; PermissionsState permissionsState = sb.getPermissionsState(); //【1】对于 installer 他没有权限去改变 SYSTEM_FIXED 和 POLICY_FIXED 的权限状态！ final int immutableFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED | PackageManager.FLAG_PERMISSION_POLICY_FIXED; for (String permission : pkg.requestedPermissions) &#123; final BasePermission bp; synchronized (mPackages) &#123; bp = mSettings.mPermissions.get(permission); &#125; if (bp != null &amp;&amp; (bp.isRuntime() || bp.isDevelopment()) &amp;&amp; (grantedPermissions == null || ArrayUtils.contains(grantedPermissions, permission))) &#123; final int flags = permissionsState.getPermissionFlags(permission, userId); //【2】禁止修改！ if ((flags &amp; immutableFlags) == 0) &#123; //【×3.2】授予运行时权限！ grantRuntimePermission(pkg.packageName, permission, userId); &#125; &#125; &#125;&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Permission权限管理","slug":"AndroidFramework源码分析/Permission权限管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Permission权限管理/"}],"tags":[{"name":"Permission权限管理","slug":"Permission权限管理","permalink":"https://coolqi.top/tags/Permission权限管理/"}]},{"title":"AlarmManager第 3 篇 - trigger Alarm 流程分析","slug":"AlarmManager3-triggerAlarm","date":"2017-08-15T12:46:25.000Z","updated":"2018-11-20T17:42:40.000Z","comments":true,"path":"2017/08/15/AlarmManager3-triggerAlarm/","link":"","permalink":"https://coolqi.top/2017/08/15/AlarmManager3-triggerAlarm/","excerpt":"","text":"[toc] 基于 Android7.1.1 源码，分析 AlarmManagerService 的架构和逻辑，本篇文章来分析下 trigger Alarm 的流程！ 0 回顾在上一篇 set Alarm 文章中，我们知道, set 方法会调用 AlarmMS.rescheduleKernelAlarmsLocked 方法来设置下一个 alarm！ 该方法用于设置下一个 Alarm！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void rescheduleKernelAlarmsLocked() &#123; long nextNonWakeup = 0; // 设置最早的 ELAPSED_REALTIME_WAKEUP 类型的 alarm！ if (mAlarmBatches.size() &gt; 0) &#123; //【3.4.4.1】从 mAlarmBatches 中找到第一个包含 wake up 类型 alarm 的 Batch！ final Batch firstWakeup = findFirstWakeupBatchLocked(); //【2】从 mAlarmBatches 中找到第一个的 Batch！ final Batch firstBatch = mAlarmBatches.get(0); //【3】如果 firstWakeup 不为 null，且 firstWakeup 中的开始触发时间 start，不等于 mNextWakeup！ // 那就要更新 mNextWakeup，调整下一个 wake up alarm 的触发时间！ if (firstWakeup != null &amp;&amp; mNextWakeup != firstWakeup.start) &#123; // 更新 mNextWakeup 和 mLastWakeupSet！ mNextWakeup = firstWakeup.start; mLastWakeupSet = SystemClock.elapsedRealtime(); //【3.4.4.2】设置下一个要触发的 wake up 类型的 alarm！ setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start); &#125; //【4】如果 firstBatch 不等于 firstWakeup，说明 firstBatch 中不包含 wake up 类型的 alarm！ // 那就设置下一个非 wake up alarm 的触发时间！ if (firstBatch != firstWakeup) &#123; nextNonWakeup = firstBatch.start; &#125; &#125; // mPendingNonWakeupAlarms 不为 empty，说明系统中存在处于等待状态的 no wakeup 类型的 alarm！ // 那么如果 nextNonWakeup 为 0，或者 mNextNonWakeupDeliveryTime 小于 nextNonWakeup！ // 那么更新 nextNonWakeup 为 mNextNonWakeupDeliveryTime 的值！ if (mPendingNonWakeupAlarms.size() &gt; 0) &#123; if (nextNonWakeup == 0 || mNextNonWakeupDeliveryTime &lt; nextNonWakeup) &#123; nextNonWakeup = mNextNonWakeupDeliveryTime; &#125; &#125; // 最后如果，本次计算的下一个要触发的 no wake up alarm 的时间和之前的不同，更新 mNextNonWakeup 的值 // 并设置下一个 no wake up 的 alarm！ if (nextNonWakeup != 0 &amp;&amp; mNextNonWakeup != nextNonWakeup) &#123; mNextNonWakeup = nextNonWakeup; //【3.4.4.2】设置下一个要触发的 no wake up 类型的 alarm！ setLocked(ELAPSED_REALTIME, nextNonWakeup); &#125;&#125; 下一个要执行的 wake up alarm 和 no wake up alarm 最终会通过 setLocked 方法进行设置！ 12345678910111213141516171819202122private void setLocked(int type, long when) &#123; if (mNativeData != 0) &#123; // The kernel never triggers alarms with negative wakeup times // so we ensure they are positive. long alarmSeconds, alarmNanoseconds; if (when &lt; 0) &#123; alarmSeconds = 0; alarmNanoseconds = 0; &#125; else &#123; alarmSeconds = when / 1000; alarmNanoseconds = (when % 1000) * 1000 * 1000; &#125; set(mNativeData, type, alarmSeconds, alarmNanoseconds); &#125; else &#123; Message msg = Message.obtain(); msg.what = ALARM_EVENT; mHandler.removeMessages(ALARM_EVENT); mHandler.sendMessageAtTime(msg, when); &#125;&#125; setLocked 中提供了 2 种方法来设置 Alarm： 一种是通过 Alarm 驱动来设置 Alarm，同时启动一个 AlarmThread 来监听 Alarm 驱动的消息，处理触发的 Alarm！ 一种是通过自身的消息循环来设置和触发 Alarm； 正常情况下，Alarm 驱动是存在的，那么，我们先来看看正常情况！ 1 AlarmThread.runAlarmThread 内部有一个 while 循环，条件为 true，通过不断循环，来处理来自 Kernel 的消息，下面我们来看卡 AlarmThread 的 run 方法！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public void run() &#123; ArrayList&lt;Alarm&gt; triggerList = new ArrayList&lt;Alarm&gt;(); while (true) &#123; //【*1.1】waitForAlarm 最终会调用 native 层的方法，是同步阻塞的，如果该方法没有返回值 // 那 AlarmThread 将一直阻塞在这里，当其返回，说明有 alarm 触发了！ int result = waitForAlarm(mNativeData); mLastWakeup = SystemClock.elapsedRealtime(); // 更新上一次唤醒的时间 //【1】清空 triggerList，triggerList 用于保存已经触发的 Alarm！ triggerList.clear(); final long nowRTC = System.currentTimeMillis(); final long nowELAPSED = SystemClock.elapsedRealtime(); //【2】如果只是时间发生改变，而不是闹钟触发，进入这里！ if ((result &amp; TIME_CHANGED_MASK) != 0) &#123; //【2.1】由于内核内部的一些微小调整，其会返回给系统一些实际上并不是闹钟出发引起的时间变化通知 // 这里会过滤掉这些时间变化！ final long lastTimeChangeClockTime; final long expectedClockTime; synchronized (mLock) &#123; lastTimeChangeClockTime = mLastTimeChangeClockTime; expectedClockTime = lastTimeChangeClockTime + (nowELAPSED - mLastTimeChangeRealtime); &#125; if (lastTimeChangeClockTime == 0 || nowRTC &lt; (expectedClockTime-500) || nowRTC &gt; (expectedClockTime+500)) &#123; // The change is by at least +/- 500 ms (or this is the first change), // let's do it! // if (DEBUG_BATCH) &#123; Slog.v(TAG, \"Time changed notification from kernel; rebatching\"); &#125; // 从管理列表 mAlarmBatches 移除时间改变和日期改变的 Alarm 对象！ // 该方法也会触发 rebatch 过程！ removeImpl(mTimeTickSender); removeImpl(mDateChangeSender); // 重新对系统中所有的 Alarm 进行排序和批处理！ rebatchAllAlarms(); // 设置下一个发送 Intent.ACTION_TIME_TICK 和 Intent.ACTION_DATE_CHANGED 的 Alarm！ // 该方法会调用 setImpl 方法！ mClockReceiver.scheduleTimeTickEvent(); mClockReceiver.scheduleDateChangedEvent(); synchronized (mLock) &#123; // 记录时间改变的次数，同时记录上一次发生时间改变的时间点！ mNumTimeChanged++; mLastTimeChangeClockTime = nowRTC; mLastTimeChangeRealtime = nowELAPSED; &#125; // 发送时间改变的广播给所有的 userId! Intent intent = new Intent(Intent.ACTION_TIME_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); getContext().sendBroadcastAsUser(intent, UserHandle.ALL); // The world has changed on us, so we need to re-evaluate alarms // regardless of whether the kernel has told us one went off. result |= IS_WAKEUP_MASK; &#125; &#125; //【4】闹钟触发，会进入这个流程！ if (result != TIME_CHANGED_MASK) &#123; // If this was anything besides just a time change, then figure what if // anything to do about alarms. synchronized (mLock) &#123; if (localLOGV) Slog.v( TAG, \"Checking for alarms... rtc=\" + nowRTC + \", elapsed=\" + nowELAPSED); if (WAKEUP_STATS) &#123; if ((result &amp; IS_WAKEUP_MASK) != 0) &#123; long newEarliest = nowRTC - RECENT_WAKEUP_PERIOD; int n = 0; for (WakeupEvent event : mRecentWakeups) &#123; if (event.when &gt; newEarliest) break; n++; // number of now-stale entries at the list head &#125; for (int i = 0; i &lt; n; i++) &#123; mRecentWakeups.remove(); &#125; recordWakeupAlarms(mAlarmBatches, nowELAPSED, nowRTC); &#125; &#125; //【4.1】收集那些触发时间已经到了的 Alarm，该函数返回值表示是否有 wake up 类型的 alarm！！ // triggerAlarmsLocked 方法会将触发列表中的 alarm 排序！ boolean hasWakeup = triggerAlarmsLocked(triggerList, nowELAPSED, nowRTC); //【4.2】如果 hasWakeup 为 false，说明无 wake up 类型的 alarm ， // 如果 checkAllowNonWakeupDelayLocked 返回 true，说明该列表中的 alarm 要延迟发送！ if (!hasWakeup &amp;&amp; checkAllowNonWakeupDelayLocked(nowELAPSED)) &#123; // 如果没有 no wake up alarms 要分发，如果此时处于 screen off 或者其他一些特殊的情况！ // 我们会将 triggerList 添加到延迟列表 mPendingNonWakeupAlarms 中延迟分发！ if (mPendingNonWakeupAlarms.size() == 0) &#123; // 如果 mPendingNonWakeupAlarms 为 empty，初始化延迟分发时间！ mStartCurrentDelayTime = nowELAPSED; // 设置 delay 的时间点！ mNextNonWakeupDeliveryTime = nowELAPSED + ((currentNonWakeupFuzzLocked(nowELAPSED)*3)/2); &#125; mPendingNonWakeupAlarms.addAll(triggerList); // 添加到延迟集合中 mNumDelayedAlarms += triggerList.size(); // 统计延迟分发的 Alarm 个数 //【4.2.1】rebatch 所有的 Alarm，更新下一个 AlarmClock！ rescheduleKernelAlarmsLocked(); updateNextAlarmClockLocked(); &#125; else &#123; //【4.3】进入这里的，就开始要分发 Alarm 了！ // now deliver the alarm intents; if there are pending non-wakeup // alarms, we need to merge them in to the list. note we don't // just deliver them first because we generally want non-wakeup // alarms delivered after wakeup alarms. //【4.3.1】rebatch 所有的 Alarm，更新下一个 AlarmClock！ rescheduleKernelAlarmsLocked(); updateNextAlarmClockLocked(); // 如果 mPendingNonWakeupAlarms 不为 empty，那么，我们也要分发这些 Alarm！ if (mPendingNonWakeupAlarms.size() &gt; 0) &#123; //【1.2.1】这里对 mPendingNonWakeupAlarms 列表中的 Alarm 计算优先级！ // 然后将 alarms 添加到 triggerList 中，然后在进行排序！ calculateDeliveryPriorities(mPendingNonWakeupAlarms); triggerList.addAll(mPendingNonWakeupAlarms); Collections.sort(triggerList, mAlarmDispatchComparator); final long thisDelayTime = nowELAPSED - mStartCurrentDelayTime; mTotalDelayTime += thisDelayTime; // 累计延迟的时间段； if (mMaxDelayTime &lt; thisDelayTime) &#123; mMaxDelayTime = thisDelayTime; // 最大延迟的时间段； &#125; mPendingNonWakeupAlarms.clear(); // 清空 mPendingNonWakeupAlarms！ &#125; // 分发本次要触发的 Alarm！ deliverAlarmsLocked(triggerList, nowELAPSED); &#125; &#125; &#125; else &#123; // Just in case -- even though no wakeup flag was set, make sure // we have updated the kernel to the next alarm time. synchronized (mLock) &#123; rescheduleKernelAlarmsLocked(); &#125; &#125; &#125;&#125; waitForAlarm 会调用 static jint android_server_AlarmManagerService_waitForAlarm 这个 native 方法，对 /dev/alarm 驱动文件进行操作！ 1.1 AlarmMS.waitForAlarmwaitForAlarm 方法用来等待 Alarm 驱动的返回，其实阻塞性的！ 1private native int waitForAlarm(long nativeData); 该方法最后会调用 navtive 的方法，位于 frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp 文件中： 12 1.2 AlarmMS.triggerAlarmsLockedtriggerAlarmsLocked 方法用于分发那些触发时间已到的 Alarm！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132boolean triggerAlarmsLocked(ArrayList&lt;Alarm&gt; triggerList, final long nowELAPSED, final long nowRTC) &#123; boolean hasWakeup = false; //【1】mAlarmBatches 中的 Batch 都是按照触发时间点升序排列， // 接下来会遍历 mAlarmBatches，分发那些触发时间已到的 Alarm！ while (mAlarmBatches.size() &gt; 0) &#123; // 获得触发事件最早的 Batch！ Batch batch = mAlarmBatches.get(0); // 如果时间最早的 Batch 的触发时间还没到，那就不作任何操作，退出循环！ if (batch.start &gt; nowELAPSED) &#123; // Everything else is scheduled for the future break; &#125; //【1.1】能够走到这里，说明 batch 的触发时间已经到了，那么我们要移除这个 Batch，防止重复分发！ mAlarmBatches.remove(0); //【1.2】分发这个 Batch 中的所有的 Alarm！ final int N = batch.size(); for (int i = 0; i &lt; N; i++) &#123; Alarm alarm = batch.get(i); //【1.2.1】如果 Alarm 设置了 AlarmManager.FLAG_ALLOW_WHILE_IDLE 标志位， // 说明其在系统处于 idle 状态也可以触发！ if ((alarm.flags&amp;AlarmManager.FLAG_ALLOW_WHILE_IDLE) != 0) &#123; // 对于 allow while idle 类型的 Alarm，我们要检验其触发时间，看其距离上次触发事件是否 // 不小于规定的最小时间间隔：mAllowWhileIdleMinTime long lastTime = mLastAllowWhileIdleDispatch.get(alarm.uid, 0); long minTime = lastTime + mAllowWhileIdleMinTime; // 如果 nowELAPSED &lt; minTime，说明虽然该 alarm 的触发时间到了，但是时间小于规定的最小时间 // 那么，按照最小时间重新设置 alarm！ if (nowELAPSED &lt; minTime) &#123; // 设置 alarm 的触发时间为 minTime，最大触发时间至少为 minTime！ alarm.whenElapsed = minTime; if (alarm.maxWhenElapsed &lt; minTime) &#123; alarm.maxWhenElapsed = minTime; &#125; if (RECORD_DEVICE_IDLE_ALARMS) &#123; IdleDispatchEntry ent = new IdleDispatchEntry(); ent.uid = alarm.uid; ent.pkg = alarm.operation.getCreatorPackage(); ent.tag = alarm.operation.getTag(\"\"); ent.op = \"RESCHEDULE\"; ent.elapsedRealtime = nowELAPSED; ent.argRealtime = lastTime; mAllowWhileIdleDispatches.add(ent); &#125; // 按照最小时间，重新设置 alarm，然后继续处理下一个 alarm！！ setImplLocked(alarm, true, false); continue; &#125; &#125; //【1.2.2】进入这里，说明 Alarm 此时需要被分发！ alarm.count = 1; // Alarm 闹钟的触发次数初始化为 1； triggerList.add(alarm); // 将这个 alarm 添加到 triggerList 中去！ // 如果 alarm 是 wake from idle 类型的，在 event log 文件中打印出来，方便调试！ if ((alarm.flags&amp;AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) &#123; EventLogTags.writeDeviceIdleWakeFromIdle(mPendingIdleUntil != null ? 1 : 0, alarm.statsTag); &#125; //【1.2.3】如果此时要触发的 Alarm 是 mPendingIdleUntil，那么说明系统要从 idle 状态恢复了，那么 // 设置 mPendingIdleUntil 为 null，同时 rebatch 其他的 alarm，恢复因为 idle 状态而处于等待状态的 alarm if (mPendingIdleUntil == alarm) &#123; mPendingIdleUntil = null; rebatchAllAlarmsLocked(false); restorePendingWhileIdleAlarmsLocked(); &#125; //【1.2.3】如果此时要触发的 Alarm 是 mNextWakeFromIdle，说明该 alarm 会将系统从 idle 状态唤醒！ // 那么设置 mNextWakeFromIdle 为 null，同时 rebatch 其他的 alarm！ if (mNextWakeFromIdle == alarm) &#123; mNextWakeFromIdle = null; rebatchAllAlarmsLocked(false); &#125; //【1.2.3】如果 alarm.repeatInterval 大于 0，说明该 alarm 是一个 repeating alarm！ // 我们计算下一次触发的时间，再次设置 alarm！ // 这里要注意一点，因为系统可能进入休眠或者关机，alarm 可能错过了多个周期时间的触发！ if (alarm.repeatInterval &gt; 0) &#123; // 这里是计算，我们可能因为系统休眠或者关机，错过了几个周期，当然该结果是可以为 0 的； // 我们需要把错过的触发次数也统计进去！！ alarm.count += (nowELAPSED - alarm.whenElapsed) / alarm.repeatInterval; // 计算下次的触发时间！ final long delta = alarm.count * alarm.repeatInterval; final long nextElapsed = alarm.whenElapsed + delta; // 设置 alarm！ setImplLocked(alarm.type, alarm.when + delta, nextElapsed, alarm.windowLength, maxTriggerTime(nowELAPSED, nextElapsed, alarm.repeatInterval), alarm.repeatInterval, alarm.operation, null, null, alarm.flags, true, alarm.workSource, alarm.alarmClock, alarm.uid, alarm.packageName); &#125; // 如果该 alarm 是 wake up 类型的，hasWakeup 为 true！ if (alarm.wakeup) &#123; hasWakeup = true; &#125; // 该 alarm 是通过 setAlarmClock 方法设置的，当该 alarm 触发后，我们会计算下一个 AlarmClock if (alarm.alarmClock != null) &#123; mNextAlarmClockMayChange = true; &#125; &#125; &#125; // 用于记录分发次数。每分发一个新的 alarm 集，该值会加 1； mCurrentSeq++; //【2】计算分发优先级！ calculateDeliveryPriorities(triggerList); //【3】对要分发的 alarm 进行排序，先依据优先级，优先级相同，按照时间升序排序！ Collections.sort(triggerList, mAlarmDispatchComparator); if (localLOGV) &#123; for (int i=0; i&lt;triggerList.size(); i++) &#123; Slog.v(TAG, \"Triggering alarm #\" + i + \": \" + triggerList.get(i)); &#125; &#125; return hasWakeup;&#125; 1.2.1 AlarmMS.calculateDeliveryPrioritiescalculateDeliveryPriorities 方法用于计算分发的优先级！参数 alarms 表示所有需要触发的 alarm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void calculateDeliveryPriorities(ArrayList&lt;Alarm&gt; alarms) &#123; final int N = alarms.size(); for (int i = 0; i &lt; N; i++) &#123; Alarm a = alarms.get(i); //【1】计算 alarm 优先级！ final int alarmPrio; if (a.operation != null &amp;&amp; Intent.ACTION_TIME_TICK.equals(a.operation.getIntent().getAction())) &#123; //【1.1】如果该 alarm 是 Intent.ACTION_TIME_TICK，那么优先级为 PRIO_TICK alarmPrio = PRIO_TICK; &#125; else if (a.wakeup) &#123; //【1.2】如果该 alarm 是 wake up 类型的，那么优先级为 PRIO_WAKEUP alarmPrio = PRIO_WAKEUP; &#125; else &#123; //【1.3】其他类型的 alarm 优先级为 PRIO_NORMAL alarmPrio = PRIO_NORMAL; &#125; //【2】获得 alarm 的优先级对象，和其发送者 packageName PriorityClass packagePrio = a.priorityClass; String alarmPackage = (a.operation != null) ? a.operation.getCreatorPackage() : a.packageName; // 如果 packagePrio 为 null，那就优先在缓存 mPriorities 中找，找不到；创建新的，并加入到缓存中！ if (packagePrio == null) packagePrio = mPriorities.get(alarmPackage); if (packagePrio == null) &#123; packagePrio = a.priorityClass = new PriorityClass(); // lowest prio &amp; stale sequence mPriorities.put(alarmPackage, packagePrio); &#125; // 更新 alarm 的 priorityClass 优先级对象! a.priorityClass = packagePrio; //【3】更新 alarm 优先级！ if (packagePrio.seq != mCurrentSeq) &#123; //【3.1】如果 packagePrio.seq 不等于 mCurrentSeq，说明在本次的发送列表中，这是来自这个包的第一个 Alarm // 那么执行初始化操作！ packagePrio.priority = alarmPrio; packagePrio.seq = mCurrentSeq; &#125; else &#123; //【3.2】如果 packagePrio.seq == mCurrentSeq，说明在发送列表中，有来自同一个 package 的多个 Alarm。 // 那就调整优先级，规则： TICK &lt; WAKEUP &lt; NORMAL if (alarmPrio &lt; packagePrio.priority) &#123; packagePrio.priority = alarmPrio; &#125; &#125; &#125;&#125; 这里设置到了如下的几种 alarm 优先级，值越小，优先级越高！ 123static final int PRIO_TICK = 0; // 时间改变!static final int PRIO_WAKEUP = 1; // 唤醒!static final int PRIO_NORMAL = 2; // 正常! 同时有一个集合 mPriorities，用于保存发送者的 package 和其对应 Alarm 优先级： 123456789101112final class PriorityClass &#123; int seq; int priority; PriorityClass() &#123; seq = mCurrentSeq - 1; priority = PRIO_NORMAL; &#125;&#125;final HashMap&lt;String, PriorityClass&gt; mPriorities = new HashMap&lt;&gt;();int mCurrentSeq = 0; PriorityClass 用于表示优先级别！ 1.2.2 Collections.sort(triggerList, mAlarmDispatchComparator)接下来，对 triggerList 进行排序，这里用到了一个比较器 mAlarmDispatchComparator！ 123456789101112131415161718192021final Comparator&lt;Alarm&gt; mAlarmDispatchComparator = new Comparator&lt;Alarm&gt;() &#123; @Override public int compare(Alarm lhs, Alarm rhs) &#123; // priority class trumps everything. TICK &lt; WAKEUP &lt; NORMAL if (lhs.priorityClass.priority &lt; rhs.priorityClass.priority) &#123; return -1; &#125; else if (lhs.priorityClass.priority &gt; rhs.priorityClass.priority) &#123; return 1; &#125; // within each class, sort by nominal delivery time if (lhs.whenElapsed &lt; rhs.whenElapsed) &#123; return -1; &#125; else if (lhs.whenElapsed &gt; rhs.whenElapsed) &#123; return 1; &#125; // same priority class + same target delivery time return 0; &#125;&#125;; 首先按照优先级从高到低进行排序，然后按照触发时间从小到大进行排序，如果优先级和时间相同，保持先后顺序不变！ 1.3 AlarmMS.checkAllowNonWakeupDelayLocked该方法用于检查是否需要延迟 no wake up 类型的 Alarm 的分发！ 123456789101112131415161718boolean checkAllowNonWakeupDelayLocked(long nowELAPSED) &#123; //【1】如果此时处于亮屏状态，无需延迟！ if (mInteractive) &#123; return false; &#125; //【2】如果此时处于熄屏状态，但是我们还没有分发过任何 Alarm，无需延迟！ if (mLastAlarmDeliveryTime &lt;= 0) &#123; return false; &#125; //【3】如果此时系统中有等待中的 no wake up 类型的 alarm，但是其分发时间 mNextNonWakeupDeliveryTime 已经过去了 // 那就无需延迟（看注释是为了解决一个在 Looper 中卡住的 bugs）！ if (mPendingNonWakeupAlarms.size() &gt; 0 &amp;&amp; mNextNonWakeupDeliveryTime &lt; nowELAPSED) &#123; return false; &#125; // 计算当前时间距离上次分发的时间间隔，比较其和熄屏时间间隔的大小！！ long timeSinceLast = nowELAPSED - mLastAlarmDeliveryTime; return timeSinceLast &lt;= currentNonWakeupFuzzLocked(nowELAPSED);&#125; 规则如下： 如果此时处于亮屏状态，无需延迟！ 如果此时处于熄屏状态，但是我们还没有分发过任何 Alarm，无需延迟！ 如果此时处于熄屏状态，我们之前也分发过 Alarm，那么如果 此时系统中有等待中的 no wake up 类型的 alarm，其分发时间已经过去了，无需延迟； 如果上面三个条件都不满足，那么如果距离上次分发 Alarm 的时间超过了 no wake up 类型 alarm 的最大延迟分发时间，那就无需延迟！ currentNonWakeupFuzzLocked 用来计算了 no wake up 类型 alarm 的最大延迟分发时间 1.3.1 AlarmMS.currentNonWakeupFuzzLocked该方法是用来计算熄屏幕的时长，然后根据时常，来确定 no wake up 类型的 alarm 的延迟触发的最长时间！！ 1234567891011121314long currentNonWakeupFuzzLocked(long nowELAPSED) &#123; long timeSinceOn = nowELAPSED - mNonInteractiveStartTime; //【1】如果熄屏时间小于 5 mins，那么延迟最多 2 mins if (timeSinceOn &lt; 5*60*1000) &#123; return 2*60*1000; //【2】如果熄屏时间小于 30 mins，那么延迟最多 15 mins &#125; else if (timeSinceOn &lt; 30*60*1000) &#123; return 15*60*1000; &#125; else &#123; //【3】其他情况，那么延迟最多 60 mins return 60*60*1000; &#125;&#125; 不多说了！ 1.4 AlarmMS.deliverAlarmsLockeddeliverAlarmsLocked 方法用于分发已经出发的 Alarm！ 123456789101112131415161718192021222324252627282930void deliverAlarmsLocked(ArrayList&lt;Alarm&gt; triggerList, long nowELAPSED) &#123; //【1】设置上一次的发送时间点！ mLastAlarmDeliveryTime = nowELAPSED; //【2】遍历 triggerList，分发 Alarm！ for (int i=0; i&lt;triggerList.size(); i++) &#123; Alarm alarm = triggerList.get(i); //【2.1】判断该 Alarm 是否是 allow while idle 的！ final boolean allowWhileIdle = (alarm.flags&amp;AlarmManager.FLAG_ALLOW_WHILE_IDLE) != 0; try &#123; if (localLOGV) &#123; Slog.v(TAG, \"sending alarm \" + alarm); &#125; if (RECORD_ALARMS_IN_HISTORY) &#123; // 用于系统记录信息！ if (alarm.workSource != null &amp;&amp; alarm.workSource.size() &gt; 0) &#123; for (int wi=0; wi&lt;alarm.workSource.size(); wi++) &#123; ActivityManagerNative.noteAlarmStart( alarm.operation, alarm.workSource.get(wi), alarm.statsTag); &#125; &#125; else &#123; ActivityManagerNative.noteAlarmStart( alarm.operation, alarm.uid, alarm.statsTag); &#125; &#125; //【1.5】调用 DeliveryTracker 的 deliverLocked 方法，分发 Alarm！ mDeliveryTracker.deliverLocked(alarm, nowELAPSED, allowWhileIdle); &#125; catch (RuntimeException e) &#123; Slog.w(TAG, \"Failure sending alarm.\", e); &#125; &#125;&#125; 接下来，我们去看看 DeliveryTracker： 1.5 DeliveryTracker.deliverLockedDeliveryTracker 用以监控和跟踪 Alarm 的分发！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124class DeliveryTracker extends IAlarmCompleteListener.Stub implements PendingIntent.OnFinished &#123; ... ... ... ... /** * Deliver an alarm and set up the post-delivery handling appropriately */ public void deliverLocked(Alarm alarm, long nowELAPSED, boolean allowWhileIdle) &#123; //【1】针对于 Alarm 的触发方式，做不同的处理！ if (alarm.operation != null) &#123; //【1.1】如果是通过 PendingIntent 触发，进入这里，这里会调用 PendingIntent 的 send 方法，将 Intent // 发送给接收方！ try &#123; alarm.operation.send(getContext(), 0, mBackgroundIntent.putExtra( Intent.EXTRA_ALARM_COUNT, alarm.count), mDeliveryTracker, mHandler, null, allowWhileIdle ? mIdleOptions : null); &#125; catch (PendingIntent.CanceledException e) &#123; // 如果 send 出现异常，那么如果是重复闹钟，那就将这个 Alarm 移除；否则，直接 return 掉！ if (alarm.repeatInterval &gt; 0) &#123; removeImpl(alarm.operation); // 该方法会 rebatch 其他的 A &#125; return; &#125; &#125; else &#123; //【1.2】如果是通过 onAlarmListener 接收，进入这里，调用其 doAlarm 方法！ try &#123; if (DEBUG_LISTENER_CALLBACK) &#123; Slog.v(TAG, \"Alarm to uid=\" + alarm.uid + \" listener=\" + alarm.listener.asBinder()); &#125; // 跨进程调用应用进程中的 onAlarmListener 的 doAlarm 方法！ alarm.listener.doAlarm(this); // 设置监听超时处理！ mHandler.sendMessageDelayed( mHandler.obtainMessage(AlarmHandler.LISTENER_TIMEOUT, alarm.listener.asBinder()), mConstants.LISTENER_TIMEOUT); &#125; catch (Exception e) &#123; // 如果分发出现异常，那就 return，不做处理！！ if (DEBUG_LISTENER_CALLBACK) &#123; Slog.i(TAG, \"Alarm undeliverable to listener \" + alarm.listener.asBinder(), e); &#125; return; &#125; &#125; //【2】alarm 要开始准备分发了，开始统计跟踪 wakelock 和 status！ if (mBroadcastRefCount == 0) &#123; setWakelockWorkSource(alarm.operation, alarm.workSource, alarm.type, alarm.statsTag, (alarm.operation == null) ? alarm.uid : -1, true); mWakeLock.acquire(); // 申请 wakeLock 锁，防止分发过程睡下去！ // 发送 REPORT_ALARMS_ACTIVE 给 AlarmHandler，AlarmHandler 会通知 DeviceIdleController //，有 alarm 处于 active 状态！ mHandler.obtainMessage(AlarmHandler.REPORT_ALARMS_ACTIVE, 1).sendToTarget(); &#125; //【3】创建 InFlight 对象，表示该 Alarm 正在分发过程中！ final InFlight inflight = new InFlight(AlarmManagerService.this, alarm.operation, alarm.listener, alarm.workSource, alarm.uid, alarm.packageName, alarm.type, alarm.statsTag, nowELAPSED); mInFlight.add(inflight); mBroadcastRefCount++; // 引用计数加 1； //【4】如果这个 alarm 是 allow while idle 的，那就要记录下该 alarm 的上一次分发时间 // 保存到 mLastAllowWhileIdleDispatch 中！ if (allowWhileIdle) &#123; mLastAllowWhileIdleDispatch.put(alarm.uid, nowELAPSED); if (RECORD_DEVICE_IDLE_ALARMS) &#123; // 用于 dump 操作，不关注！ IdleDispatchEntry ent = new IdleDispatchEntry(); ent.uid = alarm.uid; ent.pkg = alarm.packageName; ent.tag = alarm.statsTag; ent.op = \"DELIVER\"; ent.elapsedRealtime = nowELAPSED; mAllowWhileIdleDispatches.add(ent); &#125; &#125; //【5】设置 alarm 状态！ final BroadcastStats bs = inflight.mBroadcastStats; bs.count++; if (bs.nesting == 0) &#123; bs.nesting = 1; bs.startTime = nowELAPSED; &#125; else &#123; bs.nesting++; &#125; final FilterStats fs = inflight.mFilterStats; fs.count++; if (fs.nesting == 0) &#123; fs.nesting = 1; fs.startTime = nowELAPSED; &#125; else &#123; fs.nesting++; &#125; //【6】如果 alarm 是 wake up 类型的！ if (alarm.type == ELAPSED_REALTIME_WAKEUP || alarm.type == RTC_WAKEUP) &#123; bs.numWakeup++; // 更新 wake up 的次数！ fs.numWakeup++; if (alarm.workSource != null &amp;&amp; alarm.workSource.size() &gt; 0) &#123; for (int wi=0; wi&lt;alarm.workSource.size(); wi++) &#123; final String wsName = alarm.workSource.getName(wi); ActivityManagerNative.noteWakeupAlarm( alarm.operation, alarm.workSource.get(wi), (wsName != null) ? wsName : alarm.packageName, alarm.statsTag); &#125; &#125; else &#123; ActivityManagerNative.noteWakeupAlarm( alarm.operation, alarm.uid, alarm.packageName, alarm.statsTag); &#125; &#125; &#125;&#125; mDeliveryTracker 是 AlarmManagerService 的内部变量，用于监控分发的过程！ 这里我们看到，DeliveryTracker 继承了 IAlarmCompleteListener.Stub，这个是由 IAlarmCompleteListener.aidl 文件生成的一个服务端“桩”对象，作用很明显了，用于跨进程通信，即：系统进程和应用进程！ 原因很简单，DeliveryTracker 用于监控 Alarm 的分发，所以系统需要知道客户端对 Alarm 的分发和处理结果，所以应用进程那边一定会有 DeliveryTracker 的代理对象的！ 同时 DeliveryTracker 还实现了 PendingIntent.OnFinished 接口，用于另外一种分发方式！ 我们继续看！ 1.5.1 new InFlight系统会对每一个 Alarm 都创建其 InFlight 对象，并保存到 mInFlight！ 12345678910111213141516171819202122232425262728293031static final class InFlight &#123; final PendingIntent mPendingIntent; final IBinder mListener; final WorkSource mWorkSource; final int mUid; final String mTag; final BroadcastStats mBroadcastStats; final FilterStats mFilterStats; final int mAlarmType; InFlight(AlarmManagerService service, PendingIntent pendingIntent, IAlarmListener listener, WorkSource workSource, int uid, String alarmPkg, int alarmType, String tag, long nowELAPSED) &#123; mPendingIntent = pendingIntent; // PendingIntent 对象！ mListener = listener != null ? listener.asBinder() : null; // AlarmListener 对象！ mWorkSource = workSource; mUid = uid; mTag = tag; mBroadcastStats = (pendingIntent != null) ? service.getStatsLocked(pendingIntent) : service.getStatsLocked(uid, alarmPkg); FilterStats fs = mBroadcastStats.filterStats.get(mTag); if (fs == null) &#123; fs = new FilterStats(mBroadcastStats, mTag); mBroadcastStats.filterStats.put(mTag, fs); &#125; fs.lastTime = nowELAPSED; mFilterStats = fs; mAlarmType = alarmType; // Alarm 的类型！ &#125;&#125; 1.5.1.1 AlarmMS.getStatsLockedgetStatsLocked 用于获得 Alarm 对应的 BroadcastStats 对象！ 12345678910111213141516171819private final BroadcastStats getStatsLocked(PendingIntent pi) &#123; String pkg = pi.getCreatorPackage(); int uid = pi.getCreatorUid(); return getStatsLocked(uid, pkg);&#125;private final BroadcastStats getStatsLocked(int uid, String pkgName) &#123; ArrayMap&lt;String, BroadcastStats&gt; uidStats = mBroadcastStats.get(uid); if (uidStats == null) &#123; uidStats = new ArrayMap&lt;String, BroadcastStats&gt;(); mBroadcastStats.put(uid, uidStats); &#125; BroadcastStats bs = uidStats.get(pkgName); if (bs == null) &#123; bs = new BroadcastStats(uid, pkgName); uidStats.put(pkgName, bs); &#125; return bs;&#125; 每一个 Alarm 都会有一个 BroadcastStats，用于保存该 Alarm 的分发状态！ 同时，AlarmManagerService 也有一个集合：mBroadcastStats，来管理每个 uid 对应的广播分发状态！ 12final SparseArray&lt;ArrayMap&lt;String, BroadcastStats&gt;&gt; mBroadcastStats = new SparseArray&lt;ArrayMap&lt;String, BroadcastStats&gt;&gt;(); 映射关系：create uid -&gt; ArrayMap：create packageName -&gt; BroadcastStats！ 2 分发的流程前面我们看到，如果 setAlarm 是通过 PendingIntent 的方式来设置的，系统会通过如下方式分发 Alarm！ 12345alarm.operation.send(getContext(), 0, mBackgroundIntent.putExtra( Intent.EXTRA_ALARM_COUNT, alarm.count), mDeliveryTracker, mHandler, null, allowWhileIdle ? mIdleOptions : null); 如果 setAlarm 是通过 AlarmListener 的方式来设置的，系统会通过如下方式分发 Alarm！ 1234567// 跨进程调用应用进程中的 onAlarmListener 的 doAlarm 方法！alarm.listener.doAlarm(this);// 设置监听超时处理！mHandler.sendMessageDelayed( mHandler.obtainMessage(AlarmHandler.LISTENER_TIMEOUT, alarm.listener.asBinder()), mConstants.LISTENER_TIMEOUT); 下面我们来看看二者的区别！ 2.1 Alarm.PendingIntent.send我们可以看到，对于 PendingIntent，我们会将 Alarm 的重复分发次数通过 Intent.EXTRA_ALARM_COUNT 发送给处理方！ 123456789101112131415161718192021222324public void send(Context context, int code, @Nullable Intent intent, @Nullable OnFinished onFinished, @Nullable Handler handler, @Nullable String requiredPermission, @Nullable Bundle options) throws CanceledException &#123; try &#123; String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null; //【1】调用 AMS 的 sendIntentSender 方法发送这个 Alarm！！ int res = ActivityManagerNative.getDefault().sendIntentSender( mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) // 创建了 FinishedDispatcher 对象！ : null, requiredPermission, options); if (res &lt; 0) &#123; throw new CanceledException(); &#125; &#125; catch (RemoteException e) &#123; throw new CanceledException(e); &#125;&#125; 这里要注意，我们传入的参数 onFinished 实现对象是 mDeliveryTracker！ 这里我们要简单提一下 mTarget，他是 PendingIntent 的内部成员变量，是一个 IIntentSender Binder 对象！我们在调用 PendingIntent.getService 等方法的时候，会有如下的逻辑： 2.1.1 new FinishedDispatcher123456789101112131415161718192021222324private static class FinishedDispatcher extends IIntentReceiver.Stub implements Runnable &#123; private final PendingIntent mPendingIntent; private final OnFinished mWho; // mDeliveryTracker 对象！ private final Handler mHandler; private Intent mIntent; private int mResultCode; private String mResultData; private Bundle mResultExtras; private static Handler sDefaultSystemHandler; FinishedDispatcher(PendingIntent pi, OnFinished who, Handler handler) &#123; mPendingIntent = pi; mWho = who; if (handler == null &amp;&amp; ActivityThread.isSystem()) &#123; if (sDefaultSystemHandler == null) &#123; sDefaultSystemHandler = new Handler(Looper.getMainLooper()); &#125; mHandler = sDefaultSystemHandler; &#125; else &#123; mHandler = handler; &#125; &#125;&#125; 如果没有传入指定的 Handler， 2.1.2 ActivityMS.sendIntentSenderPendingIntent.send 方法最终会调用 AMS.sendIntentSender 方法，当然这里涉及到了 PendingIntent 架构和逻辑，这里不做过多的讨论！ 1234567891011121314151617181920212223242526272829@Overridepublic int sendIntentSender(IIntentSender target, int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) &#123; //【1】一般情况，每一个 PendingIntent 都会有一个 PendingIntentRecord 在系统中与之对应！ // 默认情况下会调用 PendingIntentRecord 的 sendWithResult 方法！ if (target instanceof PendingIntentRecord) &#123; return ((PendingIntentRecord)target).sendWithResult(code, intent, resolvedType, finishedReceiver, requiredPermission, options); &#125; else &#123; // 下面是特殊情况，我们不关注！ if (intent == null) &#123; Slog.wtf(TAG, \"Can't use null intent with direct IIntentSender call\"); intent = new Intent(Intent.ACTION_MAIN); &#125; try &#123; target.send(code, intent, resolvedType, null, requiredPermission, options); &#125; catch (RemoteException e) &#123; &#125; if (finishedReceiver != null) &#123; try &#123; // 处理分发结果！ finishedReceiver.performReceive(intent, 0, null, null, false, false, UserHandle.getCallingUserId()); &#125; catch (RemoteException e) &#123; &#125; &#125; return 0; &#125;&#125; 正常情况下，会调用 PendingIntentRecord.sendWithResult 分发 alarm！ 2.1.3 PendingIntentRecord.sendWithResult123456public int sendWithResult(int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) &#123; // 继续调用 sendInner 方法！ return sendInner(code, intent, resolvedType, finishedReceiver, requiredPermission, null, null, 0, 0, 0, options, null);&#125; 2.1.4 PendingIntentRecord.sendInner123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int sendInner(int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options, IActivityContainer container) &#123; if (intent != null) intent.setDefusable(true); if (options != null) options.setDefusable(true); if (whitelistDuration &gt; 0 &amp;&amp; !canceled) &#123; // Must call before acquiring the lock. It's possible the method return before sending // the intent due to some validations inside the lock, in which case the UID shouldn't // be whitelisted, but since the whitelist is temporary, that would be ok. owner.tempWhitelistAppForPowerSave(Binder.getCallingPid(), Binder.getCallingUid(), uid, whitelistDuration); &#125; synchronized (owner) &#123; final ActivityContainer activityContainer = (ActivityContainer)container; if (activityContainer != null &amp;&amp; activityContainer.mParentActivity != null &amp;&amp; activityContainer.mParentActivity.state != ActivityStack.ActivityState.RESUMED) &#123; // Cannot start a child activity if the parent is not resumed. return ActivityManager.START_CANCELED; &#125; if (!canceled) &#123; sent = true; if ((key.flags&amp;PendingIntent.FLAG_ONE_SHOT) != 0) &#123; owner.cancelIntentSenderLocked(this, true); canceled = true; &#125; Intent finalIntent = key.requestIntent != null ? new Intent(key.requestIntent) : new Intent(); final boolean immutable = (key.flags &amp; PendingIntent.FLAG_IMMUTABLE) != 0; if (!immutable) &#123; if (intent != null) &#123; int changes = finalIntent.fillIn(intent, key.flags); if ((changes &amp; Intent.FILL_IN_DATA) == 0) &#123; resolvedType = key.requestResolvedType; &#125; &#125; else &#123; resolvedType = key.requestResolvedType; &#125; flagsMask &amp;= ~Intent.IMMUTABLE_FLAGS; flagsValues &amp;= flagsMask; finalIntent.setFlags((finalIntent.getFlags() &amp; ~flagsMask) | flagsValues); &#125; else &#123; resolvedType = key.requestResolvedType; &#125; final long origId = Binder.clearCallingIdentity(); boolean sendFinish = finishedReceiver != null; int userId = key.userId; if (userId == UserHandle.USER_CURRENT) &#123; userId = owner.mUserController.getCurrentOrTargetUserIdLocked(); &#125; int res = 0; // 根据 alarm 的类型，做不同的处理！ switch (key.type) &#123; case ActivityManager.INTENT_SENDER_ACTIVITY: if (options == null) &#123; options = key.options; &#125; else if (key.options != null) &#123; Bundle opts = new Bundle(key.options); opts.putAll(options); options = opts; &#125; try &#123; if (key.allIntents != null &amp;&amp; key.allIntents.length &gt; 1) &#123; Intent[] allIntents = new Intent[key.allIntents.length]; String[] allResolvedTypes = new String[key.allIntents.length]; System.arraycopy(key.allIntents, 0, allIntents, 0, key.allIntents.length); if (key.allResolvedTypes != null) &#123; System.arraycopy(key.allResolvedTypes, 0, allResolvedTypes, 0, key.allResolvedTypes.length); &#125; allIntents[allIntents.length-1] = finalIntent; allResolvedTypes[allResolvedTypes.length-1] = resolvedType; owner.startActivitiesInPackage(uid, key.packageName, allIntents, allResolvedTypes, resultTo, options, userId); &#125; else &#123; owner.startActivityInPackage(uid, key.packageName, finalIntent, resolvedType, resultTo, resultWho, requestCode, 0, options, userId, container, null); &#125; &#125; catch (RuntimeException e) &#123; Slog.w(TAG, \"Unable to send startActivity intent\", e); &#125; break; case ActivityManager.INTENT_SENDER_ACTIVITY_RESULT: if (key.activity.task.stack != null) &#123; key.activity.task.stack.sendActivityResultLocked(-1, key.activity, key.who, key.requestCode, code, finalIntent); &#125; break; case ActivityManager.INTENT_SENDER_BROADCAST: try &#123; // If a completion callback has been requested, require // that the broadcast be delivered synchronously int sent = owner.broadcastIntentInPackage(key.packageName, uid, finalIntent, resolvedType, finishedReceiver, code, null, null, requiredPermission, options, (finishedReceiver != null), false, userId); if (sent == ActivityManager.BROADCAST_SUCCESS) &#123; sendFinish = false; &#125; &#125; catch (RuntimeException e) &#123; Slog.w(TAG, \"Unable to send startActivity intent\", e); &#125; break; case ActivityManager.INTENT_SENDER_SERVICE: try &#123; owner.startServiceInPackage(uid, finalIntent, resolvedType, key.packageName, userId); &#125; catch (RuntimeException e) &#123; Slog.w(TAG, \"Unable to send startService intent\", e); &#125; catch (TransactionTooLargeException e) &#123; res = ActivityManager.START_CANCELED; &#125; break; &#125; // 处理分发结果！ if (sendFinish &amp;&amp; res != ActivityManager.START_CANCELED) &#123; try &#123; finishedReceiver.performReceive(new Intent(finalIntent), 0, null, null, false, false, key.userId); &#125; catch (RemoteException e) &#123; &#125; &#125; Binder.restoreCallingIdentity(origId); return res; &#125; &#125; return ActivityManager.START_CANCELED;&#125; 2.2 Alarm.Listener.doAlarmAlarm.Listener 是一个 Binder 对象，其服务端是应用进程的 ListenerWrapper 对象，之前我们知道 ListenerWrapper 实现了 IAlarmListener.Stub： 12 3 特殊的触发路径如果没有 Alarm 驱动，那么我们知道 Alarm 的触发是通过内部的一个 AlarmHandler 实现的： 12345678910private void setLocked(int type, long when) &#123; if (mNativeData != 0) &#123; ... ... ... &#125; else &#123; Message msg = Message.obtain(); msg.what = ALARM_EVENT; mHandler.removeMessages(ALARM_EVENT); mHandler.sendMessageAtTime(msg, when); &#125;&#125; 可以看到，最后发送的是 ALARM_EVENT 给 AlarmHandler： 3.1 AlarmHandler.handleMessage[ALARM_EVENT]12345678910111213141516171819202122232425262728public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case ALARM_EVENT: &#123; // 同样的 triggerList！ ArrayList&lt;Alarm&gt; triggerList = new ArrayList&lt;Alarm&gt;(); synchronized (mLock) &#123; final long nowRTC = System.currentTimeMillis(); final long nowELAPSED = SystemClock.elapsedRealtime(); // 调用 triggerAlarmsLocked 收集触发的 alarm！ triggerAlarmsLocked(triggerList, nowELAPSED, nowRTC); updateNextAlarmClockLocked(); // 更新下一个 AlarmClock &#125; // 分发 Alarm！ for (int i=0; i&lt;triggerList.size(); i++) &#123; Alarm alarm = triggerList.get(i); try &#123; alarm.operation.send(); // 这里再次调用了 PendingIntent 的 send 方法！ &#125; catch (PendingIntent.CanceledException e) &#123; if (alarm.repeatInterval &gt; 0) &#123; // 发送出问题，如果是重复性 Alarm，那就移除该 Alarm！ removeImpl(alarm.operation); &#125; &#125; &#125; break; &#125; &#125;&#125; 这个方法逻辑很简单，不多说了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AlarmManager闹钟管理","slug":"AndroidFramework源码分析/AlarmManager闹钟管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AlarmManager闹钟管理/"}],"tags":[{"name":"AlarmManager闹钟管理","slug":"AlarmManager闹钟管理","permalink":"https://coolqi.top/tags/AlarmManager闹钟管理/"}]},{"title":"AppOps 第 2 篇 - AppOpsManager 分析","slug":"AppOps2-AppOpsManager","date":"2017-08-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/08/13/AppOps2-AppOpsManager/","link":"","permalink":"https://coolqi.top/2017/08/13/AppOps2-AppOpsManager/","excerpt":"","text":"[toc] 本文基于 Android 7.1.1 源码分析，如有错误，欢迎指正，谢谢！ 0 综述AppOpsService 实现了大部分的核心功能逻辑，但它不能被其他模块直接调用访问，而是通过 AppOpsManager 提供访问接口。 1 重要常量和变量下面我们来看下 AppOpsManager 中定义的一些重要的变量和常量！ 1.1 Operation CodeAppOpsManager 一共定义了 64 种 Op Code，我们一起看下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// when adding one of these:// - increment _NUM_OP// - add rows to sOpToSwitch, sOpToString, sOpNames, sOpToPerms, sOpDefault// - add descriptive strings to Settings/res/values/arrays.xml// - add the op to the appropriate template in AppOpsState.OpsTemplate (settings app)/** @hide No operation specified. */public static final int OP_NONE = -1;/** @hide Access to coarse location information. */public static final int OP_COARSE_LOCATION = 0;/** @hide Access to fine location information. */public static final int OP_FINE_LOCATION = 1;/** @hide Causing GPS to run. */public static final int OP_GPS = 2;/** @hide */public static final int OP_VIBRATE = 3;/** @hide */public static final int OP_READ_CONTACTS = 4;/** @hide */public static final int OP_WRITE_CONTACTS = 5;/** @hide */public static final int OP_READ_CALL_LOG = 6;/** @hide */public static final int OP_WRITE_CALL_LOG = 7;/** @hide */public static final int OP_READ_CALENDAR = 8;/** @hide */public static final int OP_WRITE_CALENDAR = 9;/** @hide */public static final int OP_WIFI_SCAN = 10;/** @hide */public static final int OP_POST_NOTIFICATION = 11;/** @hide */public static final int OP_NEIGHBORING_CELLS = 12;/** @hide */public static final int OP_CALL_PHONE = 13;/** @hide */public static final int OP_READ_SMS = 14;/** @hide */public static final int OP_WRITE_SMS = 15;/** @hide */public static final int OP_RECEIVE_SMS = 16;/** @hide */public static final int OP_RECEIVE_EMERGECY_SMS = 17;/** @hide */public static final int OP_RECEIVE_MMS = 18;/** @hide */public static final int OP_RECEIVE_WAP_PUSH = 19;/** @hide */public static final int OP_SEND_SMS = 20;/** @hide */public static final int OP_READ_ICC_SMS = 21;/** @hide */public static final int OP_WRITE_ICC_SMS = 22;/** @hide */public static final int OP_WRITE_SETTINGS = 23;/** @hide */public static final int OP_SYSTEM_ALERT_WINDOW = 24;/** @hide */public static final int OP_ACCESS_NOTIFICATIONS = 25;/** @hide */public static final int OP_CAMERA = 26;/** @hide */public static final int OP_RECORD_AUDIO = 27;/** @hide */public static final int OP_PLAY_AUDIO = 28;/** @hide */public static final int OP_READ_CLIPBOARD = 29;/** @hide */public static final int OP_WRITE_CLIPBOARD = 30;/** @hide */public static final int OP_TAKE_MEDIA_BUTTONS = 31;/** @hide */public static final int OP_TAKE_AUDIO_FOCUS = 32;/** @hide */public static final int OP_AUDIO_MASTER_VOLUME = 33;/** @hide */public static final int OP_AUDIO_VOICE_VOLUME = 34;/** @hide */public static final int OP_AUDIO_RING_VOLUME = 35;/** @hide */public static final int OP_AUDIO_MEDIA_VOLUME = 36;/** @hide */public static final int OP_AUDIO_ALARM_VOLUME = 37;/** @hide */public static final int OP_AUDIO_NOTIFICATION_VOLUME = 38;/** @hide */public static final int OP_AUDIO_BLUETOOTH_VOLUME = 39;/** @hide */public static final int OP_WAKE_LOCK = 40;/** @hide Continually monitoring location data. */public static final int OP_MONITOR_LOCATION = 41;/** @hide Continually monitoring location data with a relatively high power request. */public static final int OP_MONITOR_HIGH_POWER_LOCATION = 42;/** @hide Retrieve current usage stats via &#123;@link UsageStatsManager&#125;. */public static final int OP_GET_USAGE_STATS = 43;/** @hide */public static final int OP_MUTE_MICROPHONE = 44;/** @hide */public static final int OP_TOAST_WINDOW = 45;/** @hide Capture the device's display contents and/or audio */public static final int OP_PROJECT_MEDIA = 46;/** @hide Activate a VPN connection without user intervention. */public static final int OP_ACTIVATE_VPN = 47;/** @hide Access the WallpaperManagerAPI to write wallpapers. */public static final int OP_WRITE_WALLPAPER = 48;/** @hide Received the assist structure from an app. */public static final int OP_ASSIST_STRUCTURE = 49;/** @hide Received a screenshot from assist. */public static final int OP_ASSIST_SCREENSHOT = 50;/** @hide Read the phone state. */public static final int OP_READ_PHONE_STATE = 51;/** @hide Add voicemail messages to the voicemail content provider. */public static final int OP_ADD_VOICEMAIL = 52;/** @hide Access APIs for SIP calling over VOIP or WiFi. */public static final int OP_USE_SIP = 53;/** @hide Intercept outgoing calls. */public static final int OP_PROCESS_OUTGOING_CALLS = 54;/** @hide User the fingerprint API. */public static final int OP_USE_FINGERPRINT = 55;/** @hide Access to body sensors such as heart rate, etc. */public static final int OP_BODY_SENSORS = 56;/** @hide Read previously received cell broadcast messages. */public static final int OP_READ_CELL_BROADCASTS = 57;/** @hide Inject mock location into the system. */public static final int OP_MOCK_LOCATION = 58;/** @hide Read external storage. */public static final int OP_READ_EXTERNAL_STORAGE = 59;/** @hide Write external storage. */public static final int OP_WRITE_EXTERNAL_STORAGE = 60;/** @hide Turned on the screen. */public static final int OP_TURN_SCREEN_ON = 61;/** @hide Get device accounts. */public static final int OP_GET_ACCOUNTS = 62;/** @hide Control whether an application is allowed to run in the background. */public static final int OP_RUN_IN_BACKGROUND = 63; 具体的意思，这里就暂时不解释了！ 我们可以看到，原生定义了 64 个 Operation Code，但是也支持扩充，从第一行的 log 中可以看出：如果想扩充，需要更新相应的集合！ 同时，AppOpsManager 内部也定义了一些数组： 1.1.1 数组 RUNTIME_PERMISSIONS_OPS123456789101112131415161718192021222324252627282930313233343536private static final int[] RUNTIME_PERMISSIONS_OPS = &#123; // Contacts OP_READ_CONTACTS, OP_WRITE_CONTACTS, OP_GET_ACCOUNTS, // Calendar OP_READ_CALENDAR, OP_WRITE_CALENDAR, // SMS OP_SEND_SMS, OP_RECEIVE_SMS, OP_READ_SMS, OP_RECEIVE_WAP_PUSH, OP_RECEIVE_MMS, OP_READ_CELL_BROADCASTS, // Storage OP_READ_EXTERNAL_STORAGE, OP_WRITE_EXTERNAL_STORAGE, // Location OP_COARSE_LOCATION, OP_FINE_LOCATION, // Phone OP_READ_PHONE_STATE, OP_CALL_PHONE, OP_READ_CALL_LOG, OP_WRITE_CALL_LOG, OP_ADD_VOICEMAIL, OP_USE_SIP, OP_PROCESS_OUTGOING_CALLS, // Microphone OP_RECORD_AUDIO, // Camera OP_CAMERA, // Body sensors OP_BODY_SENSORS&#125;; RUNTIME_PERMISSIONS_OPS 中定义了一些运行时权限相关的 Op，从名字我们能很容易看出他们映射的是什么运行时权限！ 1.1.2 数组 sOpToSwitch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static int[] sOpToSwitch = new int[] &#123; OP_COARSE_LOCATION, OP_COARSE_LOCATION, OP_COARSE_LOCATION, OP_VIBRATE, OP_READ_CONTACTS, OP_WRITE_CONTACTS, OP_READ_CALL_LOG, OP_WRITE_CALL_LOG, OP_READ_CALENDAR, OP_WRITE_CALENDAR, OP_COARSE_LOCATION, OP_POST_NOTIFICATION, OP_COARSE_LOCATION, OP_CALL_PHONE, OP_READ_SMS, OP_WRITE_SMS, OP_RECEIVE_SMS, OP_RECEIVE_SMS, OP_RECEIVE_SMS, OP_RECEIVE_SMS, OP_SEND_SMS, OP_READ_SMS, OP_WRITE_SMS, OP_WRITE_SETTINGS, OP_SYSTEM_ALERT_WINDOW, OP_ACCESS_NOTIFICATIONS, OP_CAMERA, OP_RECORD_AUDIO, OP_PLAY_AUDIO, OP_READ_CLIPBOARD, OP_WRITE_CLIPBOARD, OP_TAKE_MEDIA_BUTTONS, OP_TAKE_AUDIO_FOCUS, OP_AUDIO_MASTER_VOLUME, OP_AUDIO_VOICE_VOLUME, OP_AUDIO_RING_VOLUME, OP_AUDIO_MEDIA_VOLUME, OP_AUDIO_ALARM_VOLUME, OP_AUDIO_NOTIFICATION_VOLUME, OP_AUDIO_BLUETOOTH_VOLUME, OP_WAKE_LOCK, OP_COARSE_LOCATION, OP_COARSE_LOCATION, OP_GET_USAGE_STATS, OP_MUTE_MICROPHONE, OP_TOAST_WINDOW, OP_PROJECT_MEDIA, OP_ACTIVATE_VPN, OP_WRITE_WALLPAPER, OP_ASSIST_STRUCTURE, OP_ASSIST_SCREENSHOT, OP_READ_PHONE_STATE, OP_ADD_VOICEMAIL, OP_USE_SIP, OP_PROCESS_OUTGOING_CALLS, OP_USE_FINGERPRINT, OP_BODY_SENSORS, OP_READ_CELL_BROADCASTS, OP_MOCK_LOCATION, OP_READ_EXTERNAL_STORAGE, OP_WRITE_EXTERNAL_STORAGE, OP_TURN_SCREEN_ON, OP_GET_ACCOUNTS, OP_RUN_IN_BACKGROUND,&#125;; 数组 sOpToSwitch 的长度是 64，保存的是 Op 和 Op 的映射，下标 i 是具体的 Operation，而 value 对应 Operation 的允许情况将决定下标对应的 Operation 的允许情况！ 一般情况下，是一对一的映射关系，比如 OP_RUN_IN_BACKGROUND 只和自身相对应，而 OP_COARSE_LOCATION，OP_FINE_LOCATION 和 OP_GPS 则是由 OP_COARSE_LOCATION 是否被运允许来统一决定！！ 映射到界面上，就是一个 op 所谓 switch 开关决定一个或者多个 op 的允许情况！ 1.1.3 数组 sOpToString123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static String[] sOpToString = new String[] &#123; OPSTR_COARSE_LOCATION, OPSTR_FINE_LOCATION, null, null, OPSTR_READ_CONTACTS, OPSTR_WRITE_CONTACTS, OPSTR_READ_CALL_LOG, OPSTR_WRITE_CALL_LOG, OPSTR_READ_CALENDAR, OPSTR_WRITE_CALENDAR, null, null, null, OPSTR_CALL_PHONE, OPSTR_READ_SMS, null, OPSTR_RECEIVE_SMS, null, OPSTR_RECEIVE_MMS, OPSTR_RECEIVE_WAP_PUSH, OPSTR_SEND_SMS, null, null, OPSTR_WRITE_SETTINGS, OPSTR_SYSTEM_ALERT_WINDOW, null, OPSTR_CAMERA, OPSTR_RECORD_AUDIO, null, null, null, null, null, null, null, null, null, null, null, null, null, OPSTR_MONITOR_LOCATION, OPSTR_MONITOR_HIGH_POWER_LOCATION, OPSTR_GET_USAGE_STATS, null, null, null, OPSTR_ACTIVATE_VPN, null, null, null, OPSTR_READ_PHONE_STATE, OPSTR_ADD_VOICEMAIL, OPSTR_USE_SIP, null, OPSTR_USE_FINGERPRINT, OPSTR_BODY_SENSORS, OPSTR_READ_CELL_BROADCASTS, OPSTR_MOCK_LOCATION, OPSTR_READ_EXTERNAL_STORAGE, OPSTR_WRITE_EXTERNAL_STORAGE, null, OPSTR_GET_ACCOUNTS, null,&#125;; 数组 sOpToString 的长度是 64，保存的是 Op 和对应的字符串常量的映射，如果没有对应的字符串相映射，可以为 null； 1234567891011/** Access to coarse location information. */public static final String OPSTR_COARSE_LOCATION = \"android:coarse_location\";/** Access to fine location information. */public static final String OPSTR_FINE_LOCATION = \"android:fine_location\";/** Continually monitoring location data. */public static final String OPSTR_MONITOR_LOCATION = \"android:monitor_location\";/** Continually monitoring location data with a relatively high power request. */public static final String OPSTR_MONITOR_HIGH_POWER_LOCATION... ... ... 可以看出来，这个 op 对应的 str 的格式是：“android:xxxxxx” 1.1.4 数组 sOpPerms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static String[] sOpPerms = new String[] &#123; android.Manifest.permission.ACCESS_COARSE_LOCATION, android.Manifest.permission.ACCESS_FINE_LOCATION, null, android.Manifest.permission.VIBRATE, android.Manifest.permission.READ_CONTACTS, android.Manifest.permission.WRITE_CONTACTS, android.Manifest.permission.READ_CALL_LOG, android.Manifest.permission.WRITE_CALL_LOG, android.Manifest.permission.READ_CALENDAR, android.Manifest.permission.WRITE_CALENDAR, android.Manifest.permission.ACCESS_WIFI_STATE, null, // no permission required for notifications null, // neighboring cells shares the coarse location perm android.Manifest.permission.CALL_PHONE, android.Manifest.permission.READ_SMS, null, // no permission required for writing sms android.Manifest.permission.RECEIVE_SMS, android.Manifest.permission.RECEIVE_EMERGENCY_BROADCAST, android.Manifest.permission.RECEIVE_MMS, android.Manifest.permission.RECEIVE_WAP_PUSH, android.Manifest.permission.SEND_SMS, android.Manifest.permission.READ_SMS, null, // no permission required for writing icc sms android.Manifest.permission.WRITE_SETTINGS, android.Manifest.permission.SYSTEM_ALERT_WINDOW, android.Manifest.permission.ACCESS_NOTIFICATIONS, android.Manifest.permission.CAMERA, android.Manifest.permission.RECORD_AUDIO, null, // no permission for playing audio null, // no permission for reading clipboard null, // no permission for writing clipboard null, // no permission for taking media buttons null, // no permission for taking audio focus null, // no permission for changing master volume null, // no permission for changing voice volume null, // no permission for changing ring volume null, // no permission for changing media volume null, // no permission for changing alarm volume null, // no permission for changing notification volume null, // no permission for changing bluetooth volume android.Manifest.permission.WAKE_LOCK, null, // no permission for generic location monitoring null, // no permission for high power location monitoring android.Manifest.permission.PACKAGE_USAGE_STATS, null, // no permission for muting/unmuting microphone null, // no permission for displaying toasts null, // no permission for projecting media null, // no permission for activating vpn null, // no permission for supporting wallpaper null, // no permission for receiving assist structure null, // no permission for receiving assist screenshot Manifest.permission.READ_PHONE_STATE, Manifest.permission.ADD_VOICEMAIL, Manifest.permission.USE_SIP, Manifest.permission.PROCESS_OUTGOING_CALLS, Manifest.permission.USE_FINGERPRINT, Manifest.permission.BODY_SENSORS, Manifest.permission.READ_CELL_BROADCASTS, null, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE, null, // no permission for turning the screen on Manifest.permission.GET_ACCOUNTS, null, // no permission for running in background&#125;; 数组 sOpPerms 的长度是 64，保存的是 Op 和对应权限的映射，如果没有对应的权限相映射，可以为 null； 可以看到，AppOps 不仅映射 dangerous 权限，还映射了 signature 权限！ 1.1.4 数组 sOpRestrictions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static String[] sOpRestrictions = new String[] &#123; UserManager.DISALLOW_SHARE_LOCATION, //COARSE_LOCATION UserManager.DISALLOW_SHARE_LOCATION, //FINE_LOCATION UserManager.DISALLOW_SHARE_LOCATION, //GPS null, //VIBRATE null, //READ_CONTACTS null, //WRITE_CONTACTS UserManager.DISALLOW_OUTGOING_CALLS, //READ_CALL_LOG UserManager.DISALLOW_OUTGOING_CALLS, //WRITE_CALL_LOG null, //READ_CALENDAR null, //WRITE_CALENDAR UserManager.DISALLOW_SHARE_LOCATION, //WIFI_SCAN null, //POST_NOTIFICATION null, //NEIGHBORING_CELLS null, //CALL_PHONE UserManager.DISALLOW_SMS, //READ_SMS UserManager.DISALLOW_SMS, //WRITE_SMS UserManager.DISALLOW_SMS, //RECEIVE_SMS null, //RECEIVE_EMERGENCY_SMS UserManager.DISALLOW_SMS, //RECEIVE_MMS null, //RECEIVE_WAP_PUSH UserManager.DISALLOW_SMS, //SEND_SMS UserManager.DISALLOW_SMS, //READ_ICC_SMS UserManager.DISALLOW_SMS, //WRITE_ICC_SMS null, //WRITE_SETTINGS UserManager.DISALLOW_CREATE_WINDOWS, //SYSTEM_ALERT_WINDOW null, //ACCESS_NOTIFICATIONS UserManager.DISALLOW_CAMERA, //CAMERA UserManager.DISALLOW_RECORD_AUDIO, //RECORD_AUDIO null, //PLAY_AUDIO null, //READ_CLIPBOARD null, //WRITE_CLIPBOARD null, //TAKE_MEDIA_BUTTONS null, //TAKE_AUDIO_FOCUS UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_MASTER_VOLUME UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_VOICE_VOLUME UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_RING_VOLUME UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_MEDIA_VOLUME UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_ALARM_VOLUME UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_NOTIFICATION_VOLUME UserManager.DISALLOW_ADJUST_VOLUME, //AUDIO_BLUETOOTH_VOLUME null, //WAKE_LOCK UserManager.DISALLOW_SHARE_LOCATION, //MONITOR_LOCATION UserManager.DISALLOW_SHARE_LOCATION, //MONITOR_HIGH_POWER_LOCATION null, //GET_USAGE_STATS UserManager.DISALLOW_UNMUTE_MICROPHONE, // MUTE_MICROPHONE UserManager.DISALLOW_CREATE_WINDOWS, // TOAST_WINDOW null, //PROJECT_MEDIA null, // ACTIVATE_VPN UserManager.DISALLOW_WALLPAPER, // WRITE_WALLPAPER null, // ASSIST_STRUCTURE null, // ASSIST_SCREENSHOT null, // READ_PHONE_STATE null, // ADD_VOICEMAIL null, // USE_SIP null, // PROCESS_OUTGOING_CALLS null, // USE_FINGERPRINT null, // BODY_SENSORS null, // READ_CELL_BROADCASTS null, // MOCK_LOCATION null, // READ_EXTERNAL_STORAGE null, // WRITE_EXTERNAL_STORAGE null, // TURN_ON_SCREEN null, // GET_ACCOUNTS null, // RUN_IN_BACKGROUND&#125;; 数组 sOpRestrictions 的长度为 64，用来指定 Op 是否应该受到用户限制的影响。每一个 Op 都应该和一个用户限制相映射，如果某个 Op 不受任何用户限制的影响，那么 value 为 null。 1.1.5 数组 sOpAllowSystemRestrictionBypass123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static boolean[] sOpAllowSystemRestrictionBypass = new boolean[] &#123; true, //COARSE_LOCATION true, //FINE_LOCATION false, //GPS false, //VIBRATE false, //READ_CONTACTS false, //WRITE_CONTACTS false, //READ_CALL_LOG false, //WRITE_CALL_LOG false, //READ_CALENDAR false, //WRITE_CALENDAR true, //WIFI_SCAN false, //POST_NOTIFICATION false, //NEIGHBORING_CELLS false, //CALL_PHONE false, //READ_SMS false, //WRITE_SMS false, //RECEIVE_SMS false, //RECEIVE_EMERGECY_SMS false, //RECEIVE_MMS false, //RECEIVE_WAP_PUSH false, //SEND_SMS false, //READ_ICC_SMS false, //WRITE_ICC_SMS false, //WRITE_SETTINGS true, //SYSTEM_ALERT_WINDOW false, //ACCESS_NOTIFICATIONS false, //CAMERA false, //RECORD_AUDIO false, //PLAY_AUDIO false, //READ_CLIPBOARD false, //WRITE_CLIPBOARD false, //TAKE_MEDIA_BUTTONS false, //TAKE_AUDIO_FOCUS false, //AUDIO_MASTER_VOLUME false, //AUDIO_VOICE_VOLUME false, //AUDIO_RING_VOLUME false, //AUDIO_MEDIA_VOLUME false, //AUDIO_ALARM_VOLUME false, //AUDIO_NOTIFICATION_VOLUME false, //AUDIO_BLUETOOTH_VOLUME false, //WAKE_LOCK false, //MONITOR_LOCATION false, //MONITOR_HIGH_POWER_LOCATION false, //GET_USAGE_STATS false, //MUTE_MICROPHONE true, //TOAST_WINDOW false, //PROJECT_MEDIA false, //ACTIVATE_VPN false, //WALLPAPER false, //ASSIST_STRUCTURE false, //ASSIST_SCREENSHOT false, //READ_PHONE_STATE false, //ADD_VOICEMAIL false, // USE_SIP false, // PROCESS_OUTGOING_CALLS false, // USE_FINGERPRINT false, // BODY_SENSORS false, // READ_CELL_BROADCASTS false, // MOCK_LOCATION false, // READ_EXTERNAL_STORAGE false, // WRITE_EXTERNAL_STORAGE false, // TURN_ON_SCREEN false, // GET_ACCOUNTS false, // RUN_IN_BACKGROUND&#125;; 数组 sOpAllowSystemRestrictionBypass 的长度为 64，数组下标表示具体的 Op，值表示相应的 Operation 是否允许 system 和 system ui 要绕开用户限制！ 1.1.5 数组 sOpDefaultMode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static int[] sOpDefaultMode = new int[] &#123; AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_IGNORED, // OP_WRITE_SMS AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_DEFAULT, // OP_WRITE_SETTINGS AppOpsManager.MODE_DEFAULT, // OP_SYSTEM_ALERT_WINDOW AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_DEFAULT, // OP_GET_USAGE_STATS AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_IGNORED, // OP_PROJECT_MEDIA AppOpsManager.MODE_IGNORED, // OP_ACTIVATE_VPN AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ERRORED, // OP_MOCK_LOCATION AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, // OP_TURN_ON_SCREEN AppOpsManager.MODE_ALLOWED, AppOpsManager.MODE_ALLOWED, // OP_RUN_IN_BACKGROUND&#125;; 数组 sOpDefaultMode 的长度为 64，用来指定每个 Operation 的默认允许情况（Mode）。 1.1.5 数组 sOpDisableReset123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static boolean[] sOpDisableReset = new boolean[] &#123; false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, // OP_WRITE_SMS false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false,&#125;; 数组 sOpDisableReset 的长度为 64，用来指定是否允许在重置所有应用偏好设置后，重置 Operation 的授予情况，true 表示禁止重置，false 表示允许重置。 1.1.7 哈希表 sOpStrToOp 和 sRuntimePermToOp12345// 用于保存 Op name 和 Op Code 的映射关系！private static HashMap&lt;String, Integer&gt; sOpStrToOp = new HashMap&lt;&gt;();// 用于保存运行时权限和 Op Code 的映射关系！private static HashMap&lt;String, Integer&gt; sRuntimePermToOp = new HashMap&lt;&gt;(); AppOpsManager 有一个静态代码块，static 静态代码块中，会对 AppOpsManager 的每个数组的长度进行 check，如果与 _NUM_OP 值不一致，就会抛异常，会导致开不了机。 同时也会对 sOpStrToOp 和 sRuntimePermToOp 进行初始化！12345678910111213141516171819202122232425262728293031323334353637383940414243444546static &#123; if (sOpToSwitch.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpToSwitch length \" + sOpToSwitch.length + \" should be \" + _NUM_OP); &#125; if (sOpToString.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpToString length \" + sOpToString.length + \" should be \" + _NUM_OP); &#125; if (sOpNames.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpNames length \" + sOpNames.length + \" should be \" + _NUM_OP); &#125; if (sOpPerms.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpPerms length \" + sOpPerms.length + \" should be \" + _NUM_OP); &#125; if (sOpDefaultMode.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpDefaultMode length \" + sOpDefaultMode.length + \" should be \" + _NUM_OP); &#125; if (sOpDisableReset.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpDisableReset length \" + sOpDisableReset.length + \" should be \" + _NUM_OP); &#125; if (sOpRestrictions.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpRestrictions length \" + sOpRestrictions.length + \" should be \" + _NUM_OP); &#125; if (sOpAllowSystemRestrictionBypass.length != _NUM_OP) &#123; throw new IllegalStateException(\"sOpAllowSYstemRestrictionsBypass length \" + sOpRestrictions.length + \" should be \" + _NUM_OP); &#125; //【1】初始化 sOpStrToOp for (int i=0; i&lt;_NUM_OP; i++) &#123; if (sOpToString[i] != null) &#123; sOpStrToOp.put(sOpToString[i], i); &#125; &#125; //【2】初始化 sRuntimePermToOp for (int op : RUNTIME_PERMISSIONS_OPS) &#123; if (sOpPerms[op] != null) &#123; sRuntimePermToOp.put(sOpPerms[op], op); &#125; &#125;&#125; 1.2 Operation Mode每一个 Operation Code 都会有如下的 4 中控制状态： 1public static final int MODE_ALLOWED = 0; 该值是 checkOp/noteOp/startOp 方法的返回结果之一，同时也是 Operation 的控制状态之一，表示调用者允许执行相应的操作！ 1public static final int MODE_IGNORED = 1; 该值是 checkOp/noteOp/startOp 方法的返回结果之一，同时也是 Operation 的控制状态之一，表示调用者不允许执行相应的操作！ 返回该值不会导致应用因为没权限而 crash！ 1public static final int MODE_DEFAULT = 3; 该值是 checkOp/noteOp/startOp 方法的返回结果之一，表示给定的调用者应该进行权限检查。这种模式通常不被使用; 它只能与 appop 权限一起使用，调用者必须明确检查并处理它。 1public static final int MODE_ERRORED = 2; 该值是 checkOpNoThrow/noteOpNoThrow/startOpNoThrow 方法的返回结果之一，表示调用者不允许执行相应的操作！ 返回该值的同时，会抛出异常 SecurityException，导致应用因为没权限而 crash！ 1.3 属性相关方法1.3.1 opToSwitch123public static int opToSwitch(int op) &#123; return sOpToSwitch[op];&#125; 该方法会返回控制给定 op 的 op 开关（也是一个 op） 1.3.2 opToName12345678910111213public static String opToName(int op) &#123; if (op == OP_NONE) return \"NONE\"; return op &lt; sOpNames.length ? sOpNames[op] : (\"Unknown(\" + op + \")\");&#125;public static int strDebugOpToOp(String op) &#123; for (int i=0; i&lt;sOpNames.length; i++) &#123; if (sOpNames[i].equals(op)) &#123; return i; &#125; &#125; throw new IllegalArgumentException(\"Unknown operation string: \" + op);&#125; 上述两个方法用于在给定 op 和其对应的字符串名称之间相互转换，用于 debug，通过数组 sOpNames 获得对应的！ 1.3.3 opToName123public static String opToPermission(int op) &#123; return sOpPerms[op];&#125; 该方法会返回给定 op 对应的权限，如果没有返回 null，通过数组 sOpPerms 获得权限！ 1.3.4 opToRestriction123public static String opToRestriction(int op) &#123; return sOpRestrictions[op];&#125; 该方法会返回和给定 op 相关联的用户限制，如果没有返回 null，通过数组 sOpRestrictions 获得权限！ 1.3.5 permissionToOpCode1234public static int permissionToOpCode(String permission) &#123; Integer boxedOpCode = sRuntimePermToOp.get(permission); return boxedOpCode != null ? boxedOpCode : OP_NONE;&#125; 该方法会返回和指定运行时权限相关联的 Operation，如果没有返回 null，通过数组 sRuntimePermToOp 获得权限！ 1.3.6 opAllowSystemBypassRestriction123public static boolean opAllowSystemBypassRestriction(int op) &#123; return sOpAllowSystemRestrictionBypass[op];&#125; 该方法用于判断指定的 Op 是否允许系统（和系统UI）绕过用户对操作的限制！ 1.3.7 opToDefaultMode123public static int opToDefaultMode(int op) &#123; return sOpDefaultMode[op];&#125; 该方法用于返回指定的 op 的默认控制情况！ 1.3.8 opAllowsReset1234/** @hide */public static boolean opAllowsReset(int op) &#123; return !sOpDisableReset[op];&#125; 该方法用于判断指定的 op 的是否允许自身的状态被重置！ 1.3.9 permissionToOp12345678/** @hide */public static String permissionToOp(String permission) &#123; final Integer opCode = sRuntimePermToOp.get(permission); if (opCode == null) &#123; return null; &#125; return sOpToString[opCode];&#125; 该方法用于获得指定的 permission 对应的 op 的名称！ 1.3.10 strOpToOp12345678/** @hide */public static int strOpToOp(String op) &#123; Integer val = sOpStrToOp.get(op); if (val == null) &#123; throw new IllegalArgumentException(\"Unknown operation string: \" + op); &#125; return val;&#125; 该方法用于获得指定的 op 字符串名称对应的 Operation Code！ #2 重要函数和接口 AppOpsManager 提供了大量的接口，用于设置和检查权限： 2.1 setUidMode 相关方法设置 uid 的 mode： 123456789101112131415161718/** @hide */public void setUidMode(int code, int uid, int mode) &#123; try &#123; mService.setUidMode(code, uid, mode); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;/** @hide */@SystemApipublic void setUidMode(String appOp, int uid, int mode) &#123; try &#123; mService.setUidMode(AppOpsManager.strOpToOp(appOp), uid, mode); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; setUidMode 方法能够给属于该 uid 的所有应用程序的指定 op 设置控制状态！ 2.2 setUserRestriction 相关方法设置用户限制：12345678910111213141516171819202122/** @hide */public void setUserRestriction(int code, boolean restricted, IBinder token) &#123; //【1】调用了第二个方法！ setUserRestriction(code, restricted, token, /*exceptionPackages*/null);&#125;/** @hide */public void setUserRestriction(int code, boolean restricted, IBinder token, String[] exceptionPackages) &#123; //【2】调用了第三个方法！ setUserRestrictionForUser(code, restricted, token, exceptionPackages, mContext.getUserId());&#125;/** @hide */public void setUserRestrictionForUser(int code, boolean restricted, IBinder token, String[] exceptionPackages, int userId) &#123; try &#123; mService.setUserRestriction(code, restricted, token, userId, exceptionPackages); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; setUserRestriction 方法用于给指定的 op 设置用户限制！ 2.3 checkOp 相关方法检查权限： 123456789101112131415public int checkOp(String op, int uid, String packageName) &#123; return checkOp(strOpToOp(op), uid, packageName);&#125;public int checkOp(int op, int uid, String packageName) &#123; try &#123; int mode = mService.checkOperation(op, uid, packageName); if (mode == MODE_ERRORED) &#123; throw new SecurityException(buildSecurityExceptionMsg(op, uid, packageName)); &#125; return mode; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; checkOp 用于判断 package 是否允许执行相应的操作，如果不允许，会抛出 SecurityException 异常 123456789101112public int checkOpNoThrow(String op, int uid, String packageName) &#123; return checkOpNoThrow(strOpToOp(op), uid, packageName);&#125;/** @hide */public int checkOpNoThrow(int op, int uid, String packageName) &#123; try &#123; return mService.checkOperation(op, uid, packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; checkOpNoThrow 用于判断 package 是否允许执行相应的操作，如果不允许，不会抛出 SecurityException 异常，会返回 MODE_ERRORED！ 2.4 noteOp 相关方法检查权限，在检验后会做记录校验结果： 12345678910111213141516public int noteOp(String op, int uid, String packageName) &#123; return noteOp(strOpToOp(op), uid, packageName);&#125;/** @hide */ public int noteOp(int op, int uid, String packageName) &#123; try &#123; int mode = mService.noteOperation(op, uid, packageName); if (mode == MODE_ERRORED) &#123; throw new SecurityException(buildSecurityExceptionMsg(op, uid, packageName)); &#125; return mode; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; noteOp 和 checkOp 类似，但是在检验后会做记录校验结果，在结果为 MODE_ERRORED 的情况下，会抛出异常 SecurityException。 123456789101112public int noteOpNoThrow(String op, int uid, String packageName) &#123; return noteOpNoThrow(strOpToOp(op), uid, packageName);&#125;/** @hide */public int noteOpNoThrow(int op, int uid, String packageName) &#123; try &#123; return mService.noteOperation(op, uid, packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; noteOp 用于判断 package 是否允许执行相应的操作，在结果为 MODE_ERRORED 的情况下，不会抛出异常 SecurityException。 2.5 noteProxyOp 相关方法检查跨进程 ipc 通信时，调用方 proxiedPackageName 是否有权限，在检验后会做记录校验结果： 1234567891011public int noteProxyOp(int op, String proxiedPackageName) &#123; //【1】调用另外一个 noteProxyOpNoThrow 方法！ int mode = noteProxyOpNoThrow(op, proxiedPackageName); if (mode == MODE_ERRORED) &#123; throw new SecurityException(\"Proxy package \" + mContext.getOpPackageName() + \" from uid \" + Process.myUid() + \" or calling package \" + proxiedPackageName + \" from uid \" + Binder.getCallingUid() + \" not allowed to perform \" + sOpNames[op]); &#125; return mode;&#125; 另外一个方法：123456789public int noteProxyOpNoThrow(int op, String proxiedPackageName) &#123; try &#123; //【1】调用服务端的 noteProxyOperation 方法！ return mService.noteProxyOperation(op, mContext.getOpPackageName(), Binder.getCallingUid(), proxiedPackageName); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 不多说了！ 2.6 startOp 相关方法用于监控长时间的 op 操作！ 12345678910111213141516/** @hide */public int startOp(int op) &#123; return startOp(op, Process.myUid(), mContext.getOpPackageName());&#125;public int startOp(int op, int uid, String packageName) &#123; try &#123; int mode = mService.startOperation(getToken(mService), op, uid, packageName); if (mode == MODE_ERRORED) &#123; throw new SecurityException(buildSecurityExceptionMsg(op, uid, packageName)); &#125; return mode; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; startOp 用于报告应用程序已开始执行长时间运行的操作。 必须同时传入要检查的应用程序的 uid 和 packageName; 这个函数将验证这两个匹配，如果不匹配，则返回 MODE_IGNORED 。 如果此调用成功，则此应用程序的最后执行时间将更新为当前时间，并且该操作将被标记为 “正在运行”。 在这种情况下，稍后必须调用 finishOp 来报告应用程序何时不再执行操作。 12345678/** @hide */public int startOpNoThrow(int op, int uid, String packageName) &#123; try &#123; return mService.startOperation(getToken(mService), op, uid, packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; startOpNoThrow 和 startOp 类似，只是当结果为 MODE_ERRORED 时，不会抛出异常！ startOpNoThrow 方法调用的是 AppOpsService 的 startOperation 方法，第一个参数传入的是 getToken(mService)，这个方法会返回一个 ClientState 对象！ 2.7 finishOp 相关方法结束 startOp 方法监控的操作： 1234567891011121314151617/** @hide */public void finishOp(int op) &#123; finishOp(op, Process.myUid(), mContext.getOpPackageName());&#125;public void finishOp(String op, int uid, String packageName) &#123; finishOp(strOpToOp(op), uid, packageName);&#125;/** @hide */public void finishOp(int op, int uid, String packageName) &#123; try &#123; mService.finishOperation(getToken(mService), op, uid, packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 报告应用程序不再执行之前使用 startOp 开始的操作，此处提供的参数必须与 startOp 时传递的参数完全相同。 2.8 startWatchingMode 相关方法这里我们一起看下 stopWatchingMode 方法！ startWatchingMode 方法 12345678910111213141516171819202122232425262728public void startWatchingMode(String op, String packageName, final OnOpChangedListener callback) &#123; startWatchingMode(strOpToOp(op), packageName, callback);&#125;/** @hide */public void startWatchingMode(int op, String packageName, final OnOpChangedListener callback) &#123; synchronized (mModeWatchers) &#123; IAppOpsCallback cb = mModeWatchers.get(callback); if (cb == null) &#123; cb = new IAppOpsCallback.Stub() &#123; public void opChanged(int op, int uid, String packageName) &#123; if (callback instanceof OnOpChangedInternalListener) &#123; ((OnOpChangedInternalListener)callback).onOpChanged(op, packageName); &#125; if (sOpToString[op] != null) &#123; callback.onOpChanged(sOpToString[op], packageName); &#125; &#125; &#125;; mModeWatchers.put(callback, cb); &#125; try &#123; //【1】调用了 AppOpsService 的相关接口！ mService.startWatchingMode(op, packageName, cb); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; startWatchingMode 监视给定应用程序中给定操作的模式的变化！当发生变化后会回调 OnOpChangedListener 接口！ stopWatchingMode 方法 123456789101112public void stopWatchingMode(OnOpChangedListener callback) &#123; synchronized (mModeWatchers) &#123; IAppOpsCallback cb = mModeWatchers.get(callback); if (cb != null) &#123; try &#123; mService.stopWatchingMode(cb); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125;&#125; 停止监控。 与 callback 回调相关的所有监控都将被删除！ 2.9 setMode 相关方法同样是设置 op 的 mode，setMode 方法选择更多些： 12345678/** @hide */public void setMode(int code, int uid, String packageName, int mode) &#123; try &#123; mService.setMode(code, uid, packageName, mode); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AppOps应用操作管理","slug":"AndroidFramework源码分析/AppOps应用操作管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AppOps应用操作管理/"}],"tags":[{"name":"AppOps应用操作管理","slug":"AppOps应用操作管理","permalink":"https://coolqi.top/tags/AppOps应用操作管理/"}]},{"title":"Permission第 4 篇 - requestPermission 权限申请","slug":"Permission4-requestPermission","date":"2017-08-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/08/13/Permission4-requestPermission/","link":"","permalink":"https://coolqi.top/2017/08/13/Permission4-requestPermission/","excerpt":"","text":"[TOC] 0 综述基于 Android 7.1.1 源码，分析系统的权限管理机制！ 我们来分析下 dangerous 权限的申请，这类权限只能在 Activity 中申请，Activity 提供了如下接口，来帮助程序申请权限： 1 Activity.requestPermissions - 请求入口123456789101112public final void requestPermissions(@NonNull String[] permissions, int requestCode) &#123; if (mHasCurrentPermissionsRequest) &#123; Log.w(TAG, \"Can reqeust only one set of permissions at a time\"); //【1】防止同一时间多次申请权限！ onRequestPermissionsResult(requestCode, new String[0], new int[0]); return; &#125; //【2】设置了发送给 packageInstaller 的 intent！ Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions); startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null); mHasCurrentPermissionsRequest = true;&#125; 1.1 PackageManager.buildRequestPermissionsIntent123456789public Intent buildRequestPermissionsIntent(@NonNull String[] permissions) &#123; if (ArrayUtils.isEmpty(permissions)) &#123; throw new IllegalArgumentException(\"permission cannot be null or empty\"); &#125; Intent intent = new Intent(ACTION_REQUEST_PERMISSIONS); intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions); intent.setPackage(getPermissionControllerPackageName()); return intent;&#125; 这里创建了一个 intent，action 为 android.content.pm.action.REQUEST_PERMISSIONS，同时用 intent 封装了权限信息！123456@SystemApipublic static final String ACTION_REQUEST_PERMISSIONS = \"android.content.pm.action.REQUEST_PERMISSIONS\"; // hide@SystemApipublic static final String EXTRA_REQUEST_PERMISSIONS_NAMES = \"android.content.pm.extra.REQUEST_PERMISSIONS_NAMES\"; 接下来，我们要问，谁会接受这个 intent 呢？ 下面还调用了 getPermissionControllerPackageName 方法，设置了 intent 的接收者123456@Overridepublic String getPermissionControllerPackageName() &#123; synchronized (mPackages) &#123; return mRequiredInstallerPackage; // 就是 PackageInstaller！ &#125;&#125; 就是 PackageInstaller，我们需要进入 PackageInstaller，分析接下来的逻辑！ 2 PackageInstaller.GrantPermissionsActivity通过分析 PackageInstaller 的代码，我们知道了 GrantPermissionsActivity 会接受该 intent！ 123456789&lt;activity android:name=\".permission.ui.GrantPermissionsActivity\" android:configChanges=\"orientation|keyboardHidden|screenSize\" android:excludeFromRecents=\"true\" android:theme=\"@style/GrantPermissions\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.content.pm.action.REQUEST_PERMISSIONS\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; GrantPermissionsActivity 虽然是一个 Activity，但实际的现实效果是一个 Dialog，下面我们会一个一个分析！ 2.1 GrantPermissionsActivity.onCreate我们去 onCreate 方法中去看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class GrantPermissionsActivity extends OverlayTouchActivity implements GrantPermissionsViewHandler.ResultListener &#123; @Override public void onCreate(Bundle icicle) &#123; super.onCreate(icicle); setFinishOnTouchOutside(false); setTitle(R.string.permission_request_title); // 根据不同的设备类型进行不同的操作！ if (DeviceUtils.isTelevision(this)) &#123; mViewHandler = new com.android.packageinstaller.permission.ui.television .GrantPermissionsViewHandlerImpl(this).setResultListener(this); &#125; else if (DeviceUtils.isWear(this)) &#123; mViewHandler = new GrantPermissionsWatchViewHandler(this).setResultListener(this); &#125; else &#123; //【2.1.1】对于 Android 来说，进入这里，创建了一个 GrantPermissionsViewHandlerImpl，用于显示权限弹窗 // 以及和处理和弹窗相关的逻辑！ mViewHandler = new com.android.packageinstaller.permission.ui.handheld .GrantPermissionsViewHandlerImpl(this).setResultListener(this); &#125; //【1】获得应用本次要请求的运行时权限！ mRequestedPermissions = getIntent().getStringArrayExtra( PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES); if (mRequestedPermissions == null) &#123; mRequestedPermissions = new String[0]; &#125; //【2】创建每个权限对应的授结果况数组，默认值为！ final int requestedPermCount = mRequestedPermissions.length; mGrantResults = new int[requestedPermCount]; Arrays.fill(mGrantResults, PackageManager.PERMISSION_DENIED); if (requestedPermCount == 0) &#123; // 如果请求权限的数量为 0 ，无法申请！ //【2.1.2】调用 setResultAndFinish 结束申请！ setResultAndFinish(); return; &#125; //【2.1.3】获得请求的应用程序信息 PackageInfo callingPackageInfo = getCallingPackageInfo(); // 如果应用程序不存在，或者应用程序没有申请权限，无法申请！ if (callingPackageInfo == null || callingPackageInfo.requestedPermissions == null || callingPackageInfo.requestedPermissions.length &lt;= 0) &#123; setResultAndFinish(); return; &#125; // 如果应用程序的 targetSdkVersion 低于 Android M，不能申请运行时权限，直接取消！ if (callingPackageInfo.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123; mRequestedPermissions = new String[0]; mGrantResults = new int[0]; setResultAndFinish(); return; &#125; //【2.1.4】通过 DevicePolicyManager 获得设备对于权限的配置，然后根据配置信息，更新运行时权限的默认状态！ DevicePolicyManager devicePolicyManager = getSystemService(DevicePolicyManager.class); final int permissionPolicy = devicePolicyManager.getPermissionPolicy(null); updateDefaultResults(callingPackageInfo, permissionPolicy); //【2.1.5】创建了一个 AppPermissions 对象！ mAppPermissions = new AppPermissions(this, callingPackageInfo, null, false, new Runnable() &#123; @Override public void run() &#123; setResultAndFinish(); &#125; &#125;); //【3】接着遍历本次请求的所有运行时权限！ for (String requestedPermission : mRequestedPermissions) &#123; AppPermissionGroup group = null; //【3.1】找到该运行时权限所在的 group，我们会授予该组内的所有运行时权限！ for (AppPermissionGroup nextGroup : mAppPermissions.getPermissionGroups()) &#123; if (nextGroup.hasPermission(requestedPermission)) &#123; group = nextGroup; break; &#125; &#125; if (group == null) &#123; continue; &#125; //【2.1.6】处理那些没有被 fix 的需要提醒的权限！ if (!group.isUserFixed() &amp;&amp; !group.isPolicyFixed()) &#123; // 根据设备配置，对权限做不同的处理！ switch (permissionPolicy) &#123; case DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT: &#123; // 如果设备策略管理设定的是自动授予， // 如果该 group 中有权限未授予，那就授予他们！ if (!group.areRuntimePermissionsGranted()) &#123; group.grantRuntimePermissions(false); &#125; group.setPolicyFixed(); // 设置 policy fix 标志，不再提醒！ &#125; break; case DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY: &#123; // 如果设备策略管理设定的是自动拒绝， // 如果该 group 中有权限已授予，那就拒绝他们！ if (group.areRuntimePermissionsGranted()) &#123; group.revokeRuntimePermissions(false); &#125; group.setPolicyFixed(); &#125; break; default: &#123; // 如果设备策略管理设定的是其他策略（也是正常情况）， // 如果 group 中有权限未授予，那就将其添加到 mRequestGrantPermissionGroups，接下来要申请！ // 如果 group 中有权限已授予，那就授予所有的权限，并更新授予结果； if (!group.areRuntimePermissionsGranted()) &#123; mRequestGrantPermissionGroups.put(group.getName(), new GroupState(group)); &#125; else &#123; group.grantRuntimePermissions(false); updateGrantResults(group); // 更新申请结果 &#125; &#125; break; &#125; &#125; else &#123; // 如果权限已经被 fix，不用再提醒，那就直接更新权限的申请结果！ updateGrantResults(group); &#125; &#125; //【2.1.7】显示权限申请弹窗界面！ setContentView(mViewHandler.createView()); Window window = getWindow(); WindowManager.LayoutParams layoutParams = window.getAttributes(); mViewHandler.updateWindowAttributes(layoutParams); window.setAttributes(layoutParams); //【2.1.8】显示权限请求 ui，处理权限的授予和拒绝！ if (!showNextPermissionGroupGrantRequest()) &#123; //【2.1.9】返回处理结果！ setResultAndFinish(); &#125; &#125;&#125; 2.1.1 new GrantPermissionsViewHandlerImpl(this)有一个成员变量 private GrantPermissionsViewHandler mViewHandler，用于处理权限弹窗的显示和相关逻辑显示，在 onCreate 方法中，首先会创建一个 GrantPermissionsViewHandlerImpl 对象！12345678public final class GrantPermissionsViewHandlerImpl implements GrantPermissionsViewHandler, OnClickListener &#123; public GrantPermissionsViewHandlerImpl(Context context) &#123; mContext = context; &#125; &#125; 同时，又调用了 setResultListener，设置监听器！ 12345@Overridepublic GrantPermissionsViewHandlerImpl setResultListener(ResultListener listener) &#123; mResultListener = listener; return this;&#125; 这里的 ResultListener 就是 GrantPermissionsActivity，因为其实现了 ResultListener 接口！ 2.1.2 GrantPermissionsActivity.setResultAndFinish当遇到一些特殊情况，不能继续申请权限的时候，我们会调用 setResultAndFinish 结束申请！ 1234private void setResultAndFinish() &#123; setResultIfNeeded(RESULT_OK); finish();&#125; 继续调用了 setResultIfNeeded 方法！1234567891011private void setResultIfNeeded(int resultCode) &#123; if (!mResultSet) &#123; mResultSet = true; logRequestedPermissionGroups(); Intent result = new Intent(PackageManager.ACTION_REQUEST_PERMISSIONS); result.putExtra(PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES, mRequestedPermissions); result.putExtra(PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS, mGrantResults); // 调用 Activity.setResult 方法！ setResult(resultCode, result); &#125;&#125; 2.1.3 GrantPermissionsActivity.getCallingPackageInfo该方法用于获得申请运行时权限的应用的 PackageInfo 对象！12345678910private PackageInfo getCallingPackageInfo() &#123; try &#123; //【2.1.3.1】最终调用 PMS 的 getPackageInfo 方法！ return getPackageManager().getPackageInfo(getCallingPackage(), PackageManager.GET_PERMISSIONS); &#125; catch (NameNotFoundException e) &#123; Log.i(LOG_TAG, \"No package: \" + getCallingPackage(), e); return null; &#125;&#125; PackageManager.GET_PERMISSIONS 标志是为了限制查询到的数据的量！ 2.1.3.1 PackageManagerS.getPackageInfoflags 传入 PackageManager.GET_PERMISSIONS！12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic PackageInfo getPackageInfo(String packageName, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; flags = updateFlagsForPackage(flags, userId, packageName); enforceCrossUserPermission(Binder.getCallingUid(), userId, false /* requireFullPermission */, false /* checkShell */, \"get package info\"); synchronized (mPackages) &#123; // 如果 package 重命名过，返回旧名字！ packageName = normalizePackageNameLPr(packageName); final boolean matchFactoryOnly = (flags &amp; MATCH_FACTORY_ONLY) != 0; PackageParser.Package p = null; if (matchFactoryOnly) &#123; final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(packageName); if (ps != null) &#123; return generatePackageInfo(ps, flags, userId); &#125; &#125; // 从 PMS.mPackages 中获取扫描解析后的 PackageParser.Package 对象！ if (p == null) &#123; p = mPackages.get(packageName); if (matchFactoryOnly &amp;&amp; p != null &amp;&amp; !isSystemApp(p)) &#123; return null; &#125; &#125; if (DEBUG_PACKAGE_INFO) Log.v(TAG, \"getPackageInfo \" + packageName + \": \" + p); if (p != null) &#123; //【2.1.3.2】如果有扫描结果，那就调用 generatePackageInfo 返回包信息！ return generatePackageInfo((PackageSetting)p.mExtras, flags, userId); &#125; // 如果没有扫描结果，那么我们从上一次的安装信息中获取包信息！ if (!matchFactoryOnly &amp;&amp; (flags &amp; MATCH_UNINSTALLED_PACKAGES) != 0) &#123; final PackageSetting ps = mSettings.mPackages.get(packageName); return generatePackageInfo(ps, flags, userId); &#125; &#125; return null;&#125; 流程很简单，不多说了！ 2.1.3.2 PackageManagerS.generatePackageInfo12345678910111213141516171819202122232425private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; if (ps == null) &#123; return null; &#125; // 获得扫描信息！ final PackageParser.Package p = ps.pkg; if (p == null) &#123; return null; &#125; // 获得该 package 的权限状态信息！ final PermissionsState permissionsState = ps.getPermissionsState(); // 如果 flags 设置了 GET_GIDS，说明我们要获得 gids 信息，那就计算 gid！ final int[] gids = (flags &amp; PackageManager.GET_GIDS) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(userId); // 获取应用已经被授予的所有权限！ final Set&lt;String&gt; permissions = ArrayUtils.isEmpty(p.requestedPermissions) ? Collections.&lt;String&gt;emptySet() : permissionsState.getPermissions(userId); // 获取应用在当前 userId 下的状态信息！ final PackageUserState state = ps.readUserState(userId); //【2.1.3.3】继续调用 generatePackageInfo！ return PackageParser.generatePackageInfo(p, gids, flags, ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);&#125; 继续看： 2.1.3.3 PackageManagerS.generatePackageInfo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public static PackageInfo generatePackageInfo(PackageParser.Package p, int gids[], int flags, long firstInstallTime, long lastUpdateTime, Set&lt;String&gt; grantedPermissions, PackageUserState state, int userId) &#123; if (!checkUseInstalledOrHidden(flags, state) || !p.isMatch(flags)) &#123; return null; &#125; //【1】创建了一个 PackageInfo 对象，保存应用的包信息的拷贝！ PackageInfo pi = new PackageInfo(); pi.packageName = p.packageName; pi.splitNames = p.splitNames; pi.versionCode = p.mVersionCode; pi.baseRevisionCode = p.baseRevisionCode; pi.splitRevisionCodes = p.splitRevisionCodes; pi.versionName = p.mVersionName; pi.sharedUserId = p.mSharedUserId; pi.sharedUserLabel = p.mSharedUserLabel; pi.applicationInfo = generateApplicationInfo(p, flags, state, userId); pi.installLocation = p.installLocation; pi.coreApp = p.coreApp; if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0 || (pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) &#123; pi.requiredForAllUsers = p.mRequiredForAllUsers; &#125; pi.restrictedAccountType = p.mRestrictedAccountType; pi.requiredAccountType = p.mRequiredAccountType; pi.overlayTarget = p.mOverlayTarget; pi.firstInstallTime = firstInstallTime; pi.lastUpdateTime = lastUpdateTime; //【2】根据 flags 设置的标志位，获取标志为对应的信息！ if ((flags&amp;PackageManager.GET_GIDS) != 0) &#123; pi.gids = gids; &#125; if ((flags&amp;PackageManager.GET_CONFIGURATIONS) != 0) &#123; int N = p.configPreferences != null ? p.configPreferences.size() : 0; if (N &gt; 0) &#123; pi.configPreferences = new ConfigurationInfo[N]; p.configPreferences.toArray(pi.configPreferences); &#125; N = p.reqFeatures != null ? p.reqFeatures.size() : 0; if (N &gt; 0) &#123; pi.reqFeatures = new FeatureInfo[N]; p.reqFeatures.toArray(pi.reqFeatures); &#125; N = p.featureGroups != null ? p.featureGroups.size() : 0; if (N &gt; 0) &#123; pi.featureGroups = new FeatureGroupInfo[N]; p.featureGroups.toArray(pi.featureGroups); &#125; &#125; if ((flags &amp; PackageManager.GET_ACTIVITIES) != 0) &#123; final int N = p.activities.size(); if (N &gt; 0) &#123; int num = 0; final ActivityInfo[] res = new ActivityInfo[N]; for (int i = 0; i &lt; N; i++) &#123; final Activity a = p.activities.get(i); if (state.isMatch(a.info, flags)) &#123; res[num++] = generateActivityInfo(a, flags, state, userId); &#125; &#125; pi.activities = ArrayUtils.trimToSize(res, num); &#125; &#125; if ((flags &amp; PackageManager.GET_RECEIVERS) != 0) &#123; final int N = p.receivers.size(); if (N &gt; 0) &#123; int num = 0; final ActivityInfo[] res = new ActivityInfo[N]; for (int i = 0; i &lt; N; i++) &#123; final Activity a = p.receivers.get(i); if (state.isMatch(a.info, flags)) &#123; res[num++] = generateActivityInfo(a, flags, state, userId); &#125; &#125; pi.receivers = ArrayUtils.trimToSize(res, num); &#125; &#125; if ((flags &amp; PackageManager.GET_SERVICES) != 0) &#123; final int N = p.services.size(); if (N &gt; 0) &#123; int num = 0; final ServiceInfo[] res = new ServiceInfo[N]; for (int i = 0; i &lt; N; i++) &#123; final Service s = p.services.get(i); if (state.isMatch(s.info, flags)) &#123; res[num++] = generateServiceInfo(s, flags, state, userId); &#125; &#125; pi.services = ArrayUtils.trimToSize(res, num); &#125; &#125; if ((flags &amp; PackageManager.GET_PROVIDERS) != 0) &#123; final int N = p.providers.size(); if (N &gt; 0) &#123; int num = 0; final ProviderInfo[] res = new ProviderInfo[N]; for (int i = 0; i &lt; N; i++) &#123; final Provider pr = p.providers.get(i); if (state.isMatch(pr.info, flags)) &#123; res[num++] = generateProviderInfo(pr, flags, state, userId); &#125; &#125; pi.providers = ArrayUtils.trimToSize(res, num); &#125; &#125; if ((flags&amp;PackageManager.GET_INSTRUMENTATION) != 0) &#123; int N = p.instrumentation.size(); if (N &gt; 0) &#123; pi.instrumentation = new InstrumentationInfo[N]; for (int i=0; i&lt;N; i++) &#123; pi.instrumentation[i] = generateInstrumentationInfo( p.instrumentation.get(i), flags); &#125; &#125; &#125; // 因为我们只设置了 GET_PERMISSIONS，所以只会手机和权限相关的信息！ if ((flags&amp;PackageManager.GET_PERMISSIONS) != 0) &#123; // 处理该应用定义的所有权限！ int N = p.permissions.size(); if (N &gt; 0) &#123; pi.permissions = new PermissionInfo[N]; for (int i=0; i&lt;N; i++) &#123; pi.permissions[i] = generatePermissionInfo(p.permissions.get(i), flags); &#125; &#125; // 处理该应用请求的所有权限！ N = p.requestedPermissions.size(); if (N &gt; 0) &#123; pi.requestedPermissions = new String[N]; pi.requestedPermissionsFlags = new int[N]; for (int i=0; i&lt;N; i++) &#123; final String perm = p.requestedPermissions.get(i); // requestedPermissions[i] 表示应用申请的权限名； pi.requestedPermissions[i] = perm; // requestedPermissionsFlags[i] 表示应用申请的权限的授予情况； // 开始默认初始化为需要再次请求，然后比较该权限是否已经被授予，如果授予，改为授予状态！ pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_REQUIRED; if (grantedPermissions != null &amp;&amp; grantedPermissions.contains(perm)) &#123; pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_GRANTED; &#125; &#125; &#125; &#125; if ((flags&amp;PackageManager.GET_SIGNATURES) != 0) &#123; int N = (p.mSignatures != null) ? p.mSignatures.length : 0; if (N &gt; 0) &#123; pi.signatures = new Signature[N]; System.arraycopy(p.mSignatures, 0, pi.signatures, 0, N); &#125; &#125; return pi;&#125; 最后，返回的是一个 PackageInfo 对象！ 2.1.4 GrantPermissionsActivity.updateDefaultResults更新下权限的默认授予情况！1234567891011private void updateDefaultResults(PackageInfo callingPackageInfo, int permissionPolicy) &#123; final int requestedPermCount = mRequestedPermissions.length; for (int i = 0; i &lt; requestedPermCount; i++) &#123; String permission = mRequestedPermissions[i]; //【2.1.3.1 】如果申请应用的信息存在，那么会调用 computePermissionGrantState 方法，获得权限的默认授予状态！ // 否则，所有运行时权限默认为 deny！ mGrantResults[i] = callingPackageInfo != null ? computePermissionGrantState(callingPackageInfo, permission, permissionPolicy) : PERMISSION_DENIED; &#125;&#125; 关键的实现是在 computePermissionGrantState 中！ 2.1.4.1 GrantPermissionsActivity.computePermissionGrantState该方法用于根据参数，计算该运行时权限的授予情况，这里的 permission 是应用本次申请的运行时权限！1234567891011121314151617181920212223242526272829303132333435363738394041private int computePermissionGrantState(PackageInfo callingPackageInfo, String permission, int permissionPolicy) &#123; boolean permissionRequested = false; //【1】如果运行时权限 permission 在 package 请求权限列表中 // 并且已经授予，那么就返回 PERMISSION_GRANTED！ for (int i = 0; i &lt; callingPackageInfo.requestedPermissions.length; i++) &#123; if (permission.equals(callingPackageInfo.requestedPermissions[i])) &#123; permissionRequested = true; if ((callingPackageInfo.requestedPermissionsFlags[i] &amp; PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0) &#123; return PERMISSION_GRANTED; &#125; break; &#125; &#125; //【2】申请的运行时权限，应用没有申明，返回 PERMISSION_DENIED！ if (!permissionRequested) &#123; return PERMISSION_DENIED; &#125; //【3】只有基本权限类型为 dangerous 的权限才需要动态申请，其他类型的权限，默认返回 PERMISSION_DENIED！ try &#123; PermissionInfo pInfo = getPackageManager().getPermissionInfo(permission, 0); if ((pInfo.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE) != PermissionInfo.PROTECTION_DANGEROUS) &#123; return PERMISSION_DENIED; &#125; &#125; catch (NameNotFoundException e) &#123; return PERMISSION_DENIED; &#125; //【4】根据 permissionPolicy 的值来处理权限的授予情况，如果是 PERMISSION_POLICY_AUTO_GRANT，表示自动授予； // 那么返回 PERMISSION_GRANTED，否则返回 PERMISSION_DENIED！ switch (permissionPolicy) &#123; case DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT: &#123; return PERMISSION_GRANTED; &#125; default: &#123; return PERMISSION_DENIED; &#125; &#125;&#125; 最后 computePermissionGrantState 的结果会保存 mGrantResults 数组中！ 不多说了！ 2.1.5 new AppPermissions - 封装 App 的权限请求信息这里的 onErrorCallback 是一个 Runnable，执行后会触发 setResultAndFinish 方法！ 1234567891011121314public AppPermissions(Context context, PackageInfo packageInfo, String[] permissions, boolean sortGroups, Runnable onErrorCallback) &#123; mContext = context; mPackageInfo = packageInfo; // 请求权限的应用的 PackageInfo 实例！ mFilterPermissions = permissions; // 传入 null； mAppLabel = BidiFormatter.getInstance().unicodeWrap( packageInfo.applicationInfo.loadSafeLabel( context.getPackageManager()).toString()); mSortGroups = sortGroups; // 传入 false； mOnErrorCallback = onErrorCallback; //【2.1.4.1】加载权限组信息！ loadPermissionGroups();&#125; mFilterPermissions 属性表示要过滤的权限，这里我们传入的是 null； 同时，AppPermissions 还有如下的属性： 1234// 保存所有运行时权限所属的组信息 AppPermissionGroupprivate final ArrayList&lt;AppPermissionGroup&gt; mGroups = new ArrayList&lt;&gt;();// 保存组名和 AppPermissionGroup 的映射关系private final LinkedHashMap&lt;String, AppPermissionGroup&gt; mNameToGroupMap = new LinkedHashMap&lt;&gt;(); 2.1.5.1 AppPermissions.loadPermissionGroups加载权限组信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void loadPermissionGroups() &#123; mGroups.clear(); if (mPackageInfo.requestedPermissions == null) &#123; return; &#125; if (mFilterPermissions != null) &#123; //【1】mFilterPermissions 为 null，不进入！ for (String filterPermission : mFilterPermissions) &#123; for (String requestedPerm : mPackageInfo.requestedPermissions) &#123; if (!filterPermission.equals(requestedPerm)) &#123; // 过滤掉那些不是 filterPermission 的权限！ continue; &#125; if (hasGroupForPermission(requestedPerm)) &#123; break; &#125; AppPermissionGroup group = AppPermissionGroup.create(mContext, mPackageInfo, requestedPerm); if (group == null) &#123; break; &#125; mGroups.add(group); break; &#125; &#125; &#125; else &#123; //【2】遍历该 package 请求的所有权限（安装/运行）， for (String requestedPerm : mPackageInfo.requestedPermissions) &#123; //【2.1.4.1.1】判断是否已经有对应的 group 存在，存在的话，那就不处理！ if (hasGroupForPermission(requestedPerm)) &#123; continue; &#125; //【2.1.4.1.2】如果不存在，那就创建一个 AppPermissionGroup 对象，封装运行时权限所属的组信息！ AppPermissionGroup group = AppPermissionGroup.create(mContext, mPackageInfo, requestedPerm); if (group == null) &#123; continue; &#125; mGroups.add(group); //【2.1】添加到 mGroups 中！ &#125; &#125; if (mSortGroups) &#123; //【3】如果 mSortGroups 为 true，表示对 group 进行排序！ Collections.sort(mGroups); &#125; //【4】mNameToGroupMap 用于保存组名和 AppPermissionGroup 的映射关系！ mNameToGroupMap.clear(); for (AppPermissionGroup group : mGroups) &#123; mNameToGroupMap.put(group.getName(), group); &#125;&#125; 对于 mPackageInfo.requestedPermissions，不仅包含运行时权限，还包含安装时权限！ 2.1.5.1.1 AppPermissions.hasGroupForPermission加载权限组信息！123456789private boolean hasGroupForPermission(String permission) &#123; //【1】遍历所有的 AppPermissionGroup，如果 permission 在 group 的权限集合中，返回 true！ for (AppPermissionGroup group : mGroups) &#123; if (group.hasPermission(permission)) &#123; return true; &#125; &#125; return false;&#125; AppPermissions 内部有一个 mGroups，保存所有的权限组信息 AppPermissionGroup 实例！ 1234567public final class AppPermissionGroup implements Comparable&lt;AppPermissionGroup&gt; &#123; private final ArrayMap&lt;String, Permission&gt; mPermissions = new ArrayMap&lt;&gt;(); //【2】在该 group 中是否有该权限！ public boolean hasPermission(String permission) &#123; return mPermissions.get(permission) != null; &#125;&#125; AppPermissionGroup 内部有一个 mPermissions 哈希表，用于保存该 group 中所有权限的权限名和其 Permission 的映射关系！ 2.1.5.1.2 AppPermissionGroup.create[3] - 创建运行时权限组信息接下来我们看下，AppPermissionGroup 的创建，String permissionName 表示的是该 package 的申请的权限： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static AppPermissionGroup create(Context context, PackageInfo packageInfo, String permissionName) &#123; //【1】获得运行时权限的信息，找不到，返回 null； PermissionInfo permissionInfo; try &#123; permissionInfo = context.getPackageManager().getPermissionInfo(permissionName, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; return null; &#125; //【2】校验权限的类型，如果该权限的基本类型不是 dangerous 或者说权限的 flags 没有设置 FLAG_INSTALLED 属性 // 或者权限的 flags 设置了 FLAG_REMOVED 属性，那么，返回 null! if (permissionInfo.protectionLevel != PermissionInfo.PROTECTION_DANGEROUS || (permissionInfo.flags &amp; PermissionInfo.FLAG_INSTALLED) == 0 || (permissionInfo.flags &amp; PermissionInfo.FLAG_REMOVED) != 0) &#123; return null; &#125; //【3】查询该权限所属 group 的信息，如果权限的 group 属性不为 null，说明其有所属组； PackageItemInfo groupInfo = permissionInfo; if (permissionInfo.group != null) &#123; try &#123; groupInfo = context.getPackageManager().getPermissionGroupInfo( permissionInfo.group, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; /* ignore */ &#125; &#125; //【4】查询所有属于该 group 的权限信息，保存到 permissionInfos 列表中！！ // 注意这里的 permissionInfos 会包含应用没有申请的权限！ List&lt;PermissionInfo&gt; permissionInfos = null; if (groupInfo instanceof PermissionGroupInfo) &#123; try &#123; permissionInfos = context.getPackageManager().queryPermissionsByGroup( groupInfo.name, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; /* ignore */ &#125; &#125; //【2.1.4.1.3】创建 AppPermissionGroup 对象！！ return create(context, packageInfo, groupInfo, permissionInfos, Process.myUserHandle());&#125; 这里可以看到，流程【2】中，会排除掉所有的非 dangerous 类型的权限！ 在创建一个 group 的时候，会将属于该 group 的所有权限都查出来！！ 这里继续调用了五参数的 create 方法！ 2.1.5.1.3 AppPermissionGroup.create[5]继续调用 create 方法来创建 AppPermissionGroup 对象！ 参数分析： PackageInfo packageInfo：本次请求权限的 package 的 PackageInfo 对象； PackageItemInfo groupInfo：该 package 的请求的权限所属的组信息； List permissionInfos：属于该组的所有权限信息； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public static AppPermissionGroup create(Context context, PackageInfo packageInfo, PackageItemInfo groupInfo, List&lt;PermissionInfo&gt; permissionInfos, UserHandle userHandle) &#123; //【2.1.5.1.3.1】创建一个 AppPermissionGroup 对象，封装了 group name，label 相关信息！ AppPermissionGroup group = new AppPermissionGroup(context, packageInfo, groupInfo.name, groupInfo.packageName, groupInfo.loadLabel(context.getPackageManager()), loadGroupDescription(context, groupInfo), groupInfo.packageName, groupInfo.icon, userHandle); // 如果 groupInfo 不是权限组对象，而是一个运行时权限，那就添加到 permissionInfos 中！ if (groupInfo instanceof PermissionInfo) &#123; permissionInfos = new ArrayList&lt;&gt;(); permissionInfos.add((PermissionInfo) groupInfo); &#125; //【1】如果权限组没有权限，返回 null，该 group 无效！ if (permissionInfos == null || permissionInfos.isEmpty()) &#123; return null; &#125; //【2】遍历该 package 请求的所有权限（安装/运行）！ final int permissionCount = packageInfo.requestedPermissions.length; for (int i = 0; i &lt; permissionCount; i++) &#123; String requestedPermission = packageInfo.requestedPermissions[i]; PermissionInfo requestedPermissionInfo = null; //【2.1】如果应用请求的权限（安装/运行）中有权限属于该权限组，我们会处理该权限！ // permissionInfos 是该权限组中的所有权限，这里我们要过滤掉非应用申请的权限！ for (PermissionInfo permissionInfo : permissionInfos) &#123; if (requestedPermission.equals(permissionInfo.name)) &#123; requestedPermissionInfo = permissionInfo; break; &#125; &#125; if (requestedPermissionInfo == null) &#123; continue; &#125; //【2.2】我们只处理运行时权限，对于非 dangerous 权限，直接跳过！！ if (requestedPermissionInfo.protectionLevel != PermissionInfo.PROTECTION_DANGEROUS) &#123; continue; &#125; // Don't allow toggling non-platform permission groups for legacy apps via app ops. // 如果应用程序的 targetSdkVersion 不高于 Android 5.1，并且定义权限组的 package 不是 android！ // 不处理该运行时权限！ if (packageInfo.applicationInfo.targetSdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1 &amp;&amp; !PLATFORM_PACKAGE_NAME.equals(groupInfo.packageName)) &#123; continue; &#125; //【2.3】判断该运行时权限是否已经授予！ final boolean granted = (packageInfo.requestedPermissionsFlags[i] &amp; PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0; //【2.4】当该运行时权限的定义者不为系统时，appOp 为 null，如果为系统权限的话，匹配其对应的 AppOps， // 也有可能为 null！ final String appOp = PLATFORM_PACKAGE_NAME.equals(requestedPermissionInfo.packageName) ? AppOpsManager.permissionToOp(requestedPermissionInfo.name) : null; //【2.5】如果该系统权限有对应的 AppOps，获得其模式的值是否为 ALLOWED! final boolean appOpAllowed = appOp != null &amp;&amp; context.getSystemService(AppOpsManager.class).checkOpNoThrow(appOp, packageInfo.applicationInfo.uid, packageInfo.packageName) == AppOpsManager.MODE_ALLOWED; //【2.6】获得权限的 flags，可以取值为 user set,user fixed 等等！ final int flags = context.getPackageManager().getPermissionFlags( requestedPermission, packageInfo.packageName, userHandle); //【2.1.5.1.3.2】创建一个 Permission 对象，保存该运行时权限的信息！ Permission permission = new Permission(requestedPermission, granted, appOp, appOpAllowed, flags); //【2.1.5.1.3.3】添加到 AppPermissionGroup 中去！ group.addPermission(permission); &#125; return group;&#125; 到这里，AppPermissionGroup 就正式创建完了！ 2.1.5.1.3.1 new AppPermissionGroup创建了一个 AppPermissionGroup，封装运行时权限所在权限组信息！123456789101112131415161718192021222324252627public final class AppPermissionGroup implements Comparable&lt;AppPermissionGroup&gt; &#123; ... ... ... private AppPermissionGroup(Context context, PackageInfo packageInfo, String name, String declaringPackage, CharSequence label, CharSequence description, String iconPkg, int iconResId, UserHandle userHandle) &#123; mContext = context; mUserHandle = userHandle; mPackageManager = mContext.getPackageManager(); mPackageInfo = packageInfo; mAppSupportsRuntimePermissions = packageInfo.applicationInfo .targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1; // 该应用是否支持运行时权限！ mAppOps = context.getSystemService(AppOpsManager.class); mActivityManager = context.getSystemService(ActivityManager.class); mDeclaringPackage = declaringPackage; mName = name; mLabel = label; mDescription = description; if (iconResId != 0) &#123; mIconPkg = iconPkg; mIconResId = iconResId; &#125; else &#123; mIconPkg = context.getPackageName(); mIconResId = R.drawable.ic_perm_device_info; &#125; &#125; ... ... ...&#125; AppPermissionGroup 内部有一个 mPermissions 集合，负责管理该 group 中该 package 申请的权限！ 2.1.5.1.3.2 new Permission该 Permission 是 PackageInstaller 定义的一个类，和系统中的不一样！ Permission 用来封装一个运行时权限信息！12345678910111213141516public final class Permission &#123; private final String mName; private final String mAppOp; private boolean mGranted; // 是否已经授予该权限！ private boolean mAppOpAllowed; private int mFlags; public Permission(String name, boolean granted, String appOp, boolean appOpAllowed, int flags) &#123; mName = name; // mGranted = granted; mAppOp = appOp; mAppOpAllowed = appOpAllowed; mFlags = flags; &#125; 2.1.5.1.3.3 AppPermissionGroup.addPermission将该运行时权限添加到 AppPermissionGroup.mPermissions 中去！123private void addPermission(Permission permission) &#123; mPermissions.put(permission.getName(), permission);&#125; 2.1.6 处理运行时权限组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//【3】接着遍历本次请求的所有运行时权限！for (String requestedPermission : mRequestedPermissions) &#123; AppPermissionGroup group = null; //【3.1】找到该运行时权限所在的 group!！ for (AppPermissionGroup nextGroup : mAppPermissions.getPermissionGroups()) &#123; if (nextGroup.hasPermission(requestedPermission)) &#123; group = nextGroup; break; &#125; &#125; if (group == null) &#123; continue; &#125; //【2.1.6.1】处理那些 no fix 的需要提醒的权限！ if (!group.isUserFixed() &amp;&amp; !group.isPolicyFixed()) &#123; // 根据设备配置，对权限做不同的处理！ switch (permissionPolicy) &#123; case DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT: &#123; // 如果设备策略管理设定的是自动授予， //【2.1.6.2】且该 group 中有权限未授予，那就授予他们！ if (!group.areRuntimePermissionsGranted()) &#123; //【3.1】授予权限 group.grantRuntimePermissions(false); &#125; group.setPolicyFixed(); // 设置 policy fix 标志位 &#125; break; case DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY: &#123; // 如果设备策略管理设定的是自动拒绝， //【2.1.6.2】且该 group 中有权限已授予，那就拒绝他们！ if (group.areRuntimePermissionsGranted()) &#123; //【3.2】撤掉权限 group.revokeRuntimePermissions(false); &#125; group.setPolicyFixed(); // 设置 policy fix 标志位 &#125; break; default: &#123; // 如果设备策略管理设定的是其他策略（正常情况）， // 如果 group 中有权限未授予，那就将其添加到 mRequestGrantPermissionGroups，接下来要申请！ // 如果 group 中有权限已授予，那就授予所有的权限，并更新授予结果； if (!group.areRuntimePermissionsGranted()) &#123; // 同【2.1.6.2】 mRequestGrantPermissionGroups.put(group.getName(), new GroupState(group)); &#125; else &#123; //【3.1】直接授予运行时权限！ group.grantRuntimePermissions(false); updateGrantResults(group); // 更新申请结果！ &#125; &#125; break; &#125; &#125; else &#123; // 如果权限已经被 fix，不用再提醒，那就直接更新权限的申请结果！ updateGrantResults(group); &#125; ... ... ... ...&#125; 当然，一般情况下，我们会进入 default 分支！ 这里的 mRequestGrantPermissionGroups 用于保存所有的需要申请的 group 信息： 123456789101112private static final class GroupState &#123; static final int STATE_UNKNOWN = 0; static final int STATE_ALLOWED = 1; static final int STATE_DENIED = 2; final AppPermissionGroup mGroup; int mState = STATE_UNKNOWN; GroupState(AppPermissionGroup group) &#123; mGroup = group; &#125;&#125; AppPermissionGroup 会被封装为一个 GroupState 对象，GroupState.mState 保存了该组的授予情况！ 2.1.6.1 AppPermissionGroup.isUserFixed/isPolicyFixed判断该权限组中是否包含没被 user fix 的权限，如果包含，返回 false！ 1234567891011public boolean isUserFixed() &#123; final int permissionCount = mPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; Permission permission = mPermissions.valueAt(i); //【1】该权限组只要有一个 no user fix 的权限，那个这个组就是 no user fix 的！ if (!permission.isUserFixed()) &#123; return false; &#125; &#125; return true;&#125; 调用了 Permission.isUserFixed 方法！123public boolean isUserFixed() &#123; return (mFlags &amp; PackageManager.FLAG_PERMISSION_USER_FIXED) != 0;&#125; 同样的，isPolicyFixed 也是类似的作用，判断该权限组中是否包含没有被 policy fix 的权限！1234567891011public boolean isPolicyFixed() &#123; final int permissionCount = mPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; Permission permission = mPermissions.valueAt(i); //【1】该权限组中没有任何一个 policy fix 的权限，那个这个组才是 no policy fix 的！ if (permission.isPolicyFixed()) &#123; return true; &#125; &#125; return false;&#125; 这是因为 policy fix 属于系统的默认授予机制，针对整个组的权限！ 同样的调用了 Permission.isPolicyFixed 方法！123public boolean isPolicyFixed() &#123; return (mFlags &amp; PackageManager.FLAG_PERMISSION_POLICY_FIXED) != 0;&#125; 2.1.6.2 AppPermissionGroup.areRuntimePermissionsGranted该方法用户判断该 group 中是否有运行时权限被授予！123public boolean areRuntimePermissionsGranted() &#123; return areRuntimePermissionsGranted(null);&#125; 接着会调用一参数的 areRuntimePermissionsGranted 方法，参数的意思不多说了！123456789101112131415161718192021222324public boolean areRuntimePermissionsGranted(String[] filterPermissions) &#123; if (LocationUtils.isLocationGroupAndProvider(mName, mPackageInfo.packageName)) &#123; return LocationUtils.isLocationEnabled(mContext); &#125; //【1】遍历该组中的所有运行时权限，根据前面知道，该组中的权限都是该 package 申请的！ final int permissionCount = mPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; Permission permission = mPermissions.valueAt(i); if (filterPermissions != null // 如果 filterPermissions 不为 null，那就只处理其内部的权限！ &amp;&amp; !ArrayUtils.contains(filterPermissions, permission.getName())) &#123; continue; &#125; //【1.1】如果应用支持运行时权限机制，并且该权限已经被授予，那就返回 true！ if (mAppSupportsRuntimePermissions) &#123; if (permission.isGranted()) &#123; return true; &#125; &#125; else if (permission.isGranted() &amp;&amp; (permission.getAppOp() == null || permission.isAppOpAllowed())) &#123; return true; &#125; &#125; return false; // 如果该 group 中没有运行时权限被授予，返回 false！&#125; 如果有一个运行时权限被授予，那么就会返回 true！ 如果没有一个运行时权限被授予，那么就会返回 false！ 2.1.7 GPViewHandlerImpl.createView接着，通过 setContentView，创建布局界面！12345678910111213141516171819202122232425262728@Overridepublic View createView() &#123; mRootView = (ManualLayoutFrame) LayoutInflater.from(mContext) .inflate(R.layout.grant_permissions, null); mButtonBar = (ButtonBarLayout) mRootView.findViewById(R.id.button_group); mButtonBar.setAllowStacking(true); mMessageView = (TextView) mRootView.findViewById(R.id.permission_message); mIconView = (ImageView) mRootView.findViewById(R.id.permission_icon); mCurrentGroupView = (TextView) mRootView.findViewById(R.id.current_page_text); mDoNotAskCheckbox = (CheckBox) mRootView.findViewById(R.id.do_not_ask_checkbox); mAllowButton = (Button) mRootView.findViewById(R.id.permission_allow_button); mDialogContainer = (ViewGroup) mRootView.findViewById(R.id.dialog_container); mDescContainer = (ViewGroup) mRootView.findViewById(R.id.desc_container); mCurrentDesc = (ViewGroup) mRootView.findViewById(R.id.perm_desc_root); mAllowButton.setOnClickListener(this); // 授予按钮！ mRootView.findViewById(R.id.permission_deny_button).setOnClickListener(this); // 拒绝按钮！ mDoNotAskCheckbox.setOnClickListener(this); // 不在提醒按钮！ if (mGroupName != null) &#123; // mGroupName 用于恢复界面显示！ updateDescription(); updateGroup(); updateDoNotAskCheckBox(); &#125; return mRootView;&#125; 我们看到，这里给三个按钮绑定的点击事件！ 12345678910111213141516171819202122@Overridepublic void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.permission_allow_button: // 授予权限 if (mResultListener != null) &#123; view.clearAccessibilityFocus(); mResultListener.onPermissionGrantResult(mGroupName, true, false); &#125; break; case R.id.permission_deny_button: // 拒绝权限 mAllowButton.setEnabled(true); if (mResultListener != null) &#123; view.clearAccessibilityFocus(); mResultListener.onPermissionGrantResult(mGroupName, false, mShowDonNotAsk &amp;&amp; mDoNotAskCheckbox.isChecked()); &#125; break; case R.id.do_not_ask_checkbox: // 不再提醒 mAllowButton.setEnabled(!mDoNotAskCheckbox.isChecked()); break; &#125;&#125; 当我们点击 allow 或者 deny 后，会回调 mResultListener.onPermissionGrantResult 方法！ 当我们点击授予后，执行：1mResultListener.onPermissionGrantResult(mGroupName, true, false); 当我们点击拒绝后，执行：1mResultListener.onPermissionGrantResult(mGroupName, false, mShowDonNotAsk &amp;&amp; mDoNotAskCheckbox.isChecked()); onPermissionGrantResult 参数解析 onPermissionGrantResult 的第二个参数 granted 表示授予或者拒绝，为 true 表示授予，为 false 表示拒绝； onPermissionGrantResult 的第三个参数 doNotAskAgain 表示是否不再询问，为 true 表示不再询问，为 false 需再次询问； onPermissionGrantResult 参数处理 如果用户本次授予了权限，那么 doNotAskAgain 为 false，意味着下次会继续询问； 如果用户本次拒绝了权限，但是没有选择不再提醒，那么 doNotAskAgain 为 false，意味着下次会继续询问； 如果用户本次拒绝了权限，但是同时选择不再提醒，那么 doNotAskAgain 为 true，那么下次就不会再提醒询问了； 当我们点击不再提醒 CheckBox 后，可以看到，授予按钮是无法点击的！ 2.1.7.1 GrantPermissionsActivity.onPermissionGrantResultmResultListener 实际上就是 GrantPermissionsActivity，我们去看看 onPermissionGrantResult 方法！ 123456789101112131415161718192021@Overridepublic void onPermissionGrantResult(String name, boolean granted, boolean doNotAskAgain) &#123; //【1】根据 name 获得对应的运行时权限组！ GroupState groupState = mRequestGrantPermissionGroups.get(name); if (groupState.mGroup != null) &#123; if (granted) &#123; //【2.1.6.3】处理授予情况！ groupState.mGroup.grantRuntimePermissions(doNotAskAgain); groupState.mState = GroupState.STATE_ALLOWED; // 更新 group 状态！ &#125; else &#123; //【2.1.6.4】处理拒绝情况！ groupState.mGroup.revokeRuntimePermissions(doNotAskAgain); groupState.mState = GroupState.STATE_DENIED; &#125; updateGrantResults(groupState.mGroup); // 更新结果！ &#125; if (!showNextPermissionGroupGrantRequest()) &#123; //【2.1.8】继续下一个组的处理！ setResultAndFinish(); //【2.1.9】处理请求结果，结束！ &#125;&#125; 可以看到，对于每个组的运行时权限，最后调用的是 setResultAndFinish 会将权限处理的结果返回给请求的 activity！ 2.1.8 GPViewHandlerImpl.showNextPermissionGroupGrantRequest接下来，就是请求运行时权限了！mRequestGrantPermissionGroups 中保存了所有需要请求的运行时权限组！ 1234567891011121314151617181920212223242526272829303132333435private boolean showNextPermissionGroupGrantRequest() &#123; final int groupCount = mRequestGrantPermissionGroups.size(); int currentIndex = 0; for (GroupState groupState : mRequestGrantPermissionGroups.values()) &#123; if (groupState.mState == GroupState.STATE_UNKNOWN) &#123; CharSequence appLabel = mAppPermissions.getAppLabel(); Spanned message = Html.fromHtml(getString(R.string.permission_warning_template, appLabel, groupState.mGroup.getDescription()), 0); //【1】将权限信息作为 titile！ setTitle(message); Resources resources; try &#123; resources = getPackageManager().getResourcesForApplication( groupState.mGroup.getIconPkg()); &#125; catch (NameNotFoundException e) &#123; // Fallback to system. resources = Resources.getSystem(); &#125; int icon = groupState.mGroup.getIconResId(); //【2.1.8.1】更新 ui 显示！ mViewHandler.updateUi(groupState.mGroup.getName(), groupCount, currentIndex, Icon.createWithResource(resources, icon), message, groupState.mGroup.isUserSet()); return true; &#125; currentIndex++; &#125; return false;&#125; 最后会调用了 updateUi 方法，更新 ui 显示！ updateUi 的最后一个参数：boolean showDonNotAsk 表示是否显示 “不再提醒” 的 CheckBox，为 true，表示不显示，其值取决于：1groupState.mGroup.isUserSet() 我们去看看 group 的 isUserSet 方法！12345678910public boolean isUserSet() &#123; final int permissionCount = mPermissions.size(); for (int i = 0; i &lt; permissionCount; i++) &#123; Permission permission = mPermissions.valueAt(i); if (!permission.isUserSet()) &#123; return false; &#125; &#125; return true;&#125; 也就是说，取决于该 group 中该应用请求的运行时权限是否都是 user set 的，即：之前用户是否拒绝授予过权限，只有之前拒绝过并且没有选择不在提醒，下一次提醒用户时，才会显示 checkbox！ 2.1.8.1 GPViewHandlerImpl.updateUishowDonNotAsk 的取值为 groupState.mGroup.isUserSet()，就似乎说，如果用户之前拒绝了该权限并且没有选择不再提醒，那么再次提示时 showDonNotAsk 为 true！ 1234567891011121314151617181920212223242526@Overridepublic void updateUi(String groupName, int groupCount, int groupIndex, Icon icon, CharSequence message, boolean showDonNotAsk) &#123; //【1】保存当前的显示内容和进度！ mGroupName = groupName; // group 名！ mGroupCount = groupCount; // group 的总数！ mGroupIndex = groupIndex; // 当前处理的 group！ mGroupIcon = icon; mGroupMessage = message; mShowDonNotAsk = showDonNotAsk; // 是否显示 checkBox mDoNotAskChecked = false; // 是否不再提醒！ // If this is a second (or later) permission and the views exist, then animate. if (mIconView != null) &#123; if (mGroupIndex &gt; 0) &#123; // The first message will be announced as the title of the activity, all others // we need to announce ourselves. mDescContainer.announceForAccessibility(message); animateToPermission(); &#125; else &#123; updateDescription(); updateGroup(); updateDoNotAskCheckBox(); &#125; &#125;&#125; 接下来，就会显示出权限弹窗了！ 用户会通过点击弹窗中的按钮，授予或者拒绝权限！ 2.1.8.1.1 GPViewHandlerImpl.updateDescription1234private void updateDescription() &#123; mIconView.setImageDrawable(mGroupIcon.loadDrawable(mContext)); mMessageView.setText(mGroupMessage);&#125; 2.1.8.1.2 GPViewHandlerImpl.updateGroup123456789private void updateGroup() &#123; if (mGroupCount &gt; 1) &#123; mCurrentGroupView.setVisibility(View.VISIBLE); mCurrentGroupView.setText(mContext.getString(R.string.current_permission_template, mGroupIndex + 1, mGroupCount)); &#125; else &#123; mCurrentGroupView.setVisibility(View.INVISIBLE); &#125;&#125; 2.1.8.1.3 GPViewHandlerImpl.updateDoNotAskCheckBox是否显示 CheckBox 取决于 mShowDonNotAsk，如果 mShowDonNotAsk 为 true，那就显示 checkBox！ CheckBox 的默认状态则是由 mDoNotAskChecked 来决定，默认 mDoNotAskChecked 为 false，此时 CheckBox 没有被选中！ 同时 CheckBox 的点击也会修改 mDoNotAskChecked 的值！123456789101112private void updateDoNotAskCheckBox() &#123; if (mShowDonNotAsk) &#123; // 显示 CheckBox mDoNotAskCheckbox.setVisibility(View.VISIBLE); mDoNotAskCheckbox.setOnClickListener(this); mDoNotAskCheckbox.setChecked(mDoNotAskChecked); // 根据 mDoNotAskChecked 的值设置 CheckBox 的状态！ &#125; else &#123; // 不显示 CheckBox mDoNotAskCheckbox.setVisibility(View.GONE); mDoNotAskCheckbox.setOnClickListener(null); &#125;&#125; 2.1.9 GrantPermissionsActivity.setResultAndFinish处理结果：1234private void setResultAndFinish() &#123; setResultIfNeeded(RESULT_OK); finish(); // 调用 finish，结束当前 activity！&#125; setResultAndFinish 会调用 setResultIfNeeded 方法！12345678910111213private void setResultIfNeeded(int resultCode) &#123; if (!mResultSet) &#123; mResultSet = true; logRequestedPermissionGroups(); // 同样的，创建一个 intent，action 为 ACTION_REQUEST_PERMISSIONS！ Intent result = new Intent(PackageManager.ACTION_REQUEST_PERMISSIONS); // 保存了请求的权限和请求结果！ result.putExtra(PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES, mRequestedPermissions); result.putExtra(PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS, mGrantResults); // 将结果返回给请求权限的 activity setResult(resultCode, result); &#125;&#125; 在调用了 finish 后，请求结果会返回到请求的 acitivty！ 2.1.9.1 RequestActivity.onRequestPermissionsResult1234@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#125; 最后，我们会在请求的 activity 中收到权限请求的结果！ 3 AppPermissionGroup: Grant or Revoke - 授予/拒绝下面我们来看看 AppPermissionGroup 是如何授予和拒绝权限的！ 3.1 AppPermissionGroup.grantRuntimePermissionsfixedByTheUser 表示是否是被用户 fix 的: 对于 permissionPolicy 如果为 DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT 的情况，其值为 false，我们会自动授予权限！ 正常情况下，是需要根据用户的选择来设置这个值的，如果用户本次授予了权限，那么 fixedByTheUser 依然为 false； 123public boolean grantRuntimePermissions(boolean fixedByTheUser) &#123; return grantRuntimePermissions(fixedByTheUser, null);&#125; 调用的二参数的同名方法！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public boolean grantRuntimePermissions(boolean fixedByTheUser, String[] filterPermissions) &#123; final int uid = mPackageInfo.applicationInfo.uid; //【1】我们仅将权限切换到支持运行时权限的应用程序，否则，如果权限授予应用程序，则会切换与权限对应的应用程序op。 for (Permission permission : mPermissions.values()) &#123; if (filterPermissions != null // 处理权限过滤，这里不关注！ &amp;&amp; !ArrayUtils.contains(filterPermissions, permission.getName())) &#123; continue; &#125; if (mAppSupportsRuntimePermissions) &#123; //【1.1】对于运行时权限进入这里！ if (permission.isSystemFixed()) &#123; // 如果运行时权限被 system fix 了，结束处理！ return false; &#125; //【1.1.1】确保运行时权限在授予之前，AppOp 为 allow 状态！ // 判断该权限是否有对应的 AppOps，如果有且不处于 Allow 状态，设置其为 Allow！ if (permission.hasAppOp() &amp;&amp; !permission.isAppOpAllowed()) &#123; permission.setAppOpAllowed(true); mAppOps.setUidMode(permission.getAppOp(), uid, AppOpsManager.MODE_ALLOWED); &#125; if (!permission.isGranted()) &#123; permission.setGranted(true); //【4.1】调用了 pms 的接口授予用户权限 mPackageManager.grantRuntimePermission(mPackageInfo.packageName, permission.getName(), mUserHandle); &#125; //【1.1.2】如果 fixedByTheUser 为 false，更新权限的 flags。 if (!fixedByTheUser) &#123; // 如果该运行时权限处于 user fix 或者 user set 状态，那么我们会强制取消 user fix 状态！ // 这样用户就可以再次请求请求权限，因为其不处于 user fix 状态！ if (permission.isUserFixed() || permission.isUserSet()) &#123; permission.setUserFixed(false); permission.setUserSet(true); // 更新权限的 flags， // 去掉 flags 中 FLAG_PERMISSION_USER_FIXED 和 FLAG_PERMISSION_USER_SET 位！ mPackageManager.updatePermissionFlags(permission.getName(), mPackageInfo.packageName, PackageManager.FLAG_PERMISSION_USER_FIXED | PackageManager.FLAG_PERMISSION_USER_SET, 0, mUserHandle); &#125; &#125; &#125; else &#123; //【1.2】如果应用不支持运行时权限，这里不处理未授予情况，因为在 API 23 之前运行时权限是自动授予的！ if (!permission.isGranted()) &#123; continue; &#125; int killUid = -1; int mask = 0; // 如果权限没有对应的 app op，那么说明这是一个第三方应用，那么我们不对其做调整； // 否则，我们会调整其 app op！ if (permission.hasAppOp()) &#123; // 如果权限不允许 app op，那就开启 app ops！ if (!permission.isAppOpAllowed()) &#123; permission.setAppOpAllowed(true); // 开启 app op mAppOps.setUidMode(permission.getAppOp(), uid, AppOpsManager.MODE_ALLOWED); // 对于旧版本的不支持运行时权限的应用，当其运行时权限改变后，其不会尝试重试资源的访问， // 所以我们需要杀掉其进程，使其重新加载！ killUid = uid; &#125; // 如果应用从不支持运行时权限升级到了支持运行时权限的版本，升级后不能自动授予权限！ // 权限设置了 FLAG_PERMISSION_REVOKE_ON_UPGRADE 标志位！ if (permission.shouldRevokeOnUpgrade()) &#123; permission.setRevokeOnUpgrade(false); mask |= PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE; &#125; &#125; if (mask != 0) &#123; // 更新该权限的 flags，取消 FLAG_PERMISSION_REVOKE_ON_UPGRADE 标志位！ mPackageManager.updatePermissionFlags(permission.getName(), mPackageInfo.packageName, mask, 0, mUserHandle); &#125; if (killUid != -1) &#123; // 杀掉进程！ mActivityManager.killUid(uid, KILL_REASON_APP_OP_CHANGE); &#125; &#125; &#125; return true;&#125; 对于允许权限的情况： 那么 fixedByTheUser 只能是 false，我们会取消 user set 和 user fix 标志位！ 3.2 AppPermissionGroup.revokeRuntimePermissions对于 permissionPolicy 为 DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY 的情况，fixedByTheUser 为 false，同时会自动撤销权限！ 正常情况下，是需要根据用户的选择来设置这个值的，如果用户本次拒绝了权限，但是 fixedByTheUser 可能有两种情况： 如果用户只是拒绝了权限，但是没有点击不再提醒，那么 fixedByTheUser 为 false； 如果用户不仅拒绝了权限，同时选择了不再提醒，那么 fixedByTheUser 为 true； 123public boolean revokeRuntimePermissions(boolean fixedByTheUser) &#123; return revokeRuntimePermissions(fixedByTheUser, null);&#125; 调用了 revokeRuntimePermissions 的另一个方法！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public boolean revokeRuntimePermissions(boolean fixedByTheUser, String[] filterPermissions) &#123; final int uid = mPackageInfo.applicationInfo.uid; //【1】我们仅将权限切换到支持运行时权限的应用程序，否则，如果权限授予应用程序，则会切换与权限对应的应用程序 op。 for (Permission permission : mPermissions.values()) &#123; if (filterPermissions != null &amp;&amp; !ArrayUtils.contains(filterPermissions, permission.getName())) &#123; continue; &#125; if (mAppSupportsRuntimePermissions) &#123; //【1.1】对于运行时权限进入这里！ if (permission.isSystemFixed()) &#123; // 如果运行时权限被 system fix 了，结束处理！ return false; &#125; if (permission.isGranted()) &#123; permission.setGranted(false); //【4.2】调用了 PMS 的接口撤销权限 mPackageManager.revokeRuntimePermission(mPackageInfo.packageName, permission.getName(), mUserHandle); &#125; //【1.1.1】更新权限的标志位！ if (fixedByTheUser) &#123; //【1.1.1.1】如果 fixedByTheUser 是 true，且权限是 user set 或者不是 user fix， // 我们取消 set 设置其为 user fix！ if (permission.isUserSet() || !permission.isUserFixed()) &#123; permission.setUserSet(false); permission.setUserFixed(true); // 取消 user set 标志，设置 user fix 标志！ mPackageManager.updatePermissionFlags(permission.getName(), mPackageInfo.packageName, PackageManager.FLAG_PERMISSION_USER_SET | PackageManager.FLAG_PERMISSION_USER_FIXED, PackageManager.FLAG_PERMISSION_USER_FIXED, mUserHandle); &#125; &#125; else &#123; //【1.1.1.2】如果 fixedByTheUser 是 false，且权限不是 user set，我们设置其为 user set！ if (!permission.isUserSet()) &#123; permission.setUserSet(true); // 设置 user set 标志，表示用户已经做过选择！！ mPackageManager.updatePermissionFlags(permission.getName(), mPackageInfo.packageName, PackageManager.FLAG_PERMISSION_USER_SET, PackageManager.FLAG_PERMISSION_USER_SET, mUserHandle); &#125; &#125; &#125; else &#123; //【1.2】如果应用不支持运行时权限，这里不处理未授予情况，因为在 API 23 之前运行时权限是自动授予的！ if (!permission.isGranted()) &#123; continue; &#125; int mask = 0; int flags = 0; int killUid = -1; // 如果权限没有对应的 app op，那么说明这是一个第三方应用，那么我们不对其做调整； // 否则，我们会调整其 app op！ if (permission.hasAppOp()) &#123; if (permission.isAppOpAllowed()) &#123; // 如果权限允许 app op，那就关闭 app ops！ permission.setAppOpAllowed(false); mAppOps.setUidMode(permission.getAppOp(), uid, AppOpsManager.MODE_IGNORED); // 对于旧版本的不支持运行时权限的引用，当其运行时权限改变后，其不会尝试重试资源的访问， // 所以我们需要杀掉其进程，使其重新加载！ killUid = uid; &#125; // 如果应用从不支持运行时权限升级到了支持运行时权限的版本，升级后不能自动授予权限！ // 权限未设置 FLAG_PERMISSION_REVOKE_ON_UPGRADE 标志位！ if (!permission.shouldRevokeOnUpgrade()) &#123; permission.setRevokeOnUpgrade(true); mask |= PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE; flags |= PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE; &#125; &#125; if (mask != 0) &#123; // 更新该权限的 flags，增加 FLAG_PERMISSION_REVOKE_ON_UPGRADE 标志位！ mPackageManager.updatePermissionFlags(permission.getName(), mPackageInfo.packageName, mask, flags, mUserHandle); &#125; if (killUid != -1) &#123; // 杀掉进程！ mActivityManager.killUid(uid, KILL_REASON_APP_OP_CHANGE); &#125; &#125; &#125; return true;&#125; 对于拒绝权限的情况： 如果用户没有选择不再提醒，那么 fixedByTheUser 为 false，我们会设置 user set 标志位！ 如果用户同时还选择了不再提醒，那么 fixedByTheUser 为 true，那么会取消 user set 标志位，同时设置 user fix 标志位！ 4 PackageManagerService: Grant or Revoke - 核心接口当然，核心方法是调用 pms 的接口完成的，我们去看看这些方法！ 4.1 PackageManagerS.grantRuntimePermission授予运行时权限： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@Overridepublic void grantRuntimePermission(String packageName, String name, final int userId) &#123; if (!sUserManager.exists(userId)) &#123; //【1】校验用户是否存在！ Log.e(TAG, \"No such user:\" + userId); return; &#125; mContext.enforceCallingOrSelfPermission( //【2】校验调用者是否有相应权限； android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS, \"grantRuntimePermission\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, true /* checkShell */, \"grantRuntimePermission\"); final int uid; final SettingBase sb; synchronized (mPackages) &#123; final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; //【3】package 不存在，异常！ throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; //【4】权限不存在，异常！ throw new IllegalArgumentException(\"Unknown permission: \" + name); &#125; enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp); //【5】如果 targetSdkVersion 小于 M，那么是不支持运行时权限的，我们在安装的时候会自动授予运行时权限！ if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M &amp;&amp; bp.isRuntime()) &#123; return; &#125; uid = UserHandle.getUid(userId, pkg.applicationInfo.uid); sb = (SettingBase) pkg.mExtras; if (sb == null) &#123;//【6】升级包未安装过，异常！ throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; final PermissionsState permissionsState = sb.getPermissionsState(); //【7】获得权限的 flags 标志位，如果该权限是被 system fix 的，我们不能操作这样的权限！ final int flags = permissionsState.getPermissionFlags(name, userId); if ((flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) &#123; throw new SecurityException(\"Cannot grant system fixed permission \" + name + \" for package \" + packageName); &#125; //【8】如果该权限是开发者权限，特殊处理，作为安装时权限，立刻授予！ // 授予成功，会触发 Settings.writeLPr 方法，该方法会更新多个文件 // 包括 pacakges.xml，pacakges.list，runtime-permissions.xml 等文件！ if (bp.isDevelopment()) &#123; if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; scheduleWriteSettingsLocked(); &#125; return; &#125; if (pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123; Slog.w(TAG, \"Cannot grant runtime permission to a legacy app\"); return; &#125; //【9】授予权限，并处理授予结果！！ final int result = permissionsState.grantRuntimePermission(bp, userId); switch (result) &#123; case PermissionsState.PERMISSION_OPERATION_FAILURE: &#123; //【9.1】授予失败，可能应用已经被授予权限了！ return; &#125; case PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED: &#123; //【9.2】授予成功，但是应用映射的 gids 变化了！ final int appId = UserHandle.getAppId(pkg.applicationInfo.uid); mHandler.post(new Runnable() &#123; @Override public void run() &#123; //【9.2.1】杀掉应用的进程，应用后续会重启！ killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED); &#125; &#125;); &#125; break; &#125; mOnPermissionChangeListeners.onPermissionsChanged(uid); //【10】更新 runtime-permissions.xml 文件！ mSettings.writeRuntimePermissionsForUserLPr(userId, false); &#125; // Only need to do this if user is initialized. Otherwise it's a new user // and there are no processes running as the user yet and there's no need // to make an expensive call to remount processes for the changed permissions. if (READ_EXTERNAL_STORAGE.equals(name) || WRITE_EXTERNAL_STORAGE.equals(name)) &#123; final long token = Binder.clearCallingIdentity(); try &#123; if (sUserManager.isInitialized(userId)) &#123; MountServiceInternal mountServiceInternal = LocalServices.getService( MountServiceInternal.class); mountServiceInternal.onExternalStoragePolicyChanged(uid, packageName); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125;&#125; 4.2 PackageManagerS.revokeRuntimePermission拒绝运行时权限！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Overridepublic void revokeRuntimePermission(String packageName, String name, int userId) &#123; if (!sUserManager.exists(userId)) &#123; //【1】校验用户是否存在！ Log.e(TAG, \"No such user:\" + userId); return; &#125; mContext.enforceCallingOrSelfPermission( //【2】校验调用者是否有相应权限； android.Manifest.permission.REVOKE_RUNTIME_PERMISSIONS, \"revokeRuntimePermission\"); enforceCrossUserPermission(Binder.getCallingUid(), userId, true /* requireFullPermission */, true /* checkShell */, \"revokeRuntimePermission\"); final int appId; synchronized (mPackages) &#123; final PackageParser.Package pkg = mPackages.get(packageName); if (pkg == null) &#123; //【3】package 不存在，异常！ throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; final BasePermission bp = mSettings.mPermissions.get(name); if (bp == null) &#123; //【4】权限不存在，异常！ throw new IllegalArgumentException(\"Unknown permission: \" + name); &#125; enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp); //【5】如果 targetSdkVersion 小于 M，那么是不支持运行时权限的，我们在安装的时候会自动授予运行时权限！ if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M &amp;&amp; bp.isRuntime()) &#123; return; &#125; SettingBase sb = (SettingBase) pkg.mExtras; if (sb == null) &#123; //【6】升级包未安装过，异常！ throw new IllegalArgumentException(\"Unknown package: \" + packageName); &#125; final PermissionsState permissionsState = sb.getPermissionsState(); //【7】获得权限的 flags 标志位，如果该权限是被 system fix 的，我们不能撤销这样的权限！ final int flags = permissionsState.getPermissionFlags(name, userId); if ((flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) &#123; throw new SecurityException(\"Cannot revoke system fixed permission \" + name + \" for package \" + packageName); &#125; //【8】如果该权限是开发者权限，特殊处理，立刻授予！ // 授予成功，会触发 Settings.writeLPr 方法，该方法会更新多个文件 // 包括 pacakges.xml，pacakges.list，runtime-permissions.xml 等文件！ if (bp.isDevelopment()) &#123; if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; scheduleWriteSettingsLocked(); &#125; return; &#125; //【9】撤销运行时权限！ if (permissionsState.revokeRuntimePermission(bp, userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; return; &#125; mOnPermissionChangeListeners.onPermissionsChanged(pkg.applicationInfo.uid); //【10】更新 runtime-permissions.xml 文件！ mSettings.writeRuntimePermissionsForUserLPr(userId, true); appId = UserHandle.getAppId(pkg.applicationInfo.uid); &#125; killUid(appId, userId, KILL_APP_REASON_PERMISSIONS_REVOKED); // 杀掉应用的进程！&#125; 最后的又进入了 PermissionsState 对象，这个我在 PMS 中有分析过，这里就不在多说了！！ 5 Activity.shouldShowRequestPermissionRationale - 解释权限含义为了防止用户因为不理解而拒绝了权限，我们可以在恰当的时间给用户解释为什么申请权限，这里要用到 shouldShowRequestPermissionRationale 方法！ 123public boolean shouldShowRequestPermissionRationale(@NonNull String permission) &#123; return getPackageManager().shouldShowRequestPermissionRationale(permission);&#125; 最终会调用 PackageManagerService 中的方法！ 5.1 PackageManagerS.shouldShowRequestPermissionRationale该方法的返回值决定了是否应该给用户解释权限！ 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) &#123; if (UserHandle.getCallingUserId() != userId) &#123; mContext.enforceCallingPermission( android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, \"canShowRequestPermissionRationale for user \" + userId); &#125; final int uid = getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, userId); if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(uid)) &#123; return false; &#125; //【1】如果已经拒绝权限，那么就返回 false！ if (checkPermission(permissionName, packageName, userId) == PackageManager.PERMISSION_GRANTED) &#123; return false; &#125; final int flags; final long identity = Binder.clearCallingIdentity(); try &#123; // 获得权限的标志位！ flags = getPermissionFlags(permissionName, packageName, userId); &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; // fixedFlags 包含了所有的被 fix 的情况！ final int fixedFlags = PackageManager.FLAG_PERMISSION_SYSTEM_FIXED | PackageManager.FLAG_PERMISSION_POLICY_FIXED | PackageManager.FLAG_PERMISSION_USER_FIXED; //【2】如果该权限被 fix 了，那就返回 false； if ((flags &amp; fixedFlags) != 0) &#123; return false; &#125; //【3】判断权限是否被 user set，如果被用户 set 了，返回 true！ return (flags &amp; PackageManager.FLAG_PERMISSION_USER_SET) != 0;&#125; policy fix 和 system fix 这些状态都是系统机制的处理！ 我们可以看到： 如果用户授予了权限，那么该方法返回的是 false； 如果该权限被 system/policy/user fix 了，即用户拒绝了授权，又点击了不再提醒，那返回的是 false； 如果该权限被 user set 了，即用户拒绝了授权，但是没有点击不再提醒，那么会返回 true；","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Permission权限管理","slug":"AndroidFramework源码分析/Permission权限管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Permission权限管理/"}],"tags":[{"name":"Permission权限管理","slug":"Permission权限管理","permalink":"https://coolqi.top/tags/Permission权限管理/"}]},{"title":"UsageStats 第 4 篇 - UsageStatsService 和其他服务和进程的交互","slug":"UsageStats4-usageStatsServiceInteractionWithServiceOrProcess","date":"2017-08-03T12:46:25.000Z","updated":"2018-11-20T16:56:01.000Z","comments":true,"path":"2017/08/03/UsageStats4-usageStatsServiceInteractionWithServiceOrProcess/","link":"","permalink":"https://coolqi.top/2017/08/03/UsageStats4-usageStatsServiceInteractionWithServiceOrProcess/","excerpt":"","text":"[toc] 基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理！ 0 综述本文主要分析 UsageStatsService 和其他服务 / 进程交互！ 我们知道 UsageStatsService 内部有两个类 LocalService 和 BinderService，他们是 UsageStatsService 提供給其他服务或进程的通信接口类！ BinderService BinderService 主要用于跨进程调用： 1private final class BinderService extends IUsageStatsManager.Stub &#123;...&#125; BinderService 继承了 IUsageStatsManager.Stub，作为服务端桩对象，注册进 ServiceManager！ 我们在其他进程中可以通过 UsageStatsManager 来获得客户端代理对象！ LocalService LocalService 用于系统进程中的其他服务调用，比如 ActivityManagerService，NotificationManagerService 等服务，下面是一些主要接口的调用逻辑： 1234567891011LocalService.reportEvent -&gt; UsageStatsService.H.MSG_REPORT_EVENTLocalService.reportConfigurationChange -&gt; UsageStatsService.H.MSG_REPORT_EVENTLocalService.reportShortcutUsage -&gt; UsageStatsService.H.MSG_REPORT_EVENTLocalService.reportContentProviderUsage -&gt; UsageStatsService.H.MSG_REPORT_CONTENT_PROVIDER_USAGELocalService.isAppIdle -&gt; UsageStatsService.isAppIdleFilteredLocalService.getIdleUidsForUser -&gt; UsageStatsService.getIdleUidsForUseLocalService.isAppIdleParoleOn -&gt; UsageStatsService.isParoledOrChargingLocalService.addAppIdleStateChangeListener -&gt; UsageStatsService.addListener 我们重点关注 LocalService 的逻辑调用！ 1 和 UsageStatsService 通信的服务 ActivityManagerService 12mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); NotificationManagerService 123456@Overridepublic void onStart() &#123; ... ... ... mAppUsageStats = LocalServices.getService(UsageStatsManagerInternal.class); ... ... ..&#125; NetworkPolicyManagerService 1234567891011public void systemReady() &#123; Trace.traceBegin(Trace.TRACE_TAG_NETWORK, \"systemReady\"); try &#123; if (!isBandwidthControlEnabled()) &#123; Slog.w(TAG, \"bandwidth controls disabled, unable to enforce policy\"); return; &#125; mUsageStats = LocalServices.getService(UsageStatsManagerInternal.class); ... ... ...&#125; AppIdleController 1234567private AppIdleController(JobSchedulerService service, Context context, Object lock) &#123; super(service, context, lock); mJobSchedulerService = service; mUsageStatsInternal = LocalServices.getService(UsageStatsManagerInternal.class); mAppIdleParoleOn = true; mUsageStatsInternal.addAppIdleStateChangeListener(new AppIdleStateChangeListener());&#125; 主要有以上的服务！ 2 ActivityManagerServiceActivityManagerService 和 UsageStatsService 交互可算是重头戏！ 2.1 updateUsageStatsupdateUsageStats 方法用于更新 Activity 的使用信息！ 2.1.1 调用时机我们来看看调用时机： ActivityStack.startPausingLocked 当 activty 进入 paused 状态的时候，会触发 startPausingLocked 方法！ 1234567891011121314151617181920212223242526272829final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean dontWait) &#123; ... ... ... if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Enqueueing pending pause: \" + prev); try &#123; EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); //【2.1.2】记录 activity 组件的 UsageEvents.Event.MOVE_TO_BACKGROUND 事件！ mService.updateUsageStats(prev, false); //【1】拉起 activity 的 onPause 方法！ prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125; catch (Exception e) &#123; // Ignore exception, if process died other code will cleanup. Slog.w(TAG, \"Exception thrown during pause\", e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; ... ... ...&#125; ActivityStackSupervisor.reportResumedActivityLocked 当 activty 进入 resume 状态的时候，会触发 reportResumedActivityLocked 方法！12345678910111213boolean reportResumedActivityLocked(ActivityRecord r) &#123; final ActivityStack stack = r.task.stack; if (isFocusedStack(stack)) &#123; //【2.1.2】记录 activity 组件的 UsageEvents.Event.MOVE_TO_FOREGROUND 事件！ mService.updateUsageStats(r, true); &#125; if (allResumedActivitiesComplete()) &#123; ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); mWindowManager.executeAppTransition(); return true; &#125; return false;&#125; ActivityStack.handleAppDiedLocked 当 app process 死亡后，会触发 ActivityStack.handleAppDiedLocked 方法！ 12345678910111213boolean handleAppDiedLocked(ProcessRecord app) &#123; if (mPausingActivity != null &amp;&amp; mPausingActivity.app == app) &#123; if (DEBUG_PAUSE || DEBUG_CLEANUP) Slog.v(TAG_PAUSE, \"App died while pausing: \" + mPausingActivity); mPausingActivity = null; &#125; if (mLastPausedActivity != null &amp;&amp; mLastPausedActivity.app == app) &#123; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; //【1】调用自身的 removeHistoryRecordsForAppLocked 方法！ return removeHistoryRecordsForAppLocked(app);&#125; 进入 removeHistoryRecordsForAppLocked 方法！ 12345678910111213141516171819202122232425262728293031323334353637383940414243boolean removeHistoryRecordsForAppLocked(ProcessRecord app) &#123; ... ... ... for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final ArrayList&lt;ActivityRecord&gt; activities = mTaskHistory.get(taskNdx).mActivities; for (int activityNdx = activities.size() - 1; activityNdx &gt;= 0; --activityNdx) &#123; final ActivityRecord r = activities.get(activityNdx); --i; if (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP, \"Record #\" + i + \" \" + r + \": app=\" + r.app); if (r.app == app) &#123; if (r.visible) &#123; hasVisibleActivities = true; &#125; final boolean remove; ... ... ... if (remove) &#123; if (DEBUG_ADD_REMOVE || DEBUG_CLEANUP) Slog.i(TAG_ADD_REMOVE, \"Removing activity \" + r + \" from stack at \" + i + \": haveState=\" + r.haveState + \" stateNotNeeded=\" + r.stateNotNeeded + \" finishing=\" + r.finishing + \" state=\" + r.state + \" callers=\" + Debug.getCallers(5)); if (!r.finishing) &#123; Slog.w(TAG, \"Force removing \" + r + \": app died, no saved state\"); EventLog.writeEvent(EventLogTags.AM_FINISH_ACTIVITY, r.userId, System.identityHashCode(r), r.task.taskId, r.shortComponentName, \"proc died without state saved\"); if (r.state == ActivityState.RESUMED) &#123; //【2.2.2】如果 activity 处于 resume 状态，记录状态！ mService.updateUsageStats(r, false); &#125; &#125; &#125; else &#123; ... ... .. &#125; ... ... ... &#125; &#125; &#125; return hasVisibleActivities; &#125; 逻辑很简单，不多说！ 2.1.2 方法流程分析参数 boolean resumed 表示是否处于 resume 状态！ 123456789101112131415161718192021222324void updateUsageStats(ActivityRecord component, boolean resumed) &#123; if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, \"updateUsageStats: comp=\" + component + \"res=\" + resumed); final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); if (resumed) &#123; if (mUsageStatsService != null) &#123; //【2.1.3】如果是 resume 状态，记录 UsageEvents.Event.MOVE_TO_FOREGROUND 事件！ mUsageStatsService.reportEvent(component.realActivity, component.userId, UsageEvents.Event.MOVE_TO_FOREGROUND); &#125; synchronized (stats) &#123; stats.noteActivityResumedLocked(component.app.uid); &#125; &#125; else &#123; if (mUsageStatsService != null) &#123; //【2.1.3】如果不是 resume 状态，记录 UsageEvents.Event.MOVE_TO_BACKGROUND 事件！ mUsageStatsService.reportEvent(component.realActivity, component.userId, UsageEvents.Event.MOVE_TO_BACKGROUND); &#125; synchronized (stats) &#123; stats.noteActivityPausedLocked(component.app.uid); &#125; &#125;&#125; 不多说了！ 2.1.3 LocalService.reportEvent这里最终调用了 reportEvent 方法，传入的 ComponentName component 为 Activity！1234567891011121314151617@Overridepublic void reportEvent(ComponentName component, int userId, int eventType) &#123; if (component == null) &#123; Slog.w(TAG, \"Event reported without a component name\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = component.getPackageName(); event.mClass = component.getClassName(); event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = eventType; //【1】发送了 MSG_REPORT_EVENT 消息！ mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget();&#125; 不多说了！ 2.2 updateConfigurationLocked2.2.1 调用时机主要是和 Configuration 配置更新相关的内容，调用地方过多，这里先不列出！ 2.2.2 方法流程分析和 updateConfigurationLocked 相关的有多个重载函数： 1234567891011121314151617181920212223242526272829303132333435363738394041public void updateConfiguration(Configuration values) &#123; enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, \"updateConfiguration()\"); synchronized(this) &#123; if (values == null &amp;&amp; mWindowManager != null) &#123; // sentinel: fetch the current configuration from the window manager values = mWindowManager.computeNewConfiguration(); &#125; if (mWindowManager != null) &#123; mProcessList.applyDisplaySize(mWindowManager); &#125; final long origId = Binder.clearCallingIdentity(); if (values != null) &#123; Settings.System.clearConfiguration(values); &#125; updateConfigurationLocked(values, null, false); Binder.restoreCallingIdentity(origId); &#125;&#125;void updateUserConfigurationLocked() &#123; Configuration configuration = new Configuration(mConfiguration); Settings.System.adjustConfigurationForUser(mContext.getContentResolver(), configuration, mUserController.getCurrentUserIdLocked(), Settings.System.canWrite(mContext)); updateConfigurationLocked(configuration, null, false);&#125;boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale) &#123; return updateConfigurationLocked(values, starting, initLocale, false /* deferResume */);&#125;boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean deferResume) &#123; // pass UserHandle.USER_NULL as userId because we don't persist configuration for any user return updateConfigurationLocked(values, starting, initLocale, false /* persistent */, UserHandle.USER_NULL, deferResume);&#125; updateConfigurationLocked 方法用于更新指定 activity 的 Configuration 属性，主要有两个作用： 改变当前的配置； 确保指定的 activity 使用的是当前最新的 activity； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume) &#123; int changes = 0; //【1】停止布局！ if (mWindowManager != null) &#123; mWindowManager.deferSurfaceLayout(); &#125; //【2】处理配置变化！ if (values != null) &#123; //【2.1】获得旧配置的拷贝； Configuration newConfig = new Configuration(mConfiguration); //【2.2】获得配置的更新信息！ changes = newConfig.updateFrom(values); if (changes != 0) &#123; if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.i(TAG_CONFIGURATION, \"Updating configuration to: \" + values); EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes); //【2.3】处理多语言的更新！ if (!initLocale &amp;&amp; !values.getLocales().isEmpty() &amp;&amp; values.userSetLocale) &#123; final LocaleList locales = values.getLocales(); int bestLocaleIndex = 0; if (locales.size() &gt; 1) &#123; if (mSupportedSystemLocales == null) &#123; mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales(); &#125; bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(mSupportedSystemLocales)); &#125; SystemProperties.set(\"persist.sys.locale\", locales.get(bestLocaleIndex).toLanguageTag()); LocaleList.setDefault(locales, bestLocaleIndex); mHandler.sendMessage(mHandler.obtainMessage(SEND_LOCALE_TO_MOUNT_DAEMON_MSG, locales.get(bestLocaleIndex))); &#125; //【2.4】计算本次更新的序列号； mConfigurationSeq++; if (mConfigurationSeq &lt;= 0) &#123; mConfigurationSeq = 1; &#125; //【2.5】更新配置引用对象！ newConfig.seq = mConfigurationSeq; mConfiguration = newConfig; Slog.i(TAG, \"Config changes=\" + Integer.toHexString(changes) + \" \" + newConfig); //【×2.2.3】调用 reportConfigurationChange 方法！ mUsageStatsService.reportConfigurationChange(newConfig, mUserController.getCurrentUserIdLocked()); final Configuration configCopy = new Configuration(mConfiguration); // TODO: If our config changes, should we auto dismiss any currently // showing dialogs? mShowDialogs = shouldShowDialogs(newConfig, mInVrMode); AttributeCache ac = AttributeCache.instance(); if (ac != null) &#123; ac.updateConfiguration(configCopy); &#125; //【2.6】更新资源配置！ mSystemThread.applyConfigurationToResources(configCopy); if (persistent &amp;&amp; Settings.System.hasInterestingConfigurationChanges(changes)) &#123; Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG); msg.obj = new Configuration(configCopy); msg.arg1 = userId; mHandler.sendMessage(msg); &#125; //【2.7】调整屏幕密度改变 final boolean isDensityChange = (changes &amp; ActivityInfo.CONFIG_DENSITY) != 0; if (isDensityChange) &#123; // Reset the unsupported display size dialog. mUiHandler.sendEmptyMessage(SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG); killAllBackgroundProcessesExcept(Build.VERSION_CODES.N, ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE); &#125; //【2.8】修改进程的配置信息！ for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); try &#123; if (app.thread != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, \"Sending to proc \" + app.processName + \" new config \" + mConfiguration); app.thread.scheduleConfigurationChanged(configCopy); &#125; &#125; catch (Exception e) &#123; &#125; &#125; //【2.9】发送配置改变的广播！ Intent intent = new Intent(Intent.ACTION_CONFIGURATION_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_FOREGROUND); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL); if ((changes&amp;ActivityInfo.CONFIG_LOCALE) != 0) &#123; intent = new Intent(Intent.ACTION_LOCALE_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); if (initLocale || !mProcessesReady) &#123; intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); &#125; broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL); &#125; &#125; //【2.10】更新 wms 中的配置信息，并且检查在更新了配置后，是否有 stack 需要被 resize； // 如果有的话，那就进行 resize 和 relaunch！ if (mWindowManager != null) &#123; final int[] resizedStacks = mWindowManager.setNewConfiguration(mConfiguration); if (resizedStacks != null) &#123; for (int stackId : resizedStacks) &#123; final Rect newBounds = mWindowManager.getBoundsForNewConfiguration(stackId); mStackSupervisor.resizeStackLocked( stackId, newBounds, null, null, false, false, deferResume); &#125; &#125; &#125; &#125; boolean kept = true; final ActivityStack mainStack = mStackSupervisor.getFocusedStack(); //【4】获得焦点栈，调整 top activity 的配置信息！ // mainStack is null during startup. if (mainStack != null) &#123; if (changes != 0 &amp;&amp; starting == null) &#123; starting = mainStack.topRunningActivityLocked(); &#125; if (starting != null) &#123; kept = mainStack.ensureActivityConfigurationLocked(starting, changes, false); mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes, !PRESERVE_WINDOWS); &#125; &#125; //【5】继续布局！ if (mWindowManager != null) &#123; mWindowManager.continueSurfaceLayout(); &#125; return kept;&#125; 这里调用了 UsageStatsService.reportConfigurationChange 方法，更新配置信息！ 2.2.3 LocalService.updateConfigurationLocked12345678910111213141516@Overridepublic void reportConfigurationChange(Configuration config, int userId) &#123; if (config == null) &#123; Slog.w(TAG, \"Configuration event reported with a null config\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = \"android\"; event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = UsageEvents.Event.CONFIGURATION_CHANGE; event.mConfiguration = new Configuration(config); mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget();&#125; 对于 config 相关的 event 来说，目标包名是 android！ 2.3 maybeUpdateProviderUsageStatsLocked2.3.1 调用时机 ActivityManagerService.publishContentProviders 当注册 ContentProvider 的时候，会触发 publishContentProviders 方法！ 123456789101112131415161718192021222324252627282930313233public final void publishContentProviders(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers) &#123; if (providers == null) &#123; return; &#125; enforceNotIsolatedCaller(\"publishContentProviders\"); synchronized (this) &#123; final ProcessRecord r = getRecordForAppLocked(caller); if (DEBUG_MU) Slog.v(TAG_MU, \"ProcessRecord uid = \" + r.uid); if (r == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when publishing content providers\"); &#125; final long origId = Binder.clearCallingIdentity(); final int N = providers.size(); for (int i = 0; i &lt; N; i++) &#123; ContentProviderHolder src = providers.get(i); ... ... ... updateOomAdjLocked(r); //【2.3.2】调用 maybeUpdateProviderUsageStatsLocked 方法，记录 ContentProvider 使用信息！ maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125; ActivityManagerService.getContentProviderImpl 当获得 ContentProvider 的时候，会触发 getContentProviderImpl 方法！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; synchronized(this) &#123; long startTime = SystemClock.uptimeMillis(); ... ... ... boolean providerRunning = cpr != null &amp;&amp; cpr.proc != null &amp;&amp; !cpr.proc.killed; if (providerRunning) &#123; cpi = cpr.info; String msg; checkTime(startTime, \"getContentProviderImpl: before checkContentProviderPermission\"); if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser)) != null) &#123; throw new SecurityException(msg); &#125; checkTime(startTime, \"getContentProviderImpl: after checkContentProviderPermission\"); if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; ContentProviderHolder holder = cpr.newHolder(null); holder.provider = null; return holder; &#125; final long origId = Binder.clearCallingIdentity(); checkTime(startTime, \"getContentProviderImpl: incProviderCountLocked\"); conn = incProviderCountLocked(r, cpr, token, stable); if (conn != null &amp;&amp; (conn.stableCount+conn.unstableCount) == 1) &#123; if (cpr.proc != null &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123; checkTime(startTime, \"getContentProviderImpl: before updateLruProcess\"); updateLruProcessLocked(cpr.proc, false, null); checkTime(startTime, \"getContentProviderImpl: after updateLruProcess\"); &#125; &#125; checkTime(startTime, \"getContentProviderImpl: before updateOomAdj\"); final int verifiedAdj = cpr.proc.verifiedAdj; boolean success = updateOomAdjLocked(cpr.proc); if (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123; success = false; &#125; //【2.2.2】调用 maybeUpdateProviderUsageStatsLocked 方法再次记录！ maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name); checkTime(startTime, \"getContentProviderImpl: after updateOomAdj\"); if (DEBUG_PROVIDER) Slog.i(TAG_PROVIDER, \"Adjust success: \" + success); if (!success) &#123; Slog.i(TAG, \"Existing provider \" + cpr.name.flattenToShortString() + \" is crashing; detaching \" + r); boolean lastRef = decProviderCountLocked(conn, cpr, token, stable); checkTime(startTime, \"getContentProviderImpl: before appDied\"); appDiedLocked(cpr.proc); checkTime(startTime, \"getContentProviderImpl: after appDied\"); if (!lastRef) &#123; return null; &#125; providerRunning = false; conn = null; &#125; else &#123; cpr.proc.verifiedAdj = cpr.proc.setAdj; &#125; Binder.restoreCallingIdentity(origId); &#125; ... ... ... &#125; return cpr != null ? cpr.newHolder(conn) : null;&#125; 对于 getContentProviderImpl 这里我们不再过多分析！ 2.3.2 方法流程分析maybeUpdateProviderUsageStatsLocked 方法中会进行事件上报！123456789101112131415161718private void maybeUpdateProviderUsageStatsLocked(ProcessRecord app, String providerPkgName, String authority) &#123; if (app == null) return; if (app.curProcState &lt;= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123; UserState userState = mUserController.getStartedUserStateLocked(app.userId); if (userState == null) return; final long now = SystemClock.elapsedRealtime(); Long lastReported = userState.mProviderLastReportedFg.get(authority); if (lastReported == null || lastReported &lt; now - 60 * 1000L) &#123; if (mSystemReady) &#123; //【2.3.3】调用了 reportContentProviderUsage 方法！ mUsageStatsService.reportContentProviderUsage( authority, providerPkgName, app.userId); &#125; userState.mProviderLastReportedFg.put(authority, now); &#125; &#125;&#125; 2.3.3 LocalService.reportContentProviderUsage12345678910@Overridepublic void reportContentProviderUsage(String name, String packageName, int userId) &#123; SomeArgs args = SomeArgs.obtain(); args.arg1 = name; args.arg2 = packageName; args.arg3 = userId; //【1】发送了 MSG_REPORT_CONTENT_PROVIDER_USAGE 消息！ mHandler.obtainMessage(MSG_REPORT_CONTENT_PROVIDER_USAGE, args) .sendToTarget();&#125; 不多说了！ 2.4 maybeUpdateUsageStatsLocked2.4.1 调用时机 ActivityManagerService.applyOomAdjLocked 在调整进程的 oomAdj 的时候，会触发 maybeUpdateUsageStatsLocked！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) &#123; boolean success = true; if (app.curRawAdj != app.setRawAdj) &#123; app.setRawAdj = app.curRawAdj; &#125; int changes = 0; if (app.curAdj != app.setAdj) &#123; ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Set \" + app.pid + \" \" + app.processName + \" adj \" + app.curAdj + \": \" + app.adjType); app.setAdj = app.curAdj; app.verifiedAdj = ProcessList.INVALID_ADJ; &#125; ... ... ... //【1】当进程的 ProcState 发生了变化是，进入 IF 分支！ if (app.setProcState != app.curProcState) &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Proc state change of \" + app.processName + \" to \" + app.curProcState); boolean setImportant = app.setProcState &lt; ActivityManager.PROCESS_STATE_SERVICE; boolean curImportant = app.curProcState &lt; ActivityManager.PROCESS_STATE_SERVICE; if (setImportant &amp;&amp; !curImportant) &#123; BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); synchronized (stats) &#123; app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed); &#125; app.lastCpuTime = app.curCpuTime; &#125; //【2.4.1】在更新进程的状态之前，调用 maybeUpdateUsageStatsLocked 方法 // 记录进程的信息！ maybeUpdateUsageStatsLocked(app, nowElapsed); app.setProcState = app.curProcState; if (app.setProcState &gt;= ActivityManager.PROCESS_STATE_HOME) &#123; app.notCachedSinceIdle = false; &#125; if (!doingAll) &#123; setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now); &#125; else &#123; app.procStateChanged = true; &#125; &#125; else if (app.reportedInteraction &amp;&amp; (nowElapsed-app.interactionEventTime) &gt; USAGE_STATS_INTERACTION_INTERVAL) &#123; //【2.4.1】对于长期处于互动状态的应用，我们需要每天至少报告一次，以免它们进入 idle 状态。 maybeUpdateUsageStatsLocked(app, nowElapsed); &#125; ... ... ... return success;&#125; 这里调用了 maybeUpdateUsageStatsLocked 方法！ 2.4.2 方法流程分析下面我们来看看 maybeUpdateUsageStatsLocked 方法流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void maybeUpdateUsageStatsLocked(ProcessRecord app, long nowElapsed) &#123; if (DEBUG_USAGE_STATS) &#123; Slog.d(TAG, \"Checking proc [\" + Arrays.toString(app.getPackageList()) + \"] state changes: old = \" + app.setProcState + \", new = \" + app.curProcState); &#125; if (mUsageStatsService == null) &#123; return; &#125; //【1】判断此时进程是否处于交互中！ boolean isInteraction; if (app.curProcState &lt;= ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE) &#123; //【2】如果进程的 curProcState 小于等于 PROCESS_STATE_BOUND_FOREGROUND_SERVICE: 3 // 此时是处于交互状态的！ isInteraction = true; app.fgInteractionTime = 0; &#125; else if (app.curProcState &lt;= ActivityManager.PROCESS_STATE_TOP_SLEEPING) &#123; //【3】如果进程的 curProcState 小于等于 PROCESS_STATE_TOP_SLEEPING: 5 // 进入这里！！ if (app.fgInteractionTime == 0) &#123; app.fgInteractionTime = nowElapsed; isInteraction = false; &#125; else &#123; isInteraction = nowElapsed &gt; app.fgInteractionTime + SERVICE_USAGE_INTERACTION_TIME; &#125; &#125; else &#123; //【4】如果 app.forcingToForeground 为 null，并且进程的 curProcState // 小于等于 PROCESS_STATE_IMPORTANT_FOREGROUND:6 说明该进程是可以被感知的重要进程！ // isInteraction 为 true！ isInteraction = app.forcingToForeground == null &amp;&amp; app.curProcState &lt;= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; app.fgInteractionTime = 0; &#125; //【5】如果本次进程是处于交互状态，并且上次是处于非交互状态（或者此时距离上次交互时间点超过了交互间隔） // 那么我们会上报一次记录！ if (isInteraction &amp;&amp; (!app.reportedInteraction || (nowElapsed-app.interactionEventTime) &gt; USAGE_STATS_INTERACTION_INTERVAL)) &#123; app.interactionEventTime = nowElapsed; String[] packages = app.getPackageList(); if (packages != null) &#123; for (int i = 0; i &lt; packages.length; i++) &#123; //【5.1】调用了 reportEvent 方法，更新进程中所有 pacakge 的使用信息 // event 类型为 SYSTEM_INTERACTION！ mUsageStatsService.reportEvent(packages[i], app.userId, UsageEvents.Event.SYSTEM_INTERACTION); &#125; &#125; &#125; //【6】更新 app.reportedInteraction 和 app.interactionEventTime！ app.reportedInteraction = isInteraction; if (!isInteraction) &#123; app.interactionEventTime = 0; &#125;&#125; 最终调用了 UsageStatsService.reportEvent 方法！ 2.4.3 LocalService.reportEvent12345678910111213141516@Overridepublic void reportEvent(String packageName, int userId, int eventType) &#123; if (packageName == null) &#123; Slog.w(TAG, \"Event reported without a package name\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = packageName; // This will later be converted to system time. event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = eventType; mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget();&#125; 2.5 shutdownshutdown 主要用关机时候，保存重要的信息！1234567891011121314151617181920212223242526272829@Overridepublic boolean shutdown(int timeout) &#123; if (checkCallingPermission(android.Manifest.permission.SHUTDOWN) != PackageManager.PERMISSION_GRANTED) &#123; throw new SecurityException(\"Requires permission \" + android.Manifest.permission.SHUTDOWN); &#125; boolean timedout = false; synchronized(this) &#123; mShuttingDown = true; updateEventDispatchingLocked(); timedout = mStackSupervisor.shutdownLocked(timeout); &#125; mAppOpsService.shutdown(); if (mUsageStatsService != null) &#123; //【1】调用 UsageStatsService 的 prepareShutdown 方法！ mUsageStatsService.prepareShutdown(); &#125; mBatteryStatsService.shutdown(); synchronized (this) &#123; mProcessStats.shutdownLocked(); notifyTaskPersisterLocked(null, true); &#125; return timedout;&#125; 这个逻辑不多说了！ 3 NotificationManagerService我们来看看 NotificationManagerService 和 UsageStatsService 的通信： 3.1 onStart12345678910@Override public void onStart() &#123; Resources resources = getContext().getResources(); mMaxPackageEnqueueRate = Settings.Global.getFloat(getContext().getContentResolver(), Settings.Global.MAX_NOTIFICATION_ENQUEUE_RATE, DEFAULT_MAX_NOTIFICATION_ENQUEUE_RATE); ... ... ... mAppUsageStats = LocalServices.getService(UsageStatsManagerInternal.class); 3.2 setNotificationsShownFromListener当通知可见后 setNotificationsShownFromListener 会被触发！ 123456789101112131415161718192021222324252627282930313233@Overridepublic void setNotificationsShownFromListener(INotificationListener token, String[] keys) &#123; long identity = Binder.clearCallingIdentity(); try &#123; synchronized (mNotificationList) &#123; final ManagedServiceInfo info = mListeners.checkServiceTokenLocked(token); if (keys != null) &#123; final int N = keys.length; for (int i = 0; i &lt; N; i++) &#123; NotificationRecord r = mNotificationsByKey.get(keys[i]); if (r == null) continue; final int userId = r.sbn.getUserId(); if (userId != info.userid &amp;&amp; userId != UserHandle.USER_ALL &amp;&amp; !mUserProfiles.isCurrentProfile(userId)) &#123; throw new SecurityException(\"Disallowed call from listener: \" + info.service); &#125; if (!r.isSeen()) &#123; if (DBG) Slog.d(TAG, \"Marking notification as seen \" + keys[i]); //【1】调用了 UsageStatsService 的 reportEvent 方法！ mAppUsageStats.reportEvent(r.sbn.getPackageName(), userId == UserHandle.USER_ALL ? UserHandle.USER_SYSTEM : userId, UsageEvents.Event.USER_INTERACTION); r.setSeen(); &#125; &#125; &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125;&#125; 这里对传入的 UserId 做了一个判断，如果为 UserHandle.USER_ALL，那么就设置为 UserHandle.USER_SYSTEM！ 最终，调用了 UsageStatsService.reportEvent 上报事件：1234mAppUsageStats.reportEvent(r.sbn.getPackageName(), userId == UserHandle.USER_ALL ? UserHandle.USER_SYSTEM : userId, UsageEvents.Event.USER_INTERACTION); 4 NetworkPolicyManagerService我们来看看 NetworkPolicyManagerService 和 UsageStatsService 的通信方式！ 4.1 systemReady先来看看 NetworkPolicyManagerService 的 systemReady 方法！ 12345678910111213141516public void systemReady() &#123; Trace.traceBegin(Trace.TRACE_TAG_NETWORK, \"systemReady\"); try &#123; if (!isBandwidthControlEnabled()) &#123; Slog.w(TAG, \"bandwidth controls disabled, unable to enforce policy\"); return; &#125; //【1】获得了 UsageStats 对象！ mUsageStats = LocalServices.getService(UsageStatsManagerInternal.class); ... ... ... ... //【2】注册 AppIdleStateChangeListener 监听器！ mUsageStats.addAppIdleStateChangeListener(new AppIdleStateChangeListener()); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_NETWORK); &#125;&#125; 可以看到，最关键的一个地方，就是监听器的注册！ 4.2 new AppIdleStateChangeListenerAppIdleStateChangeListener 继承了 UsageStatsManagerInternal.AppIdleStateChangeListener，覆写了两个父类方法： onAppIdleStateChanged：用于监听 app idle 状态变化！ onParoleStateChanged：用于监听 app 假释状态的变化！ 123456789101112131415161718192021222324252627private class AppIdleStateChangeListener extends UsageStatsManagerInternal.AppIdleStateChangeListener &#123; @Override public void onAppIdleStateChanged(String packageName, int userId, boolean idle) &#123; try &#123; final int uid = mContext.getPackageManager().getPackageUidAsUser(packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, userId); if (LOGV) Log.v(TAG, \"onAppIdleStateChanged(): uid=\" + uid + \", idle=\" + idle); synchronized (mUidRulesFirstLock) &#123; //【4.3.1】更新 app idle 规则； updateRuleForAppIdleUL(uid); //【4.3.2】更新省电模式的规则； updateRulesForPowerRestrictionsUL(uid); &#125; &#125; catch (NameNotFoundException nnfe) &#123; &#125; &#125; @Override public void onParoleStateChanged(boolean isParoleOn) &#123; synchronized (mUidRulesFirstLock) &#123; //【4.4.1】更新 app idle parole 规则； updateRulesForAppIdleParoleUL(); &#125; &#125;&#125; 4.3 App Idle State Changed处理 app idle 状态的改变！ 当 AppIdleStateChangeListener.onAppIdleStateChanged 触发！ 4.3.1 updateRuleForAppIdleUL12345678910111213141516void updateRuleForAppIdleUL(int uid) &#123; //【1】判断 uid 是否在名单中，在名单中的应用不受机制影响！！ if (!isUidValidForBlacklistRules(uid)) return; int appId = UserHandle.getAppId(uid); if (!mPowerSaveTempWhitelistAppIds.get(appId) &amp;&amp; isUidIdle(uid) &amp;&amp; !isUidForegroundOnRestrictPowerUL(uid)) &#123; //【4.3.1.1】修改 FIREWALL_CHAIN_STANDBY 的规则为 FIREWALL_RULE_DENY setUidFirewallRule(FIREWALL_CHAIN_STANDBY, uid, FIREWALL_RULE_DENY); &#125; else &#123; //【4.3.1.2】修改 FIREWALL_CHAIN_STANDBY 的规则为 FIREWALL_RULE_DEFAULT setUidFirewallRule(FIREWALL_CHAIN_STANDBY, uid, FIREWALL_RULE_DEFAULT); &#125;&#125; 4.3.1.1 setUidFirewallRule123456789101112131415161718private void setUidFirewallRule(int chain, int uid, int rule) &#123; if (chain == FIREWALL_CHAIN_DOZABLE) &#123; mUidFirewallDozableRules.put(uid, rule); &#125; else if (chain == FIREWALL_CHAIN_STANDBY) &#123; //【1】将 FIREWALL_CHAIN_STANDBY 相关的规则加入 mUidFirewallStandbyRules！ mUidFirewallStandbyRules.put(uid, rule); &#125; else if (chain == FIREWALL_CHAIN_POWERSAVE) &#123; mUidFirewallPowerSaveRules.put(uid, rule); &#125; try &#123; mNetworkManager.setFirewallUidRule(chain, uid, rule); &#125; catch (IllegalStateException e) &#123; Log.wtf(TAG, \"problem setting firewall uid rules\", e); &#125; catch (RemoteException e) &#123; // ignored; service lives in system_server &#125;&#125; 4.3.2 updateRulesForPowerRestrictionsUL[1]1234567891011private void updateRulesForPowerRestrictionsUL(int uid) &#123; final int oldUidRules = mUidRules.get(uid, RULE_NONE); final int newUidRules = updateRulesForPowerRestrictionsUL(uid, oldUidRules, false); if (newUidRules == RULE_NONE) &#123; mUidRules.delete(uid); &#125; else &#123; mUidRules.put(uid, newUidRules); &#125;&#125; 4.4 Parole State Changed处理 app 假释状态的改变！ 4.4.1 updateRulesForAppIdleParoleUL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 void updateRulesForAppIdleParoleUL() &#123; //【1】判断此时是否处于假释状态！ boolean paroled = mUsageStats.isAppIdleParoleOn(); //【2】判断是否可以访问网网络！ boolean enableChain = !paroled; enableFirewallChainUL(FIREWALL_CHAIN_STANDBY, enableChain); //【3】遍历 mUidFirewallStandbyRules 中的所有 rule！ int ruleCount = mUidFirewallStandbyRules.size(); for (int i = 0; i &lt; ruleCount; i++) &#123; int uid = mUidFirewallStandbyRules.keyAt(i); int oldRules = mUidRules.get(uid); if (enableChain) &#123; //【3.1】如果可以访问网络，取消掉 RULE_ALLOW_ALL/RULE_REJECT_ALL 位！ oldRules &amp;= MASK_METERED_NETWORKS; &#125; else &#123; //【3.2】如果不可以访问网络，并且 oldRules 没有设置 RULE_ALLOW_ALL/RULE_REJECT_ALL 位！ // 那就跳过，否则进入下面的环节！ if ((oldRules &amp; MASK_ALL_NETWORKS) == 0) continue; &#125; //【4.4.2】进入 updateRulesForPowerRestrictionsUL 方法！ updateRulesForPowerRestrictionsUL(uid, oldRules, paroled); &#125; &#125;``` ### 4.4.2 updateRulesForPowerRestrictionsUL[3]```java private int updateRulesForPowerRestrictionsUL(int uid, int oldUidRules, boolean paroled) &#123; if (!isUidValidForBlacklistRules(uid)) &#123; if (LOGD) Slog.d(TAG, \"no need to update restrict power rules for uid \" + uid); return RULE_NONE; &#125; //【1】判断是否是 idle 状态！ final boolean isIdle = !paroled &amp;&amp; isUidIdle(uid); //【2】判断是否是强制模式！ final boolean restrictMode = isIdle || mRestrictPower || mDeviceIdleMode; //【3】判断 uid 下的进程是否是前台进程！ final boolean isForeground = isUidForegroundOnRestrictPowerUL(uid); //【4】判断 uid 是否在省电白名单中！ final boolean isWhitelisted = isWhitelistedBatterySaverUL(uid); final int oldRule = oldUidRules &amp; MASK_ALL_NETWORKS; int newRule = RULE_NONE; //【5】 if (isForeground) &#123; if (restrictMode) &#123; newRule = RULE_ALLOW_ALL; &#125; &#125; else if (restrictMode) &#123; newRule = isWhitelisted ? RULE_ALLOW_ALL : RULE_REJECT_ALL; &#125; //【6】计算新的 rules,oldUidRules &amp; MASK_METERED_NETWORKS 取消旧的高四位！ final int newUidRules = (oldUidRules &amp; MASK_METERED_NETWORKS) | newRule; if (LOGV) &#123; Log.v(TAG, \"updateRulesForPowerRestrictionsUL(\" + uid + \")\" + \", isIdle: \" + isIdle + \", mRestrictPower: \" + mRestrictPower + \", mDeviceIdleMode: \" + mDeviceIdleMode + \", isForeground=\" + isForeground + \", isWhitelisted=\" + isWhitelisted + \", oldRule=\" + uidRulesToString(oldRule) + \", newRule=\" + uidRulesToString(newRule) + \", newUidRules=\" + uidRulesToString(newUidRules) + \", oldUidRules=\" + uidRulesToString(oldUidRules)); &#125; //【7】如果规则发生了变化，那就发送 MSG_RULES_CHANGED 消息！ if (newRule != oldRule) &#123; if (newRule == RULE_NONE || (newRule &amp; RULE_ALLOW_ALL) != 0) &#123; if (LOGV) Log.v(TAG, \"Allowing non-metered access for UID \" + uid); &#125; else if ((newRule &amp; RULE_REJECT_ALL) != 0) &#123; if (LOGV) Log.v(TAG, \"Rejecting non-metered access for UID \" + uid); &#125; else &#123; Log.wtf(TAG, \"Unexpected change of non-metered UID state for \" + uid + \": foreground=\" + isForeground + \", whitelisted=\" + isWhitelisted + \", newRule=\" + uidRulesToString(newUidRules) + \", oldRule=\" + uidRulesToString(oldUidRules)); &#125; mHandler.obtainMessage(MSG_RULES_CHANGED, uid, newUidRules).sendToTarget(); &#125; return newUidRules; &#125; 5 AppIdleController学习过 JobSchedulerSerivce，我们知道 AppIdleController 会判断 app 是否进入 idle 状态，这样动态控制 app 对应的 job！ 5.1 new AppIdleController12345678910private AppIdleController(JobSchedulerService service, Context context, Object lock) &#123; super(service, context, lock); mJobSchedulerService = service; //【1】获得 UsageStatsService 的 LocalService 对象！ mUsageStatsInternal = LocalServices.getService(UsageStatsManagerInternal.class); //【2】初始化 mAppIdleParoleOn 为 true！ mAppIdleParoleOn = true; //【3】注册 AppIdleStateChangeListener 监听器！ mUsageStatsInternal.addAppIdleStateChangeListener(new AppIdleStateChangeListener());&#125; 5.2 new AppIdleStateChangeListenerAppIdleStateChangeListener 用于监听 app idle 状态的变化！1234567891011121314151617181920212223242526272829303132333435private class AppIdleStateChangeListener extends UsageStatsManagerInternal.AppIdleStateChangeListener &#123; @Override public void onAppIdleStateChanged(String packageName, int userId, boolean idle) &#123; boolean changed = false; synchronized (mLock) &#123; //【1】如果此时应用进入了假释状态，不处理！ if (mAppIdleParoleOn) &#123; return; &#125; //【2】为系统中的所有 Job 执行 PackageUpdateFunc 操作！ // idle 表示是否处于 idle 状态！ PackageUpdateFunc update = new PackageUpdateFunc(userId, packageName, idle); mJobSchedulerService.getJobStore().forEachJob(update); if (update.mChanged) &#123; changed = true; &#125; &#125; //【3】通知 JobSchedulerService，AppIdleController 状态发生了变化！ // 需要执行/停止 Job！ if (changed) &#123; mStateChangedListener.onControllerStateChanged(); &#125; &#125; @Override public void onParoleStateChanged(boolean isParoleOn) &#123; if (DEBUG) &#123; Slog.d(LOG_TAG, \"Parole on: \" + isParoleOn); &#125; //【4】当应用的假释模式发生变化后，调用 setAppIdleParoleOn 方法！ setAppIdleParoleOn(isParoleOn); &#125;&#125; 当应用的 app idle 状态发生了变化，会触发 onAppIdleStateChanged 方法！ 当应用的 app 假释状态发生了变化，会触发 onParoleStateChanged 方法！ 5.2.1 PackageUpdateFunc.process当 app idle 状态变化后，会触发 AppIdleController.AppIdleStateChangeListener.onAppIdleStateChanged 方法！ 1234567891011121314151617181920212223242526272829final static class PackageUpdateFunc implements JobStore.JobStatusFunctor &#123; final int mUserId; final String mPackage; final boolean mIdle; boolean mChanged; // 是否有 job 的条件发生变化！ PackageUpdateFunc(int userId, String pkg, boolean idle) &#123; mUserId = userId; mPackage = pkg; mIdle = idle; &#125; @Override public void process(JobStatus jobStatus) &#123; //【1】匹配到对应的 JobStatus！ if (jobStatus.getSourcePackageName().equals(mPackage) &amp;&amp; jobStatus.getSourceUserId() == mUserId) &#123; //【1.1】设置 Job 的 AppNotIdle 条件，如果 Job 的条件发生变化 // mChanged 为 true！ if (jobStatus.setAppNotIdleConstraintSatisfied(!mIdle)) &#123; if (DEBUG) &#123; Slog.d(LOG_TAG, \"App Idle state changed, setting idle state of \" + mPackage + \" to \" + mIdle); &#125; mChanged = true; &#125; &#125; &#125;&#125;; jobStatus.setAppNotIdleConstraintSatisfied 方法用于设置 app 是否满足不处于 idle 状态下的条件！ 5.2.2 setAppIdleParoleOn当应用的 app 假释状态发生了变化，会触发 setAppIdleParoleOn 方法！ 12345678910111213141516171819202122232425void setAppIdleParoleOn(boolean isAppIdleParoleOn) &#123; boolean changed = false; synchronized (mLock) &#123; //【1】如果假释状态没有变化，不处理! if (mAppIdleParoleOn == isAppIdleParoleOn) &#123; return; &#125; //【2】保存最新的假释状态！ mAppIdleParoleOn = isAppIdleParoleOn; //【3】对所有的 Job 执行 GlobalUpdateFunc！ GlobalUpdateFunc update = new GlobalUpdateFunc(); mJobSchedulerService.getJobStore().forEachJob(update); //【4】如果 Job 触发条件变化，changed 为 true！ if (update.mChanged) &#123; changed = true; &#125; &#125; //【4】通知 JobSchedulerService，AppIdleController 状态发生了变化！ // 需要执行/停止 Job！ if (changed) &#123; mStateChangedListener.onControllerStateChanged(); &#125;&#125; 方法流程很简单！ 5.2.2.1 GlobalUpdateFunc.process我们来看看 GlobalUpdateFunc 的逻辑！1234567891011121314151617final class GlobalUpdateFunc implements JobStore.JobStatusFunctor &#123; boolean mChanged; @Override public void process(JobStatus jobStatus) &#123; String packageName = jobStatus.getSourcePackageName(); //【1】判断 app 是否处于 idle 状态，满足条件是进入了 idle 状态，但是不能是假释状态！ final boolean appIdle = !mAppIdleParoleOn &amp;&amp; mUsageStatsInternal.isAppIdle(packageName, jobStatus.getSourceUid(), jobStatus.getSourceUserId()); if (DEBUG) &#123; Slog.d(LOG_TAG, \"Setting idle state of \" + packageName + \" to \" + appIdle); &#125; //【2】修改 Job 的 appNotIdle 执行条件，如果条件发生了变化，mChanged 为 true！ if (jobStatus.setAppNotIdleConstraintSatisfied(!appIdle)) &#123; mChanged = true; &#125; &#125;&#125;; 方法流程很简单！ 5.3 maybeStartTrackingJobLockedAppIdleController 开始监控指定的 Job！ 123456789101112131415161718192021@Overridepublic void maybeStartTrackingJobLocked(JobStatus jobStatus, JobStatus lastJob) &#123; //【1】如果还没有初始化过假释状态，进行初始化！ if (!mInitializedParoleOn) &#123; mInitializedParoleOn = true; //【1.1】调用 UsageStatsService.isAppIdleParoleOn 方法判断此时是否是应用假释模式！ mAppIdleParoleOn = mUsageStatsInternal.isAppIdleParoleOn(); &#125; String packageName = jobStatus.getSourcePackageName(); //【2】判断 app 是否处于 app idle ，满足 2 个条件，应用处于 idle 状态，但是不能处于假释模式！ final boolean appIdle = !mAppIdleParoleOn &amp;&amp; mUsageStatsInternal.isAppIdle(packageName, jobStatus.getSourceUid(), jobStatus.getSourceUserId()); if (DEBUG) &#123; Slog.d(LOG_TAG, \"Start tracking, setting idle state of \" + packageName + \" to \" + appIdle); &#125; //【3】设置 Job 的条件属性！ jobStatus.setAppNotIdleConstraintSatisfied(!appIdle);&#125; 方法流程很简单！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"UsageStats使用状态管理","slug":"AndroidFramework源码分析/UsageStats使用状态管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/UsageStats使用状态管理/"}],"tags":[{"name":"UsageStats使用状态管理","slug":"UsageStats使用状态管理","permalink":"https://coolqi.top/tags/UsageStats使用状态管理/"}]},{"title":"AppOps 第 1 篇 - AppOpsService 的启动","slug":"AppOps1-AppOpsServiceStartProcess","date":"2017-08-01T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/08/01/AppOps1-AppOpsServiceStartProcess/","link":"","permalink":"https://coolqi.top/2017/08/01/AppOps1-AppOpsServiceStartProcess/","excerpt":"","text":"[toc] 本文基于 Android 7.1.1 源码分析，如有错误，欢迎指正，谢谢！ 0 综述AppOpsService 的初始化是在 ActivityManagerService 启动的时候： 123456789101112131415161718192021222324252627282930public ActivityManagerService(Context systemContext) &#123; ... ... ... mHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false /*allowIo*/); mHandlerThread.start(); mHandler = new MainHandler(mHandlerThread.getLooper()); ... ... ... // TODO: Move creation of battery stats service outside of activity manager service. File dataDir = Environment.getDataDirectory(); File systemDir = new File(dataDir, \"system\"); systemDir.mkdirs(); ... ... ... //【1】创建了 AppOpsService 对象！ mAppOpsService = new AppOpsService(new File(systemDir, \"appops.xml\"), mHandler); //【2】启动监听，开始监听是否有应用要在后台运行！ mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null, new IAppOpsCallback.Stub() &#123; @Override public void opChanged(int op, int uid, String packageName) &#123; if (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != null) &#123; if (mAppOpsService.checkOperation(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; runInBackgroundDisabled(uid); &#125; &#125; &#125; &#125;); ... ... ...&#125; 1 new AppOpsService创建 AppOpsService 的时候，传入了一个 File 对象，用于访问 /data/system/appops.xml 文件！ 123456public AppOpsService(File storagePath, Handler handler) &#123; mFile = new AtomicFile(storagePath); mHandler = handler; //【2】从 /data/system/appops.xml 文件中读取记录！ readState();&#125; 我们来看下，appops.xml 文件的内容： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;app-ops&gt; &lt;uid n=\"1001\"&gt; &lt;op m=\"0\" n=\"15\"/&gt; &lt;/uid&gt; &lt;pkg n=\"android\"&gt; &lt;uid n=\"1000\" p=\"true\"&gt; &lt;op n=\"0\" pu=\"0\" t=\"1514736165168\"/&gt; &lt;op n=\"1\" pu=\"0\" t=\"1514738472778\"/&gt; &lt;op d=\"133\" n=\"3\" t=\"1514752786349\"/&gt; &lt;op n=\"24\" r=\"1514738089301\"/&gt; &lt;op n=\"40\" t=\"1514756174224\"/&gt; &lt;op d=\"20027926\" n=\"41\" t=\"1514736155960\"/&gt; &lt;op n=\"61\" pu=\"0\" t=\"1514756174065\"/&gt; &lt;/uid&gt; &lt;/pkg&gt; &lt;pkg n=\"com.android.settings\"&gt; &lt;uid n=\"1000\" p=\"true\"&gt; &lt;op d=\"135\" n=\"3\" t=\"1514738402132\"/&gt; &lt;op m=\"0\" n=\"15\"/&gt; &lt;op n=\"59\" pp=\"com.android.providers.media\" pu=\"0\" t=\"1514738336945\"/&gt; &lt;op n=\"60\" pu=\"0\" t=\"1514736151388\"/&gt; &lt;op n=\"63\" pu=\"0\" t=\"1514749896628\"/&gt; &lt;op n=\"73\" pu=\"0\" t=\"1514749896649\"/&gt; &lt;/uid&gt; &lt;/pkg&gt; &lt;pkg n=\"com.android.systemui\"&gt; &lt;uid n=\"1000\" p=\"true\"&gt; &lt;op d=\"74\" n=\"3\" t=\"1514752786572\"/&gt; &lt;op n=\"24\" r=\"1514741582746\"/&gt; &lt;op d=\"98\" n=\"40\" t=\"1514752835557\"/&gt; &lt;op n=\"59\" pu=\"0\" t=\"493576354\"/&gt; &lt;op n=\"60\" pu=\"0\" t=\"493576354\"/&gt; &lt;/uid&gt; &lt;/pkg&gt;&lt;/app-ops&gt; 内容我们先简单的分析下： uid 用于记录和 uid 相关的限制信息； pkg 用于记录和具体应用的限制信息； 2 AppOpsService.readStateAppOpsService 启动的时候，会读取本地持久化文件，恢复上一次的数据！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void readState() &#123; synchronized (mFile) &#123; synchronized (this) &#123; FileInputStream stream; try &#123; stream = mFile.openRead(); &#125; catch (FileNotFoundException e) &#123; Slog.i(TAG, \"No existing app ops \" + mFile.getBaseFile() + \"; starting empty\"); return; &#125; boolean success = false; mUidStates.clear(); try &#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(stream, StandardCharsets.UTF_8.name()); int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; ; &#125; if (type != XmlPullParser.START_TAG) &#123; throw new IllegalStateException(\"no start tag found\"); &#125; int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"pkg\")) &#123; //【1】读取 pkg 标签； readPackage(parser); &#125; else if (tagName.equals(\"uid\")) &#123; //【2】读取 uid 标签； readUidOps(parser); &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;app-ops&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; success = true; &#125; catch (IllegalStateException e) &#123; Slog.w(TAG, \"Failed parsing \" + e); &#125; catch (NullPointerException e) &#123; Slog.w(TAG, \"Failed parsing \" + e); &#125; catch (NumberFormatException e) &#123; Slog.w(TAG, \"Failed parsing \" + e); &#125; catch (XmlPullParserException e) &#123; Slog.w(TAG, \"Failed parsing \" + e); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Failed parsing \" + e); &#125; catch (IndexOutOfBoundsException e) &#123; Slog.w(TAG, \"Failed parsing \" + e); &#125; finally &#123; if (!success) &#123; mUidStates.clear(); &#125; try &#123; stream.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; &#125;&#125; readState 会 pkg 和 uid 标签的数据，然后保存到内部的数据结构中！ 2.1 AppOpsService.readUid[1] - 读取 uid 的 op 信息首先，解析的是 uid 信息！ 123&lt;uid n=\"1001\"&gt; &lt;op m=\"0\" n=\"15\"/&gt;&lt;/uid&gt; 解释一下： uid 的 n 属性表示 uid 的取值； op 的 n 属性表示 op 的数值，m 表示 op 的 mode 值； 我们来看看解析的过程！ 12345678910111213141516171819202122232425262728void readUidOps(XmlPullParser parser) throws NumberFormatException, XmlPullParserException, IOException &#123; final int uid = Integer.parseInt(parser.getAttributeValue(null, \"n\")); int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"op\")) &#123; // 解析 op 子标签！ final int code = Integer.parseInt(parser.getAttributeValue(null, \"n\")); // final int mode = Integer.parseInt(parser.getAttributeValue(null, \"m\")); //【2.1.1】调用 getUidStateLocked 获得 uid 对应的状态信息，如果没有，就会创建一个！ UidState uidState = getUidStateLocked(uid, true); if (uidState.opModes == null) &#123; uidState.opModes = new SparseIntArray(); &#125; uidState.opModes.put(code, mode); &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;uid-ops&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 我们看到，创建了一个 UidState 对象，封装对 uid 的 op 控制，uidState.opModes 则保存了该 uid 的所有 op 和控制情况的映射关系！ 2.1.1 getUidStateLocked12345678910111213private UidState getUidStateLocked(int uid, boolean edit) &#123; // 通过 uid，获得对应的 UidState 对象！ UidState uidState = mUidStates.get(uid); if (uidState == null) &#123; if (!edit) &#123; return null; &#125; //【2.1.2】创建一个新的 UidState，并添加到 mUidStates 中！ uidState = new UidState(uid); mUidStates.put(uid, uidState); &#125; return uidState;&#125; AppOpsService 有一个内部的 SparseArray，用于保存 uid 和其对应的 UidState 的映射关系！1private final SparseArray&lt;UidState&gt; mUidStates = new SparseArray&lt;&gt;(); 2.1.2 new UidState12345678910111213141516171819private static final class UidState &#123; public final int uid; // uid 值 public ArrayMap&lt;String, Ops&gt; pkgOps; //【2.1.2.1】属于 uid 的所有 package 和其 Op 集合的映射关系！ public SparseIntArray opModes; // 用于保存该 uid 的 op 集合 ！ public UidState(int uid) &#123; this.uid = uid; &#125; public void clear() &#123; pkgOps = null; opModes = null; &#125; public boolean isDefault() &#123; return (pkgOps == null || pkgOps.isEmpty()) &amp;&amp; (opModes == null || opModes.size() &lt;= 0); &#125;&#125; UidState.pkgOps 是一个 ArrayMap，key 为 packageName，而 value 为 Ops，Ops 用于封装该 package 所有的 Op 控制数据！ 这里涉及到了一个 Ops 类，我们来看下他的结构! 2.1.2.1 new Ops可以看到 Ops 本质上是一个 SparseArray，用于记录 package 的所有 Op 控制信息！1234567891011public final static class Ops extends SparseArray&lt;Op&gt; &#123; public final String packageName; // 所属的 package public final UidState uidState; // 所属的 UidState public final boolean isPrivileged; public Ops(String _packageName, UidState _uidState, boolean _isPrivileged) &#123; packageName = _packageName; uidState = _uidState; isPrivileged = _isPrivileged; &#125;&#125; 保存的规则是：下标为 op，值为控制情况！ 2.2 AppOpsService.readPackage - 读取 package 的 op 信息我们来看下 readPackage 解析的数据： 12345678910&lt;pkg n=\"com.android.settings\"&gt; // readPackage 解析 &lt;uid n=\"1000\" p=\"true\"&gt; // readUid[2] 解析 &lt;op d=\"135\" n=\"3\" t=\"1514738402132\"/&gt; &lt;op m=\"0\" n=\"15\"/&gt; &lt;op n=\"59\" pp=\"com.android.providers.media\" pu=\"0\" t=\"1514738336945\"/&gt; &lt;op n=\"60\" pu=\"0\" t=\"1514736151388\"/&gt; &lt;op n=\"63\" pu=\"0\" t=\"1514749896628\"/&gt; &lt;op n=\"73\" pu=\"0\" t=\"1514749896649\"/&gt; &lt;/uid&gt;&lt;/pkg&gt; 解释一下： pkg 的 n 属性表示包名； uid 的 n 表示应用包所属的 uid 值，uid 的 p 表示应用包是否是特权应用； op 的 n 属性表示 op 的数值，m 表示 op 的 mode 值； 首先是解析 pkg 标签！1234567891011121314151617181920212223void readPackage(XmlPullParser parser) throws NumberFormatException, XmlPullParserException, IOException &#123; //【1】获取包名 package name！ String pkgName = parser.getAttributeValue(null, \"n\"); int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"uid\")) &#123; //【2.1.1】这里的 uid 标签是 pkg 标签的子标签！ readUid(parser, pkgName); &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;pkg&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 继续来看： 2.2.1 AppOpsService.readUid[2]然后是解析子 uid 标签！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void readUid(XmlPullParser parser, String pkgName) throws NumberFormatException, XmlPullParserException, IOException &#123; //【1】解析 n 属性，uid； int uid = Integer.parseInt(parser.getAttributeValue(null, \"n\")); //【2】解析 p 属性，是否是特权应用； String isPrivilegedString = parser.getAttributeValue(null, \"p\"); boolean isPrivileged = false; if (isPrivilegedString == null) &#123; try &#123; IPackageManager packageManager = ActivityThread.getPackageManager(); if (packageManager != null) &#123; //【3】获得 pkg 对应的 ApplicationInfo 对象！ ApplicationInfo appInfo = ActivityThread.getPackageManager() .getApplicationInfo(pkgName, 0, UserHandle.getUserId(uid)); if (appInfo != null) &#123; isPrivileged = (appInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0; &#125; &#125; else &#123; return; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Could not contact PackageManager\", e); &#125; &#125; else &#123; //【4】是否是特权应用！ isPrivileged = Boolean.parseBoolean(isPrivilegedString); &#125; int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); //【5】解析 op 标签！ if (tagName.equals(\"op\")) &#123; //【2.2.1.1】创建一个 Op 对象，封装 op 标签的属性！ // 解析 n 属性，表示 op 的类别，保存到 Op.op！ Op op = new Op(uid, pkgName, Integer.parseInt(parser.getAttributeValue(null, \"n\"))); String mode = parser.getAttributeValue(null, \"m\"); // 解析 m 属性，用于获取该 op 的 mode 情况！ if (mode != null) &#123; op.mode = Integer.parseInt(mode); &#125; String time = parser.getAttributeValue(null, \"t\"); // 解析 t 属性，用于获取该 op 的授予情况！ if (time != null) &#123; op.time = Long.parseLong(time); &#125; time = parser.getAttributeValue(null, \"r\"); // 解析 r 属性，用于获取该 op 的拒绝时间！ if (time != null) &#123; op.rejectTime = Long.parseLong(time); &#125; String dur = parser.getAttributeValue(null, \"d\"); // 解析 d 属性，用于获取该 op 的时间间隔！ if (dur != null) &#123; op.duration = Integer.parseInt(dur); &#125; String proxyUid = parser.getAttributeValue(null, \"pu\"); // 解析 pu 属性，用于获取该 op 的代理 uid！ if (proxyUid != null) &#123; op.proxyUid = Integer.parseInt(proxyUid); &#125; String proxyPackageName = parser.getAttributeValue(null, \"pp\"); // 解析 pp 属性，用于获取该 op 的代理 pkg！ if (proxyPackageName != null) &#123; op.proxyPackageName = proxyPackageName; &#125; //【2.1.1】获得 uid 对应的 UidState 状态对象！ UidState uidState = getUidStateLocked(uid, true); if (uidState.pkgOps == null) &#123; // 如果 uidState.pkgOps 为 null，初始化！ uidState.pkgOps = new ArrayMap&lt;&gt;(); &#125; //【2.2.1.1】从 uidState.pkgOps 获得该 package 的 Ops 集合 // 如果为 null，会创建一个新的 Ops！ Ops ops = uidState.pkgOps.get(pkgName); if (ops == null) &#123; ops = new Ops(pkgName, uidState, isPrivileged); // 将其添加到 uidState.pkgOps 中！ uidState.pkgOps.put(pkgName, ops); &#125; // 保存 op 类别和对应的控制情况！ ops.put(op.op, op); &#125; else &#123; Slog.w(TAG, \"Unknown element under &lt;pkg&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 整个过程很简单，不多说了！ 2.2.1.1 new Op创建一个 Op 对象，封装 package 的每一个 Operation 信息！12345678910111213141516171819public final static class Op &#123; public final int uid; // 所属 uid public final String packageName; // 所属 package public int proxyUid = -1; public String proxyPackageName; public final int op; // 操作码，表示一个访问操作！ public int mode; // 操作的控制信息！ public int duration; public long time; public long rejectTime; public int nesting; public Op(int _uid, String _packageName, int _op) &#123; uid = _uid; packageName = _packageName; op = _op; mode = AppOpsManager.opToDefaultMode(op); // 计算 op 的默认控制状态！ &#125;&#125; 3 AppOpsService.startWatchingMode在 AMS 的构造函数中，接着启动了对 AppOpsManager.OP_RUN_IN_BACKGROUND op 操作的监听！1234567891011mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null, new IAppOpsCallback.Stub() &#123; @Override public void opChanged(int op, int uid, String packageName) &#123; if (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != null) &#123; if (mAppOpsService.checkOperation(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; runInBackgroundDisabled(uid); &#125; &#125; &#125; &#125;); 可以看到，这里传入了一个回调：1234567891011121314new IAppOpsCallback.Stub() &#123; @Override public void opChanged(int op, int uid, String packageName) &#123; //【1】当 op 为 AppOpsManager.OP_RUN_IN_BACKGROUND 时，并且 packageName 不为 null // 这时候会检查 packageName 是有允许在后台运行！ if (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != null) &#123; //【1.1】检查是否有权限执行 op 操作，关于这部分内容，我们后面再分析！ if (mAppOpsService.checkOperation(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; //【3.2.1】如果不允许，ams 会 stop 掉该进程！ runInBackgroundDisabled(uid); &#125; &#125; &#125;&#125; 这个 Callback 是一个 IAppOpsCallback.Stub 对象，用于跨进程通信，为什么是个桩对象呢？我们后面会知道！ op 参数表示的是要监听的 op 操作；packageName 表示要监听的具体的 package，这里传入的是 null；callback 表示当 op 操作发生改变时，要执行的回调！ 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void startWatchingMode(int op, String packageName, IAppOpsCallback callback) &#123; if (callback == null) &#123; return; &#125; synchronized (this) &#123; op = (op != AppOpsManager.OP_NONE) ? AppOpsManager.opToSwitch(op) : op; //【×3.1】将 callback 转为 Binder 对象，封装为一个 Callback 对象，添加到 mModeWatchers 中！ Callback cb = mModeWatchers.get(callback.asBinder()); if (cb == null) &#123; // 创建了一个 Callback 对象，用于监听远程 Binder 对象的死亡布告对象 // 这样当 IAppOpsCallback.Stub 死亡后，可以停止监听！ cb = new Callback(callback); // 将 IAppOpsCallback.Stub 和 Callback 的映射保存到 mModeWatchers 中！ mModeWatchers.put(callback.asBinder(), cb); &#125; //【3.2】将要监听的 op 操作和对应的监听回调 Callback 的映射关系保存到 mOpModeWatchers 中！ if (op != AppOpsManager.OP_NONE) &#123; ArrayList&lt;Callback&gt; cbs = mOpModeWatchers.get(op); if (cbs == null) &#123; cbs = new ArrayList&lt;Callback&gt;(); mOpModeWatchers.put(op, cbs); &#125; cbs.add(cb); &#125; //【3.3】将要监听的 package 和对应的监听回调 Callback 的映射关系保存到 mPackageModeWatchers 中！ if (packageName != null) &#123; ArrayList&lt;Callback&gt; cbs = mPackageModeWatchers.get(packageName); if (cbs == null) &#123; cbs = new ArrayList&lt;Callback&gt;(); mPackageModeWatchers.put(packageName, cbs); &#125; cbs.add(cb); &#125; &#125;&#125; AppOpsService 内部有多个集合：123//【1】用与 IBinder 作和对应的回调 Callback 的映射关系！final ArrayMap&lt;IBinder, Callback&gt; mModeWatchers = new ArrayMap&lt;IBinder, Callback&gt;(); 用于保存远程回调 IAppOpsCallback.Stub 和其对应的死亡仆告对象 Callback 的映射关系，当 IAppOpsCallback.Stub 死亡后，Callback.binderDied 会被触发，然 123456//【1】用与保存 op 操作和对应的回调 Callback 的映射关系！final SparseArray&lt;ArrayList&lt;Callback&gt;&gt; mOpModeWatchers = new SparseArray&lt;ArrayList&lt;Callback&gt;&gt;();//【2】用与保存 package 和对应的回调 Callback 的映射关系！final ArrayMap&lt;String, ArrayList&lt;Callback&gt;&gt; mPackageModeWatchers = new ArrayMap&lt;String, ArrayList&lt;Callback&gt;&gt;(); 而 mOpModeWatchers 和 mPackageModeWatchers 则是从不同的角度来建立监听关系：mOpModeWatchers 是从具体 op 的角度，而 mPackageModeWatchers 则是从 package 的角度！ 可以看到 Callback 实例的作用是，作为远程回调的死亡仆告对象，用于停止监听！！ 3.1 new Callback - 死亡回调我们来看下 Callback 对象的创建，同时 Callback 又是一个 DeathRecipient 对象，用来监听远程 IAppOpsCallback 桩对象是否死亡！123456789101112131415161718192021public final class Callback implements DeathRecipient &#123; final IAppOpsCallback mCallback; public Callback(IAppOpsCallback callback) &#123; mCallback = callback; try &#123; //【1】将自身注册为一个死亡仆告对象！ mCallback.asBinder().linkToDeath(this, 0); &#125; catch (RemoteException e) &#123; &#125; &#125; public void unlinkToDeath() &#123; //【2】解除注册！ mCallback.asBinder().unlinkToDeath(this, 0); &#125; @Override public void binderDied() &#123; //【3.1.1】当远程桩对象死亡后，停止监听！ stopWatchingMode(mCallback); &#125;&#125; 当远程的 IAppOpsCallback.Stub 死亡后，AppOpsService.stopWatchingMode 会被执行！ 3.1.1 AppOpsService.stopWatchingMode123456789101112131415161718192021222324252627282930@Overridepublic void stopWatchingMode(IAppOpsCallback callback) &#123; if (callback == null) &#123; return; &#125; synchronized (this) &#123; //【1】从 mModeWatchers 中移除 Callback！ Callback cb = mModeWatchers.remove(callback.asBinder()); if (cb != null) &#123; // 解除死亡仆告对象注册！ cb.unlinkToDeath(); //【2】从 mOpModeWatchers 移除该 Callback！ for (int i=mOpModeWatchers.size()-1; i&gt;=0; i--) &#123; ArrayList&lt;Callback&gt; cbs = mOpModeWatchers.valueAt(i); cbs.remove(cb); if (cbs.size() &lt;= 0) &#123; mOpModeWatchers.removeAt(i); &#125; &#125; //【3】从 mPackageModeWatchers 移除该 Callback！ for (int i=mPackageModeWatchers.size()-1; i&gt;=0; i--) &#123; ArrayList&lt;Callback&gt; cbs = mPackageModeWatchers.valueAt(i); cbs.remove(cb); if (cbs.size() &lt;= 0) &#123; mPackageModeWatchers.removeAt(i); &#125; &#125; &#125; &#125;&#125; 流程很简单，不多说了！ 3.2 AMS 对 OP_RUN_IN_BACKGROUND 的处理再次回到 AMS 的构造器中去看看： 12345678910//【1】当 op 为 AppOpsManager.OP_RUN_IN_BACKGROUND 时，并且 packageName 不为 null// 这时候会检查 packageName 是有允许在后台运行！if (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != null) &#123; //【1.1】检查是否有权限执行 op 操作，关于这部分内容，我们后面再分析！ if (mAppOpsService.checkOperation(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; //【3.2.1】如果不允许，ams 会 stop 掉该进程！ runInBackgroundDisabled(uid); &#125;&#125; AMS 中并没有监听某个具体的 package 的 op 变化，所以 packageName 传入的是 null；AMS 关心的是 AppOpsManager.OP_RUN_IN_BACKGROUND 操作的变化！ 当有 op 发生变化后，opChanged 方法会被调用，这时 AMS 会判断如果 op 为 AppOpsManager.OP_RUN_IN_BACKGROUND，同时 packageName 不为 null； 这时，AMS 会调用 mAppOpsService.checkOperation 判断该应用是否允许后台运行，如果不允许，那么，会调用 runInBackgroundDisabled 方法 stop 掉进程！ 3.2.1 runInBackgroundDisabled123456789101112131415final void runInBackgroundDisabled(int uid) &#123; synchronized (this) &#123; UidRecord uidRec = mActiveUids.get(uid); //【1】如果该 uid 仍然在运行，那么只有其处于 idle 状态才能 stop 进程！ if (uidRec != null) &#123; if (uidRec.idle) &#123; //【3.2.2】stop 进程！ doStopUidLocked(uidRec.uid, uidRec); &#125; &#125; else &#123; //【2】如果 uid 不再运行，那就 stop 进程！ doStopUidLocked(uid, null); &#125; &#125;&#125; 3.2.2 doStopUidLocked1234final void doStopUidLocked(int uid, final UidRecord uidRec) &#123; mServices.stopInBackgroundLocked(uid); // stop 掉该进程！ enqueueUidChangeLocked(uidRec, uid, UidRecord.CHANGE_IDLE);&#125; 这里就不多说了！ 4 AppOpsService.publish - publish 到 ServiceManager 中！我们回到 ActivityManagerService 的 start 方法中去看看：12345678910private void start() &#123; Process.removeAllProcessGroups(); mProcessCpuThread.start(); mBatteryStatsService.publish(mContext); //【1】调用了 AppOpsService 方法！ mAppOpsService.publish(mContext); Slog.d(\"AppOps\", \"AppOpsService published\"); LocalServices.addService(ActivityManagerInternal.class, new LocalService());&#125; 我们来看看 AppOpsService.publish！1234public void publish(Context context) &#123; mContext = context; ServiceManager.addService(Context.APP_OPS_SERVICE, asBinder());&#125; 将自身注册进入 ServiceManager 中！ 5 AppOpsService.systemReady我们回到 ActivityManagerService 的 systemReady 方法中去看看： 123456789101112131415161718192021222324public void systemReady(final Runnable goingCallback) &#123; synchronized(this) &#123; if (mSystemReady) &#123; // If we're done calling all the receivers, run the next \"boot phase\" passed in // by the SystemServer if (goingCallback != null) &#123; goingCallback.run(); &#125; return; &#125; mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class); // Make sure we have the current profile info, since it is needed for security checks. mUserController.onSystemReady(); mRecentTasks.onSystemReadyLocked(); //【1】调用了 mAppOpsService 的 systemReady 方法！ mAppOpsService.systemReady(); mSystemReady = true; &#125; ... ... ... ...&#125; 去看看 mAppOpsService 的 systemReady 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public void systemReady() &#123; synchronized (this) &#123; boolean changed = false; for (int i = mUidStates.size() - 1; i &gt;= 0; i--) &#123; UidState uidState = mUidStates.valueAt(i); //【×5.1】获取属于该 uid 的所有 PacakgeName！ String[] packageNames = getPackagesForUid(uidState.uid); if (ArrayUtils.isEmpty(packageNames)) &#123; //【1】如果属于该 uid 的 package 为 null，从 mUidStates 中移除！ uidState.clear(); mUidStates.removeAt(i); changed = true; continue; &#125; // 如果 uidState.pkgOps 为 null，跳过！ ArrayMap&lt;String, Ops&gt; pkgs = uidState.pkgOps; if (pkgs == null) &#123; continue; &#125; //【2】我们知道 uidState.pkgOps 保存了该 uid 下所有的 package 的 op 信息！ Iterator&lt;Ops&gt; it = pkgs.values().iterator(); while (it.hasNext()) &#123; // 遍历每一个 package 的 Op 信息！ Ops ops = it.next(); int curUid = -1; try &#123; //【2.1】首先，通过包名获得 package 的 uid！ curUid = AppGlobals.getPackageManager().getPackageUid(ops.packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, UserHandle.getUserId(ops.uidState.uid)); &#125; catch (RemoteException ignored) &#123; &#125; //【2.2】然后和 op 所属的 uid 进行比较，如果不相等，说明 package 信息发生了变化！ // 移除旧的 Ops 集合！ if (curUid != ops.uidState.uid) &#123; Slog.i(TAG, \"Pruning old package \" + ops.packageName + \"/\" + ops.uidState + \": new uid=\" + curUid); it.remove(); changed = true; &#125; &#125; if (uidState.isDefault()) &#123; //【3】移除那些没有对应 Package 和 Ops 的 UidState！ mUidStates.removeAt(i); &#125; &#125; if (changed) &#123; //【5.2】如果 changed 为 true，表示 UidState，或者 Ops 发生了变化，更新本地持久化文件！ scheduleFastWriteLocked(); &#125; &#125; MountServiceInternal mountServiceInternal = LocalServices.getService( MountServiceInternal.class); mountServiceInternal.addExternalStoragePolicy( new MountServiceInternal.ExternalStorageMountPolicy() &#123; @Override public int getMountMode(int uid, String packageName) &#123; if (Process.isIsolated(uid)) &#123; return Zygote.MOUNT_EXTERNAL_NONE; &#125; if (noteOperation(AppOpsManager.OP_READ_EXTERNAL_STORAGE, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; return Zygote.MOUNT_EXTERNAL_NONE; &#125; if (noteOperation(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; return Zygote.MOUNT_EXTERNAL_READ; &#125; return Zygote.MOUNT_EXTERNAL_WRITE; &#125; @Override public boolean hasExternalStorage(int uid, String packageName) &#123; final int mountMode = getMountMode(uid, packageName); return mountMode == Zygote.MOUNT_EXTERNAL_READ || mountMode == Zygote.MOUNT_EXTERNAL_WRITE; &#125; &#125;);&#125; 5.1 getPackagesForUid获取 uid 所有的 package： 123456789101112private static String[] getPackagesForUid(int uid) &#123; String[] packageNames = null; try &#123; packageNames = AppGlobals.getPackageManager().getPackagesForUid(uid); &#125; catch (RemoteException e) &#123; /* ignore - local call */ &#125; if (packageNames == null) &#123; return EmptyArray.STRING; &#125; return packageNames;&#125; 以数组形式放回！ 5.2 scheduleFastWriteLocked更新本地的持久化文件！12345678private void scheduleFastWriteLocked() &#123; if (!mFastWriteScheduled) &#123; mWriteScheduled = true; mFastWriteScheduled = true; mHandler.removeCallbacks(mWriteRunner); mHandler.postDelayed(mWriteRunner, 10*1000); // &#125;&#125; 这里的 mHandler 是由 AMS 创建的一个子线程的 Handler！ 123456789101112131415161718final Runnable mWriteRunner = new Runnable() &#123; public void run() &#123; synchronized (AppOpsService.this) &#123; mWriteScheduled = false; mFastWriteScheduled = false; //【1】创建一个 AsyncTask 异步任务对象！ AsyncTask&lt;Void, Void, Void&gt; task = new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; //【5.3】writeState 更新持久化文件！ writeState(); return null; &#125; &#125;; //【2】执行任务！ task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null); &#125; &#125;&#125;; 继续来看！！ 5.3 writeState我们来看下，如何更新持久化文件！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115void writeState() &#123; synchronized (mFile) &#123; //【5.2.1】获得所有 package 的 Op 信息！ List&lt;AppOpsManager.PackageOps&gt; allOps = getPackagesForOps(null); FileOutputStream stream; try &#123; stream = mFile.startWrite(); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Failed to write state: \" + e); return; &#125; try &#123; XmlSerializer out = new FastXmlSerializer(); out.setOutput(stream, StandardCharsets.UTF_8.name()); out.startDocument(null, true); out.startTag(null, \"app-ops\"); //【1】写入 app-ops 标签！ final int uidStateCount = mUidStates.size(); for (int i = 0; i &lt; uidStateCount; i++) &#123; //【2】首先写入 uid 标签！ UidState uidState = mUidStates.valueAt(i); if (uidState.opModes != null &amp;&amp; uidState.opModes.size() &gt; 0) &#123; out.startTag(null, \"uid\"); out.attribute(null, \"n\", Integer.toString(uidState.uid)); //【2.1】写入 n 属性！ SparseIntArray uidOpModes = uidState.opModes; final int opCount = uidOpModes.size(); for (int j = 0; j &lt; opCount; j++) &#123; final int op = uidOpModes.keyAt(j); final int mode = uidOpModes.valueAt(j); out.startTag(null, \"op\"); //【2.2】写入 op 子标签，和对应的 n，m 属性！ out.attribute(null, \"n\", Integer.toString(op)); out.attribute(null, \"m\", Integer.toString(mode)); out.endTag(null, \"op\"); &#125; out.endTag(null, \"uid\"); &#125; &#125; if (allOps != null) &#123; // 如果 allOps 不为 null，那就开始写入 pkg 标签！ String lastPkg = null; for (int i=0; i&lt;allOps.size(); i++) &#123; AppOpsManager.PackageOps pkg = allOps.get(i); if (!pkg.getPackageName().equals(lastPkg)) &#123; if (lastPkg != null) &#123; out.endTag(null, \"pkg\"); &#125; lastPkg = pkg.getPackageName(); out.startTag(null, \"pkg\"); // 写入 pkg 标签 out.attribute(null, \"n\", lastPkg); // 写入 n 属性，包名 &#125; out.startTag(null, \"uid\"); // 写入 uid 子标签 out.attribute(null, \"n\", Integer.toString(pkg.getUid())); // 写入 n 属性，uid 的值 synchronized (this) &#123; Ops ops = getOpsRawLocked(pkg.getUid(), pkg.getPackageName(), false); // 写入 p 属性，表示是否是 Privileged！ if (ops != null) &#123; out.attribute(null, \"p\", Boolean.toString(ops.isPrivileged)); &#125; else &#123; out.attribute(null, \"p\", Boolean.toString(false)); &#125; &#125; List&lt;AppOpsManager.OpEntry&gt; ops = pkg.getOps(); // 处理该 package 的 Ops！ for (int j=0; j&lt;ops.size(); j++) &#123; AppOpsManager.OpEntry op = ops.get(j); out.startTag(null, \"op\"); // 写入 op 标签； out.attribute(null, \"n\", Integer.toString(op.getOp())); // 写入 n 属性，op 码； // 写入 m 属性，表示控制状态，这里先调用了 AppOpsManager.opToDefaultMode 来计算下 // 默认的控制状态。如果 op 的控制状态不等于默认值才会写入！ if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) &#123; out.attribute(null, \"m\", Integer.toString(op.getMode())); &#125; // 写入 t 属性！ long time = op.getTime(); if (time != 0) &#123; out.attribute(null, \"t\", Long.toString(time)); &#125; // 写入 r 属性！ time = op.getRejectTime(); if (time != 0) &#123; out.attribute(null, \"r\", Long.toString(time)); &#125; // 写入 d 属性！ int dur = op.getDuration(); if (dur != 0) &#123; out.attribute(null, \"d\", Integer.toString(dur)); &#125; // 写入 pu 属性！ int proxyUid = op.getProxyUid(); if (proxyUid != -1) &#123; out.attribute(null, \"pu\", Integer.toString(proxyUid)); &#125; // 写入 pp 属性！ String proxyPackageName = op.getProxyPackageName(); if (proxyPackageName != null) &#123; out.attribute(null, \"pp\", proxyPackageName); &#125; out.endTag(null, \"op\"); &#125; out.endTag(null, \"uid\"); &#125; if (lastPkg != null) &#123; out.endTag(null, \"pkg\"); &#125; &#125; out.endTag(null, \"app-ops\"); out.endDocument(); mFile.finishWrite(stream); &#125; catch (IOException e) &#123; Slog.w(TAG, \"Failed to write state, restoring backup.\", e); mFile.failWrite(stream); &#125; &#125;&#125; writeState 的流程还是很简单的！ 5.3.1 getPackagesForOps该方法用于获得所有 package 的 Op 信息，参数 ops 表示只收集其指定的 op 信息！ 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic List&lt;AppOpsManager.PackageOps&gt; getPackagesForOps(int[] ops) &#123; //【1】首先，强制检查调用者是否有 GET_APP_OPS_STATS 权限！ mContext.enforcePermission(android.Manifest.permission.GET_APP_OPS_STATS, Binder.getCallingPid(), Binder.getCallingUid(), null); ArrayList&lt;AppOpsManager.PackageOps&gt; res = null; synchronized (this) &#123; final int uidStateCount = mUidStates.size(); for (int i = 0; i &lt; uidStateCount; i++) &#123; UidState uidState = mUidStates.valueAt(i); if (uidState.pkgOps == null || uidState.pkgOps.isEmpty()) &#123; continue; &#125; //【1.1】首先，获得 uidState.pkgOps 中保存的该 uid 下，所有的 package 的 Ops！ ArrayMap&lt;String, Ops&gt; packages = uidState.pkgOps; final int packageCount = packages.size(); for (int j = 0; j &lt; packageCount; j++) &#123; //【1.2】处理每一个 package 的 Ops！ Ops pkgOps = packages.valueAt(j); //【5.3.1.1】调用 collectOps 方法,收集 package 的 Op 信息，封装为 OpEntry 对象！！ ArrayList&lt;AppOpsManager.OpEntry&gt; resOps = collectOps(pkgOps, ops); if (resOps != null) &#123; if (res == null) &#123; res = new ArrayList&lt;AppOpsManager.PackageOps&gt;(); &#125; //【5.3.1.2】创建一个 PackageOps 对象，封装该 package 的所有 Op 信息 // 最后添加到 res 列表中！ AppOpsManager.PackageOps resPackage = new AppOpsManager.PackageOps( pkgOps.packageName, pkgOps.uidState.uid, resOps); res.add(resPackage); &#125; &#125; &#125; &#125; // 返回列表！ return res;&#125; 5.3.1.1 collectOps参数 int[] ops 用于指定特定的 Op，这样我们会只收集这些特定的 Ops，当然这里我们要收集所有 package 的 Op 信息，所以 int[] ops 传入 null； 123456789101112131415161718192021222324252627private ArrayList&lt;AppOpsManager.OpEntry&gt; collectOps(Ops pkgOps, int[] ops) &#123; ArrayList&lt;AppOpsManager.OpEntry&gt; resOps = null; if (ops == null) &#123; //【1】ops 为 null，我们收集该 package 的所有 Ops！ resOps = new ArrayList&lt;AppOpsManager.OpEntry&gt;(); for (int j=0; j&lt;pkgOps.size(); j++) &#123; Op curOp = pkgOps.valueAt(j); // 处理每一个 Op 对象！ //【5.3.1.1.1】创建一个 AppOpsManager.OpEntry 对象，并添加到 resOps 中！ resOps.add(new AppOpsManager.OpEntry(curOp.op, curOp.mode, curOp.time, curOp.rejectTime, curOp.duration, curOp.proxyUid, curOp.proxyPackageName)); &#125; &#125; else &#123; for (int j=0; j&lt;ops.length; j++) &#123; Op curOp = pkgOps.get(ops[j]); if (curOp != null) &#123; //【2】ops 不为 null，我们收集数组 ops 指定的 Op！ if (resOps == null) &#123; resOps = new ArrayList&lt;AppOpsManager.OpEntry&gt;(); &#125; resOps.add(new AppOpsManager.OpEntry(curOp.op, curOp.mode, curOp.time, curOp.rejectTime, curOp.duration, curOp.proxyUid, curOp.proxyPackageName)); &#125; &#125; &#125; //【3】返回 resOps return resOps;&#125; collectOps 方法很简单，不多说了！ 5.3.1.1.1 new AppOpsManager.OpEntry12345678910111213141516171819202122public static class OpEntry implements Parcelable &#123; private final int mOp; private final int mMode; private final long mTime; private final long mRejectTime; private final int mDuration; private final int mProxyUid; private final String mProxyPackageName; public OpEntry(int op, int mode, long time, long rejectTime, int duration, int proxyUid, String proxyPackage) &#123; mOp = op; mMode = mode; mTime = time; mRejectTime = rejectTime; mDuration = duration; mProxyUid = proxyUid; mProxyPackageName = proxyPackage; &#125; ... ... ... ...// 省略 get 和 set，以及 Parcelable 相关方法！&#125; OpEntry 的结构很简单，不多说了！ 5.3.1.2 new AppOpsManager.PackageOps123456789101112public static class PackageOps implements Parcelable &#123; private final String mPackageName; // package private final int mUid; // uid private final List&lt;OpEntry&gt; mEntries; // 持有的所有 Op 对应的 OpEntry 对象！ public PackageOps(String packageName, int uid, List&lt;OpEntry&gt; entries) &#123; mPackageName = packageName; mUid = uid; mEntries = entries; &#125; ... ... ... ...// 省略 get 和 set，以及 Parcelable 相关方法！&#125; PackageOps 的结构很简单，不多说了！ 5.3.2 getOpsRawLockedgetOpsRawLocked 方法用于获得 package 的 Ops 列表！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private Ops getOpsRawLocked(int uid, String packageName, boolean edit) &#123; //【1】获得 uid 对应的 UidState！ UidState uidState = getUidStateLocked(uid, edit); if (uidState == null) &#123; return null; &#125; if (uidState.pkgOps == null) &#123; if (!edit) &#123; return null; &#125; uidState.pkgOps = new ArrayMap&lt;&gt;(); &#125; //【2】获得 package 对应的 Ops 集合！ Ops ops = uidState.pkgOps.get(packageName); if (ops == null) &#123; // 处理 package 的 ops 为 null 的特殊情况！ if (!edit) &#123; return null; &#125; boolean isPrivileged = false; //【3】如果 uid 不为 null，需要校验 uid 是否一致！ if (uid != 0) &#123; final long ident = Binder.clearCallingIdentity(); try &#123; int pkgUid = -1; try &#123; //【3.1】获得该 package 的 ApplicationInfo 对象！ ApplicationInfo appInfo = ActivityThread.getPackageManager() .getApplicationInfo(packageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getUserId(uid)); //【3.2】获得 package 的 uid，并判断是否是 FLAG_PRIVILEGED 的！ if (appInfo != null) &#123; pkgUid = appInfo.uid; isPrivileged = (appInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0; &#125; else &#123; // 如果 appInfo 为 null，那就判断一些特殊 uid 的情况！ if (\"media\".equals(packageName)) &#123; pkgUid = Process.MEDIA_UID; isPrivileged = false; &#125; else if (\"audioserver\".equals(packageName)) &#123; pkgUid = Process.AUDIOSERVER_UID; isPrivileged = false; &#125; else if (\"cameraserver\".equals(packageName)) &#123; pkgUid = Process.CAMERASERVER_UID; isPrivileged = false; &#125; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Could not contact PackageManager\", e); &#125; //【3.3】检查 uid 是否发生变化，如果有变化，无效，那就返回 null！ if (pkgUid != uid) &#123; RuntimeException ex = new RuntimeException(\"here\"); ex.fillInStackTrace(); Slog.w(TAG, \"Bad call: specified package \" + packageName + \" under uid \" + uid + \" but it is really \" + pkgUid, ex); return null; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; //【4】如果该 package 的 Ops 为 null，那就会 // 给该 package 重新创建一个 Ops，并添加到所属的 uidState.pkgOps 中！ ops = new Ops(packageName, uidState, isPrivileged); uidState.pkgOps.put(packageName, ops); &#125; return ops; // 返回该 package 的 Ops 列表！&#125; 方法很简单，不多说了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AppOps应用操作管理","slug":"AndroidFramework源码分析/AppOps应用操作管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AppOps应用操作管理/"}],"tags":[{"name":"AppOps应用操作管理","slug":"AppOps应用操作管理","permalink":"https://coolqi.top/tags/AppOps应用操作管理/"}]},{"title":"AlarmManager第 2 篇 - set Alarm 流程分析","slug":"AlarmManager2-setAlarm","date":"2017-07-25T12:46:25.000Z","updated":"2018-11-20T17:39:16.000Z","comments":true,"path":"2017/07/25/AlarmManager2-setAlarm/","link":"","permalink":"https://coolqi.top/2017/07/25/AlarmManager2-setAlarm/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，分析 AlarmManagerService 的机制 0 综述下面是设置精确 alarm 的方法： 123456789101112public static void setGlobalNoticeDialogForceShowAlarm(Context context) &#123; Intent intent = new Intent(\"com.coolqi.alarm_start\"); PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0); AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); alarmManager.cancel(pi); int timeHour = 2*24*60*60;// two days OppoLog.d(TAG, \"show global time: \" + timeHour); long triggerTime = CommonUtil.getTriggerTime(System.currentTimeMillis(), timeHour); alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pi);&#125; 1 AlarmManager.setAlarmAlarmManagerSerivce 提供了很丰富的接口来设置不同类型的 alarm，可以通过 AlarmManager.java 来看到所有的接口： 1.1 AlarmManager.setset 接口用于设置一个一次性的闹钟，该闹钟是非精确的，我们需要传入一个 triggerAtMillis 毫秒值被表示闹钟触发的时间点！ 1234public void set(@AlarmType int type, long triggerAtMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, legacyExactLength(), 0, 0, operation, null, null, null, null, null);&#125; 这个 set 方法最常用：第一个参数是 alarm 的类型，第二个是触发时间，第三个是 PendingIntent，用于启动 Service，activity，或者是 broadcastReceiver！ 可以实现跨进程，即：设置该 alarm 的进程和处理 alarm 触发的进程可以不是同一个！ 参数传递： int type：闹钟类型 type； long triggerAtMillis：触发时间，单位毫秒； long windowMillis：legacyExactLength()，API 19 以后返回值为 WINDOW_HEURISTIC，即 -1； long intervalMillis：0； int flags：0； PendingIntent operation：operation； final OnAlarmListener listener：null； String listenerTag：null； Handler targetHandler：null； WorkSource workSource：null； AlarmClockInfo alarmCloc：null； 12345public void set(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler) &#123; setImpl(type, triggerAtMillis, legacyExactLength(), 0, 0, null, listener, tag, targetHandler, null, null);&#125; 这个 set 方法并不适用于跨进程通信，其需要传入一个实现了 OnAlarmListener 接口的对象用于监听 alarm 的触发，当 alarm 触发后，OnAlarmListener 的会被 onAlarm() 执行！ targetHandler 表示的是 OnAlarmListener.onAlarm 执行时，目标线程的 handler 对象！ 12345678/** @hide */@SystemApi@RequiresPermission(android.Manifest.permission.UPDATE_DEVICE_STATS)public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, PendingIntent operation, WorkSource workSource) &#123; setImpl(type, triggerAtMillis, windowMillis, intervalMillis, 0, operation, null, null, null, workSource, null);&#125; 123456public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, String tag, OnAlarmListener listener, Handler targetHandler, WorkSource workSource) &#123; setImpl(type, triggerAtMillis, windowMillis, intervalMillis, 0, null, listener, tag, targetHandler, workSource, null);&#125; 12345678@SystemApi@RequiresPermission(android.Manifest.permission.UPDATE_DEVICE_STATS)public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, OnAlarmListener listener, Handler targetHandler, WorkSource workSource) &#123; setImpl(type, triggerAtMillis, windowMillis, intervalMillis, 0, null, listener, null, targetHandler, workSource, null);&#125; set 方法设置的 alarm 是非精确的！ 1.2 AlarmManager.setExact用于设置一个精确的闹钟，该方法是相对于 set 方法的，参数和 set 方法一样，不多说，也有 2 个方法！ 12345678910public void setExact(@AlarmType int type, long triggerAtMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, operation, null, null, null, null, null);&#125;public void setExact(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler) &#123; setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, null, listener, tag, targetHandler, null, null);&#125; 不多说了！！ 1.3 AlarmManager.setWindow用于设置一个在给定的时间窗触发的闹钟。该方法允许应用程序精确地控制操作系统调整闹钟触发时间的程度。 其中，windowStartMillis 表示时间窗的起始时间！windowStartMillis 表示时间窗的长度，其他参数和 set 方法一样！ 1234567891011public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation) &#123; setImpl(type, windowStartMillis, windowLengthMillis, 0, 0, operation, null, null, null, null, null);&#125;public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, String tag, OnAlarmListener listener, Handler targetHandler) &#123; setImpl(type, windowStartMillis, windowLengthMillis, 0, 0, null, listener, tag, targetHandler, null, null);&#125; setWindow 设置的是非精确的闹钟！ 1.4 AlarmManager.setXXXRepeatingsetRepeating 和 setInexactRepeating 用于设置一个可重复触发的闹钟，但是二者却有着不同： 12345public void setRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, 0, operation, null, null, null, null, null);&#125; setRepeating 方法在 API19 以前是精确的，其时间间隔是固定的，但是在 API19 以后则是非精确闹钟，其等价于 setInexactRepeating 方法！ 12345public void setInexactRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, 0, operation, null, null, null, null, null);&#125; setInexactRepeating 则是非精确闹钟，间隔时间不固定！ 1.5 AlarmManager.setAlarmClocksetAlarmClock 方法用于通过 AlarmClockInfo 来设置一个精确闹钟！ 1234public void setAlarmClock(AlarmClockInfo info, PendingIntent operation) &#123; setImpl(RTC_WAKEUP, info.getTriggerTime(), WINDOW_EXACT, 0, 0, operation, null, null, null, null, info);&#125; 1.6 AlarmManager.setIdleUntilsetIdleUntil 方法会将 alarm manager service 置为 idle 状态，并设置一个精确闹钟，当该闹钟触发后 alarm manager service 才会退出 idle 状态！ 12345public void setIdleUntil(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler) &#123; setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_IDLE_UNTIL, null, listener, tag, targetHandler, null, null);&#125; 可以看到，其调用 setImpl 方法的时候，传入了一个 flag，表示要将 AlarmManagerService 置为 idle 状态！ 1public static final int FLAG_IDLE_UNTIL = 1&lt;&lt;4; 该方法只能是系统调用！ 1.7 AlarmManager.setXXXAndAllowWhileIdlesetAndAllowWhileIdle 和 setExactAndAllowWhileIdle 方法用于设置在设备处于 idle 状态下，仍然能够触发的 alarm，但是二者有不同之处： 12345public void setAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, 0, FLAG_ALLOW_WHILE_IDLE, operation, null, null, null, null, null);&#125; setAndAllowWhileIdle 方法设置的是非精确闹钟！12345public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, PendingIntent operation) &#123; setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation, null, null, null, null, null);&#125; setExactAndAllowWhileIdle 方法设置的是精确闹钟！ 当 setXXXAndAllowWhileIdle 设置闹钟时候，会传入一个 flags，表示该闹钟在设别处于 idle 状态时依然可以触发！1public static final int FLAG_ALLOW_WHILE_IDLE = 1&lt;&lt;2; 2 AlarmManager.setImpl可以看到，最后都会调用 setImpl 接口： 123456789101112131415161718192021222324252627282930313233343536373839404142private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Handler targetHandler, WorkSource workSource, AlarmClockInfo alarmClock) &#123; // 触发时间最小为 0； if (triggerAtMillis &lt; 0) &#123; triggerAtMillis = 0; &#125; ListenerWrapper recipientWrapper = null; // 当传入的 listener 不为 null 时候，才会进入下面的逻辑！ if (listener != null) &#123; synchronized (AlarmManager.class) &#123; // sWrappers 是一个 ArrayMap 集合，用于保存 OnAlarmListener 和 ListenerWrapper 的映射！ if (sWrappers == null) &#123; sWrappers = new ArrayMap&lt;OnAlarmListener, ListenerWrapper&gt;(); &#125; // 如果该 OnAlarmListener 已经有了 recipientWrapper 对象，那就复用该实例； // 如果没有那就创建一个新的 recipientWrapper 实例，并将应映射关系保存进 sWrappers！ recipientWrapper = sWrappers.get(listener); // no existing wrapper =&gt; build a new one if (recipientWrapper == null) &#123; recipientWrapper = new ListenerWrapper(listener); sWrappers.put(listener, recipientWrapper); &#125; &#125; // 初始化 targetHandler，如果没有设置 targetHandler 那就为主线程的 Handler！ final Handler handler = (targetHandler != null) ? targetHandler : mMainThreadHandler; // 设置 recipientWrapper 的 Handler 变量！ recipientWrapper.setHandler(handler); &#125; try &#123; //【3】调用 AlarmManagerService 的 set 方法，设置闹钟！ mService.set(mPackageName, type, triggerAtMillis, windowMillis, intervalMillis, flags, operation, recipientWrapper, listenerTag, workSource, alarmClock); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 2.1 new ListenerWrapper如果我们指定了 OnAlarmListener，那么就会创建对应的 ListenerWrapper 实例： 123456789101112131415final class ListenerWrapper extends IAlarmListener.Stub implements Runnable &#123; final OnAlarmListener mListener; Handler mHandler; IAlarmCompleteListener mCompletion; public ListenerWrapper(OnAlarmListener listener) &#123; mListener = listener; &#125; public void setHandler(Handler h) &#123; mHandler = h; &#125; ... ... ...&#125; 其实 ListenerWrapper 是一个 Runnable 对象，其构造函数和 setHandler 都很简单，这里就不说了！ 2.1.1 ListenerWrapper.doAlarm这里先简单说一下，当闹钟触发后，会回调其 doAlarm 方法：12345678910111213@Overridepublic void doAlarm(IAlarmCompleteListener alarmManager) &#123; mCompletion = alarmManager; // 从本地的 sWrappers 中移除映射关系！ synchronized (AlarmManager.class) &#123; if (sWrappers != null) &#123; sWrappers.remove(mListener); &#125; &#125; // 调用 set alarm 是传入的 mHandler，执行任务! mHandler.post(this);&#125; 这里的 IAlarmCompleteListener 是一个接口，支持 Binder 通信，当闹钟触发后，AlarmManagerService 会传递一个实现了 IAlarmCompleteListener 接口的对象给当前进程 然后会调用自身的 run 方法，12345678910111213141516@Overridepublic void run() &#123; try &#123; // 执行 onAlarm 回调！ mListener.onAlarm(); &#125; finally &#123; // No catch -- make sure to report completion to the system process, // but continue to allow the exception to crash the app. try &#123; mCompletion.alarmComplete(this); &#125; catch (Exception e) &#123; Log.e(TAG, \"Unable to report completion to Alarm Manager!\", e); &#125; &#125;&#125; 逻辑很简单，不多说了！ 3 AlarmManagerService我们知道 set 方法最后调用了：12mService.set(mPackageName, type, triggerAtMillis, windowMillis, intervalMillis, flags, operation, recipientWrapper, listenerTag, workSource, alarmClock); 这个 mService 是服务端的 proxy 对象！AlarmManager 框架实现了 Aidl 模板，实现跨进程通讯： 1234567891011interface IAlarmManager &#123; /** windowLength == 0 means exact; windowLength &lt; 0 means the let the OS decide */ void set(String callingPackage, int type, long triggerAtTime, long windowLength, long interval, int flags, in PendingIntent operation, in IAlarmListener listener, String listenerTag, in WorkSource workSource, in AlarmManager.AlarmClockInfo alarmClock); boolean setTime(long millis); void setTimeZone(String zone); void remove(in PendingIntent operation, in IAlarmListener listener); long getNextWakeFromIdleTime(); AlarmManager.AlarmClockInfo getNextAlarmClock(int userId);&#125; AlarmManagerService 内部有一个 IBinder 对象，是 IAlarmManager.Stub 的实现对象，作为服务端的 “桩”： 3.1 AlarmMS.mService.set123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private final IBinder mService = new IAlarmManager.Stub() &#123; @Override public void set(String callingPackage, int type, long triggerAtTime, long windowLength, long interval, int flags, PendingIntent operation, IAlarmListener directReceiver, String listenerTag, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock) &#123; final int callingUid = Binder.getCallingUid(); //【1】通过 appOps 校验 uid 和包名是匹配的！ mAppOps.checkPackage(callingUid, callingPackage); //【2】重复 alarm 必须要使用 PendingIntent，不能使用 directReceiver，那就是异常！ if (interval != 0) &#123; if (directReceiver != null) &#123; throw new IllegalArgumentException(\"Repeating alarms cannot use AlarmReceivers\"); &#125; &#125; //【3】如果 workSource 不为 null， // 那就检查调用者是否具有 android.Manifest.permission.UPDATE_DEVICE_STATS 权限！ if (workSource != null) &#123; getContext().enforcePermission( android.Manifest.permission.UPDATE_DEVICE_STATS, Binder.getCallingPid(), callingUid, \"AlarmManager.set\"); &#125; //【4】清除 flags 中的 FLAG_WAKE_FROM_IDLE 和 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 标志位 // 后续会添加！ flags &amp;= ~(AlarmManager.FLAG_WAKE_FROM_IDLE | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED); //【5】如果调用者不是 system 进程，那么其不能调用 setIdleUntil 方法设置闹钟， // 所以 flags 需要去掉 FLAG_IDLE_UNTIL 位！这个标志位是告诉 AlarmManagerService 什么时候退出 idle 状态！ // 被 DeviceIdleController 调用！ if (callingUid != Process.SYSTEM_UID) &#123; flags &amp;= ~AlarmManager.FLAG_IDLE_UNTIL; &#125; //【6】如果闹钟的精确闹钟，那就设置 FLAG_STANDALONE 标志位，精确闹钟不会和其他闹钟进行批处理！ // Flags 设置 FLAG_STANDALONE 标志位！ if (windowLength == AlarmManager.WINDOW_EXACT) &#123; flags |= AlarmManager.FLAG_STANDALONE; &#125; //【7】如果是通过 setAlarmClock 方法设置的闹钟，那么其是精确的并且是 idle 状态依然生效的 // flags 设置 FLAG_WAKE_FROM_IDLE 和 FLAG_STANDALONE！ if (alarmClock != null) &#123; flags |= AlarmManager.FLAG_WAKE_FROM_IDLE | AlarmManager.FLAG_STANDALONE; //【7】如果不是调用 setAlarmClock 方法设置 alarm，进入下面的分支！ &#125; else if (workSource == null &amp;&amp; (callingUid &lt; Process.FIRST_APPLICATION_UID || Arrays.binarySearch(mDeviceIdleUserWhitelist, UserHandle.getAppId(callingUid)) &gt;= 0)) &#123; // 如果 workSource 为 null，且调用者是系统应用，或者调用者在 doze 模式白名单中 // 那么该 alarm 在 idle 状态下，不受限制，flags 设置 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED！ // 取消 FLAG_ALLOW_WHILE_IDLE 标志位！ flags |= AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED; flags &amp;= ~AlarmManager.FLAG_ALLOW_WHILE_IDLE; &#125; //【3.2】调用 AlarmManagerService 的 setImpl 方法继续设置闹钟！ setImpl(type, triggerAtTime, windowLength, interval, operation, directReceiver, listenerTag, flags, workSource, alarmClock, callingUid, callingPackage); &#125; ... ... ... ...&#125; 标志位： AlarmManager.FLAG_WAKE_FROM_IDLE: 如果设备处于 idle 状态，该类型的 alarm 会将设别唤醒！ AlarmClock 默认就是 FLAG_WAKE_FROM_IDLE 类型的！ AlarmManager.FLAG_IDLE_UNTIL: doze 模式的闹钟，只能由系统通过 setIdleUtil 来设置，这个方法会使得系统进入 idle 状态，直到这个 alarm 触发；如果系统中已经有 FLAG_WAKE_FROM_IDLE 类型的 alarm，那么 FLAG_IDLE_UNTIL 类型的 alarm 的触发事件会提前！ AlarmManager.FLAG_STANDALONE: 精确闹钟，如果设置 alarm 时，指定了闹钟为精确闹钟：WINDOW_EXACT，那么该 flags 会被设置 FLAG_STANDALONE 标志位 AlarmManager.FLAG_ALLOW_WHILE_IDLE： 即使设备处于 idle 状态，该 alarm 也能触发，通过 setAndAllowWhileIdle 和 setExactAndAllowWhileIdle 设置！ AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 如果是系统应用， 或者调用者在 doze 模式的白名单中，那么会设置 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 标志位，而不是 FLAG_ALLOW_WHILE_IDLE 标志位！ 方法流程总结： 通过 appOps 校验，uid 和包名是否一致； 重复触发的 alarm 必须要使用 PendingIntent，不能使用 directReceiver！ 如果 workSource 不为 null，调用者必须有 android.Manifest.permission.UPDATE_DEVICE_STATS 的权限！ 非 system uid 的调用者，其不能调用 setIdleUntil 方法设置 FLAG_IDLE_UNTIL！ 如果是精确闹钟，那就设置 AlarmManager.FLAG_STANDALONE 标志位！ 如果是 alarmClock，那就设置 AlarmManager.FLAG_WAKE_FROM_IDLE 和 AlarmManager.FLAG_STANDALONE！ 如果是系统应用， 或者调用者在 doze 模式的白名单中，那么会设置 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 标志位，而不是 FLAG_ALLOW_WHILE_IDLE 标志位！ 最后，调用 setImpl 方法继续设置！ 可以看到，我们在 AlarmManager 中调用的 set 接口，会调用该“桩”对象的 set 方法，桩对象的 set 最后会调用 AlarmManagerService 的 setImpl 方法！ 3.2 AlarmMS.setImplsetImpl 方法中，首先会做一些参数校验！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081void setImpl(int type, long triggerAtTime, long windowLength, long interval, PendingIntent operation, IAlarmListener directReceiver, String listenerTag, int flags, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock, int callingUid, String callingPackage) &#123; //【1】校验 PendingIntent 和 directReceiver 是否设置正确！ if ((operation == null &amp;&amp; directReceiver == null) || (operation != null &amp;&amp; directReceiver != null)) &#123; Slog.w(TAG, \"Alarms must either supply a PendingIntent or an AlarmReceiver\"); return; &#125; //【2】校验时间窗的长度 // 如果时间窗长度超过 12h，那就设置为 1h if (windowLength &gt; AlarmManager.INTERVAL_HALF_DAY) &#123; Slog.w(TAG, \"Window length \" + windowLength + \"ms suspiciously long; limiting to 1 hour\"); windowLength = AlarmManager.INTERVAL_HOUR; &#125; //【3】校验重复触发的时间间隔，最小的重复触发的时间间隔为 1min! final long minInterval = mConstants.MIN_INTERVAL; if (interval &gt; 0 &amp;&amp; interval &lt; minInterval) &#123; Slog.w(TAG, \"Suspiciously short interval \" + interval + \" millis; expanding to \" + (minInterval/1000) + \" seconds\"); interval = minInterval; &#125; //【4】校验闹钟的类型 type 是否设置的正确！ if (type &lt; RTC_WAKEUP || type &gt; ELAPSED_REALTIME) &#123; throw new IllegalArgumentException(\"Invalid alarm type \" + type); &#125; //【5】校验触发时间是否正确！ if (triggerAtTime &lt; 0) &#123; final long what = Binder.getCallingPid(); Slog.w(TAG, \"Invalid alarm trigger time! \" + triggerAtTime + \" from uid=\" + callingUid + \" pid=\" + what); triggerAtTime = 0; &#125; //【3.2.1】计算触发时间，根据闹钟是否是 RTC 类型的，进行调整！ // 如果是 RTC 格式，就将其转换成 elapsedRealtime 格式的触发时间！ final long nowElapsed = SystemClock.elapsedRealtime(); final long nominalTrigger = convertToElapsed(triggerAtTime, type); //【7】校验触发时间是否大于最低触发时间，默认是 5s，防止 alarm 频繁触发！ final long minTrigger = nowElapsed + mConstants.MIN_FUTURITY; final long triggerElapsed = (nominalTrigger &gt; minTrigger) ? nominalTrigger : minTrigger; //【8】根据时间窗取值，设置最晚触发时间！ final long maxElapsed; if (windowLength == AlarmManager.WINDOW_EXACT) &#123; //【8.1】如果取值为 WINDOW_EXACT，那就为精确闹钟，最晚触发时间和设置的时间一样！ maxElapsed = triggerElapsed; &#125; else if (windowLength &lt; 0) &#123; //【3.2.2】如果取值小于 0，其为非精确闹钟，那么这里会计算最晚触发时间！ // 并根据最晚触发时间重新计算时间窗！ maxElapsed = maxTriggerTime(nowElapsed, triggerElapsed, interval); windowLength = maxElapsed - triggerElapsed; &#125; else &#123; //【8.3】其他情况，也是非精确闹钟，说明用户显示指定了时间窗，那就依此计算最晚触发时间！ maxElapsed = triggerElapsed + windowLength; &#125; synchronized (mLock) &#123; if (DEBUG_BATCH) &#123; Slog.v(TAG, \"set(\" + operation + \") : type=\" + type + \" triggerAtTime=\" + triggerAtTime + \" win=\" + windowLength + \" tElapsed=\" + triggerElapsed + \" maxElapsed=\" + maxElapsed + \" interval=\" + interval + \" flags=0x\" + Integer.toHexString(flags)); &#125; //【3.1】调用 setImplLocked 继续设置 alarm！ setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, maxElapsed, interval, operation, directReceiver, listenerTag, flags, true, workSource, alarmClock, callingUid, callingPackage); &#125;&#125; 我们来看看这个过程： 校验 PendingIntent 和 directReceiver 是否设置正确，二者只能设置一个！ 检验时间窗，如果 windowLength 超过 12h，那就设置为 1h！ 校验重复触发的时间间隔，最小的重复触发的时间间隔为 1min! 调整触发时间 如果是 RTC 类型的闹钟，将触发事件转为相对于开机的时间！ 触发时间最短是 5s 调整最晚触发时间和时间窗 精确闹钟，最晚触发时间和设置的时间一样，无时间窗！ 非精确闹钟，如果没有显式设置时间窗，那么就根据 triggerElapsed，nowElapsed 和 interval 计算合适的最晚触发时间和时间窗！ 非精确闹钟，如果显式设置了时间窗。那么最晚触发时间为：triggerElapsed + windowLength！ 最后，调用 setImplLocked 进一步设置 alarm！ 3.2.1 AlarmMS.convertToElapsed对于触发事件，要根据闹钟的类型，来修正：123456789static long convertToElapsed(long when, int type) &#123; //【1】判断是否是 RTC 闹钟类型！ final boolean isRtc = (type == RTC || type == RTC_WAKEUP); //【2】如果是 RTC 类型的，就将其转为相对于开机的时间点！ if (isRtc) &#123; when -= System.currentTimeMillis() - SystemClock.elapsedRealtime(); &#125; return when;&#125; 计算结果：when = when - System.currentTimeMillis() + SystemClock.elapsedRealtime(); 如果是 rtc 类型，那就将其转为了相对于开机的时间！ 3.2.2 AlarmMS.maxTriggerTime接着是计算最大的触发时间，这里的 MIN_FUZZABLE_INTERVAL 表示的是最小的时间窗间隔！ 12// minimum recurrence period or alarm futurity for us to be able to fuzz itstatic final long MIN_FUZZABLE_INTERVAL = 10000; 继续来看：12345678910111213static long maxTriggerTime(long now, long triggerAtTime, long interval) &#123; //【1】如果没有设置重复的时间间隔 interval，那么时间间隔为触发时间 triggerAtTime - 当前时间 now！ // 否则，时间间隔为 interval！ long futurity = (interval == 0) ? (triggerAtTime - now) : interval; //【2】如果计算出的时间间隔 futurity 小于 10s，那么设置其为 0； if (futurity &lt; MIN_FUZZABLE_INTERVAL) &#123; futurity = 0; &#125; //【3】最后，最大的触发时间点为：开始触发时间点 + 0.75 倍的时间间隔 futurity！ return triggerAtTime + (long)(.75 * futurity);&#125; 对于非精确的 alarm，这里通过 maxTriggerTime 方法计算其批处理的时间窗为：10.75 * (interval or triggerAtTime - now) 如果计算出的时间窗小于 10 s，那么就不设置最晚执行时间！ 3.3 AlarmMS.setImplLocked[15]参数传递： int type：闹钟的类型 long when: 触发时间点； long whenElapsed：触发时间点，相对于开机时间； long windowLength：时间窗； long maxWhen：最晚触发的时间点，触发时间点，相对于开机时间！ long interval：重复触发的时间间隔； PendingIntent operation：这个很简单，不多说！ IAlarmListener directReceiver：这个很简单，也不多说！ String listenerTag：AlarmListener 的字符串描述信息！ int flags：alarm 属性标志位！ boolean doValidate：传入 true！ WorkSource workSource：工作源对象！ AlarmManager.AlarmClockInfo alarmClock：通过 setAlarmClock 方法设置才不为 null； int callingUid：调用者的 uid； String callingPackage：调用者的 package name； 对于参数，就简单的介绍到这里！ 12345678910111213141516171819202122232425private void setImplLocked(int type, long when, long whenElapsed, long windowLength, long maxWhen, long interval, PendingIntent operation, IAlarmListener directReceiver, String listenerTag, int flags, boolean doValidate, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock, int callingUid, String callingPackage) &#123; //【3.3.1】创建一个 Alarm 对象！ Alarm a = new Alarm(type, when, whenElapsed, windowLength, maxWhen, interval, operation, directReceiver, listenerTag, workSource, flags, alarmClock, callingUid, callingPackage); try &#123; // 如果不允许设置 alarm，就退出！ if (ActivityManagerNative.getDefault().getAppStartMode(callingUid, callingPackage) == ActivityManager.APP_START_MODE_DISABLED) &#123; Slog.w(TAG, \"Not setting alarm from \" + callingUid + \":\" + a + \" -- package not allowed to start\"); return; &#125; &#125; catch (RemoteException e) &#123; &#125; //【3.3.2】移除已经设置的相同的 alarm！ removeLocked(operation, directReceiver); //【3.3.3】进一步设置 alarm！ setImplLocked(a, false, doValidate);&#125; 3.3.1 AlarmMS.Alarm下面是会创建一个 Alarm 对象，保存本次 set 的 alarm 的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static class Alarm &#123; public final int type; public final long origWhen; public final boolean wakeup; public final PendingIntent operation; public final IAlarmListener listener; public final String listenerTag; public final String statsTag; public final WorkSource workSource; public final int flags; public final AlarmManager.AlarmClockInfo alarmClock; public final int uid; public final int creatorUid; public final String packageName; public int count; public long when; public long windowLength; public long whenElapsed; // 'when' in the elapsed time base public long maxWhenElapsed; // also in the elapsed time base public long repeatInterval; public PriorityClass priorityClass; public Alarm(int _type, long _when, long _whenElapsed, long _windowLength, long _maxWhen, long _interval, PendingIntent _op, IAlarmListener _rec, String _listenerTag, WorkSource _ws, int _flags, AlarmManager.AlarmClockInfo _info, int _uid, String _pkgName) &#123; type = _type; // 闹钟类型，对应的是 AlarmManager 中的四种类型！ origWhen = _when; // 触发时间点！ wakeup = _type == AlarmManager.ELAPSED_REALTIME_WAKEUP // 是否是 wake up 类型的！ || _type == AlarmManager.RTC_WAKEUP; when = _when; // 触发事件点！ whenElapsed = _whenElapsed; // 触发时间点，相对于开机时间！ windowLength = _windowLength; // 时间窗； maxWhenElapsed = _maxWhen; // 最晚触发的时间点，触发时间点，相对于开机时间！ repeatInterval = _interval; // 重复触发的时间间隔！ operation = _op; listener = _rec; listenerTag = _listenerTag; statsTag = makeTag(_op, _listenerTag, _type); workSource = _ws; flags = _flags; // 闹钟属性的标志位！ alarmClock = _info; uid = _uid; packageName = _pkgName; creatorUid = (operation != null) ? operation.getCreatorUid() : uid; // 创建 intent 的 uid &#125; public static String makeTag(PendingIntent pi, String tag, int type) &#123; final String alarmString = type == ELAPSED_REALTIME_WAKEUP || type == RTC_WAKEUP ? \"*walarm*:\" : \"*alarm*:\"; return (pi != null) ? pi.getTag(alarmString) : (alarmString + tag); &#125; ... ... ...&#125; Alarm 有几个方法，我们来看下： 3.3.1.1 Alarm.make123456public WakeupEvent makeWakeupEvent(long nowRTC) &#123; return new WakeupEvent(nowRTC, creatorUid, (operation != null) ? operation.getIntent().getAction() : (\"&lt;listener&gt;:\" + listenerTag));&#125; 这个方法是用来创建一个 wake up event！ 3.3.1.2 Alarm.matches123456789101112// Returns true if either matchespublic boolean matches(PendingIntent pi, IAlarmListener rec) &#123; return (operation != null) ? operation.equals(pi) : rec != null &amp;&amp; listener.asBinder().equals(rec.asBinder());&#125;public boolean matches(String packageName) &#123; return (operation != null) ? packageName.equals(operation.getTargetPackage()) : packageName.equals(this.packageName);&#125; 这个方法是用来匹配 Alarm 的，代码逻辑很简单，使用 packageName 或者 PendingIntent，AlarmListener 进行匹配！ 我们继续来看： 3.3.2 AlarmMS.removeLockedremoveLocked 方法用于移除一个已经存在的 alarm！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void removeLocked(PendingIntent operation, IAlarmListener directReceiver) &#123; boolean didRemove = false; //【1】遍历 mAlarmBatches 中所有的 Batch 批处理对象，从 Batch 中移除该 alarm！ for (int i = mAlarmBatches.size() - 1; i &gt;= 0; i--) &#123; Batch b = mAlarmBatches.get(i); //【3.3.2.1】匹配并移除成功会返回 true！ didRemove |= b.remove(operation, directReceiver); if (b.size() == 0) &#123; // 如果该 Batch 中没有了其他的 alarm，就移除这个 Batch！ mAlarmBatches.remove(i); &#125; &#125; //【2】遍历 mPendingWhileIdleAlarms 中所有因为进入 idle 状态而等待执行的 Alarm 对象！ // 移除和本次 alarm 匹配的 alarm！ for (int i = mPendingWhileIdleAlarms.size() - 1; i &gt;= 0; i--) &#123; if (mPendingWhileIdleAlarms.get(i).matches(operation, directReceiver)) &#123; mPendingWhileIdleAlarms.remove(i); &#125; &#125; //【3】如果 didRemove 为 true，表示确实是移除了一个相同的 alarm！ if (didRemove) &#123; if (DEBUG_BATCH) &#123; Slog.v(TAG, \"remove(operation) changed bounds; rebatching\"); &#125; boolean restorePending = false; // 表示是否恢复正在等待中的 alarm // 如果 mPendingIdleUntil 不为 null，且移除的 alarm 和 mPendingIdleUntil 匹配，那就说明 // 要退出 idle 状态！ if (mPendingIdleUntil != null &amp;&amp; mPendingIdleUntil.matches(operation, directReceiver)) &#123; // 那就设置 mPendingIdleUntil 为 null，同时设置 restorePending 为 true！ mPendingIdleUntil = null; restorePending = true; &#125; // 如果 mNextWakeFromIdle 不为 null，且移除的 alarm 和 mPendingIdleUntil 匹配， // 那就设置 mNextWakeFromIdle 为 null！！ if (mNextWakeFromIdle != null &amp;&amp; mNextWakeFromIdle.matches(operation, directReceiver)) &#123; mNextWakeFromIdle = null; &#125; //【3.3.2.2】对其他的 alarm 重新进行批处理分配！ rebatchAllAlarmsLocked(true); //【3.3.2.3】如果 restorePending 为 true，说明从 idle 状态恢复了，那就要恢复 mPendingWhileIdleAlarms // 中所有 alarm！ if (restorePending) &#123; restorePendingWhileIdleAlarmsLocked(); &#125; //【3.4.5】更新下一个 AlarmClock 的时间！ updateNextAlarmClockLocked(); &#125;&#125; 这边是匹配到和本次设置的 alarm 相同的 alarm，然后做移除操作，然后恢复一些需要执行的 alarm！ 3.3.2.1 AlarmMS.Batch.remove从一个 Batch 中移除一个 alarm，Batch 中的非精确 alarm 是按照触发事件排序的，同时 Batch 也有一个 start 变量，表示批处理内部所有 alarm 的时间点！ 12345678910111213141516171819202122232425262728293031323334353637383940414243boolean remove(final PendingIntent operation, final IAlarmListener listener) &#123; if (operation == null &amp;&amp; listener == null) &#123; if (localLOGV) &#123; Slog.w(TAG, \"requested remove() of null operation\", new RuntimeException(\"here\")); &#125; return false; &#125; boolean didRemove = false; long newStart = 0; long newEnd = Long.MAX_VALUE; int newFlags = 0; for (int i = 0; i &lt; alarms.size(); ) &#123; Alarm alarm = alarms.get(i); //【3.3.1.2】这里用到了 alarm 的 matches 匹配方法，前面有说过！ if (alarm.matches(operation, listener)) &#123; alarms.remove(i); //【1】设置 didRemove 为 true； didRemove = true; //【2】如果匹配的 alarm 是通过 setAlarmClock 设置的，就设置 mNextAlarmClockMayChange 为 true！ if (alarm.alarmClock != null) &#123; mNextAlarmClockMayChange = true; &#125; &#125; else &#123; if (alarm.whenElapsed &gt; newStart) &#123; // 更新 newStart 时间点！ newStart = alarm.whenElapsed; &#125; if (alarm.maxWhenElapsed &lt; newEnd) &#123; // 更新 newStart 时间点！ newEnd = alarm.maxWhenElapsed; &#125; newFlags |= alarm.flags; // 获得该 Batch 中所有 Alarm 的标志位！ i++; &#125; &#125; //【3】如果移除了，那就更新 Batch 的 start 和 end 时间点！ if (didRemove) &#123; start = newStart; end = newEnd; flags = newFlags; &#125; return didRemove;&#125; 我们可以看到： 从这个 batch 移除 operation 或者 listener 匹配的 alarm，并更新 batch 的 start， end 和 flags 对象！ 如果被移除的 alarm 是通过 setAlarmClock 设置的，那么 mNextAlarmClockMayChange 为 true，后面系统会调用指定方法来更新下一个 AlarmClock！ 我们可以看到，当我们从 Batch 中移除一个 Alarm 后，Batch 的 start 和 end 时间点发生了变化，这样会导致 Batch 在 mAlarmBatches 中的顺序发生变化！ 3.3.2.2 AlarmMS.rebatchAllAlarmsLocked该方法用于重新对所有的 alarm 进行 batch 批处理！ 123456789101112131415161718192021222324252627282930313233343536void rebatchAllAlarmsLocked(boolean doValidate) &#123; //【1】将 mAlarmBatches 拷贝一份到 oldSet 中，并清空 mAlarmBatches！ ArrayList&lt;Batch&gt; oldSet = (ArrayList&lt;Batch&gt;) mAlarmBatches.clone(); mAlarmBatches.clear(); Alarm oldPendingIdleUntil = mPendingIdleUntil; final long nowElapsed = SystemClock.elapsedRealtime(); final int oldBatches = oldSet.size(); //【2】遍历每一个 Batch 的中 Alarm，重新进行批处理分配！ for (int batchNum = 0; batchNum &lt; oldBatches; batchNum++) &#123; Batch batch = oldSet.get(batchNum); final int N = batch.size(); for (int i = 0; i &lt; N; i++) &#123; //【3.3.2.1.1】重新添加 Alarm！ reAddAlarmLocked(batch.get(i), nowElapsed, doValidate); &#125; &#125; //【3】如果 oldPendingIdleUntil 不为 null，而 mPendingIdleUntil 为 null // 说明，此时推出了 idle 状态，那就恢复那些因为 idle 状态而等待的 alarm！ // × 这里感觉是为了解决 bug，因为看逻辑，不会进入这里 if (oldPendingIdleUntil != null &amp;&amp; oldPendingIdleUntil != mPendingIdleUntil) &#123; Slog.wtf(TAG, \"Rebatching: idle until changed from \" + oldPendingIdleUntil + \" to \" + mPendingIdleUntil); if (mPendingIdleUntil == null) &#123; //【3.3.2.3】恢复等待中的 alarm！ restorePendingWhileIdleAlarmsLocked(); &#125; &#125; //【3.4.4】重新调度并设置下一个 alarm！ rescheduleKernelAlarmsLocked(); //【3.4.5】更新下一个 AlarmClock 闹钟！ updateNextAlarmClockLocked();&#125; 3.3.2.2.1 AlarmManagerService.reAddAlarmLocked该方法用于重新添加 alarm！ 123456789101112131415161718void reAddAlarmLocked(Alarm a, long nowElapsed, boolean doValidate) &#123; a.when = a.origWhen; long whenElapsed = convertToElapsed(a.when, a.type); final long maxElapsed; if (a.windowLength == AlarmManager.WINDOW_EXACT) &#123; // 根据类型的不同，计算最大触发时间！ maxElapsed = whenElapsed; // 精确闹钟！ &#125; else &#123; //【3.2.2】非精确闹钟！ maxElapsed = (a.windowLength &gt; 0) ? (whenElapsed + a.windowLength) : maxTriggerTime(nowElapsed, whenElapsed, a.repeatInterval); &#125; a.whenElapsed = whenElapsed; a.maxWhenElapsed = maxElapsed; //【3.4】调用 setImplLocked 方法重新设置 alarm，注意这里的 rebatching 值为 true！ setImplLocked(a, true, doValidate);&#125; 可以看到这里调用了 setImplLocked 三参数方法，重新设置该 alarm！ 在 setImplLocked 方法中，会重新为 Alarm 分配 Batch，并对 mAlarmBatches 中的所有 Batch 重新排序，后面我们能够看到对该方法的分析，在第 3.4 节！ 3.3.2.3 AlarmMS.restorePendingWhileIdleAlarmsLocked接着，当系统退出 idle 状态后，要恢复那些因为 idle 状态而等待触发的 alarm！ 123456789101112131415161718192021222324252627282930313233343536void restorePendingWhileIdleAlarmsLocked() &#123; if (RECORD_DEVICE_IDLE_ALARMS) &#123; // RECORD_DEVICE_IDLE_ALARMS 默认为 false，用于 dump 不处理； IdleDispatchEntry ent = new IdleDispatchEntry(); ent.uid = 0; ent.pkg = \"FINISH IDLE\"; ent.elapsedRealtime = SystemClock.elapsedRealtime(); mAllowWhileIdleDispatches.add(ent); &#125; // 如果此时 mPendingWhileIdleAlarms 不为 empty，那就说明有等待触发的 alarm！ // 将其重新进行批处理分配！ if (mPendingWhileIdleAlarms.size() &gt; 0) &#123; ArrayList&lt;Alarm&gt; alarms = mPendingWhileIdleAlarms; mPendingWhileIdleAlarms = new ArrayList&lt;&gt;(); final long nowElapsed = SystemClock.elapsedRealtime(); for (int i=alarms.size() - 1; i &gt;= 0; i--) &#123; Alarm a = alarms.get(i); //【3.3.2.1.1】这里调用了 reAddAlarmLocked 方法，重新批处理 alarm，该方法上面有说过！ reAddAlarmLocked(a, nowElapsed, false); &#125; &#125; // 更新 ALLOW_WHILE_IDLE 最小时间！ mConstants.updateAllowWhileIdleMinTimeLocked(); //【3.3.2.4】重新调度，设置 alarm！ rescheduleKernelAlarmsLocked(); //【3.3.2.5】更新下一个 Alarm 的触发时间！ updateNextAlarmClockLocked(); // 发送一个时间改变的广播，用于更新 ui！ try &#123; mTimeTickSender.send(); &#125; catch (PendingIntent.CanceledException e) &#123; &#125;&#125; 继续看！ 3.4 AlarmMS.setImplLocked[3]接下来，我们来看一个非常重要的方法 setImplLocked！，第二个参数 rebatching 表示是否是 rebatch，正常流程下，rebatching 是为 false； 但是，当我们 rebatch 或者 restore 其他 alarm 时，rebatching 传入的是 true！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154private void setImplLocked(Alarm a, boolean rebatching, boolean doValidate) &#123; //【1】如果 alarm 设置了 AlarmManager.FLAG_IDLE_UNTIL 标志位，说明是 setIdleUtil 方法设置的！ // 这是一种很特殊的闹钟，用于将系统设置为 idle 状态，但其触发后退出 idle 状态！ // 如果有其他 alarm 会将系统从 idle 状态唤醒的话，并且其触发事件比 setIdleUtil 更早的的话，我们需要将 // setIdleUtil 闹钟的时间提前！ if ((a.flags&amp;AlarmManager.FLAG_IDLE_UNTIL) != 0) &#123; // 如果 mNextWakeFromIdle 不为 null，说明有 alarm 会在设备处于 idle 的状态下唤醒设备 // 如果 mNextWakeFromIdle 的触发时间更早，那么需要调整 setIdleUtil 的时间为 mNextWakeFromIdle 的触发时间！ if (mNextWakeFromIdle != null &amp;&amp; a.whenElapsed &gt; mNextWakeFromIdle.whenElapsed) &#123; // 因为是精确闹钟，所以所有时间相同！ a.when = a.whenElapsed = a.maxWhenElapsed = mNextWakeFromIdle.whenElapsed; &#125; //【3.4.1】接着对 setIdleUtil 闹钟的触发时间做一个细微调整，将前面设置的触发时间提前一个时间段！ final long nowElapsed = SystemClock.elapsedRealtime(); final int fuzz = fuzzForDuration(a.whenElapsed-nowElapsed); if (fuzz &gt; 0) &#123; if (mRandom == null) &#123; mRandom = new Random(); &#125; // 可以看到，最后进一步调整的提前时间间隔为 0 到 fuzz 的一个随机整数时间，单位是分钟！ final int delta = mRandom.nextInt(fuzz); a.whenElapsed -= delta; if (false) &#123; Slog.d(TAG, \"Alarm when: \" + a.whenElapsed); Slog.d(TAG, \"Delta until alarm: \" + (a.whenElapsed-nowElapsed)); Slog.d(TAG, \"Applied fuzz: \" + fuzz); Slog.d(TAG, \"Final delta: \" + delta); Slog.d(TAG, \"Final when: \" + a.whenElapsed); &#125; a.when = a.maxWhenElapsed = a.whenElapsed; &#125; &#125; else if (mPendingIdleUntil != null) &#123; // 如果没有设置 FLAG_IDLE_UNTIL 标志位，那么就要判断下 mPendingIdleUntil 是否为 null； // 其不为 null，说明系统现在处于 idle 状态，如果 alarm 没有设置一下的几种标志位的话， // 那就将其加入到 mPendingWhileIdleAlarms 列表中，等到系统退出 idle 状态后，再设置这些闹钟！ if ((a.flags&amp;(AlarmManager.FLAG_ALLOW_WHILE_IDLE | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED | AlarmManager.FLAG_WAKE_FROM_IDLE)) == 0) &#123; mPendingWhileIdleAlarms.add(a); return; &#125; &#125; // RECORD_DEVICE_IDLE_ALARMS 变量默认为 false，如果为 true，那么系统会记录那些在 idle 状态下能够触发的 alarm！ // 保存到 mAllowWhileIdleDispatches 中，我们在 dumpsys alarm 的时候能看到！ if (RECORD_DEVICE_IDLE_ALARMS) &#123; if ((a.flags &amp; AlarmManager.FLAG_ALLOW_WHILE_IDLE) != 0) &#123; IdleDispatchEntry ent = new IdleDispatchEntry(); ent.uid = a.uid; ent.pkg = a.operation.getCreatorPackage(); ent.tag = a.operation.getTag(\"\"); ent.op = \"SET\"; ent.elapsedRealtime = SystemClock.elapsedRealtime(); ent.argRealtime = a.whenElapsed; mAllowWhileIdleDispatches.add(ent); &#125; &#125; //【3.4.2】为新的 alarm 选择一个合适的 Batch， // 如果闹钟的 alarm 的 flags 设置了 AlarmManager.FLAG_STANDALONE 标志 // 那么其为精确闹钟，那么必须单独在一个 Batch 中！ int whichBatch = ((a.flags&amp;AlarmManager.FLAG_STANDALONE) != 0) ? -1 : attemptCoalesceLocked(a.whenElapsed, a.maxWhenElapsed); if (whichBatch &lt; 0) &#123; //【3.4.3】创建一个新的 Batch，并添加到 mAlarmBatch，并对 mAlarmBatches 按开始时间升序排列！ Batch batch = new Batch(a); addBatchLocked(mAlarmBatches, batch); &#125; else &#123; //【3.4.3】如果 whichBatch &gt;= 0，说明已经找到合适的 Batch 了，那我们就将其添加进去 Batch batch = mAlarmBatches.get(whichBatch); // 如果当前 alarm 的加入使得了 batch 开始时间和结束时间的改变，则 add 返回 true // 那么此时，我们需要对 mAlarmBatches 重新排序！ if (batch.add(a)) &#123; // 排序方法很简单，先移除这个 Batch，再重新添加！ mAlarmBatches.remove(whichBatch); addBatchLocked(mAlarmBatches, batch); &#125; &#125; // 如果 a.alarmClock 不为 null，则是通过 setAlarmClock 设置的，那就设置 mNextAlarmClockMayChange 为 true！ // 下面会根据这个变量更新 AlarmClock！ if (a.alarmClock != null) &#123; mNextAlarmClockMayChange = true; &#125; boolean needRebatch = false; // 如果是通过 setIdleUtil 设置的闹钟，系统此时将进入 idle 状态！ if ((a.flags&amp;AlarmManager.FLAG_IDLE_UNTIL) != 0) &#123; if (RECORD_DEVICE_IDLE_ALARMS) &#123; if (mPendingIdleUntil == null) &#123; IdleDispatchEntry ent = new IdleDispatchEntry(); ent.uid = 0; ent.pkg = \"START IDLE\"; ent.elapsedRealtime = SystemClock.elapsedRealtime(); mAllowWhileIdleDispatches.add(ent); &#125; &#125; // 设置 mPendingIdleUntil，更新 allow while idle 最小时间！ // 因为此时系统进入了 idle 状态，需要 rebatch 其他的闹钟，needRebatch 置为 true！ mPendingIdleUntil = a; mConstants.updateAllowWhileIdleMinTimeLocked(); needRebatch = true; &#125; else if ((a.flags&amp;AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) &#123; // 如果该 alarm 是会在 idle 状态下唤醒，如果此时 mNextWakeFromIdle 为 null，或者 // mNextWakeFromIdle 的触发时间晚，那就更新 mNextWakeFromIdle 为本次设置的新的 alarm！ if (mNextWakeFromIdle == null || mNextWakeFromIdle.whenElapsed &gt; a.whenElapsed) &#123; mNextWakeFromIdle = a; // If this wake from idle is earlier than whatever was previously scheduled, // and we are currently idling, then we need to rebatch alarms in case the idle // until time needs to be updated. // 如果此时 if (mPendingIdleUntil != null) &#123; needRebatch = true; &#125; &#125; &#125; // 如果 rebatching 为 true，表示本次是 rebatch 恢复操作，那么就不会进入下面的分支，原因很简单 // 因为 rebatch 在前面就已经执行的相应的操作了！ if (!rebatching) &#123; if (DEBUG_VALIDATE) &#123; // 用于 debug。 if (doValidate &amp;&amp; !validateConsistencyLocked()) &#123; Slog.v(TAG, \"Tipping-point operation: type=\" + a.type + \" when=\" + a.when + \" when(hex)=\" + Long.toHexString(a.when) + \" whenElapsed=\" + a.whenElapsed + \" maxWhenElapsed=\" + a.maxWhenElapsed + \" interval=\" + a.repeatInterval + \" op=\" + a.operation + \" flags=0x\" + Integer.toHexString(a.flags)); rebatchAllAlarmsLocked(false); needRebatch = false; &#125; &#125; if (needRebatch) &#123; // 如果 needRebatch 为 true，那么我们要重新批处理所有的 alarm！ rebatchAllAlarmsLocked(false); &#125; // 调度 kernel 设置 alarm！ rescheduleKernelAlarmsLocked(); // 更新下一个 AlarmClock！ updateNextAlarmClockLocked(); &#125;&#125; 该方法的主要逻辑如下： 3.4.1 AlarmMS.fuzzForDuration我们来看看 fuzzForDuration 方法： 123456789101112static int fuzzForDuration(long duration) &#123; if (duration &lt; 15*60*1000) &#123; //【1】如果 duration 小于 15 分钟，那么我们要调整的时间间隔为 duration return (int)duration; &#125; else if (duration &lt; 90*60*1000) &#123; //【2】如果 duration 大于等于 15 分钟，小于 1 小时 30 分钟，那么我们要调整的时间间隔为 15 分钟！ return 15*60*1000; &#125; else &#123; //【2】如果 duration 大于等于 1 小时 30 分钟，那调整的时间间隔为 30 分钟！ return 30*60*1000; &#125;&#125; 3.4.2 AlarmMS.attemptCoalesceLocked通过非精确闹钟的触发时间，找到一个合适的 Batch ！ 123456789101112int attemptCoalesceLocked(long whenElapsed, long maxWhen) &#123; final int N = mAlarmBatches.size(); for (int i = 0; i &lt; N; i++) &#123; Batch b = mAlarmBatches.get(i); // 匹配到合适的 Batch，那就返回该 Batch 下标！ if ((b.flags&amp;AlarmManager.FLAG_STANDALONE) == 0 &amp;&amp; b.canHold(whenElapsed, maxWhen)) &#123; return i; &#125; &#125; // 无法找到一个合适的，就返回 -1，创建一个新的！ return -1;&#125; 可以看到，一个合适的 Batch 满足的条件如下： Batch 的 flags 没有 AlarmManager.FLAG_STANDALONE 标志位，即该 Batch 是只能用于保存非精确闹钟！ canHold 方法返回 true，即：这个 Batch 能够容纳这个 Alarm！ 下面，我们来看看 canHold 方法的逻辑： 3.4.2.1 AlarmMS.Batch.canHoldcanHold 方法用来判断，该 alarm 是否可以加入到这个 Batch 中：123boolean canHold(long whenElapsed, long maxWhen) &#123; return (end &gt;= whenElapsed) &amp;&amp; (start &lt;= maxWhen);&#125; 从方法中可以看出，可以容纳的依据是： batch.end &gt;= alarm.whenElapsed batch.start &lt;= alarm.maxWhen 即：batch 的时间间隔和 alarm 的触发时间间隔必须有交集！！ 3.4.3 AlarmMS.addBatchLocked我们来看看 addBatchLocked 方法的逻辑： 1234567891011static boolean addBatchLocked(ArrayList&lt;Batch&gt; list, Batch newBatch) &#123; //【1】其实就是根据 Batch 的 start 时间，查找到一个更合适的 index！ int index = Collections.binarySearch(list, newBatch, sBatchOrder); if (index &lt; 0) &#123; index = 0 - index - 1; &#125; //【2】插入 index 位置处！ list.add(index, newBatch); //【3】如果返回 true，表示 Batch 处于 list 的开头位置！ return (index == 0);&#125; 这里的 sBatchOrder 是一个 BatchTimeOrder 实例，实现了 Comparator 接口，用来比较两个 Batch 的 start 时间的大小！ 123456789101112131415static final BatchTimeOrder sBatchOrder = new BatchTimeOrder(); static class BatchTimeOrder implements Comparator&lt;Batch&gt; &#123; public int compare(Batch b1, Batch b2) &#123; long when1 = b1.start; long when2 = b2.start; if (when1 &gt; when2) &#123; return 1; &#125; if (when1 &lt; when2) &#123; return -1; &#125; return 0; &#125; &#125; 可以看到，mAlarmBatches 中的 Batch 是按照开始时间从小到大排序的！！ 下面我们来看看 Batch 的相关方法： 3.4.3.1 AlarmMS.Batch.Batch当我们要将一个 Alarm 添加到新创建的 Batch 中的时候，会对 Batch 进行初始化： 12345678910111213Batch() &#123; start = 0; end = Long.MAX_VALUE; flags = 0;&#125;Batch(Alarm seed) &#123; // 初始化 start 为 alarm 的开始触发时间，end 为 alarm 的最大开始触发时间 start = seed.whenElapsed; end = seed.maxWhenElapsed; flags = seed.flags; alarms.add(seed);&#125; 不多说了，继续看！ 3.4.3.2 AlarmMS.Batch.add将一个 Alarm 添加到已存在的一个 Batch，通过 add 方法：12345678910111213141516171819202122232425262728boolean add(Alarm alarm) &#123; boolean newStart = false; //【1】按照开始触发时间递增的顺序，给这个 alarm 找到合适的位置！ int index = Collections.binarySearch(alarms, alarm, sIncreasingTimeOrder); if (index &lt; 0) &#123; index = 0 - index - 1; &#125; //【2】添加到指定的位置！ alarms.add(index, alarm); if (DEBUG_BATCH) &#123; Slog.v(TAG, \"Adding \" + alarm + \" to \" + this); &#125; //【3】更改 Batch 的 start 和 end 时间！ if (alarm.whenElapsed &gt; start) &#123; start = alarm.whenElapsed; newStart = true; &#125; if (alarm.maxWhenElapsed &lt; end) &#123; end = alarm.maxWhenElapsed; &#125; //【4】更新 Batch 的 flags！ flags |= alarm.flags; if (DEBUG_BATCH) &#123; Slog.v(TAG, \" =&gt; now \" + this); &#125; return newStart;&#125; 可以看到，如果 Batch 的 start 时间发生变化，那么 add 会返回 true！ 这里用到了一个比较器对象：123456789101112131415static final IncreasingTimeOrder sIncreasingTimeOrder = new IncreasingTimeOrder();public static class IncreasingTimeOrder implements Comparator&lt;Alarm&gt; &#123; public int compare(Alarm a1, Alarm a2) &#123; long when1 = a1.whenElapsed; long when2 = a2.whenElapsed; if (when1 &gt; when2) &#123; return 1; &#125; if (when1 &lt; when2) &#123; return -1; &#125; return 0; &#125;&#125; sIncreasingTimeOrder 是用来对 Batch 中的 alarm 进行排序的，规则是按照开始时间递增的顺序！ 3.4.4 AlarmMS.rescheduleKernelAlarmsLocked该方法用于设置下一个 alarm！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void rescheduleKernelAlarmsLocked() &#123; long nextNonWakeup = 0; // 设置最早的 ELAPSED_REALTIME_WAKEUP 类型的 alarm！ if (mAlarmBatches.size() &gt; 0) &#123; //【3.4.4.1】从 mAlarmBatches 中找到第一个包含 wake up 类型 alarm 的 Batch！ final Batch firstWakeup = findFirstWakeupBatchLocked(); //【2】从 mAlarmBatches 中找到第一个的 Batch！ final Batch firstBatch = mAlarmBatches.get(0); //【3】如果 firstWakeup 不为 null，且 firstWakeup 中的开始触发时间 start，不等于 mNextWakeup！ // 那就要更新 mNextWakeup，调整下一个 wake up alarm 的触发时间！ if (firstWakeup != null &amp;&amp; mNextWakeup != firstWakeup.start) &#123; // 更新 mNextWakeup 和 mLastWakeupSet！ mNextWakeup = firstWakeup.start; mLastWakeupSet = SystemClock.elapsedRealtime(); //【3.4.4.2】设置下一个要触发的 wake up 类型的 alarm！ setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start); &#125; //【4】如果 firstBatch 不等于 firstWakeup，说明 firstBatch 中不包含 wake up 类型的 alarm！ // 那就设置下一个非 wake up alarm 的触发时间！ if (firstBatch != firstWakeup) &#123; nextNonWakeup = firstBatch.start; &#125; &#125; // mPendingNonWakeupAlarms 不为 empty，说明系统中存在处于等待状态的 no wakeup 类型的 alarm！ // 那么如果 nextNonWakeup 为 0，或者 mNextNonWakeupDeliveryTime 小于 nextNonWakeup！ // 那么更新 nextNonWakeup 为 mNextNonWakeupDeliveryTime 的值！ if (mPendingNonWakeupAlarms.size() &gt; 0) &#123; if (nextNonWakeup == 0 || mNextNonWakeupDeliveryTime &lt; nextNonWakeup) &#123; nextNonWakeup = mNextNonWakeupDeliveryTime; &#125; &#125; // 最后如果，本次计算的下一个要触发的 no wake up alarm 的时间和之前的不同，更新 mNextNonWakeup 的值 // 并设置下一个 no wake up 的 alarm！ if (nextNonWakeup != 0 &amp;&amp; mNextNonWakeup != nextNonWakeup) &#123; mNextNonWakeup = nextNonWakeup; //【3.4.4.2】设置下一个要触发的 no wake up 类型的 alarm！ setLocked(ELAPSED_REALTIME, nextNonWakeup); &#125;&#125; 变量解释： mNextWakeup 表示下一个最早的 wake up 类型 alarm 的触发时间； mLastWakeupSet 表示上一次设置 wake up 类型 alarm 的时间，取值为 SystemClock.elapsedRealtime()； mNextNonWakeup 表示的是下一个最早的 no wake up 类型 alarm 的触发时间； 通常，二者是一起设置的！ 逻辑梳理： 该方法首先是确定下一个要触发的 wake up 和非 wake up 类型的 alarm 的触发时间：mNextWakeup 和 mNextNonWakeup！ 对于 wake up 类型，那就在所有的 Batch 中找到第一个持有 wake up 类型 alarm 的 Batch，其 Batch.start 就是 mNextWakeup！ 对于非 wake up 类型，确定 mNextNonWakeup 要分为以下几步： 如果第一个持有 wake up 类型 alarm 的 Batch 不是 first batch，那么 firstBatch.Start 为可选值，保存到 nextNonWakeup 中！ 如果此时 mPendingNonWakeupAlarms 不为 empty，说明系统中有正在等待的 no wake up 类型的闹钟，如果此时 nextNonWakeup 为 0，或者 mNextNonWakeupDeliveryTime 小于 nextNonWakeup，那么 mNextNonWakeupDeliveryTime 就是一个更优的选择，保存到 nextNonWakeup 中； 最后，如果 nextNonWakeup 和 mNextNonWakeup 不相等，那就使用 nextNonWakeup 更新 mNextNonWakeup！ 然后，分别设置两种闹钟！ 3.4.4.1 AlarmMS.findFirstWakeupBatchLockedfindFirstWakeupBatchLocked 方法在所有的 Batch 中找到第一个包含 wake up 类型 alarm 的 Batch，然后返回！ 12345678910private Batch findFirstWakeupBatchLocked() &#123; final int N = mAlarmBatches.size(); for (int i = 0; i &lt; N; i++) &#123; Batch b = mAlarmBatches.get(i); if (b.hasWakeups()) &#123; // 判断该 Batch 是否包含 wake up 类型的 alarm！ return b; &#125; &#125; return null;&#125; 这里调用了 Batch 的 hasWakeups 接口： 3.4.4.1.1 AlarmMS.Batch.hasWakeups123456789101112boolean hasWakeups() &#123; final int N = alarms.size(); // 遍历其内部的所有的 Alarm！ for (int i = 0; i &lt; N; i++) &#123; Alarm a = alarms.get(i); // 这里的 type 取值为 AlarmManager 中的四种 if ((a.type &amp; TYPE_NONWAKEUP_MASK) == 0) &#123; return true; &#125; &#125; return false;&#125; 3.4.4.2 AlarmMS.setLocked用于设置一个 alarm！12345678910111213141516171819202122private void setLocked(int type, long when) &#123; if (mNativeData != 0) &#123; // 记录秒和纳秒！ long alarmSeconds, alarmNanoseconds; if (when &lt; 0) &#123; alarmSeconds = 0; alarmNanoseconds = 0; &#125; else &#123; alarmSeconds = when / 1000; alarmNanoseconds = (when % 1000) * 1000 * 1000; &#125; // 设置 alarm！ set(mNativeData, type, alarmSeconds, alarmNanoseconds); &#125; else &#123; Message msg = Message.obtain(); msg.what = ALARM_EVENT; mHandler.removeMessages(ALARM_EVENT); mHandler.sendMessageAtTime(msg, when); &#125;&#125; 我们可以看到，这里使用了 2 中方式来设置闹钟！ 第一种：通过 Alarm 驱动来设置 mNativeData 不为 0，表示 Alarm 驱动存在，就直接调用 set 方法，通过 Alarm 驱动设置这个 alarm！ 1private native void set(long nativeData, int type, long seconds, long nanoseconds); 当然，正常情况，是通过 Alarm 驱动来设置的，因为这样能够实现休眠唤醒！ 除非找不到 Alarm 驱动 mNativeData 为 0，说明 Alarm 驱动不存在，那就通过 Timer 定时器设置，这里通过发送一个 ALARM_EVENT 给 AlarmHandler，然后处理消息，设置 alarm！ 3.4.4.3 AlarmMS.updateNextAlarmInfoForUserLocked123456789101112131415161718192021222324private void updateNextAlarmInfoForUserLocked(int userId, AlarmManager.AlarmClockInfo alarmClock) &#123; if (alarmClock != null) &#123; if (DEBUG_ALARM_CLOCK) &#123; Log.v(TAG, \"Next AlarmClockInfoForUser(\" + userId + \"): \" + formatNextAlarm(getContext(), alarmClock, userId)); &#125; //【1】更新 alarmClock！ mNextAlarmClockForUser.put(userId, alarmClock); &#125; else &#123; if (DEBUG_ALARM_CLOCK) &#123; Log.v(TAG, \"Next AlarmClockInfoForUser(\" + userId + \"): None\"); &#125; //【1】移除指定的 userId 信息！ mNextAlarmClockForUser.remove(userId); &#125; // 将 mPendingSendNextAlarmClockChangedForUser 中 userId 对应的置为 true！ mPendingSendNextAlarmClockChangedForUser.put(userId, true); mHandler.removeMessages(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED); // 发送 SEND_NEXT_ALARM_CLOCK_CHANGED 给 AlarmHandler！ mHandler.sendEmptyMessage(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);&#125; 关于 AlarmHandler 我们后面会提到！ 3.4.5 AlarmMS.updateNextAlarmClockLocked该方法用于更新下一个 AlarmClock 的时间，当我们触发或者移除了一个 setAlarmClock 设置的 alarm 后，需要更新下一个 AlarmClock 的触发！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private void updateNextAlarmClockLocked() &#123; //【1】如果 mNextAlarmClockMayChange 为 false，表示并没有移除或者触发一个 AlarmClock 闹钟，那就返回！ if (!mNextAlarmClockMayChange) &#123; return; &#125; //【2】设置 mNextAlarmClockMayChange 为 false； mNextAlarmClockMayChange = false; //【3】用于缓存更新后的所有的 AlarmClock，用于后续更新 mNextAlarmClockForUser！ SparseArray&lt;AlarmManager.AlarmClockInfo&gt; nextForUser = mTmpSparseAlarmClockArray; nextForUser.clear(); //【4】遍历所有的 Alarm Batch，找到所有的 AlarmClock 闹钟！ final int N = mAlarmBatches.size(); for (int i = 0; i &lt; N; i++) &#123; ArrayList&lt;Alarm&gt; alarms = mAlarmBatches.get(i).alarms; final int M = alarms.size(); for (int j = 0; j &lt; M; j++) &#123; Alarm a = alarms.get(j); //【4.1】a.alarmClock 不为 null，说明这是一个 AlarmClock 类型的闹钟！ if (a.alarmClock != null) &#123; // 获得 AlarmClock 所属的 userId！ final int userId = UserHandle.getUserId(a.uid); // 获得该 userId 下的当前 AlarmClock！ AlarmManager.AlarmClockInfo current = mNextAlarmClockForUser.get(userId); if (DEBUG_ALARM_CLOCK) &#123; Log.v(TAG, \"Found AlarmClockInfo \" + a.alarmClock + \" at \" + formatNextAlarm(getContext(), a.alarmClock, userId) + \" for user \" + userId); &#125; // Alarms 和 Batches 是通过时间排序的，所以这需要比较时间！ if (nextForUser.get(userId) == null) &#123; // 如果缓存中的 userId 是第一次添加，那将 a.alarmClock 添加到缓存中，不考虑 current！ nextForUser.put(userId, a.alarmClock); &#125; else if (a.alarmClock.equals(current) &amp;&amp; current.getTriggerTime() &lt;= nextForUser.get(userId).getTriggerTime()) &#123; // nextForUser.get(userId) 不等于 null，说明该 userId 在缓存中已经有 AlarmClock 了！ // 相同 userId，alarmClock 相同，但是 current 触发时间比缓存中的更早，那就用 current 替换缓存中！ nextForUser.put(userId, current); &#125; &#125; &#125; &#125; //【5】通过上面的预处理，缓存 nextForUser 中存储的是每个 userId 下最早触发的 alarmClock！ // 接着是用缓存 nextForUser 更新 mNextAlarmClockForUser！ final int NN = nextForUser.size(); for (int i = 0; i &lt; NN; i++) &#123; AlarmManager.AlarmClockInfo newAlarm = nextForUser.valueAt(i); int userId = nextForUser.keyAt(i); AlarmManager.AlarmClockInfo currentAlarm = mNextAlarmClockForUser.get(userId); //【4.1】相同 userId，但是 AlarmClockInfo 不相等，那就更新 mNextAlarmClockForUser！ if (!newAlarm.equals(currentAlarm)) &#123; updateNextAlarmInfoForUserLocked(userId, newAlarm); &#125; &#125; //【6】移除 mNextAlarmClockForUser 已经触发的 AlarmClock！ final int NNN = mNextAlarmClockForUser.size(); for (int i = NNN - 1; i &gt;= 0; i--) &#123; int userId = mNextAlarmClockForUser.keyAt(i); if (nextForUser.get(userId) == null) &#123; //【3.4.5.1】调用 updateNextAlarmInfoForUserLocked updateNextAlarmInfoForUserLocked(userId, null); &#125; &#125;&#125; 变量说明： mNextAlarmClockForUser 用于保存每个 userId 下即将出发的下一个 AlarmClock！ 方法的流程总结： 获得当前系统中最新的 AlarmClock 信息，保存到缓存 nextForUser 中； 如果缓存 nextForUser 中 userId 下还没有 AlarmClock，那就将该 AlarmClock 添加到缓存中！ 如果缓存 nextForUser 中 userId 下已经有某个 AlarmClock，那就进一步比较： 只有当该 userId 下的缓存 AlarmClock 和 mNextAlarmClockForUser 中对应的 AlarmClock 相等，且 mNextAlarmClockForUser 中对应的 AlarmClock 触发时间更早，才会替换缓存；否则，保留缓存！ 用缓存 nextForUser 来更新 mNextAlarmClockForUser 列表； 再次比较缓存 nextForUser 和 mNextAlarmClockForUser 中 userId 相同的 AlarmClock，如果二者不相同，用缓存更新 mNextAlarmClockForUser！ 删除 mNextAlarmClockForUser 中某些 userId 下已经无效的 Alarm； 3.4.5.1 AlarmMS.updateNextAlarmInfoForUserLocked为指定 userId 更新 AlarmClock 123456789101112131415161718192021222324private void updateNextAlarmInfoForUserLocked(int userId, AlarmManager.AlarmClockInfo alarmClock) &#123; //【1】如果传入的 alarmClock 不为 null，那就替换 userId 下已有的 alarmClock！ // 如果传入的 alarmClock 为 null，那就移除 userId 和对应的 alarmClock！ if (alarmClock != null) &#123; if (DEBUG_ALARM_CLOCK) &#123; Log.v(TAG, \"Next AlarmClockInfoForUser(\" + userId + \"): \" + formatNextAlarm(getContext(), alarmClock, userId)); &#125; mNextAlarmClockForUser.put(userId, alarmClock); &#125; else &#123; if (DEBUG_ALARM_CLOCK) &#123; Log.v(TAG, \"Next AlarmClockInfoForUser(\" + userId + \"): None\"); &#125; mNextAlarmClockForUser.remove(userId); &#125; //【2】当某个 userId 下的 AlarmClock 发生了变化，我们会将其记录到 mPendingSendNextAlarmClockChangedForUser 列表中！ mPendingSendNextAlarmClockChangedForUser.put(userId, true); //【3】发送 SEND_NEXT_ALARM_CLOCK_CHANGED 给 AlarmHandler，AlarmHandler 会处理该消息！ mHandler.removeMessages(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED); mHandler.sendEmptyMessage(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);&#125; mPendingSendNextAlarmClockChangedForUser 列表用来记录某个 userId 下的 AlarmClock 发生了变化，如果发生了变化，他会用 userId -&gt; true 的映射关系保存！ 最后会发送 AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED 给 AlarmHandler 来处理，我们去看看： 3.4.5.1.1 AlarmMS.AlarmHandler[SEND_NEXT_ALARM_CLOCK_CHANGED]123case SEND_NEXT_ALARM_CLOCK_CHANGED: sendNextAlarmClockChanged(); break; AlarmHandler 会调用 sendNextAlarmClockChanged 来处理消息： 3.4.5.1.2 AlarmMS.sendNextAlarmClockChanged123456789101112131415161718192021222324252627282930313233private void sendNextAlarmClockChanged() &#123; //【1】创建了一个 SparseArray 数组，用于保存要处理的 userId 和其 AlarmClock！ SparseArray&lt;AlarmManager.AlarmClockInfo&gt; pendingUsers = mHandlerSparseAlarmClockArray; pendingUsers.clear(); //【2】将 mPendingSendNextAlarmClockChangedForUser 的 user Id 和对应的 AlarmClock 保存到 pendingUsers 中！ synchronized (mLock) &#123; final int N = mPendingSendNextAlarmClockChangedForUser.size(); for (int i = 0; i &lt; N; i++) &#123; int userId = mPendingSendNextAlarmClockChangedForUser.keyAt(i); pendingUsers.append(userId, mNextAlarmClockForUser.get(userId)); &#125; // 清空 mPendingSendNextAlarmClockChangedForUser！ mPendingSendNextAlarmClockChangedForUser.clear(); &#125; //【3】保存 AlarmClock 信息，并发送广播！ final int N = pendingUsers.size(); for (int i = 0; i &lt; N; i++) &#123; int userId = pendingUsers.keyAt(i); AlarmManager.AlarmClockInfo alarmClock = pendingUsers.valueAt(i); // 将这个 AlarmClock 的信息保存到 Settings 数据库中！ Settings.System.putStringForUser(getContext().getContentResolver(), Settings.System.NEXT_ALARM_FORMATTED, formatNextAlarm(getContext(), alarmClock, userId), userId); // 发送 NEXT_ALARM_CLOCK_CHANGED_INTENT 给指定的 userId！ getContext().sendBroadcastAsUser(NEXT_ALARM_CLOCK_CHANGED_INTENT, new UserHandle(userId)); &#125;&#125; mHandlerSparseAlarmClockArray 是一个预先创建的 SparseArray，没有很特殊的用途！ 在 sendNextAlarmClockChanged 方法中，我们会处理前面的 mPendingSendNextAlarmClockChangedForUser！ 3.5 阶段总结到这里，我们 setAlarm 的整个流程就分析完成了，下面，我们来总结一下整个过程！ … … …","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AlarmManager闹钟管理","slug":"AndroidFramework源码分析/AlarmManager闹钟管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AlarmManager闹钟管理/"}],"tags":[{"name":"AlarmManager闹钟管理","slug":"AlarmManager闹钟管理","permalink":"https://coolqi.top/tags/AlarmManager闹钟管理/"}]},{"title":"Permission第 3 篇 - checkPermissions 权限检查","slug":"Permission3-checkPermissions","date":"2017-07-06T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/07/06/Permission3-checkPermissions/","link":"","permalink":"https://coolqi.top/2017/07/06/Permission3-checkPermissions/","excerpt":"","text":"[toc] 0 综述基于 Android 7.1.1 源码，分析系统的权限管理机制！ 下面来看下系统中的 check permission 相关的接口： 1 Context 权限检查接口 - ContextImpl在应用中申请权限离不开 Context，Context 中暴露了多个检查权限相关的接口，具体的实现是在 ContextImpl 中！ 1.1 checkCallingPermission检查来自其他进程的调用者的是否有权限，该接口不能用于检查自身是否具有权限！ 12345678910111213@Overridepublic int checkCallingPermission(String permission) &#123; if (permission == null) &#123; throw new IllegalArgumentException(\"permission is null\"); &#125; int pid = Binder.getCallingPid(); if (pid != Process.myPid()) &#123; //【*1.3】调用自身的 checkPermission 方法！ return checkPermission(permission, pid, Binder.getCallingUid()); &#125; return PackageManager.PERMISSION_DENIED;&#125; 应用程序权限检查，最终需要进入框架层！ 1.2 checkCallingOrSelfPermission该方法和 checkCallingPermission 不同，他还可以检查自身是否具有权限！123456789@Overridepublic int checkCallingOrSelfPermission(String permission) &#123; if (permission == null) &#123; throw new IllegalArgumentException(\"permission is null\"); &#125; //【*1.3】调用自身的 checkPermission 方法！ return checkPermission(permission, Binder.getCallingPid(), Binder.getCallingUid());&#125; 1.3 checkPermission checkPermission[3] 该方法需要指定 pid 和 uid： 1234567891011121314@Overridepublic int checkPermission(String permission, int pid, int uid) &#123; if (permission == null) &#123; throw new IllegalArgumentException(\"permission is null\"); &#125; try &#123; //【*2.2】调用了 ams 的 checkPermission 接口 return ActivityManagerNative.getDefault().checkPermission( permission, pid, uid); &#125; catch (RemoteException e) &#123; return PackageManager.PERMISSION_DENIED; &#125;&#125; checkPermission[4] 还有一个重载函数，需要额外传入一个 callerToken 实例，这里是一个 hide 方法，目前是隐藏的，只能由系统调用： 123456789101112131415/** @hide */@Overridepublic int checkPermission(String permission, int pid, int uid, IBinder callerToken) &#123; if (permission == null) &#123; throw new IllegalArgumentException(\"permission is null\"); &#125; try &#123; //【*2.10】调用了 ams 的 checkPermissionWithToken 接口 return ActivityManagerNative.getDefault().checkPermissionWithToken( permission, pid, uid, callerToken); &#125; catch (RemoteException e) &#123; return PackageManager.PERMISSION_DENIED; &#125;&#125; 1.4 Check Uri PermissionsContextImpl 还提供了检查 Uri Permissions 的接口，这些接口依赖于一个 modeFlags 标志位，取值有如下： 12Intent.FLAG_GRANT_READ_URI_PERMISSIONIntent.FLAG_GRANT_WRITE_URI_PERMISSION 下面我们来看下相关的接口的逻辑： 1.4.1 checkCallingUriPermission同样的，这个方法只能检查其他进程是否具有访问 uri 权限！ 12345678910@Overridepublic int checkCallingUriPermission(Uri uri, int modeFlags) &#123; int pid = Binder.getCallingPid(); if (pid != Process.myPid()) &#123; //【*1.4.3】调用 ContextImpl 的 checkUriPermission 方法！ return checkUriPermission(uri, pid, Binder.getCallingUid(), modeFlags); &#125; return PackageManager.PERMISSION_DENIED;&#125; 1.4.2 checkCallingOrSelfUriPermission同样的，这个方法能检查其他进程或者自身是否具有访问 uri 权限！ 123456@Overridepublic int checkCallingOrSelfUriPermission(Uri uri, int modeFlags) &#123; //【*1.4.3】调用 ContextImpl 的 checkUriPermission 方法！ return checkUriPermission(uri, Binder.getCallingPid(), Binder.getCallingUid(), modeFlags);&#125; 1.4.3 checkUriPermissioncheckUriPermission 方法一共有三个重载实现： checkUriPermission[6] 1234567891011121314151617181920212223242526272829303132@Overridepublic int checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags) &#123; if (DEBUG) &#123; Log.i(\"foo\", \"checkUriPermission: uri=\" + uri + \"readPermission=\" + readPermission + \" writePermission=\" + writePermission + \" pid=\" + pid + \" uid=\" + uid + \" mode\" + modeFlags); &#125; //【1】如果 flags 设置了 FLAG_GRANT_READ_URI_PERMISSION 标志位，那么 // 如果 readPermission 不为 null，且 pid uid 是有这个 readPermission 权限的； // 那就返回 PERMISSION_GRANTED if ((modeFlags &amp; Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) &#123; if (readPermission == null || checkPermission(readPermission, pid, uid) == PackageManager.PERMISSION_GRANTED) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; //【2】如果 flags 设置了 FLAG_GRANT_WRITE_URI_PERMISSION 标志位，那么 // 如果 writePermission 不为 null，且 pid uid 是有这个 writePermission 权限的； // 那就返回 PERMISSION_GRANTED if ((modeFlags &amp; Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) &#123; if (writePermission == null || checkPermission(writePermission, pid, uid) == PackageManager.PERMISSION_GRANTED) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; //【*self-other】上述条件不满足的话，会进入到这部分中，调用另外一个重载的函数： return uri != null ? checkUriPermission(uri, pid, uid, modeFlags) : PackageManager.PERMISSION_DENIED;&#125; checkUriPermission[4] 第二个 checkUriPermission 会被第一个方法调用： 1234567891011@Overridepublic int checkUriPermission(Uri uri, int pid, int uid, int modeFlags) &#123; try &#123; //【*2.9】调用 ams 的 checkUriPermission 方法！ return ActivityManagerNative.getDefault().checkUriPermission( ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), null); &#125; catch (RemoteException e) &#123; return PackageManager.PERMISSION_DENIED; &#125;&#125; checkUriPermission[5] 第三个 checkUriPermission 方法，需要传入一个 IBinder token 对象，这是一个 hide 方法，只能由系统调用！ 123456789101112/** @hide */@Overridepublic int checkUriPermission(Uri uri, int pid, int uid, int modeFlags, IBinder callerToken) &#123; try &#123; //【*2.9】调用 ams 的 checkUriPermission 方法！ return ActivityManagerNative.getDefault().checkUriPermission( ContentProvider.getUriWithoutUserId(uri), pid, uid, modeFlags, resolveUserId(uri), callerToken); &#125; catch (RemoteException e) &#123; return PackageManager.PERMISSION_DENIED; &#125;&#125; 2 框架层权限检查接口 - ActivityManagerService我们来看看 Android 7.1.1 中框架层提供了那些用于校验权限的接口，这些接口主要位于 ActivityManager，ActivityManagerService 中，我们做一个简单的归类！ 访问 ContentProvider 的权限校验； 1String checkContentProviderPermissionLocked(ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) 判断 pid，uid 对应的进程是否具有某个权限； 123 // 检测调用者的权限，第一个方法会调用第二个方法！int checkCallingPermission(String permission) &#123;...&#125;int checkPermission(String permission, int pid, int uid) &#123;...&#125; 检测组件的权限； 12 // 检测组件的权限int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) &#123;...&#125; 检测 Uri 相关的权限； 123456789101112131415161718int checkGrantUriPermission(int callingUid, String targetPkg, Uri uri, final int modeFlags, int userId) &#123;...&#125;NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, int mode, NeededUriGrants needed, int targetUserId) &#123;...&#125; int checkGrantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, int lastTargetUid) &#123;...&#125;int checkUriPermission(Uri uri, int pid, int uid, final int modeFlags, int userId, IBinder callerToken) &#123;...&#125; boolean checkUriPermissionLocked(GrantUri grantUri, int uid, final int modeFlags) &#123;...&#125;boolean checkHoldingPermissionsLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, final int modeFlags) &#123;...&#125; boolean checkHoldingPermissionsInternalLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, final int modeFlags, boolean considerUidPermissions) &#123;...&#125; 检测 Binder 对象的权限； 1int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) &#123;...&#125; 同时，系统也提供了一些强制检查权限的接口，以 enforce 开头，我们在很多的系统调用过程中都会看到，这些接口会调用上面的接口来查询权限是否授予，没有授予会抛出异常，这里就不再列举！ 2.1 checkCallingPermission该方法用于判断调用者是否具有指定的权限，内部会自动通过 Binder 相关接口获得调用者的 pid 和 uid！！123456int checkCallingPermission(String permission) &#123; //【*2.2】这里调用了 checkPermission 方法！ return checkPermission(permission, Binder.getCallingPid(), UserHandle.getAppId(Binder.getCallingUid()));&#125; 该方法内部会通过 Binder.getCallingPid() 和 Binder.getCallingUid() 方法，计算 pid 和 uid！ 2.1.1 调用时机checkCallingPermission 方法系统中调用的很多，一些重要服务都会调用它来检查权限，比如 InputManagerService，WindowManagerService，NotificationManagerService，DisplayManagerService 等等，下面只简单列出来几个： 2.1.1.1 NotificationManagerService.enforcePolicyAccess123456789101112private void enforcePolicyAccess(String pkg, String method) &#123; //【1】检查调用者是否有 MANAGE_NOTIFICATIONS 权限 if (PackageManager.PERMISSION_GRANTED == getContext().checkCallingPermission( android.Manifest.permission.MANAGE_NOTIFICATIONS)) &#123; return; &#125; checkCallerIsSameApp(pkg); if (!checkPolicyAccess(pkg)) &#123; Slog.w(TAG, \"Notification policy access denied calling \" + method); throw new SecurityException(\"Notification policy access denied\"); &#125;&#125; NotificationManagerService 有很多方法设计到了权限校验，这里只是举例展示。 2.1.1.2 InputManagerService.addKeyboardLayoutForInputDevice12345678910@Override // Binder callpublic void addKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier, String keyboardLayoutDescriptor) &#123; //【1】检查调用者是否有 SET_KEYBOARD_LAYOUT 权限 if (!checkCallingPermission(android.Manifest.permission.SET_KEYBOARD_LAYOUT, \"addKeyboardLayoutForInputDevice()\")) &#123; throw new SecurityException(\"Requires SET_KEYBOARD_LAYOUT permission\"); &#125; ... ... ... ...&#125; InputManagerService 有很多方法设计到了权限校验，这里只是举例展示。 2.1.1.3 WindowManagerService.startAppFreezingScreen123456789101112131415161718192021222324@Overridepublic void startAppFreezingScreen(IBinder token, int configChanges) &#123; //【1】检查调用者是否有 MANAGE_APP_TOKENS 权限 if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS, \"setAppFreezingScreen()\")) &#123; throw new SecurityException(\"Requires MANAGE_APP_TOKENS permission\"); &#125; synchronized(mWindowMap) &#123; if (configChanges == 0 &amp;&amp; okToDisplay()) &#123; if (DEBUG_ORIENTATION) Slog.v(TAG_WM, \"Skipping set freeze of \" + token); return; &#125; AppWindowToken wtoken = findAppWindowToken(token); if (wtoken == null || wtoken.appToken == null) &#123; Slog.w(TAG_WM, \"Attempted to freeze screen with non-existing app token: \" + wtoken); return; &#125; final long origId = Binder.clearCallingIdentity(); startAppFreezingScreenLocked(wtoken); Binder.restoreCallingIdentity(origId); &#125;&#125; WindowManagerService 有很多方法设计到了权限校验，这里只是举例展示。 2.2 checkPermission该方法用于判断 pid uid 是否有具体的权限，调用这个方法必须要知道对应的 pid 和 uid： 12345678@Overridepublic int checkPermission(String permission, int pid, int uid) &#123; if (permission == null) &#123; return PackageManager.PERMISSION_DENIED; &#125; //【*2.12】调用了 checkComponentPermission 方法！ return checkComponentPermission(permission, pid, uid, -1, true);&#125; 2.2.1 调用时机checkPermission 方法的调用也很多，所以简单的看几个： 2.2.1.1 ActivityManagerService.isGetTasksAllowed1234567891011121314151617181920212223private boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) &#123; //【1】检查调用者是否具有 REAL_GET_TASKS 和 GET_TASKS 权限！ boolean allowed = checkPermission(android.Manifest.permission.REAL_GET_TASKS, callingPid, callingUid) == PackageManager.PERMISSION_GRANTED; if (!allowed) &#123; if (checkPermission(android.Manifest.permission.GET_TASKS, callingPid, callingUid) == PackageManager.PERMISSION_GRANTED) &#123; try &#123; if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) &#123; allowed = true; if (DEBUG_TASKS) Slog.w(TAG, caller + \": caller \" + callingUid + \" is using old GET_TASKS but privileged; allowing\"); &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; if (!allowed) &#123; if (DEBUG_TASKS) Slog.w(TAG, caller + \": caller \" + callingUid + \" does not hold REAL_GET_TASKS; limiting output\"); &#125; return allowed;&#125; 2.2.2 跨进程调用调用方法：12345try &#123; ActivityManagerNative.getDefault().checkPermission(...);&#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer();&#125; 具体流程： ActivityManagerProxy 123456789101112131415public int checkPermission(String permission, int pid, int uid) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeString(permission); data.writeInt(pid); data.writeInt(uid); mRemote.transact(CHECK_PERMISSION_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; ActivityManagerNative 12345678910case CHECK_PERMISSION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); String perm = data.readString(); int pid = data.readInt(); int uid = data.readInt(); int res = checkPermission(perm, pid, uid); reply.writeNoException(); reply.writeInt(res); return true;&#125; 2.3 checkContentProviderPermissionLockedcheckContentProviderPermissionLocked 方法用于判断： 进程 ProcessRecord 是否可以访问目标 ContentProvider 对象，该方法返回 null 表示该进程是有这个权限的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private final String checkContentProviderPermissionLocked( ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) &#123; //【1】获得进程的 pid 和 uid！ final int callingPid = (r != null) ? r.pid : Binder.getCallingPid(); final int callingUid = (r != null) ? r.uid : Binder.getCallingUid(); boolean checkedGrants = false; //【2】如果 checkUser 为 true 的话，会进入下面的分支，检查 userId if (checkUser) &#123; // Looking for cross-user grants before enforcing the typical cross-users permissions int tmpTargetUserId = mUserController.unsafeConvertIncomingUserLocked(userId); if (tmpTargetUserId != UserHandle.getUserId(callingUid)) &#123; if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) &#123; return null; &#125; checkedGrants = true; &#125; userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, false, ALLOW_NON_FULL, \"checkContentProviderPermissionLocked \" + cpi.authority, null); if (userId != tmpTargetUserId) &#123; // When we actually went to determine the final targer user ID, this ended // up different than our initial check for the authority. This is because // they had asked for USER_CURRENT_OR_SELF and we ended up switching to // SELF. So we need to re-check the grants again. checkedGrants = false; &#125; &#125; //【*2.12】检查访问进程是否具有读权限！ if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; //【*2.12】检查访问进程是否具有写权限！ if (checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; //【3】检查访问进程是否具有 pathPermissions，每个 path 都可以指定 read 和 write 权限！ PathPermission[] pps = cpi.pathPermissions; if (pps != null) &#123; int i = pps.length; while (i &gt; 0) &#123; i--; PathPermission pp = pps[i]; //【*2.12】检查访问进程是否具有 path 读权限！ String pprperm = pp.getReadPermission(); if (pprperm != null &amp;&amp; checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; //【*2.12】检查访问进程是否具有 path 写权限！ String ppwperm = pp.getWritePermission(); if (ppwperm != null &amp;&amp; checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) &#123; return null; &#125; &#125; &#125; if (!checkedGrants &amp;&amp; checkAuthorityGrants(callingUid, cpi, userId, checkUser)) &#123; return null; &#125; String msg; //【4】最后校验该 ContentProvider 是否是 exported 的！ if (!cpi.exported) &#123; msg = \"Permission Denial: opening provider \" + cpi.name + \" from \" + (r != null ? r : \"(null)\") + \" (pid=\" + callingPid + \", uid=\" + callingUid + \") that is not exported from uid \" + cpi.applicationInfo.uid; &#125; else &#123; msg = \"Permission Denial: opening provider \" + cpi.name + \" from \" + (r != null ? r : \"(null)\") + \" (pid=\" + callingPid + \", uid=\" + callingUid + \") requires \" + cpi.readPermission + \" or \" + cpi.writePermission; &#125; Slog.w(TAG, msg); return msg;&#125; 我们看到了这里调用了 checkComponentPermission 方法，判断访问者对该 ContentProvider 是否具有读或写的权限！ 2.3.1 调用时机2.3.1.1 ActivityManagerService.getContentProviderImpl该方法主要是在访问 provider 的时候做权限校验的，调用的方法在 getContentProviderImpl 方法; 123456789101112131415161718192021222324252627282930313233343536373839private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; synchronized(this) &#123; ... ... ... boolean providerRunning = cpr != null &amp;&amp; cpr.proc != null &amp;&amp; !cpr.proc.killed; if (providerRunning) &#123; cpi = cpr.info; String msg; checkTime(startTime, \"getContentProviderImpl: before checkContentProviderPermission\"); //【*2.3】校验是否有访问 provider 的权限； if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser)) != null) &#123; throw new SecurityException(msg); &#125; checkTime(startTime, \"getContentProviderImpl: after checkContentProviderPermission\"); ... ... ... ... &#125; if (!providerRunning) &#123; ... ... ... ... String msg; checkTime(startTime, \"getContentProviderImpl: before checkContentProviderPermission\"); //【*2.3】同上； if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, !singleton)) != null) &#123; throw new SecurityException(msg); &#125; checkTime(startTime, \"getContentProviderImpl: after checkContentProviderPermission\"); ... ... ... ... &#125; checkTime(startTime, \"getContentProviderImpl: done!\"); &#125; ... ... ... ... return cpr != null ? cpr.newHolder(conn) : null;&#125; getContentProviderImpl 方法我就不多说了，之前分析总结过！ 2.4 checkGrantUriPermission判断 callingUid 是否能够授予 targetPkg 访问 uri 的权限，modeFlags 指定了访问模式！ 123456789public int checkGrantUriPermission(int callingUid, String targetPkg, Uri uri, final int modeFlags, int userId) &#123; enforceNotIsolatedCaller(\"checkGrantUriPermission\"); synchronized(this) &#123; //【*2.6】这里调用了 checkGrantUriPermissionLocked 方法！ return checkGrantUriPermissionLocked(callingUid, targetPkg, new GrantUri(userId, uri, false), modeFlags, -1); &#125;&#125; 该方法会对参数做一个简单的封装，然后调用 checkGrantUriPermissionLocked 继续处理！ 2.4.1 调用时机2.4.1.1 Clipboard.setPrimaryClip这里我们通过一个简单的例子来看下这个方法的使用，Android 系统有一个 Clipboard，当我们机型拷贝的时候会调用其 setPrimaryClip 方法： 1234567891011121314public void setPrimaryClip(ClipData clip, String callingPackage) &#123; synchronized (this) &#123; if (clip != null &amp;&amp; clip.getItemCount() &lt;= 0) &#123; throw new IllegalArgumentException(\"No items\"); &#125; final int callingUid = Binder.getCallingUid(); //【1】当然这边是对调用者是否有 write clipboard 的 op 操作进行检查和记录！ if (mAppOps.noteOp(AppOpsManager.OP_WRITE_CLIPBOARD, callingUid, callingPackage) != AppOpsManager.MODE_ALLOWED) &#123; return; &#125; //【2】检查调用者是否是 data 的所有者！ checkDataOwnerLocked(clip, callingUid); ... ... ... 调用了 checkDataOwnerLocked 方法：1234567private final void checkDataOwnerLocked(ClipData data, int uid) &#123; final int N = data.getItemCount(); for (int i=0; i&lt;N; i++) &#123; //【1】对所有的 data 进行检查！ checkItemOwnerLocked(data.getItemAt(i), uid); &#125;&#125; 调用了 checkItemOwnerLocked 方法：12345678910111213141516private final void checkUriOwnerLocked(Uri uri, int uid) &#123; //【1】如果 uri 的 scheme 不是 content 的话，不会检查； if (!\"content\".equals(uri.getScheme())) &#123; return; &#125; long ident = Binder.clearCallingIdentity(); try &#123; //【2】校验下 uid 是否有权限访问 uri！ mAm.checkGrantUriPermission(uid, null, ContentProvider.getUriWithoutUserId(uri), Intent.FLAG_GRANT_READ_URI_PERMISSION, ContentProvider.getUserIdFromUri(uri, UserHandle.getUserId(uid))); &#125; catch (RemoteException e) &#123; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 这个调用流程很清晰！ 2.4.1.2 VoiceInteractionSessionConnection.deliverSessionDataLocked还有一个是语音识别服务，需要传递数据的时候： 1234567891011121314151617181920212223242526272829303132333435private void deliverSessionDataLocked(AssistDataForActivity assistDataForActivity) &#123; Bundle assistData = assistDataForActivity.data.getBundle( VoiceInteractionSession.KEY_DATA); AssistStructure structure = assistDataForActivity.data.getParcelable( VoiceInteractionSession.KEY_STRUCTURE); AssistContent content = assistDataForActivity.data.getParcelable( VoiceInteractionSession.KEY_CONTENT); //【1】获得目标 uid！ int uid = assistDataForActivity.data.getInt(Intent.EXTRA_ASSIST_UID, -1); if (uid &gt;= 0 &amp;&amp; content != null) &#123; //【1.1】获得要传递的 intent，遍历处理内部的 ClipData 数据！ Intent intent = content.getIntent(); if (intent != null) &#123; ClipData data = intent.getClipData(); if (data != null &amp;&amp; Intent.isAccessUriMode(intent.getFlags())) &#123; //【1.1.1】由于目标 uid 需要访问数据，所以这里会尝试授予 uid 对应的 uri 权限！ grantClipDataPermissions(data, intent.getFlags(), uid, mCallingUid, mSessionComponentName.getPackageName()); &#125; &#125; //【1.2】同理！ ClipData data = content.getClipData(); if (data != null) &#123; grantClipDataPermissions(data, Intent.FLAG_GRANT_READ_URI_PERMISSION, uid, mCallingUid, mSessionComponentName.getPackageName()); &#125; &#125; try &#123; //【2】处理语音相关事务！ mSession.handleAssist(assistData, structure, content, assistDataForActivity.activityIndex, assistDataForActivity.activityCount); &#125; catch (RemoteException e) &#123; &#125;&#125; 调用 grantClipDataPermissions 方法，这里的 srcUid 是 EXTRA_ASSIST_UID 对应的 uid！！12345678void grantClipDataPermissions(ClipData data, int mode, int srcUid, int destUid, String destPkg) &#123; final int N = data.getItemCount(); for (int i=0; i&lt;N; i++) &#123; //【1】继续调用： grantClipDataItemPermission(data.getItemAt(i), mode, srcUid, destUid, destPkg); &#125;&#125; 再调用 grantClipDataItemPermission 方法：1234567891011void grantClipDataItemPermission(ClipData.Item item, int mode, int srcUid, int destUid, String destPkg) &#123; if (item.getUri() != null) &#123; //【1】继续调用，授予 uid 对应的 uri 权限！ grantUriPermission(item.getUri(), mode, srcUid, destUid, destPkg); &#125; Intent intent = item.getIntent(); if (intent != null &amp;&amp; intent.getData() != null) &#123; grantUriPermission(intent.getData(), mode, srcUid, destUid, destPkg); &#125;&#125; 继续调用 grantUriPermission 方法：12345678910111213141516171819202122void grantUriPermission(Uri uri, int mode, int srcUid, int destUid, String destPkg) &#123; if (!\"content\".equals(uri.getScheme())) &#123; return; &#125; long ident = Binder.clearCallingIdentity(); try &#123; //【1】做一次检查，如果有异常，那么终止操作！ mAm.checkGrantUriPermission(srcUid, null, ContentProvider.getUriWithoutUserId(uri), mode, ContentProvider.getUserIdFromUri(uri, UserHandle.getUserId(srcUid))); // No security exception, do the grant. int sourceUserId = ContentProvider.getUserIdFromUri(uri, mUser); uri = ContentProvider.getUriWithoutUserId(uri); //【2】授予 srcUid 访问 uri 的权限！ mAm.grantUriPermissionFromOwner(mPermissionOwner, srcUid, destPkg, uri, Intent.FLAG_GRANT_READ_URI_PERMISSION, sourceUserId, mUser); &#125; catch (RemoteException e) &#123; &#125; catch (SecurityException e) &#123; Slog.w(TAG, \"Can't propagate permission\", e); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 不多说了！！ 2.4.2 跨进程调用调用方法：12345try &#123; ActivityManagerNative.getDefault().checkGrantUriPermission(...);&#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer();&#125; 具体流程： ActivityManagerProxy 1234567891011121314151617public int checkGrantUriPermission(int callingUid, String targetPkg, Uri uri, int modeFlags, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeInt(callingUid); data.writeString(targetPkg); uri.writeToParcel(data, 0); data.writeInt(modeFlags); data.writeInt(userId); mRemote.transact(CHECK_GRANT_URI_PERMISSION_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; ActivityManagerNative 123456789101112case CHECK_GRANT_URI_PERMISSION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); int callingUid = data.readInt(); String targetPkg = data.readString(); Uri uri = Uri.CREATOR.createFromParcel(data); int modeFlags = data.readInt(); int userId = data.readInt(); int res = checkGrantUriPermission(callingUid, targetPkg, uri, modeFlags, userId); reply.writeNoException(); reply.writeInt(res); return true;&#125; 2.5 checkGrantUriPermissionFromIntentLocked该方法用于判断是否能够授予 targetPkg 访问 uri 的权限，uri 来自接收到的 intent； 和 2.6 的 checkGrantUriPermissionLocked 很类似，区别是 checkGrantUriPermissionLocked 直接操作的是 Uri；而该方法直接作用于 Intent！ 返回 null 表示不需要授予权限！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, int mode, NeededUriGrants needed, int targetUserId) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Checking URI perm to data=\" + (intent != null ? intent.getData() : null) + \" clip=\" + (intent != null ? intent.getClipData() : null) + \" from \" + intent + \"; flags=0x\" + Integer.toHexString(intent != null ? intent.getFlags() : 0)); //【1】如果 targetPkg / intent 为 null，则抛出异常！ if (targetPkg == null) &#123; throw new NullPointerException(\"targetPkg\"); &#125; if (intent == null) &#123; return null; &#125; //【2】获得 intent 中的 Uri 和 ClipData 数据，如果都为 null，抛出异常！ Uri data = intent.getData(); ClipData clip = intent.getClipData(); if (data == null &amp;&amp; clip == null) &#123; return null; &#125; //【3】获得 uri 所在的 userId，如果 contentUserHint 等于 UserHandle.USER_CURRENT， // 说明该 intent 没有离开当前 userId！ int contentUserHint = intent.getContentUserHint(); if (contentUserHint == UserHandle.USER_CURRENT) &#123; contentUserHint = UserHandle.getUserId(callingUid); &#125; //【4】计算目标 uid，如果已经知道需要什么权限，即 NeededUriGrants 不为 null，那么通过 NeededUriGrants.targetUid // 获得目标 uid，否则，通过 targetPkg 计算 targetUid！ final IPackageManager pm = AppGlobals.getPackageManager(); int targetUid; if (needed != null) &#123; targetUid = needed.targetUid; &#125; else &#123; try &#123; targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, targetUserId); &#125; catch (RemoteException ex) &#123; return null; &#125; if (targetUid &lt; 0) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Can't grant URI permission no uid for: \" + targetPkg + \" on user \" + targetUserId); return null; &#125; &#125; //【5】首先处理 data 数据，获得传递的 uri，调用 checkGrantUriPermissionLocked 判断是否需要授予 uri 权限！ if (data != null) &#123; GrantUri grantUri = GrantUri.resolve(contentUserHint, data); //【*2.6】首先判断是否有访问 data 指定的数据！ targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid); //【5.1】如果返回值大于 0，说明需要授予权限，创建 NeededUriGrants 对象，记录下！ if (targetUid &gt; 0) &#123; if (needed == null) &#123; needed = new NeededUriGrants(targetPkg, targetUid, mode); &#125; needed.add(grantUri); &#125; &#125; //【6】接着处理 ClipData 数据，遍历 ClipData 中的所有 item，处理其 uri 和 intent 数据！ if (clip != null) &#123; for (int i=0; i&lt;clip.getItemCount(); i++) &#123; Uri uri = clip.getItemAt(i).getUri(); if (uri != null) &#123; //【*2.6】如果其 uri 不为 null，检查是否有权限访问该 url，同样是 checkGrantUriPermissionLocked // 方法！ GrantUri grantUri = GrantUri.resolve(contentUserHint, uri); targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid); if (targetUid &gt; 0) &#123; if (needed == null) &#123; needed = new NeededUriGrants(targetPkg, targetUid, mode); &#125; needed.add(grantUri); &#125; &#125; else &#123; //【6.1】如果其 clipIntent 不为 null，递归检查该 intent! Intent clipIntent = clip.getItemAt(i).getIntent(); if (clipIntent != null) &#123; //【*2.6】递归检查！ NeededUriGrants newNeeded = checkGrantUriPermissionFromIntentLocked( callingUid, targetPkg, clipIntent, mode, needed, targetUserId); if (newNeeded != null) &#123; needed = newNeeded; &#125; &#125; &#125; &#125; &#125; //【7】返回 NeededUriGrants 对象，该对象保存了需要授权访问的所有 url！！ return needed;&#125; 该方法会返回一个 NeededUriGrants 对象，用于保存该 intent 携带的所有需要授权访问了 GrantUri 对象，包括其 ClipData 中的 intent 携带的 uri： 1234567891011static class NeededUriGrants extends ArrayList&lt;GrantUri&gt; &#123; final String targetPkg; final int targetUid; final int flags; NeededUriGrants(String targetPkg, int targetUid, int flags) &#123; this.targetPkg = targetPkg; this.targetUid = targetUid; this.flags = flags; &#125;&#125; 这里的 mode 可以设置下面的两个标志位！ 123public static final int FLAG_GRANT_READ_URI_PERMISSION = 0x00000001;public static final int FLAG_GRANT_WRITE_URI_PERMISSION = 0x00000002; 如果设置该标记，Intent 的接受者将会被赋予读/写 Intent 中 uri 数据和 Intent.ClipData 中的 uri 的权限。 当应用到 Intent 的 ClipData 时，其携带的所有 uri 都会被 intent 接收者读/写，同时其会递归处理其携带的所有 intent！ 其实，mode 的值是为了标志授予的权限类型是读还是写的，都设置的话，那就是可读可写！ 2.5.1 调用时机该方法的调用实际比较少，ActiveServices 和 ActivityManagerService 中： 2.5.1.1 ActiveServices.startServiceLocked123456789101112131415161718192021222324252627282930313233ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, String callingPackage, final int userId) throws TransactionTooLargeException &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"startService: \" + service + \" type=\" + resolvedType + \" args=\" + service.getExtras()); ... ... ... ... if (!r.startRequested) &#123; final long token = Binder.clearCallingIdentity(); try &#123; // Before going further -- if this app is not allowed to run in the // background, then at this point we aren't going to let it period. final int allowed = mAm.checkAllowBackgroundLocked( r.appInfo.uid, r.packageName, callingPid, true); if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123; Slog.w(TAG, \"Background start not allowed: service \" + service + \" to \" + r.name.flattenToShortString() + \" from pid=\" + callingPid + \" uid=\" + callingUid + \" pkg=\" + callingPackage); return null; &#125; &#125; finally &#123;f Binder.restoreCallingIdentity(token); &#125; &#125; //【1】校验了下是否需要授予 uri 权限！ NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked( callingUid, r.packageName, service, service.getFlags(), null, r.userId); ... ... ... ... return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);&#125; 这里就不多说了！ 2.6 checkGrantUriPermissionLocked判断是否需要授予 targetPkg 访问 uri 的权限，modeFlags 指定了访问模式， callingUid 是调用者 uid！ 如果 callingUid 不被允许，会抛出 SecurityException 异常！ 如果方法返回了 targetPkg 的 uid，说明需要授予权限；如果返回 -1，表示不需要或者无法授予（比如目标包已经有权限访问 uri）！ lastTargetUid 表示 targetPkg 的 uid，如果已经知道了 targetPkg.uid，那么就设置 lastTargetUid 为 targetPkg.uid 即可；如果不知道，那么设置为 -1，方法内部会计算出对应的 uid！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131int checkGrantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, int lastTargetUid) &#123; //【1】判断 modeFlags 是否至少设置了 Intent.FLAG_GRANT_WRITE_URI_PERMISSION 或者 // Intent.FLAG_GRANT_READ_URI_PERMISSION，如果都没有，返回 -1! if (!Intent.isAccessUriMode(modeFlags)) &#123; return -1; &#125; if (targetPkg != null) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Checking grant \" + targetPkg + \" permission to \" + grantUri); &#125; final IPackageManager pm = AppGlobals.getPackageManager(); //【2】如果 uri 不是和 content 相关的，异常，返回 -1； if (!ContentResolver.SCHEME_CONTENT.equals(grantUri.uri.getScheme())) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Can't grant URI permission for non-content URI: \" + grantUri); return -1; &#125; //【3】无法通过 uri 找到一个 ContentProvider，异常，返回 -1； final String authority = grantUri.uri.getAuthority(); final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, MATCH_DEBUG_TRIAGED_MISSING); if (pi == null) &#123; Slog.w(TAG, \"No content provider found for permission check: \" + grantUri.uri.toSafeString()); return -1; &#125; //【4】计算 targetPkg 的 uid！ int targetUid = lastTargetUid; if (targetUid &lt; 0 &amp;&amp; targetPkg != null) &#123; try &#123; targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getUserId(callingUid)); if (targetUid &lt; 0) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Can't grant URI permission no uid for: \" + targetPkg); return -1; &#125; &#125; catch (RemoteException ex) &#123; return -1; &#125; &#125; if (targetUid &gt;= 0) &#123; // 一般情况 targetUid &gt;= 0，说明 targetPkg 是存在的，那么就判断下 targetPkg 是否已经持有该权限！ //【*2.7】这里调用了 checkHoldingPermissionsLocked 判断是否已经有权限，如果已经持有，返回 -1； if (checkHoldingPermissionsLocked(pm, pi, grantUri, targetUid, modeFlags)) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Target \" + targetPkg + \" already has full permission to \" + grantUri); return -1; &#125; &#125; else &#123; //【5】如果 targetUid &lt; 0，说明没有 targetPkg， // 此时如果 ContentProvider 指定了读写权限，那就要进一步判断是否要授予权限；如果没有指定读写权限 // 就要看 provider 是否是暴露的，如果是 export 的，那么可以直接访问，无需授权，返回 -1； // 否则，需要继续判断； boolean allowed = pi.exported; if ((modeFlags &amp; Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) &#123; if (pi.readPermission != null) &#123; allowed = false; &#125; &#125; if ((modeFlags &amp; Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) &#123; if (pi.writePermission != null) &#123; allowed = false; &#125; &#125; if (allowed) &#123; return -1; &#125; &#125; //【6】这里来处理一种跨用户访问的特殊情况： // 如果 targetUid 和 uri 不再同一个 userId 下，并且当前 userId 下的应用不需要任何权限就可以访问该 uri， // 那么我们也会授予 targetPkg 访问 uri 的权限， // 即使 provider 没有授予该权限，这种情况 specialCrossUserGrant 为 true！ //【*2.8】这里调用了 checkHoldingPermissionsInternalLocked 方法！ boolean specialCrossUserGrant = UserHandle.getUserId(targetUid) != grantUri.sourceUserId &amp;&amp; checkHoldingPermissionsInternalLocked(pm, pi, grantUri, callingUid, modeFlags, false /*without considering the uid permissions*/); //【7】一般情况下，我们的访问是不会是跨用户的，继续判断 provider 是否允许授予 uri 权限！ if (!specialCrossUserGrant) &#123; //【7.1】provider 不允许授予 uri 权限，抛出异常！ if (!pi.grantUriPermissions) &#123; throw new SecurityException(\"Provider \" + pi.packageName + \"/\" + pi.name + \" does not allow granting of Uri permissions (uri \" + grantUri + \")\"); &#125; //【7.2】provider 允许授予 uri 权限，如果其指定了 uriPermissionPatterns，判断下要访问呢的 url // 是不是能够匹配 uriPermissionPatterns，如果不行，那就说明不允许访问，抛出异常！ if (pi.uriPermissionPatterns != null) &#123; final int N = pi.uriPermissionPatterns.length; boolean allowed = false; for (int i=0; i&lt;N; i++) &#123; if (pi.uriPermissionPatterns[i] != null &amp;&amp; pi.uriPermissionPatterns[i].match(grantUri.uri.getPath())) &#123; allowed = true; break; &#125; &#125; if (!allowed) &#123; throw new SecurityException(\"Provider \" + pi.packageName + \"/\" + pi.name + \" does not allow granting of permission to path of Uri \" + grantUri); &#125; &#125; &#125; //【8】这里判断了下调用者自身 callingUid 是否有权限访问该 Uri，如果 callingUid 不是 system uid 的话 // 就会进行检查！ if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) &#123; //【*2.7】同样的，这里调用了 checkHoldingPermissionsLocked 方法判断是否已经有权限！ if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) &#123; //【*2.10】调用了 checkUriPermissionLocked 判断是否有 uri 权限！ if (!checkUriPermissionLocked(grantUri, callingUid, modeFlags)) &#123; throw new SecurityException(\"Uid \" + callingUid + \" does not have permission to uri \" + grantUri); &#125; &#125; &#125; //【9】最后返回 targetUid，如果大于 0，说明需要授予权限！！ return targetUid;&#125; 我们看到这里会有几种情况出现异常： uri 所属的 provider 的 grantUriPermissions 为 false，说明 provider 禁止 uri 访问，会抛出异常； 如果 provider 的 grantUriPermissions 为 true，但是 provider 的 uriPermissionPatterns 中的 uri 没有和要访问的 uri 相匹配的，抛出异常； 如果调用者接口的程序，不具有对该 uri 的访问权限，那么就会抛出异常； 这里也用到了那 2 个 flags，不在多说了！ 2.6.1 调用时机该方法的调用比较少，在 ActivityManagerService 中： 一个是 2.4 checkGrantUriPermission 方法； 一个是 2.5 checkGrantUriPermissionFromIntentLocked 方法； 一个是在 grantUriPermissionLocked 方法，关于 grant 后面单独分析； 2.7 checkHoldingPermissionsLocked判断 uid 是否已经有访问 uri 的权限！1234567891011121314151617private final boolean checkHoldingPermissionsLocked( IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, final int modeFlags) &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"checkHoldingPermissionsLocked: uri=\" + grantUri + \" uid=\" + uid); //【1】首先，如果 uid 和 uri 的 userId 不相等的话，需要检查 uid 是否具有跨用户的权限！ if (UserHandle.getUserId(uid) != grantUri.sourceUserId) &#123; //【*2.12】这里调用了 checkComponentPermission 方法，如果没有跨用户的权限，那肯定是不会有 // 访问 url 的权限的！！ if (ActivityManager.checkComponentPermission(INTERACT_ACROSS_USERS, uid, -1, true) != PERMISSION_GRANTED) &#123; return false; &#125; &#125; //【*2.8】如果是同一用户下的，调用 checkHoldingPermissionsInternalLocked 方法进一步处理， // 这里 considerUidPermissions 为 true！表示需要校验 uid 权限！ return checkHoldingPermissionsInternalLocked(pm, pi, grantUri, uid, modeFlags, true);&#125; 2.7.1 调用时机该方法的调用比较少，在 ActivityManagerService 中： 一个是 2.6 checkGrantUriPermissionLocked 方法； 一个是在 revokeUriPermissionLocked 方法，关于 revoke 后面单独分析； 2.8 checkHoldingPermissionsInternalLocked判断 uid 是否已经具有访问 uri 的权限，该接口并不检查是否是跨用户的调用！ considerUidPermissions 参数表示是否检查 uid 权限，一般我们是会传入 true 的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394private final boolean checkHoldingPermissionsInternalLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, final int modeFlags, boolean considerUidPermissions) &#123; //【1】如果 provider 的 uid 和访问者 uid 一样，同一应用，那是有权限访问的，返回 true； // 如果 provider.exported 为 false，那么，其没有权限访问，返回 false； if (pi.applicationInfo.uid == uid) &#123; return true; &#125; else if (!pi.exported) &#123; return false; &#125; //【2】解析 modeFlags 中的 read 和 write 标志位，如果设置了该标志位，则为 false // 那么，下面会进行权限检查！ boolean readMet = (modeFlags &amp; Intent.FLAG_GRANT_READ_URI_PERMISSION) == 0; boolean writeMet = (modeFlags &amp; Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == 0; try &#123; //【2.1】首先判断 uid 是否持有 read 和 write 的 top-level 的权限，该权限是在 &lt;provider&gt; 标签中设定的！ // 当然判断的前提是 considerUidPermissions 为 true！ if (!readMet &amp;&amp; pi.readPermission != null &amp;&amp; considerUidPermissions &amp;&amp; (pm.checkUidPermission(pi.readPermission, uid) == PERMISSION_GRANTED)) &#123; readMet = true; &#125; if (!writeMet &amp;&amp; pi.writePermission != null &amp;&amp; considerUidPermissions &amp;&amp; (pm.checkUidPermission(pi.writePermission, uid) == PERMISSION_GRANTED)) &#123; writeMet = true; &#125; //【2.2】如果 provider 没有设置 top-level 的权限的话，allowDefaultRead 和 allowDefaultWrite 为 true！ // 否则，为 false！ boolean allowDefaultRead = pi.readPermission == null; boolean allowDefaultWrite = pi.writePermission == null; //【2.3】下面是非 top-level 的权限检查！ // 如果 provider 设置了 path permission，那还要判断 uid 其是否持有对应的 path permission！ // 当然判断的前提是 considerUidPermissions 为 true！ final PathPermission[] pps = pi.pathPermissions; if (pps != null) &#123; final String path = grantUri.uri.getPath(); int i = pps.length; //【2.3.1】只有 readMet/writeMet 为 false 时，才会做 path permission 校验！ // 因为如果 readMet | writeMet 为 true 的话，说明 uid 持有 top-level 的权限！ while (i &gt; 0 &amp;&amp; (!readMet || !writeMet)) &#123; i--; PathPermission pp = pps[i]; if (pp.match(path)) &#123; if (!readMet) &#123; final String pprperm = pp.getReadPermission(); if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Checking read perm for \" + pprperm + \" for \" + pp.getPath() + \": match=\" + pp.match(path) + \" check=\" + pm.checkUidPermission(pprperm, uid)); if (pprperm != null) &#123; //【2.3.1】当 considerUidPermissions 为 true，并且 uid 有权限，那么 readMet 为 true // 表示可读，否则 readMet == allowDefaultRead == false； //【*3.1】调用了 pms 的 checkUidPermission 接口！ if (considerUidPermissions &amp;&amp; pm.checkUidPermission(pprperm, uid) == PERMISSION_GRANTED) &#123; readMet = true; &#125; else &#123; allowDefaultRead = false; &#125; &#125; &#125; if (!writeMet) &#123; final String ppwperm = pp.getWritePermission(); if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"Checking write perm \" + ppwperm + \" for \" + pp.getPath() + \": match=\" + pp.match(path) + \" check=\" + pm.checkUidPermission(ppwperm, uid)); if (ppwperm != null) &#123; //【2.3.2】当 considerUidPermissions 为 true，并且 uid 有权限，那么 writeMet 为 true // 表示可写；否则 writeMet == allowDefaultWrite == false； //【*3.1】调用了 pms 的 checkUidPermission 接口！ if (considerUidPermissions &amp;&amp; pm.checkUidPermission(ppwperm, uid) == PERMISSION_GRANTED) &#123; writeMet = true; &#125; else &#123; allowDefaultWrite = false; &#125; &#125; &#125; &#125; &#125; &#125; //【3】如果 allowDefaultRead/allowDefaultWrite 为 true 了，设置 readMet/writeMet 为 true！ if (allowDefaultRead) readMet = true; if (allowDefaultWrite) writeMet = true; &#125; catch (RemoteException e) &#123; return false; &#125; // 最后返回 readMet &amp;&amp; writeMet，如果为 true，表示其具有访问 uri的权限！ return readMet &amp;&amp; writeMet;&#125; 通过逻辑可以知道： 如果 considerUidPermissions 为 true，那么会调用 checkUidPermission 进行 uid 权限的校验! 如果 considerUidPermissions 为 false 的话，如果 uid 想要对 provider 持有访问权限的话，只能是 1234pi.readPermission == null;pi.writePermission == null;pi.pathPermissions == null;pi.exported == true 也就是说，provider 不设置任何权限，同时是暴露的！！ 2.8.1 调用时机该方法的调用比较少，在 ActivityManagerService 中： 一个是 2.7 checkHoldingPermissionsLocked 方法中； 一个是在 revokeUriPermissionLocked 方法，关于 revoke 后面单独分析； 2.9 checkUriPermission用于检查 uid 是否持有 uri permissions： 123456789101112131415161718192021public int checkUriPermission(Uri uri, int pid, int uid, final int modeFlags, int userId, IBinder callerToken) &#123; enforceNotIsolatedCaller(\"checkUriPermission\"); //【1】通过 IBinder 对象获得调用者进程的 pid 和 uid！ Identity tlsIdentity = sCallerIdentity.get(); if (tlsIdentity != null &amp;&amp; tlsIdentity.token == callerToken) &#123; uid = tlsIdentity.uid; pid = tlsIdentity.pid; &#125; //【2】如果 pid 是系统进程自身，默认授予！ if (pid == MY_PID) &#123; return PackageManager.PERMISSION_GRANTED; &#125; synchronized (this) &#123; //【*2.10】调用 checkUriPermissionLocked 继续检查是否具有 uri 权限！ return checkUriPermissionLocked(new GrantUri(userId, uri, false), uid, modeFlags) ? PackageManager.PERMISSION_GRANTED : PackageManager.PERMISSION_DENIED; &#125;&#125; 这里的 sCallerIdentity 是一个线程本地变量：1private static final ThreadLocal&lt;Identity&gt; sCallerIdentity = new ThreadLocal&lt;Identity&gt;(); 我们通过传入的 IBinder 对象和 Identity.token 进行匹配，然后就可以获得调用者的进程 pid 和 uid！ 2.9.1 调用时机 - 跨进程该方法主要是从 Context 的 checkUriPermission 调用过来的！ 调用方法：12345try &#123; ActivityManagerNative.getDefault().checkUriPermission(...);&#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer();&#125; 具体流程： ActivityManagerProxy 123456789101112131415161718public int checkUriPermission(Uri uri, int pid, int uid, int mode, int userId, IBinder callerToken) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); uri.writeToParcel(data, 0); data.writeInt(pid); data.writeInt(uid); data.writeInt(mode); data.writeInt(userId); data.writeStrongBinder(callerToken); mRemote.transact(CHECK_URI_PERMISSION_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; ActivityManagerNative 1234567891011121314case CHECK_URI_PERMISSION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); Uri uri = Uri.CREATOR.createFromParcel(data); int pid = data.readInt(); int uid = data.readInt(); int mode = data.readInt(); int userId = data.readInt(); IBinder callerToken = data.readStrongBinder(); //【*1.9】继续调用； int res = checkUriPermission(uri, pid, uid, mode, userId, callerToken); reply.writeNoException(); reply.writeInt(res); return true;&#125; 2.10 checkUriPermissionLocked用于检查 uid 是否已经被授予uri permissions！ 1234567891011121314151617181920212223242526272829303132private final boolean checkUriPermissionLocked(GrantUri grantUri, int uid, final int modeFlags) &#123; final boolean persistable = (modeFlags &amp; Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION) != 0; final int minStrength = persistable ? UriPermission.STRENGTH_PERSISTABLE : UriPermission.STRENGTH_OWNED; //【1】如果 uid 是 0，为 root 用户，默认是授予，返回 true！ if (uid == 0) &#123; return true; &#125; //【2】获得 uid 已经被授予的 UriPermission，如果没有，返回 false，表示没有授予权限！！ final ArrayMap&lt;GrantUri, UriPermission&gt; perms = mGrantedUriPermissions.get(uid); if (perms == null) return false; //【3】精确匹配 uri！ final UriPermission exactPerm = perms.get(grantUri); if (exactPerm != null &amp;&amp; exactPerm.getStrength(modeFlags) &gt;= minStrength) &#123; return true; &#125; //【4】前缀匹配 uri！ final int N = perms.size(); for (int i = 0; i &lt; N; i++) &#123; final UriPermission perm = perms.valueAt(i); if (perm.uri.prefix &amp;&amp; grantUri.uri.isPathPrefixMatch(perm.uri.uri) &amp;&amp; perm.getStrength(modeFlags) &gt;= minStrength) &#123; return true; &#125; &#125; return false;&#125; 对于 modeFlags，除了能设置上面的 2 个标志之外，还可以设置下面的标志位： 1Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION FLAG_GRANT_READ_URI_PERMISSION 跟 FLAG_GRANT_WRITE_URI_PERMISSION 是用于授予临时权限，如果和 FLAG_GRANT_PERSISTABLE_URI_PERMISSION 结合使用，URI 权限会持久存在，重启也无法撤消，直到明确的用 revokeUriPermission(Uri, int) 撤销。 这个 flag 只提供可能持久授权。但是接收的应用必须调用 ContentResolver.takePersistableUriPermission(Uri, int) 方法实现 。 2.10.1 调用时机该方法的调用比较少，在 ActivityManagerService 中： 一个是 2.9 checkUriPermission 方法中； 一个是 2.10 checkUriPermissionLocked 方法中； 2.11 checkPermissionWithToken检查 IBinder 对象对应的进程是否具有指定权限！ 1234567891011121314151617@Overridepublic int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) &#123; if (permission == null) &#123; return PackageManager.PERMISSION_DENIED; &#125; //【1】计算 IBinder 对象对应的进程的 pid 和 uid！ Identity tlsIdentity = sCallerIdentity.get(); if (tlsIdentity != null &amp;&amp; tlsIdentity.token == callerToken) &#123; Slog.d(TAG, \"checkComponentPermission() adjusting &#123;pid,uid&#125; to &#123;\" + tlsIdentity.pid + \",\" + tlsIdentity.uid + \"&#125;\"); uid = tlsIdentity.uid; pid = tlsIdentity.pid; &#125; //【*2.12】调用 checkComponentPermission 方法，继续检查： return checkComponentPermission(permission, pid, uid, -1, true);&#125; 2.11.1 跨进程调用调用方法：12345try &#123; ActivityManagerNative.getDefault().checkPermissionWithToken(...);&#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer();&#125; 具体流程： ActivityManagerProxy 12345678910111213141516public int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeString(permission); data.writeInt(pid); data.writeInt(uid); data.writeStrongBinder(callerToken); mRemote.transact(CHECK_PERMISSION_WITH_TOKEN_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; ActivityManagerNative 123456789101112case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); String perm = data.readString(); int pid = data.readInt(); int uid = data.readInt(); IBinder token = data.readStrongBinder(); //【*2.11】继续调用； int res = checkPermissionWithToken(perm, pid, uid, token); reply.writeNoException(); reply.writeInt(res); return true;&#125; 2.12 checkComponentPermission123456789int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) &#123; if (pid == MY_PID) &#123; // 如果是进程自身，是持有权限的！ return PackageManager.PERMISSION_GRANTED; &#125; //【*2.12.1】调用 ActivityManager 的 checkComponentPermission 方法！ return ActivityManager.checkComponentPermission(permission, uid, owningUid, exported);&#125; 2.12.1 ActivityM.checkComponentPermission这个方法是一个 hide 方法，只能由系统调用！ 12345678910111213141516171819202122232425262728293031323334353637/** @hide */public static int checkComponentPermission(String permission, int uid, int owningUid, boolean exported) &#123; //【1】如果是 root 用户或者 system 用户， final int appId = UserHandle.getAppId(uid); if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //【2】隔离进程无权限！ if (UserHandle.isIsolated(uid)) &#123; return PackageManager.PERMISSION_DENIED; &#125; //【3】如果是相同 uid，有权限！ if (owningUid &gt;= 0 &amp;&amp; UserHandle.isSameApp(uid, owningUid)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //【4】如果组件不是暴露的，那就无权限！ if (!exported) &#123; /* RuntimeException here = new RuntimeException(\"here\"); here.fillInStackTrace(); Slog.w(TAG, \"Permission denied: checkComponentPermission() owningUid=\" + owningUid, here); */ return PackageManager.PERMISSION_DENIED; &#125; if (permission == null) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //【*3.1】调用 pms 的 checkUidPermission 方法继续检查权限！ try &#123; return AppGlobals.getPackageManager() .checkUidPermission(permission, uid); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 2.12.2 ActivityM.checkUidPermission同时 ActivityManager 也有 checkUidPermission 方法，这方法是一个 hide 方法，只能由系统调用！ 该方法会直接访问 pms 的接口！ 12345678910/** @hide */public static int checkUidPermission(String permission, int uid) &#123; try &#123; //【*3.1】调用 pms 的 checkUidPermission 方法继续检查权限！ return AppGlobals.getPackageManager() .checkUidPermission(permission, uid); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 3 权限检查关键接口 - PackageManagerService通过分析系统中的一些 checkPermissions 接口，我们发现最终都调用了 PackageManagerService.checkUidPermission 方法，下面我们去看下： 3.1 checkUidPermission用于检查 uid 是否具有权限 permName！ 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic int checkUidPermission(String permName, int uid) &#123; final int userId = UserHandle.getUserId(uid); //【1】首先是校验 userId 有效性！ if (!sUserManager.exists(userId)) &#123; return PackageManager.PERMISSION_DENIED; &#125; synchronized (mPackages) &#123; //【2】尝试根据 uid 获得其 PackageSetting 或者 SharedUserSetting 对象，这取决于 uid 是独立还是共享的！ Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid)); if (obj != null) &#123; final SettingBase ps = (SettingBase) obj; //【2.1】获得权限管理对象 PermissionsState！ final PermissionsState permissionsState = ps.getPermissionsState(); // 如果该权限确实授予了该 uid，返回 PackageManager.PERMISSION_GRANTED！ if (permissionsState.hasPermission(permName, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //【2.2】这里是处理一种特殊的权限！ if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; permissionsState .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; else &#123; //【3】mSystemPermissions 中保存的是系统 uid 和其权限的对应关系！ ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid); if (perms != null) &#123; if (perms.contains(permName)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; perms .contains(Manifest.permission.ACCESS_FINE_LOCATION)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; &#125; &#125; return PackageManager.PERMISSION_DENIED;&#125; 我们来看下 getUserIdLPr 方法的逻辑： 123456789public Object getUserIdLPr(int uid) &#123; if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123; final int N = mUserIds.size(); final int index = uid - Process.FIRST_APPLICATION_UID; return index &lt; N ? mUserIds.get(index) : null; &#125; else &#123; return mOtherUserIds.get(uid); &#125;&#125; uid 的取值范围： 从 Process.FIRST_APPLICATION_UID（10000） 开始的 uid 是普通 Android 的应用程序，即使用户安装的应用程序，最大值为 Process.LAST_APPLICATION_UID（19999）！ 而 Process.FIRST_APPLICATION_UID 以下的 uid 都是系统应用和系统进程的！ PackageSetting 和 SharedUserSetting： 如果应用程序是独立 uid 的话，那么其会有一个 PackageSetting 对象，然后会根据其 uid 的类型，添加到 mUserIds 或者 mOtherUserIds； 如果应用程序是共享 uid 的话，除了会创建 PackageSetting 对象，还会创建一个 SharedUserSetting 对象，用来封装共享 uid 的信息 ，然后会根据其 uid 的类型，将 SharedUserSetting 对象添加到 mUserIds 或者 mOtherUserIds； 权限的处理： 如果应用是独立 uid 的话，那么 getUserIdLPr 返回是 PackageSetting 对象！ 如果应用是共享 uid 的话，那么 getUserIdLPr 返回的是 SharedUserSetting 对象，这是因为共享同一个 uid 的应用持有相同的权限！ PackageSetting 和 SharedUserSetting 都有一个 PermissionsState 对象，用于封装 package 在不同 userId 下的权限授予情况！ 3.2 checkPermissionPMS 还有另外一个用于检查权限的方法，判断包名对应的应用程序是否有权限！ 123456789101112131415161718192021222324252627@Overridepublic int checkPermission(String permName, String pkgName, int userId) &#123; if (!sUserManager.exists(userId)) &#123; return PackageManager.PERMISSION_DENIED; &#125; synchronized (mPackages) &#123; //【1】获得该 pkg 对应的 Package 实例！ final PackageParser.Package p = mPackages.get(pkgName); if (p != null &amp;&amp; p.mExtras != null) &#123; final PackageSetting ps = (PackageSetting) p.mExtras; final PermissionsState permissionsState = ps.getPermissionsState(); //【1.1】判断 permissionsState 中该权限状态是否是 true！ if (permissionsState.hasPermission(permName, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; //【1.2】对于 ACCESS_COARSE_LOCATION 比较特殊，如果应用已经有了 ACCESS_FINE_LOCATION // 那么应用也会有 ACCESS_COARSE_LOCATION 权限！ if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; permissionsState .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) &#123; return PackageManager.PERMISSION_GRANTED; &#125; &#125; &#125; return PackageManager.PERMISSION_DENIED;&#125; 该方法用于判断 pkgName 在 userId 下，是否有权限 permName！ 3.2.1 调用时机PMS 的接口可以被其他 check 接口调用，同时我们也可以直接调用其进行权限检查： 3.2.1.1 BroadcastQueue.processNextBroadcast在我们发送广播的时候，如果广播指定了接收者的权限，那么我们会校验 1234567891011121314151617181920final void processNextBroadcast(boolean fromMsg) &#123; ... ... ... if (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp; r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123; for (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123; String requiredPermission = r.requiredPermissions[i]; try &#123; perm = AppGlobals.getPackageManager(). checkPermission(requiredPermission, info.activityInfo.applicationInfo.packageName, UserHandle .getUserId(info.activityInfo.applicationInfo.uid)); &#125; catch (RemoteException e) &#123; perm = PackageManager.PERMISSION_DENIED; &#125; ... ... ... &#125; &#125; ... ... ...&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Permission权限管理","slug":"AndroidFramework源码分析/Permission权限管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Permission权限管理/"}],"tags":[{"name":"Permission权限管理","slug":"Permission权限管理","permalink":"https://coolqi.top/tags/Permission权限管理/"}]},{"title":"AlarmManager第 1 篇 - AlarmManagerService启动","slug":"AlarmManager1-AlarmManagerServiceStartProcess","date":"2017-05-23T12:46:25.000Z","updated":"2018-11-20T16:54:06.000Z","comments":true,"path":"2017/05/23/AlarmManager1-AlarmManagerServiceStartProcess/","link":"","permalink":"https://coolqi.top/2017/05/23/AlarmManager1-AlarmManagerServiceStartProcess/","excerpt":"","text":"基于 Android7.1.1 源码，分析 AlarmManagerService 的启动流程，这里我们重点关注和分析 java 层的逻辑实现！ 123456789private void startOtherServices() &#123; ... ... ... traceBeginAndSlog(\"StartAlarmManagerService\"); //【1】启动 AlarmManagerService mSystemServiceManager.startService(AlarmManagerService.class); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); ... ... ...&#125; 首先会创建 AlarmManagerService 实例对象，然后会调用其 onStart 方法！ 1 Constructor12345public AlarmManagerService(Context context) &#123; super(context); // 创建了常量实例，用于存储其所需的一些常量！ mConstants = new Constants(mHandler);&#125; AlarmManagerService 的构造器很简单，只是创建了一个 Constants 实例对象！ 1.1 new ConstantsConstants 用来保存 alarm manger 需要的一些常量数据，其内部有一些和属性值！ 该类中所有的时间单位都是毫秒，这些常量的值和系统全局设置 Settings.Global 中的值保持同步，任何访问该类或该类中的字段都要持有 AlarmManagerService.mLock 锁！ 首先，是一些 Settings.Global 中的 key 值，用于将数据保存到 Settings 中！1234567private static final String KEY_MIN_FUTURITY = \"min_futurity\";private static final String KEY_MIN_INTERVAL = \"min_interval\";private static final String KEY_ALLOW_WHILE_IDLE_SHORT_TIME = \"allow_while_idle_short_time\";private static final String KEY_ALLOW_WHILE_IDLE_LONG_TIME = \"allow_while_idle_long_time\";private static final String KEY_ALLOW_WHILE_IDLE_WHITELIST_DURATION = \"allow_while_idle_whitelist_duration\";private static final String KEY_LISTENER_TIMEOUT = \"listener_timeout\"; 接着是一些 default 值，用于初始化成员变量！1234567private static final long DEFAULT_MIN_FUTURITY = 5 * 1000; // 默认的最小触发时间： 5sprivate static final long DEFAULT_MIN_INTERVAL = 60 * 1000; // 默认最小时间间隔； 60s!private static final long DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME = DEFAULT_MIN_FUTURITY;private static final long DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME = 9*60*1000;private static final long DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION = 10*1000; private static final long DEFAULT_LISTENER_TIMEOUT = 5 * 1000; // 默认的监听超时时间：5s 最后是一些 alarm manager 会用到的一些成员变量：1234567891011121314151617181920212223// Minimum futurity of a new alarmpublic long MIN_FUTURITY = DEFAULT_MIN_FUTURITY;// alarm 重复执行的最小时间间隔！public long MIN_INTERVAL = DEFAULT_MIN_INTERVAL;// Minimum time between ALLOW_WHILE_IDLE alarms when system is not idle.public long ALLOW_WHILE_IDLE_SHORT_TIME = DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME;// Minimum time between ALLOW_WHILE_IDLE alarms when system is idling.public long ALLOW_WHILE_IDLE_LONG_TIME = DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME;// BroadcastOptions.setTemporaryAppWhitelistDuration() to use for FLAG_ALLOW_WHILE_IDLE.public long ALLOW_WHILE_IDLE_WHITELIST_DURATION = DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION;// Direct alarm listener callback timeout// 闹钟监听回调超时时间，初始化为 5s;public long LISTENER_TIMEOUT = DEFAULT_LISTENER_TIMEOUT;private ContentResolver mResolver; // 用于访问设置的全局数据库！private final KeyValueListParser mParser = new KeyValueListParser(',');private long mLastAllowWhileIdleWhitelistDuration = -1; 接着，去看看 Constants 的构造器！ 123456public Constants(Handler handler) &#123; super(handler); // 更新 idle 相关的时间值 updateAllowWhileIdleMinTimeLocked(); updateAllowWhileIdleWhitelistDurationLocked();&#125; 1.2 Constructor.updateAllowWhileIdleMinTimeLocked这里调用了两个方法： 12345public void updateAllowWhileIdleMinTimeLocked() &#123; //【1】更新 allow while idle 类型的 alarm 的最小触发时间点！ mAllowWhileIdleMinTime = mPendingIdleUntil != null ? ALLOW_WHILE_IDLE_LONG_TIME : ALLOW_WHILE_IDLE_SHORT_TIME;&#125; 如果此时已经进入了 idle 状态，那么触发的最小时间间隔为：ALLOW_WHILE_IDLE_LONG_TIME，否则为 ALLOW_WHILE_IDLE_SHORT_TIME！ 1.3 Constructor.updateAllowWhileIdleWhitelistDurationLocked123456789public void updateAllowWhileIdleWhitelistDurationLocked() &#123; //【2】更新 mLastAllowWhileIdleWhitelistDuration 变量！ if (mLastAllowWhileIdleWhitelistDuration != ALLOW_WHILE_IDLE_WHITELIST_DURATION) &#123; mLastAllowWhileIdleWhitelistDuration = ALLOW_WHILE_IDLE_WHITELIST_DURATION; BroadcastOptions opts = BroadcastOptions.makeBasic(); opts.setTemporaryAppWhitelistDuration(ALLOW_WHILE_IDLE_WHITELIST_DURATION); mIdleOptions = opts.toBundle(); &#125;&#125; 继续来看，该方法用于设置 system 更新 idle whilde list 的时间间隔，目前是 10 × 1000 毫秒！ 2 onStart接着是重点 onStart 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Overridepublic void onStart() &#123; //【2.1】native 层的初始化操作，打开 alarm 驱动，并返回驱动文件句柄！ mNativeData = init(); mNextWakeup = mNextNonWakeup = 0; //【2.2】设置时区给 kernel，因为 kernel 重启后不会保存时区信息！ setTimeZoneImpl(SystemProperties.get(TIMEZONE_PROPERTY)); PowerManager pm = (PowerManager) getContext().getSystemService(Context.POWER_SERVICE); mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"*alarm*\"); // 创建时间发生改变的广播！ mTimeTickSender = PendingIntent.getBroadcastAsUser(getContext(), 0, new Intent(Intent.ACTION_TIME_TICK).addFlags( Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND), 0, UserHandle.ALL); // 创建日期发生改变的广播！ Intent intent = new Intent(Intent.ACTION_DATE_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING); mDateChangeSender = PendingIntent.getBroadcastAsUser(getContext(), 0, intent, Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, UserHandle.ALL); //【2.2】创建一个 ClockReceiver 广播接收者，用于接收 Intent.ACTION_DATE_CHANGED 和 Intent.ACTION_TIME_TICK 广播！ mClockReceiver = new ClockReceiver(); // 设置时间改变和日期改变的 Alarm！ mClockReceiver.scheduleTimeTickEvent(); mClockReceiver.scheduleDateChangedEvent(); //【2.3】创建监听熄屏亮屏广播的接收者！ mInteractiveStateReceiver = new InteractiveStateReceiver(); mUninstallReceiver = new UninstallReceiver(); //【2.4】如果成功打开了驱动文件句柄，那就创建一个 AlarmThread，监控驱动文件！ // 如果无法打开 Alarm 驱动，那就是用 AlarmHandler 对象！ if (mNativeData != 0) &#123; AlarmThread waitThread = new AlarmThread(); waitThread.start(); &#125; else &#123; Slog.w(TAG, \"Failed to open alarm driver. Falling back to a handler.\"); &#125; try &#123; // 注册 uid 观察者！ ActivityManagerNative.getDefault().registerUidObserver(new UidObserver(), ActivityManager.UID_OBSERVER_IDLE); &#125; catch (RemoteException e) &#123; // ignored; both services live in system_server &#125; // 将 AlarmManagerService 注册到 SystemService 中！ publishBinderService(Context.ALARM_SERVICE, mService); publishLocalService(LocalService.class, new LocalService());&#125; 下面我们来具体分析下： 2.1 init -&gt; android_server_AlarmManagerService_init1private native long init(); 可以看到，这是一个 native 方法，方法的定义在：android/frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp 中！ 最终会通过 systemCall 进入 native 层，调用 android_server_AlarmManagerService_init 方法！ 我们来看看 init 最终做了什么：1234567891011static jlong android_server_AlarmManagerService_init(JNIEnv*, jobject)&#123; //【2.1.1】初始化 alarm 驱动！ jlong ret = init_alarm_driver(); if (ret) &#123; return ret; &#125; //【2.1.2】初始化定时器 fd！ return init_timerfd();&#125; 这里我们不过多关注！ 2.2 setTimeZoneImpl更新时区信息，把当前时区保存到内核中！12345678910111213141516171819202122232425262728293031323334353637383940void setTimeZoneImpl(String tz) &#123; if (TextUtils.isEmpty(tz)) &#123; return; &#125; // 获取最新的时区信息！ TimeZone zone = TimeZone.getTimeZone(tz); // 防止重复写入 boolean timeZoneWasChanged = false; synchronized (this) &#123; // 通过系统属性获得已经保存的时区信息； String current = SystemProperties.get(TIMEZONE_PROPERTY); // 如果 current 不等于 zone.getID()。说明时区信息发生了变化！ if (current == null || !current.equals(zone.getID())) &#123; if (localLOGV) &#123; Slog.v(TAG, \"timezone changed: \" + current + \", new=\" + zone.getID()); &#125; timeZoneWasChanged = true; // 更新系统属性，应用程序会读取该属性！ SystemProperties.set(TIMEZONE_PROPERTY, zone.getID()); &#125; // 更新内核时区信息 // 内核跟踪时间偏移为GMT以西的分钟数 int gmtOffset = zone.getOffset(System.currentTimeMillis()); setKernelTimezone(mNativeData, -(gmtOffset / 60000)); &#125; TimeZone.setDefault(null); // 如果时区发生了变化，那就发送 Intent.ACTION_TIMEZONE_CHANGED 的广播！ if (timeZoneWasChanged) &#123; Intent intent = new Intent(Intent.ACTION_TIMEZONE_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING); intent.putExtra(\"time-zone\", zone.getID()); getContext().sendBroadcastAsUser(intent, UserHandle.ALL); &#125;&#125; 这里的 setKernelTimezone 是一个 native 方法，这里我们先不看！ 1private native int setKernelTimezone(long nativeData, int minuteswest); 更新 kernel 时区的信息的原因是，kernel 在重启后，并不会保存时区信息！ 2.3 ClockReceiver我们来看看 ClockReceiver，是一个动态注册的 BroadcastReceiver，用于接收 Intent.ACTION_TIME_TICK 时间改变和 Intent.ACTION_DATE_CHANGED 日期改变的广播！ 1234567891011121314151617181920212223242526272829303132class ClockReceiver extends BroadcastReceiver &#123; public ClockReceiver() &#123; // 监听 Intent.ACTION_TIME_TICK 和 Intent.ACTION_DATE_CHANGED 的广播！ IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_TIME_TICK); filter.addAction(Intent.ACTION_DATE_CHANGED); getContext().registerReceiver(this, filter); &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(Intent.ACTION_TIME_TICK)) &#123; if (DEBUG_BATCH) &#123; Slog.v(TAG, \"Received TIME_TICK alarm; rescheduling\"); &#125; // 接收到 Intent.ACTION_TIME_TICK 广播后，执行 scheduleTimeTickEvent！ scheduleTimeTickEvent(); &#125; else if (intent.getAction().equals(Intent.ACTION_DATE_CHANGED)) &#123; // 因为 kernel 无法对 DST 进行监控，基于当前时区的 gmt 偏移 + 用户空间跟踪保存的信息来重置时区信息！ TimeZone zone = TimeZone.getTimeZone(SystemProperties.get(TIMEZONE_PROPERTY)); int gmtOffset = zone.getOffset(System.currentTimeMillis()); setKernelTimezone(mNativeData, -(gmtOffset / 60000)); // 接收到 Intent.ACTION_DATE_CHANGED 广播后，执行 scheduleDateChangedEvent！ scheduleDateChangedEvent(); &#125; &#125; ... ... ... ...&#125; 可以看到： 当收到 Intent.ACTION_TIME_TICK 后，触发 scheduleTimeTickEvent 方法； 当收到 Intent.ACTION_DATE_CHANGED，触发 scheduleDateChangedEvent 方法： 2.3.1 ClockReceiver.scheduleTimeTickEvent我们来看下 scheduleTimeTickEvent，该方法每一分钟，就会给所有接收 ACTION_TIME_TICK 广播的接收者发送广播，注意这里也包括自身！ 1234567891011121314151617public void scheduleTimeTickEvent() &#123; //【1】获得当前时间对应的毫秒值！ final long currentTime = System.currentTimeMillis(); //【2】计算当前时间过 1 分钟后的毫秒值！ final long nextTime = 60000 * ((currentTime / 60000) + 1); // Schedule this event for the amount of time that it would take to get to // the top of the next minute. final long tickEventDelay = nextTime - currentTime; final WorkSource workSource = null; // Let system take blame for time tick events. //【3】设置 alarm！ setImpl(ELAPSED_REALTIME, SystemClock.elapsedRealtime() + tickEventDelay, 0, 0, mTimeTickSender, null, null, AlarmManager.FLAG_STANDALONE, workSource, null, Process.myUid(), \"android\");&#125; 可以看出 scheduleTimeTickEvent 方法会设置一个 alarm，距离当前时间的下一秒，这个 alarm 会发送 Intent.ACTION_TIME_TICK 广播！ 然后 ClockReceiver 会接收到这个广播，然后继续设置下一秒的，发送 Intent.ACTION_TIME_TICK 广播的 alarm，如此循环下去！ 2.3.2 ClockReceiver.scheduleDateChangedEvent我们来看下 scheduleDateChangedEvent： 1234567891011121314151617public void scheduleDateChangedEvent() &#123; //【1】计算下一天的 0 点整所对应的 alarm！ Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(System.currentTimeMillis()); calendar.set(Calendar.HOUR_OF_DAY, 0); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); calendar.set(Calendar.MILLISECOND, 0); calendar.add(Calendar.DAY_OF_MONTH, 1); final WorkSource workSource = null; // Let system take blame for date change events. //【2】设置 alarm！ setImpl(RTC, calendar.getTimeInMillis(), 0, 0, mDateChangeSender, null, null, AlarmManager.FLAG_STANDALONE, workSource, null, Process.myUid(), \"android\");&#125; 可以看出 scheduleDateChangedEvent 方法会设置一个 alarm，触发事件是下一天的 0 点整，这个 alarm 会发送 Intent.ACTION_DATE_CHANGED 广播！ 然后 ClockReceiver 会接收到这个广播，然后继续设置下一天 0 点整的，发送 Intent.Intent.ACTION_DATE_CHANGED 广播的 alarm，如此循环下去！ 我们可以看到这里涉及到了一个方法 setImpl，这个方法我们后续会分析，这里先简单认为其设置了一个 alarm！ 2.4 InteractiveStateReceiverInteractiveStateReceiver 用于监控熄屏亮屏的广播！ 1234567891011121314151617class InteractiveStateReceiver extends BroadcastReceiver &#123; public InteractiveStateReceiver() &#123; IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_SCREEN_ON); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); getContext().registerReceiver(this, filter); &#125; @Override public void onReceive(Context context, Intent intent) &#123; synchronized (mLock) &#123; //【2.2.1】处理熄屏亮屏广播！ interactiveStateChangedLocked(Intent.ACTION_SCREEN_ON.equals(intent.getAction())); &#125; &#125;&#125; 监听的 Alarm： Intent.ACTION_SCREEN_OFF Intent.ACTION_SCREEN_ON 继续来看： 2.4.1 interactiveStateChangedLocked这里说下参数 interactive，表示接收到的是否亮屏广播： 1Intent.ACTION_SCREEN_ON.equals(intent.getAction()) 成员变量 mInteractive 用来保存上一次的熄屏亮屏状态！ 接下来，我们来看看 interactiveStateChangedLocked 方法： 123456789101112131415161718192021222324252627282930313233void interactiveStateChangedLocked(boolean interactive) &#123; if (mInteractive != interactive) &#123; // 不相等，说明熄屏亮屏状态发生了变化！ mInteractive = interactive; // 更新 mInteractive // 获得自开机后，经过的时间，包括深度睡眠的时间！ final long nowELAPSED = SystemClock.elapsedRealtime(); if (interactive) &#123; // 如果从 screen off 变为了 screen on，说明此时是亮屏状态！ if (mPendingNonWakeupAlarms.size() &gt; 0) &#123; final long thisDelayTime = nowELAPSED - mStartCurrentDelayTime; mTotalDelayTime += thisDelayTime; if (mMaxDelayTime &lt; thisDelayTime) &#123; mMaxDelayTime = thisDelayTime; &#125; // 立刻分发那些等待中的 no wake up 类型的 alarm！ deliverAlarmsLocked(mPendingNonWakeupAlarms, nowELAPSED); mPendingNonWakeupAlarms.clear(); &#125; // 如果 mNonInteractiveStartTime 大于 0，那么就计算上次处于熄屏的时间间隔，保存到 mNonInteractiveTime！ if (mNonInteractiveStartTime &gt; 0) &#123; long dur = nowELAPSED - mNonInteractiveStartTime; if (dur &gt; mNonInteractiveTime) &#123; mNonInteractiveTime = dur; &#125; &#125; &#125; else &#123; // 如果从 screen on 变为了 screen off，说明此时是熄屏状态，记录熄屏开始时间！ mNonInteractiveStartTime = nowELAPSED; &#125; &#125;&#125; 3 onBootPhase在启动的最后阶段，system ready 的时候，会调用 AlarmManagerService 的 onBootPhase 方法！ 123456789101112@Overridepublic void onBootPhase(int phase) &#123; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; //【3.1】调用 Constants 的 start 方法！ mConstants.start(getContext().getContentResolver()); // 获得 AppOps 管理对象! mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE); // 获得 DeviceIdleController 对象！ mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class); &#125;&#125; 我们来去看看 Constants.start 方法： 3.1 Constants.start123456789public void start(ContentResolver resolver) &#123; //【1】获得系统数据库的 ContentResolver！ mResolver = resolver; //【2】监听 alarm_manager_constants 数据库的变化！ mResolver.registerContentObserver(Settings.Global.getUriFor( Settings.Global.ALARM_MANAGER_CONSTANTS), false, this); //【3】启动时，默认更新一次 Constants； updateConstants();&#125; 当 Settings.Global.ALARM_MANAGER_CONSTANTS 的数据发生变化后，会触发 Constants 的回调： 12345@Overridepublic void onChange(boolean selfChange, Uri uri) &#123; //【3.2】调用 updateConstants 更新 updateConstants();&#125; 3.2 Constants.updateConstants更新 Constants 中的属性值！1234567891011121314151617181920212223242526272829private void updateConstants() &#123; synchronized (mLock) &#123; //【1】读取 Settings 的 Global 数据库中的 alarm_manager_constants 项数据！ // 更新 Constants 内部变量！ try &#123; mParser.setString(Settings.Global.getString(mResolver, Settings.Global.ALARM_MANAGER_CONSTANTS)); &#125; catch (IllegalArgumentException e) &#123; // Failed to parse the settings string, log this and move on // with defaults. Slog.e(TAG, \"Bad device idle settings\", e); &#125; MIN_FUTURITY = mParser.getLong(KEY_MIN_FUTURITY, DEFAULT_MIN_FUTURITY); MIN_INTERVAL = mParser.getLong(KEY_MIN_INTERVAL, DEFAULT_MIN_INTERVAL); ALLOW_WHILE_IDLE_SHORT_TIME = mParser.getLong(KEY_ALLOW_WHILE_IDLE_SHORT_TIME, DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME); ALLOW_WHILE_IDLE_LONG_TIME = mParser.getLong(KEY_ALLOW_WHILE_IDLE_LONG_TIME, DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME); ALLOW_WHILE_IDLE_WHITELIST_DURATION = mParser.getLong( KEY_ALLOW_WHILE_IDLE_WHITELIST_DURATION, DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION); LISTENER_TIMEOUT = mParser.getLong(KEY_LISTENER_TIMEOUT, DEFAULT_LISTENER_TIMEOUT); updateAllowWhileIdleMinTimeLocked(); updateAllowWhileIdleWhitelistDurationLocked(); &#125;&#125; Alarm 是 AlarmManagerService 的一个内部类 Alarm，所有应用在设置 Alarm 的时候，都会在 setImplLocked 函数中将 Alarm 格式化为内部类 Alarm 的格式，定义截选如下： private static class Alarm { public int type; public int count; public long when; public long repeatInterval; public PendingIntent operation; public int uid; public int pid; 其中记录了逻辑闹钟的一些关键信息。 type域：记录着逻辑闹钟的闹钟类型，比如RTC_WAKEUP、ELAPSED_REALTIME_WAKEUP等； count域：是个辅助域，它和repeatInterval域一起工作。当repeatInterval大于0时，这个域可被用于计算下一次重复激发alarm的时间。 when域：记录闹钟的激发时间。这个域和type域相关，详细情况见后文； repeatInterval域：表示重复激发闹钟的时间间隔，如果闹钟只需激发一次，则此域为0，如果闹钟需要重复激发，此域为以毫秒为单位的时间间隔； operation域：记录闹钟激发时应该执行的动作，详细情况见后文； uid域：记录设置闹钟的进程的uid； pid域：记录设置闹钟的进程的pid。","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"AlarmManager闹钟管理","slug":"AndroidFramework源码分析/AlarmManager闹钟管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/AlarmManager闹钟管理/"}],"tags":[{"name":"AlarmManager闹钟管理","slug":"AlarmManager闹钟管理","permalink":"https://coolqi.top/tags/AlarmManager闹钟管理/"}]},{"title":"Permission第 2 篇 - PackageManager 对权限的初始化流程","slug":"Permission2-packageManagerInitPermission","date":"2017-05-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/05/13/Permission2-packageManagerInitPermission/","link":"","permalink":"https://coolqi.top/2017/05/13/Permission2-packageManagerInitPermission/","excerpt":"","text":"[toc] 基于 Android7.1.1 源码，分析权限管理机制 0 综述在分析 PackageManagerService 的时候，我们详细的分析了 PackageManagerService 的启动流程，包括安装信息解析，应用程序包的解析等等！ 其中，涉及到了对系统中权限的解析和配置，但是由于 PackageManagerService 的启动流程过于负责，所以在 PackageManagerService 相关文章中，并没有对其进行启动的总结！ 本系列文章我们详细的总结下权限相关的内容！ 1 添加共享 uid在 PMS 启动的开始，创建了 Settings 对象，同时添加了一些系统定义的共享 uid！ 12345678910111213mSettings = new Settings(mPackages);mSettings.addSharedUserLPw(\"android.uid.system\", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(\"android.uid.phone\", RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(\"android.uid.log\", LOG_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(\"android.uid.nfc\", NFC_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(\"android.uid.bluetooth\", BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(\"android.uid.shell\", SHELL_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); addSharedUserLPw 方法会创建 SharedUserSetting 对象，保存到 Settings.mSharedUsers 中！ 同时也会根据 uid 的取值添加到 Settings.mUserIds 或者 Settings.mOtherUserIds 中，取值判断的依据是：uid &gt;= Process.FIRST_APPLICATION_UID ()！ 如果是应用程序的 uid，会被添加到 mUserIds 中！ 如果是系统服务/进程的 uid，会被添加到 mOtherUserIds 中！ 因为，这里添加的 5 种共享 uid 都是系统定义的，所以会添加到 Settings.mOtherUserIds 中！ 2 解析系统配置信息1234SystemConfig systemConfig = SystemConfig.getInstance();mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures(); 这个过程会解析以下目录中的文件： 123456/etc/sysconfig：ALLOW_ALL/etc/permissions：ALLOW_ALL/odm/etc/sysconfig：ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS/odm/etc/permissions：ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS/oem/etc/sysconfig：ALLOW_FEATURES/oem/etc/permissions：ALLOW_FEATURES 可以看到，和权限相关的目录是： 12/etc/sysconfig：ALLOW_ALL/etc/permissions：ALLOW_ALL 在解析过程中 etc/permissions/platform.xml 文件是被放到了最后处理！ 在这个过程中会解析以下和权限相关的属性，我们来看下 platform.xml 文件中和权限相关的内容！ 2.1 解析 “group”获得系统中的一些特定的 gid，这些 gid 会和系统权限相互映射： 12345&lt;permission name=\"android.permission.BLUETOOTH_STACK\" &gt; &lt;group gid=\"bluetooth\" /&gt; &lt;group gid=\"wakelock\" /&gt; &lt;group gid=\"uhid\" /&gt;&lt;/permission&gt; group 标签不能单独使用，要和 permission 配合使用！ SystemConfig 会通过 android.os.Process.getGidForName 方法获得字符串 group 对应的 int 值！ getGidForName 是一个 native 方法，它的实际定义是 frameworks/base/core/jni/android_util_Process.cpp 中 123456789101112131415161718jint android_os_Process_getGidForName(JNIEnv* env, jobject clazz, jstring name) &#123; ...... const size_t N = name8.size(); if (N &gt; 0) &#123; const char* str = name8.string(); for (size_t i=0; i&lt;N; i++) &#123; if (str[i] &lt; '0' || str[i] &gt; '9') &#123; struct group* grp = getgrnam(str); if (grp == NULL) &#123; return -1; &#125; return grp-&gt;gr_gid; &#125; &#125; return atoi(str); &#125; return -1;&#125; 这里根据 groupName 调用 getgrnam 获取组信息。我们知道，getgrnam 是一个 C 库函数，在 Linux 中标准定义是根据读取 /etc/group 文件获取组信息，但在 Android 中并没有这个文件，那么这个函数是怎么实现的呢？ 该函数是定义在 bionic/libc/bionic/stubs.cpp 文件中，这里我们只关注主要的代码： 12345678910111213141516171819202122232425262728293031#include \"private/android_filesystem_config.h\"static group* android_iinfo_to_group(group* gr, const android_id_info* iinfo) &#123; gr-&gt;gr_name = (char*) iinfo-&gt;name; gr-&gt;gr_gid = iinfo-&gt;aid; gr-&gt;gr_mem[0] = gr-&gt;gr_name; gr-&gt;gr_mem[1] = NULL; return gr;&#125;static group* android_name_to_group(group* gr, const char* name) &#123; for (size_t n = 0; n &lt; android_id_count; ++n) &#123; if (!strcmp(android_ids[n].name, name)) &#123; return android_iinfo_to_group(gr, android_ids + n); &#125; &#125; return NULL;&#125;group* getgrnam(const char* name) &#123; // NOLINT: implementing bad function. stubs_state_t* state = __stubs_state(); if (state == NULL) &#123; return NULL; &#125; if (android_name_to_group(&amp;state-&gt;group_, name) != 0) &#123; return &amp;state-&gt;group_; &#125; return app_id_to_group(app_id_from_name(name), state);&#125; 显而易见，它是遍历 android_ids 数组，查找是否有对应的组。那么 android_ids 定义在那里呢？ 在 system\\core\\include\\private\\android_filesystem_config.h 文件中： 123456789101112131415static const struct android_id_info android_ids[] = &#123; &#123; \"root\", AID_ROOT, &#125;, &#123; \"system\", AID_SYSTEM, &#125;, &#123; \"radio\", AID_RADIO, &#125;, &#123; \"bluetooth\", AID_BLUETOOTH, &#125;, &#123; \"graphics\", AID_GRAPHICS, &#125;, &#123; \"input\", AID_INPUT, &#125;, &#123; \"audio\", AID_AUDIO, &#125;, ... ... ... &#123; \"everybody\", AID_EVERYBODY, &#125;, &#123; \"misc\", AID_MISC, &#125;, &#123; \"nobody\", AID_NOBODY, &#125;,&#125;; 可以看到 android_ids 定义了 uid 的字符串名称和对应的 int 值的映射，AID_XXXX 用于指定其对应的 uid/gid： 12345678910#define AID_ROOT 0 /* traditional unix root user */#define AID_SYSTEM 1000 /* system server */#define AID_RADIO 1001 /* telephony subsystem, RIL */#define AID_BLUETOOTH 1002 /* bluetooth subsystem */#define AID_GRAPHICS 1003 /* graphics devices */#define AID_INPUT 1004 /* input devices */#define AID_AUDIO 1005 /* audio devices */... ... .. ... 关于 android_filesystem_config.h 中的相关内容，我们后面再分析！ SystemConfig 会将解析到的这些全局特定的 gid 保存到 SystemConfig.mGlobalGids 中！ 2.2 解析 “permission”获得系统权限和所属的 gid： 123456&lt;permissions&gt; &lt;!--解析 permission 标签--&gt; &lt;permission name=\"android.permission.BLUETOOTH_ADMIN\" &gt; &lt;group gid=\"net_bt_admin\" /&gt; &lt;/permission&gt;&lt;/permissions&gt; 下面是解析过程： 创建一个 PermissionEntry 对象，用于封装解析到的权限信息！ 解析 perUser 属性； 解析获得该权限映射的 gid，依然是调用了 Process.getGidForName 方法，保存到 PermissionEntry.gids 中！ 最后，将解析的数据会被保存到 Settings.mPermissions 中！ 2.3 解析 “assign-permission”给特定的 uid 分配指定的权限！ 123&lt;assign-permission name=\"android.permission.MODIFY_AUDIO_SETTINGS\" uid=\"media\" /&gt;&lt;assign-permission name=\"android.permission.ACCESS_SURFACE_FLINGER\" uid=\"media\" /&gt;&lt;assign-permission name=\"android.permission.WAKE_LOCK\" uid=\"media\" /&gt; assign-permission 标签用于给那些运行在特定的 uid 下的，没有对于 package 文件的系统进程赋予更高层次的权限，比如 MediaSever 守护进程！ 下面是解析过程： 调用 Process.getUidForName 获得字符串 uid 对应的 int 值，Process.getUidForName 方法最终还是调用的前面的 getgrnam 方法！ 最后，将解析的数据会被保存到 Settings.mSystemPermissions 中！ 2.4 数据同步SystemConfig 在解析完成后，会将 Settings.mSystemPermissions 和 SystemConfig.mGlobalGids 的数据同步保存到 PMS 的集合中： 12mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions(); 3 添加配置信息中的系统权限SystemConfig 在解析完了系统配置的权限和 gid 映射关系，同时我们也得到了一些系统的权限，这里会将这些权限添加到 mSettings.mPermissions 中： 1234567891011121314ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions();for (int i = 0; i&lt; permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123; bp = new BasePermission(perm.name, \"android\", BasePermission.TYPE_BUILTIN); // 将这些系统权限添加到 Settings.mPermissions 中！ mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125;&#125; 这里会创建 BasePermission 实例，指定权限定义者包名为 android，权限类型为 BasePermission.TYPE_BUILTIN！ 如果该系统权限有映射特定的 gid，将其添加到 BasePermission.gids 中！ 4 读取上一次的安装信息接下来，Settings 会从 Packages.xml 中读取上一次安装的信息！ 1234567891011121314151617181920212223242526272829303132333435&lt;packages&gt; &lt;version sdkVersion=\"27\" databaseVersion=\"3\" fingerprint=\"../release-keys\" /&gt; &lt;version volumeUuid=\"primary_physical\" sdkVersion=\"27\" databaseVersion=\"27\" fingerprint=\".../release-keys\" /&gt; &lt;permission-trees /&gt; &lt;permissions&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" package=\"android\" protection=\"18\" /&gt; &lt;!-- ... ... ...--&gt; &lt;/permissions&gt; &lt;package name=\"com.android.providers.calendar\" codePath=\"/system/priv-app/CalendarProvider\" nativeLibraryPath=\"/system/priv-app/CalendarProvider/lib\" primaryCpuAbi=\"armeabi-v7a\" publicFlags=\"940064325\" privateFlags=\"8\" ft=\"1624a4dcee0\" it=\"1624a4dcee0\" ut=\"1624a4dcee0\" version=\"0\" sharedUserId=\"10006\" isOrphaned=\"true\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"0\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.WRITE_SETTINGS\" granted=\"true\" flags=\"0\" /&gt; &lt;!-- ... ... ...--&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=\"1\" /&gt; &lt;/package&gt; ... ... ... .. &lt;shared-user name=\"android.uid.bluetooth\" userId=\"1002\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"0\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" granted=\"true\" flags=\"0\" /&gt; &lt;!-- ... ... --&gt; &lt;/perms&gt; &lt;/shared-user&gt; &lt;/packages&gt; 上面这个 xml 文件显示了 packages.xml 中的文件结构，可以看到，他们会有一个解析的顺序！ 这个过程会会解析获得很多数据，这里我们只关注和权限相关的数据！ 4.1 解析 “permissions” 和 “permission-trees”首先会解析 permission-trees 的内容，然后在解析 permissions 的内容，其保存了上一次安装时的系统和应用定义的所有的权限信息： 123456789&lt;permissions&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" package=\"android\" protection=\"18\" /&gt; &lt;item name=\"android.permission.SEND_RECEIVE_STK_INTENT\" package=\"com.android.stk\" protection=\"2\" /&gt; &lt;item name=\"android.permission.ACCESS_CACHE_FILESYSTEM\" package=\"android\" protection=\"18\" /&gt; &lt;item name=\"android.permission.REMOTE_AUDIO_PLAYBACK\" package=\"android\" protection=\"2\" /&gt; &lt;item name=\"android.permission.DOWNLOAD_WITHOUT_NOTIFICATION\" package=\"com.android.providers.downloads\" /&gt; &lt;item name=\"android.permission.REGISTER_WINDOW_MANAGER_LISTENERS\" package=\"android\" protection=\"2\" /&gt; ... ... ...&lt;/permissions&gt; permissions 标签中保存的是非动态权限信息，permission-trees 中保存的是动态权限信息。 对于非动态权限和动态权限树，会有不同的处理： 非动态权限信息最终都会被解析保存到 Setting.mPermissions 中了！！ 动态权限信息会被保存在 Setting.mPermissionTrees 中了！！ 整个解析过程如下： 解析获得权限名 name，权限的定义包名 package，权限类型 type，以及权限的保护级别 protection 并对其修正； 修正就是为了保证附加标志位只能和基本权限类型 signiture 一起使用； 尝试从 Setttings 的权限集合中获得对应的权限对象 BasePermission 如果为 null 就会创建新的 BasePermission 对象； 如果已有对应的 BasePermission 对象，但是其 type 不是 BasePermission.TYPE_BUILTIN，也会创建新的 BasePermission 对象 ！ 判断权限是不是动态权限： 权限类型 type 是否是 dynamic，如果是，权限类型为 BasePermission.TYPE_DYNAMIC，不是就是 BasePermission.TYPE_NORMAL； 如果是非动态权限，就直接添加到 Setting.mPermissions 中； 如果是动态权限，会在创建一个 PermissionInfo 对象，封装所属权限树的信息，再添加到 Setting.mPermissionTrees 中； 4.2 解析 “package”接着是解析 package 信息，主要是调用 readPackageLPw 方法！ 4.2.1 Settings.readPackageLPw对于 readPackageLPw 方法，我们在 PMS 的启动流程中有详细分析，这里我们只关注和权限相关的代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128private void readPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException &#123; ... ... ... ... try &#123; //【1】获得应用的 name！ name = parser.getAttributeValue(null, ATTR_NAME); realName = parser.getAttributeValue(null, \"realName\"); //【2】获得 userId 和 sharedId 的名称, userId 和 sharedIdStr 不能同时存在！ idStr = parser.getAttributeValue(null, \"userId\"); uidError = parser.getAttributeValue(null, \"uidError\"); sharedIdStr = parser.getAttributeValue(null, \"sharedUserId\"); ... ... ... //【3】获得 userId 的 int 值，如果 AndroidManifest.xml 有设置 android:sharedUserId 属性， // 那么应用的 userId 就为 0！！ int userId = idStr != null ? Integer.parseInt(idStr) : 0; if (resourcePathStr == null) &#123; resourcePathStr = codePathStr; &#125; if (realName != null) &#123; realName = realName.intern(); &#125; if (name == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;package&gt; has no name at \" + parser.getPositionDescription()); &#125; else if (codePathStr == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: &lt;package&gt; has no codePath at \" + parser.getPositionDescription()); &#125; else if (userId &gt; 0) &#123; //【3.1】如果 userId 大于0，说明 package 是独立用户 id // 调用 addPackageLPw 方法保存这个有独立的 Linux 用户 ID 的 Package! packageSetting = addPackageLPw(name.intern(), realName, new File(codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags, pkgPrivateFlags, parentPackageName, null); if (PackageManagerService.DEBUG_SETTINGS) Log.i(PackageManagerService.TAG, \"Reading package \" + name + \": userId=\" + userId + \" pkg=\" + packageSetting); if (packageSetting == null) &#123; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Failure adding uid \" + userId + \" while parsing settings at \" + parser.getPositionDescription()); &#125; else &#123; // 设置时间戳，第一次安装时间，最近更新时间 packageSetting.setTimeStamp(timeStamp); packageSetting.firstInstallTime = firstInstallTime; packageSetting.lastUpdateTime = lastUpdateTime; &#125; &#125; else if (sharedIdStr != null) &#123; //【3.2】sharedIdStr 不为 null，说明 package 设置了共享用户 id！ userId = sharedIdStr != null ? Integer.parseInt(sharedIdStr) : 0; if (userId &gt; 0) &#123; // 对于共享用户 ID 这种情况，还需要验证其有效性! // 创建一个 PendingPackage 对象，来封装这个有共享用户 ID 的 package 的信息! packageSetting = new PendingPackage(name.intern(), realName, new File( codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags, pkgPrivateFlags, parentPackageName, null); // 设置时间戳，第一次安装时间，最近更新时间！ packageSetting.setTimeStamp(timeStamp); packageSetting.firstInstallTime = firstInstallTime; packageSetting.lastUpdateTime = lastUpdateTime; //【3.2.1】添加到 mPendingPackages 中，因为后续需要确定 shareUserId 的有效性！ mPendingPackages.add((PendingPackage) packageSetting); if (PackageManagerService.DEBUG_SETTINGS) Log.i(PackageManagerService.TAG, \"Reading package \" + name + \": sharedUserId=\" + userId + \" pkg=\" + packageSetting); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad sharedId \" + sharedIdStr + \" at \" + parser.getPositionDescription()); &#125; &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; &#125; catch (NumberFormatException e) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; //【4】接下解析和设置其他属性。 if (packageSetting != null) &#123; ... ... ... int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); // Legacy if (tagName.equals(TAG_DISABLED_COMPONENTS)) &#123; readDisabledComponentsLPw(packageSetting, parser, 0); &#125; else if (tagName.equals(TAG_ENABLED_COMPONENTS)) &#123; readEnabledComponentsLPw(packageSetting, parser, 0); &#125; else if (tagName.equals(\"sigs\")) &#123; // 解析 \"sigs\" packageSetting.signatures.readXml(parser, mPastSignatures); &#125; else if (tagName.equals(TAG_PERMISSIONS)) &#123; //【4.2】解析 \"perms\" readInstallPermissionsLPr(parser, packageSetting.getPermissionsState()); packageSetting.installPermissionsFixed = true; &#125; else if (tagName.equals(\"proper-signing-keyset\")) &#123; ... ... ... &#125; &#125; &#125; else &#123; XmlUtils.skipCurrentTag(parser); &#125;&#125; 流程总结： 对于分配了独立的 uid 的 package，创建 PackageSetting 对象，添加到 mPackage 中，并且将自身和 uid 的引用关心保存到 mUsersId 或者 mOthersId 中； 对于分配了共享的 uid 的 package，创建 PendingPackage 对象，添加到 mPendingPackages 中，后续会对其共享 uid 的有效性进行校验！ 在解析过程中，会判断 package 是否是共享 uid 的！ 123idStr = parser.getAttributeValue(null, \"userId\");uidError = parser.getAttributeValue(null, \"uidError\");sharedIdStr = parser.getAttributeValue(null, \"sharedUserId\"); userId 和 sharedUserId 只能存在一个，如果 package 有 sharedUserId，那么 userId 会被设置为 0； 如果 package 是独立 userId ，那么会立刻创建对应的 PackageSettings 对象！然后会调用 addPackageLPw 方法，将其添加到 Settings.mPackages 中！ 同时也会调用 addUserIdLPw 方法，将该 PackageSettings 添加到 Settings.mUserIds/Settings.mOtherUserIds 中，取决于 uid 的范围！ 如果 package 是共享 userId，这里会临时创建一个 PendingPackage 对象，添加到 Settings.mPendingPackages 中，因为共享 userId 的有效性没有确定！ 4.2.1 解析 “perms” 子标签 - 安装时权限对于上一次安装信息，package 的 perms 子标签保存了该 package 申请的安装时权限，注意是安装时权限！ 123456&lt;perms&gt; &lt;item name=\"android.permission.REAL_GET_TASKS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.INTERNET\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.ACCESS_NETWORK_STATE\" granted=\"true\" flags=\"0\" /&gt;&lt;/perms&gt; 运行时权限在另外的地方保存，我们后面再看！ 接着是解析 package 的安装时权限信息，主要是调用 readInstallPermissionsLPr 方法！ 4.2.1.1 Settings.readInstallPermissionsLPr123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void readInstallPermissionsLPr(XmlPullParser parser, PermissionsState permissionsState) throws IOException, XmlPullParserException &#123; int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(TAG_ITEM)) &#123; // 解析 \"item\" String name = parser.getAttributeValue(null, ATTR_NAME); // 接续 \"name\"，权限名称！ //【1】从之前解析的 Settings.mPermissions 获得对应的权限，如果没有，就跳过； BasePermission bp = mPermissions.get(name); if (bp == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown permission: \" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【2】解析 \"granted\" 标签，获得授予情况！ String grantedStr = parser.getAttributeValue(null, ATTR_GRANTED); final boolean granted = grantedStr == null || Boolean.parseBoolean(grantedStr); // 解析 \"flags\"标签 String flagsStr = parser.getAttributeValue(null, ATTR_FLAGS); final int flags = (flagsStr != null) ? Integer.parseInt(flagsStr, 16) : 0; //【3】处理权限授予的操作！ if (granted) &#123; //【9.1】处理默认授予的情况！ if (permissionsState.grantInstallPermission(bp) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; Slog.w(PackageManagerService.TAG, \"Permission already added: \" + name); XmlUtils.skipCurrentTag(parser); &#125; else &#123; permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; else &#123; //【9.2】处理默认不授予的情况！ if (permissionsState.revokeInstallPermission(bp) == PermissionsState.PERMISSION_OPERATION_FAILURE) &#123; Slog.w(PackageManagerService.TAG, \"Permission already added: \" + name); XmlUtils.skipCurrentTag(parser); &#125; else &#123; //【9.3】更新应用权限信息！ permissionsState.updatePermissionFlags(bp, UserHandle.USER_ALL, PackageManager.MASK_PERMISSION_FLAGS, flags); &#125; &#125; &#125; else &#123; Slog.w(PackageManagerService.TAG, \"Unknown element under &lt;permissions&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125;&#125; 这里解析到的权限授予信息会保存到 PermissionsState 对象中！ 首先会判断 Settings.mPermissions 中是否有对应的权限，如果没有，就会忽略掉该安装时权限的授予！ 解析授予状态 granted，值为 true，因为是安装时权限，解析权限的授予标志位信息 flags； 接着处理安装时权限的授予情况！ PermissionsState permissionsState 用于保存该 package 的权限状态信息，通过 packageSetting.getPermissionsState() 方法获得，如果应用是独立的 uid，那么该方法返回的是自身的 PermissionsState，如果是共享 uid，返回的是 ShareUserId 的 PermissionsState！ 12345public PermissionsState getPermissionsState() &#123; return (sharedUser != null) ? sharedUser.getPermissionsState() : super.getPermissionsState();&#125; PermissionsState 内部有一个 mPermissions 哈希表，key 为权限 name，value 为 PermissionData，PermissionData 用于保存权限的授予情况； 1private ArrayMap&lt;String, PermissionData&gt; mPermissions; 接着是处理安装时权限的授予情况： 4.2.1.1.1 PermissionsS.grantInstallPermissionpermissionsState.grantInstallPermission 方法用于授予安装时权限： 123456789101112131415161718192021222324252627282930313233343536373839404142 private int grantPermission(BasePermission permission, int userId) &#123; //【9.1.1】如果之前有权限，本次授予失败！ if (hasPermission(permission.name, userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【9.1.2】判断权限 BasePermission 在 userId 下是否有映射 gid，如果有，那 hasGids 为 true！ final boolean hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId)); //【9.1.3】如果权限 BasePermission 有映射的 gid，那就计算下该 package 的所属的 Gid 组！ final int[] oldGids = hasGids ? computeGids(userId) : NO_GIDS; //【9.1.4】创建权限的 permissionData 对象，并添加到 PermissionState.mPermissions 中！ PermissionData permissionData = ensurePermissionData(permission); //【9.1.5】授予权限！ if (!permissionData.grant(userId)) &#123; // 授权失败，就返回 PERMISSION_OPERATION_FAILURE！ return PERMISSION_OPERATION_FAILURE; &#125; //【2】如果权限有映射的 gid，在授予权限后，再次计算该 package 的所有映射的 gid！ // 比较授权前后，gid 组是否发生了变化，如果有，返回 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED！ if (hasGids) &#123; final int[] newGids = computeGids(userId); if (oldGids.length != newGids.length) &#123; return PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED; &#125; &#125; return PERMISSION_OPERATION_SUCCESS; // 返回 PERMISSION_OPERATION_SUCCESS！ &#125;``` 因为是安装时权限，所以传入的 userId 为 UserHandle.USER_ALL！hasPermission 方法用于判断该权限是否已经授予权限，如果已经授予，那就返回 **PERMISSION_OPERATION_FAILURE**！hasGids 用于判断当前要处理的安装时权限是否有映射的 gid，如果有那个 hasGids 为 true！如果 hasGids 为 true，那就要计算下该 package 当前所持有的所有权限的映射的 gid 组！接着，创建权限的 permissionData 对象，并添加到 PermissionState.mPermissions 中，key 为权限名！permissionData.grant 方法用于设置权限为授予状态：PermissionData 内部有一个 SparseArray，保存了该权限在不用 userId 下的授予状态，可以知道，对于安装时权限，由于 userid 为 UserHandle.USER_ALL，所以 mUserStates 只有一条数据：```javaprivate SparseArray&lt;PermissionState&gt; mUserStates = new SparseArray&lt;&gt;(); 如果授予失败，比如该权限已经授予等等，那么会返回 PERMISSION_OPERATION_FAILURE！！ 如果 hasGids 为 true，那么在授予后，再次计算该 package 当前持有的权限映射的所有 gid，如果 gid 发生了变化，那么返回 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED！ 如果 gid 没有发生变化，那么返回 PERMISSION_OPERATION_SUCCESS，那么会有发生变化的情况吗？是有的，比如应用程序定义的权限是没有映射 gid 的！ 如果返回的是 PERMISSION_OPERATION_SUCCESS 或者 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED ，那么接下来就会保存标志位信息！ 4.2.1.1.2 PermissionsS.revokeInstallPermissionpermissionsState.revokeInstallPermission 方法用于安装时撤销权限！ 1234567891011121314151617181920212223242526272829303132333435private int revokePermission(BasePermission permission, int userId) &#123; //【1】如果没有授予该权限，那就返回 PERMISSION_OPERATION_FAILURE！ if (!hasPermission(permission.name, userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【2】同样，计算该权限是否有映射 gid，如果有 gid，计算当前 package 持有的权限映射的所有 gid！ // 保存到 oldGids 中！ final boolean hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId)); final int[] oldGids = hasGids ? computeGids(userId) : NO_GIDS; PermissionData permissionData = mPermissions.get(permission.name); //【9.2.1】取消权限的授予！ if (!permissionData.revoke(userId)) &#123; return PERMISSION_OPERATION_FAILURE; &#125; //【9.2.2】如果该权限在所有设备用户下均没有授予该 package，即 mUserStates.size() &lt;= 0； // 那么我们要移除该权限！ if (permissionData.isDefault()) &#123; ensureNoPermissionData(permission.name); &#125; //【3】这里是比较，在撤销安装时权限后，该 package 所持有的权限映射的 gid 是否发生变化！ // 如果有，返回 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED！ if (hasGids) &#123; final int[] newGids = computeGids(userId); if (oldGids.length != newGids.length) &#123; return PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED; &#125; &#125; return PERMISSION_OPERATION_SUCCESS;&#125; 整个过程和授予很类似，这里不多说！ 4.2.1.1.3 PermissionsS.updatePermissionFlags如果返回的是 PERMISSION_OPERATION_SUCCESS 或者 PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED ，那么接下来就会保存标志位信息！ 参数传递： userId 传入的是 UserHandle.USER_ALL； flagMask 传入的是 PackageManager.MASK_PERMISSION_FLAGS，取值为 0xFF，转为二进制就是 11111 flagValues 则是解析上次安装信息时，解析该 package 的 perms 标签时，每一个权限的 flags！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public boolean updatePermissionFlags(BasePermission permission, int userId, int flagMask, int flagValues) &#123; enforceValidUserId(userId); final boolean mayChangeFlags = flagValues != 0 || flagMask != 0; //【1】如果 mPermissions 为 null，且需要更新 flags，那么会初始化 mPermissions，将 permission 添加进入！ if (mPermissions == null) &#123; if (!mayChangeFlags) &#123; return false; &#125; ensurePermissionData(permission); &#125; //【2】如果该权限 permission 没有对应的 PermissionData，且需要更新 flags，那么我们会创建 PermissionData 添加！ PermissionData permissionData = mPermissions.get(permission.name); if (permissionData == null) &#123; if (!mayChangeFlags) &#123; return false; &#125; permissionData = ensurePermissionData(permission); &#125; //【3】获得该权限的旧的 flags，用于对比！ final int oldFlags = permissionData.getFlags(userId); //【9.3.1】更新权限标志位！ final boolean updated = permissionData.updateFlags(userId, flagMask, flagValues); //【4】如果权限的状态发生了变化，那就判断是否需要重新申请！ if (updated) &#123; final int newFlags = permissionData.getFlags(userId); if ((oldFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) == 0 &amp;&amp; (newFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0) &#123; if (mPermissionReviewRequired == null) &#123; mPermissionReviewRequired = new SparseBooleanArray(); &#125; //【4.1】如果在该 userId 下需要重新申请，那么就将其添加到 mPermissionReviewRequired 中！ mPermissionReviewRequired.put(userId, true); &#125; else if ((oldFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) != 0 &amp;&amp; (newFlags &amp; PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED) == 0) &#123; //【4.2】如果在该 userId 下不需要重新申请，那么就将其从 mPermissionReviewRequired 中移除！ if (mPermissionReviewRequired != null) &#123; mPermissionReviewRequired.delete(userId); if (mPermissionReviewRequired.size() &lt;= 0) &#123; mPermissionReviewRequired = null; &#125; &#125; &#125; &#125; return updated;&#125; 对于 mayChangeFlags，由于我们 flagMask 传入的是 PackageManager.MASK_PERMISSION_FLAGS，那就意味了需要更新 flags！ 可以看到，如果 mayChangeFlags 为 true 的话，即使没有权限对应的 PermissionData 也会创建，因为这次会更新 flags！ PermissionData.getFlags 方法会获得权限旧的 flags！ 重点的操作在 PermissionData.updateFlag 方法中： 12345678910111213141516171819202122232425262728293031public boolean updateFlags(int userId, int flagMask, int flagValues) &#123; if (isInstallPermission()) &#123; // 如果是安装时权限，那么 userId 为 UserHandle.USER_ALL; userId = UserHandle.USER_ALL; &#125; if (!isCompatibleUserId(userId)) &#123; // 如果 userId 不兼容，那么会直接返回！ return false; &#125; //【1】这里进行 &amp; 操作，保留了 flagValues 和 flagMask 相同的位！ final int newFlags = flagValues &amp; flagMask; //【2】获得该 userId 下的权限状态值！ PermissionState userState = mUserStates.get(userId); if (userState != null) &#123; final int oldFlags = userState.mFlags; //【2.1】取消旧的 flags，设置新的 flags！ userState.mFlags = (userState.mFlags &amp; ~flagMask) | newFlags; if (userState.isDefault()) &#123; mUserStates.remove(userId); &#125; //【2.2】判断 flags 是否发生变化，如果发生了变化，那就返回 true！ return userState.mFlags != oldFlags; &#125; else if (newFlags != 0) &#123; //【2.3】如果该权限在该 userId 下没有状态信息，那就创建状态信息，直接设置新的 flags，返回 true！ userState = new PermissionState(mPerm.name); userState.mFlags = newFlags; mUserStates.put(userId, userState); return true; &#125; return false;&#125; 这里有一个操作： 首先，进行 &amp; 操作，保留了 flagValues 和 flagMask 相同的位，为 newFlags； 接着，userState.mFlags 表示旧的 flags，这里在 userState.mFlags 和 ~flagMask 中做了 &amp; 操作，等价于取了 userState.mFlags 和 flagMask 不同的位，然后加上 newFlags，作为新的 flags！ 结合前面的参数： flagMask 传入的是 PackageManager.MASK_PERMISSION_FLAGS 每一个位都是 1，userState.mFlags &amp; ~flagMask 操作清空了旧的 flags；flagValues &amp; flagMask 计算得到的标志位 newFlags 就是 flagValues！ 其实本质上就是设置标志位为 xml 中解析的值！ 4.3 解析 “shared-user”共享用户相关数据如下：1234567891011&lt;shared-user name=\"android.media\" userId=\"10014\"&gt; &lt;sigs count=\"1\"&gt; &lt;cert index=\"3\" /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=\"android.permission.WRITE_SETTINGS\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.RECEIVE_BOOT_COMPLETED\" granted=\"true\" flags=\"0\" /&gt; &lt;item name=\"android.permission.WRITE_MEDIA_STORAGE\" granted=\"true\" flags=\"0\" /&gt; ... ... &lt;/perms&gt;&lt;/shared-user&gt; 接下来是解析共享 uid，以及共享 uid 被授予的安装时权限！ 4.3.1 Settings.readSharedUserLPw解析系统定义的共享用户 id：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private void readSharedUserLPw(XmlPullParser parser) throws XmlPullParserException,IOException &#123; String name = null; String idStr = null; int pkgFlags = 0; int pkgPrivateFlags = 0; SharedUserSetting su = null; try &#123; name = parser.getAttributeValue(null, ATTR_NAME); // 获得共享用户的名称 idStr = parser.getAttributeValue(null, \"userId\"); // 获得共享用户的id int userId = idStr != null ? Integer.parseInt(idStr) : 0; if (\"true\".equals(parser.getAttributeValue(null, \"system\"))) &#123; // 是否是系统的用户 id！ pkgFlags |= ApplicationInfo.FLAG_SYSTEM; &#125; if (name == null) &#123; ... ... ... &#125; else if (userId == 0) &#123; ... ... ... &#125; else &#123; //【4.3.2】调用 addSharedUserLPw 方法，将这个共享用户和对应的 uid 保存下来！ if ((su = addSharedUserLPw(name.intern(), userId, pkgFlags, pkgPrivateFlags)) == null) &#123; PackageManagerService .reportSettingsProblem(Log.ERROR, \"Occurred while parsing settings at \" + parser.getPositionDescription()); &#125; &#125; &#125; catch (NumberFormatException e) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Error in package manager settings: package \" + name + \" has bad userId \" + idStr + \" at \" + parser.getPositionDescription()); &#125; if (su != null) &#123; // 解析子标签！ int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"sigs\")) &#123; su.signatures.readXml(parser, mPastSignatures); &#125; else if (tagName.equals(\"perms\")) &#123; // 解析 \"perms\" 标签 //【4.3.3】解析共享用户的权限信息！ readInstallPermissionsLPr(parser, su.getPermissionsState()); &#125; else &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unknown element under &lt;shared-user&gt;: \" + parser.getName()); XmlUtils.skipCurrentTag(parser); &#125; &#125; &#125; else &#123; XmlUtils.skipCurrentTag(parser); &#125;&#125; 可以看到，整个过程和解析 package 类似！ addSharedUserLPw 会创建对应的 SharedUserSetting 对象，在解析共享 uid 的安装时权限时，会通过 SharedUserSetting.getPermissionsState() 获得权限管理状态对象！ 4.3.2 Settings.addSharedUserLPwaddSharedUserLPw 会创建对应的 SharedUserSetting 对象！12345678910111213141516171819202122SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) &#123; //【1】创建共享用户对应的 SharedUserSetting 对象！ SharedUserSetting s = mSharedUsers.get(name); if (s != null) &#123; if (s.userId == uid) &#123; return s; &#125; PackageManagerService.reportSettingsProblem(Log.ERROR, \"Adding duplicate shared user, keeping first: \" + name); return null; &#125; s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags); s.userId = uid; //【8.1.1.2.1】根据 uid 的范围，保存到 mUsersId 和 mOthersId 中！ if (addUserIdLPw(uid, s, name)) &#123; // 将其添加到 mSharedUsers 集合中！ mSharedUsers.put(name, s); return s; &#125; return null;&#125; 流程总结： 解析 “shared-user” ，将其分装成 SharedUserSetting 对象，保存到 Settings.mSharedUsers，并根据 uid 的取值将其保存到 mUserIds 或者 mOtherIds 中！ 解析 “shared-user” 子标签 “perm” 等等，解析共享用户的权限，每个权限对应一个 PermissionData 对象，保存进入 PermisssionState 中，用于管理共享用户的权限！ 5 确定共享 uid 有效性主要逻辑如下，我们知道 mPendingPackages 中包含了 uid 为共享 uid 的 PackageSettings1234567891011121314151617181920212223242526272829303132333435363738394041//【1】对 mPendingPackages 集合中的需要验证共享用户 id 有效性的 package，进行共享用户 id 有效性的验证!final int N = mPendingPackages.size();for (int i = 0; i &lt; N; i++) &#123; final PendingPackage pp = mPendingPackages.get(i); //【8.2.1】看 sharedId 是否能对应找到一个 ShardUserSetting 对象! Object idObj = getUserIdLPr(pp.sharedId); if (idObj != null &amp;&amp; idObj instanceof SharedUserSetting) &#123; // 能找到，说明共享用户 ID 是有效的! //【8.2.2】创建 PackageSetting！ PackageSetting p = getPackageLPw(pp.name, null, pp.realName, (SharedUserSetting) idObj, pp.codePath, pp.resourcePath, pp.legacyNativeLibraryPathString, pp.primaryCpuAbiString, pp.secondaryCpuAbiString, pp.versionCode, pp.pkgFlags, pp.pkgPrivateFlags, null, true /* add */, false /* allowInstall */, pp.parentPackageName, pp.childPackageNames); if (p == null) &#123; PackageManagerService.reportSettingsProblem(Log.WARN, \"Unable to create application package for \" + pp.name); continue; &#125; // 将 PendingPackage 的其他数据拷贝到 PackageSetting 中！ p.copyFrom(pp); &#125; else if (idObj != null) &#123; String msg = \"Bad package setting: package \" + pp.name + \" has shared uid \" + pp.sharedId + \" that is not a shared uid\\n\"; mReadMessages.append(msg); PackageManagerService.reportSettingsProblem(Log.ERROR, msg); &#125; else &#123; String msg = \"Bad package setting: package \" + pp.name + \" has shared uid \" + pp.sharedId + \" that is not defined\\n\"; mReadMessages.append(msg); PackageManagerService.reportSettingsProblem(Log.ERROR, msg); &#125;&#125;mPendingPackages.clear(); // 清空 mPendingPackages 过程很简单，就是从前面解析得到的 Settings.mSharedUsers 中尝试获得 package 的共享 uid 对应的 SharedUserSetting 对象，如果存在，那么就说明共享 uid 是有效的！ getPackageLPw 方法会为那些在 mPendingPackages 中的 PendingPackage 创建对应的 PackageSetting，同时设置他们的共享 uid 为 SharedUserSetting，然后会将其添加到 Settings.mPackages 中！ 这里调用 getUserIdLPr 来从 mUserIds 或 mOtherUserIds 中获得一个共享用户对象 SharedUserSetting！ 6 读取上一次运行时权限信息1234//【8.4】读取每个 user 下的运行时权限信息！for (UserInfo user : users) &#123; mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id);&#125; 接下来是读取运行时权限的信息！ 1234567891011121314&lt;?xml version='1.0' encoding='UTF-8' standalone='yes' ?&gt;&lt;runtime-permissions fingerprint=\"OPPO/R11s/R11s:8.1.0/OPM1.171019.011/1519198279:user/release-keys\"&gt; &lt;pkg name=\"com.sohu.inputmethod.sogouoem\"&gt; &lt;item name=\"android.permission.ACCESS_FINE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.READ_EXTERNAL_STORAGE\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.ACCESS_COARSE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; ... ... ... &lt;/pkg&gt; &lt;shared-user name=\"android.uid.calendar\"&gt; &lt;item name=\"android.permission.READ_CALENDAR\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.ACCESS_FINE_LOCATION\" granted=\"true\" flags=\"20\" /&gt; &lt;item name=\"android.permission.READ_EXTERNAL_STORAGE\" granted=\"true\" flags=\"20\" /&gt; ... ... ...&lt;/runtime-permissions&gt; 6.1 RuntimePermissionsPersistence.readStateForUserSyncLPr该方法会读取指定的 userId 下的运行时权限信息，因为运行时权限每个设备用户下都不一样！ 运行时权限记录在 /data/system/users/0/runtime-permissions.xml 文件中！ 12345678910111213141516171819202122232425262728public void readStateForUserSyncLPr(int userId) &#123; //【1】获得运行时权限文件对象 runtime-permissions.xml！ File permissionsFile = getUserRuntimePermissionsFile(userId); if (!permissionsFile.exists()) &#123; return; &#125; FileInputStream in; try &#123; in = new AtomicFile(permissionsFile).openRead(); &#125; catch (FileNotFoundException fnfe) &#123; Slog.i(PackageManagerService.TAG, \"No permissions state\"); return; &#125; try &#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(in, null); //【6.2】解析运行时权限数据！ parseRuntimePermissionsLPr(parser, userId); &#125; catch (XmlPullParserException | IOException e) &#123; throw new IllegalStateException(\"Failed parsing permissions file: \" + permissionsFile , e); &#125; finally &#123; IoUtils.closeQuietly(in); &#125;&#125; 解析过程在 parseRuntimePermissionsLPr 方法中！ 6.2 RuntimePermissionsPersistence.parseRuntimePermissionsLPr用于解析运行时权限文件，获得上一次安装时的运行时权限相关的信息！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void parseRuntimePermissionsLPr(XmlPullParser parser, int userId) throws IOException, XmlPullParserException &#123; final int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; switch (parser.getName()) &#123; case TAG_RUNTIME_PERMISSIONS: &#123; //【1】解析 runtime-permissions 标签 // 解析 fingerprint 属性，保存到 mFingerprints 中！ String fingerprint = parser.getAttributeValue(null, ATTR_FINGERPRINT); mFingerprints.put(userId, fingerprint); // 然用用本次启动系统的 fingerprint 判断系统是否有升级，如果没有升级 defaultsGranted 为 true！ // 后面默认授予运行时权限会用到！ final boolean defaultsGranted = Build.FINGERPRINT.equals(fingerprint); mDefaultPermissionsGranted.put(userId, defaultsGranted); &#125; break; case TAG_PACKAGE: &#123; //【2】解析 pkg 标签 String name = parser.getAttributeValue(null, ATTR_NAME); PackageSetting ps = mPackages.get(name); if (ps == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown package:\" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【6.2.1】解析并处理 package 的运行时权限授予情况！ parsePermissionsLPr(parser, ps.getPermissionsState(), userId); &#125; break; case TAG_SHARED_USER: &#123; //【3】解析 shared-user 标签 String name = parser.getAttributeValue(null, ATTR_NAME); SharedUserSetting sus = mSharedUsers.get(name); if (sus == null) &#123; Slog.w(PackageManagerService.TAG, \"Unknown shared user:\" + name); XmlUtils.skipCurrentTag(parser); continue; &#125; //【6.2.1】解析并处理 shared-user 的运行时权限授予情况！ parsePermissionsLPr(parser, sus.getPermissionsState(), userId); &#125; break; case TAG_RESTORED_RUNTIME_PERMISSIONS: &#123; // restored-perms 标签 final String pkgName = parser.getAttributeValue(null, ATTR_PACKAGE_NAME); parseRestoredRuntimePermissionsLPr(parser, pkgName, userId); &#125; break; &#125; &#125;&#125; 这里的 mDefaultPermissionsGranted 用于判断是否进行默认运行时权限授予的！ 7 应用文件扫描PMS 会按照顺序扫描以下目录： /vendor/overlay /system/framework /system/priv-app /system/app /vendor/app /oem/app 调用 PMS.scanDirTracedLI 进行扫描，需要注意的是被扫描目录的顺序，这个顺序意味着：先被扫描到的文件，就是最终被用到的文件。 7.1 系统权限的定义系统的权限定义在 \\android\\frameworks\\base\\core\\res\\AndroidManifest.xml 文件中！但实际上最终会通过编译生成 framework-res.apk！ 我们来看看具体的权限定义： 1234567891011121314&lt;permission-group android:name=\"android.permission-group.CONTACTS\" android:icon=\"@drawable/perm_group_contacts\" android:label=\"@string/permgrouplab_contacts\" android:description=\"@string/permgroupdesc_contacts\" android:priority=\"100\" /&gt; &lt;!-- Allows an application to read the user's contacts data. &lt;p&gt;Protection level: dangerous --&gt; &lt;permission android:name=\"android.permission.READ_CONTACTS\" android:permissionGroup=\"android.permission-group.CONTACTS\" android:label=\"@string/permlab_readContacts\" android:description=\"@string/permdesc_readContacts\" android:protectionLevel=\"dangerous\" /&gt; 7.2 系统和应用权限信息的解析解析系统权限的过程，其实就是解析 framework-res.apk 的过程！ 对于这一部分，可以看【应用程序的权限配置和解析】这边博文！ 在解析完 Apk 的 AndroidManifest.xml 中定义和申请的权限信息后，会进入扫描的最后阶段 PMS.scanPackageDirtyLI 7.3 PMS.scanPackageDirtyLI无论是系统应用，还是三方应用，最终都会调用 scanPackageDirtyLI 方法处理扫描得到的数据： 这里我们重点看和权限相关的代码段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; final File scanFile = new File(pkg.codePath); ... //【×】处理包名为 \"android\" 的 apk，也就是 framework-res.apk，属于系统平台包！ if (pkg.packageName.equals(\"android\")) &#123; synchronized (mPackages) &#123; if (mAndroidApplication != null) &#123; Slog.w(TAG, \"*************************************************\"); Slog.w(TAG, \"Core android package being redefined. Skipping.\"); Slog.w(TAG, \" file=\" + scanFile); Slog.w(TAG, \"*************************************************\"); throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, \"Core android package being redefined. Skipping.\"); &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; // 进入该分支，设置系统平台包相关的属性！ // Set up information for our fall-back user intent resolution activity. mPlatformPackage = pkg; pkg.mVersionCode = mSdkVersion; mAndroidApplication = pkg.applicationInfo; if (!mResolverReplaced) &#123; // 建立 ResolverActivity 的内存对象。 mResolveActivity.applicationInfo = mAndroidApplication; mResolveActivity.name = ResolverActivity.class.getName(); mResolveActivity.packageName = mAndroidApplication.packageName; mResolveActivity.processName = \"system:ui\"; mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE; mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER; mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS; mResolveActivity.theme = R.style.Theme_Material_Dialog_Alert; mResolveActivity.exported = true; mResolveActivity.enabled = true; mResolveActivity.resizeMode = ActivityInfo.RESIZE_MODE_RESIZEABLE; mResolveActivity.configChanges = ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_KEYBOARD | ActivityInfo.CONFIG_KEYBOARD_HIDDEN; mResolveInfo.activityInfo = mResolveActivity; mResolveInfo.priority = 0; mResolveInfo.preferredOrder = 0; mResolveInfo.match = 0; mResolveComponentName = new ComponentName( mAndroidApplication.packageName, mResolveActivity.name); &#125; &#125; &#125; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Scanning package \" + pkg.packageName); &#125; synchronized (mPackages) &#123; //【1】如果 PMS.mPackages 已经包含当前的 Package，说明这个包已经被扫描过了，抛异常，不继续处理！ if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) &#123; throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, \"Application package \" + pkg.packageName + \" already installed. Skipping duplicate.\"); &#125; // 系统 apk 不进入这个分支，SCAN_REQUIRE_KNOWN 只有在扫描 data 分区是才会被设置！！ if ((scanFlags &amp; SCAN_REQUIRE_KNOWN) != 0) &#123; if (mExpectingBetter.containsKey(pkg.packageName)) &#123; logCriticalInfo(Log.WARN, \"Relax SCAN_REQUIRE_KNOWN requirement for package \" + pkg.packageName); &#125; else &#123; PackageSetting known = mSettings.peekPackageLPr(pkg.packageName); if (known != null) &#123; if (DEBUG_PACKAGE_SCANNING) &#123; Log.d(TAG, \"Examining \" + pkg.codePath + \" and requiring known paths \" + known.codePathString + \" &amp; \" + known.resourcePathString); &#125; if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals( known.resourcePathString)) &#123; throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, \"Application package \" + pkg.packageName + \" found at \" + pkg.applicationInfo.getCodePath() + \" but expected at \" + known.codePathString + \"; ignoring.\"); &#125; &#125; &#125; &#125; &#125; //【×】获得扫描到的 apk 和资源的路径，下面会用到！ File destCodeFile = new File(pkg.applicationInfo.getCodePath()); File destResourceFile = new File(pkg.applicationInfo.getResourcePath()); SharedUserSetting suid = null; PackageSetting pkgSetting = null; //【×】系统 apk 才能有 mOriginalPackages，mRealPackage 和 mAdoptPermissions！ if (!isSystemApp(pkg)) &#123; pkg.mOriginalPackages = null; pkg.mRealPackage = null; pkg.mAdoptPermissions = null; &#125; // Getting the package setting may have a side-effect, so if we // are only checking if scan would succeed, stash a copy of the // old setting to restore at the end. PackageSetting nonMutatedPs = null; synchronized (mPackages) &#123; //【×】当前的系统 package 是共享 uid 的，要判断其对应的共享 uid 是否存在！ if (pkg.mSharedUserId != null) &#123; suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true); if (suid == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Creating application package \" + pkg.packageName + \" for shared user failed\"); &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0) Log.d(TAG, \"Shared UserID \" + pkg.mSharedUserId + \" (uid=\" + suid.userId + \"): packages=\" + suid.packages); &#125; &#125; ... ... ... //【3.2.1.7.2】获得当前扫描的这个 package 对应的 packageSetting 对象，如果已经存在就直接返回，不存在就创建！ // 如果 origPackage 不为 null，创建新的需要重命名为源包的名字！ pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false); if (pkgSetting == null) &#123; throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, \"Creating application package \" + pkg.packageName + \" failed\"); &#125; //【×】对于系统 package，如果 origPackage 不为 null，改名为源包的名字！ if (pkgSetting.origPackage != null) &#123; pkg.setPackageName(origPackage.name); String msg = \"New package \" + pkgSetting.realName + \" renamed to replace old package \" + pkgSetting.name; reportSettingsProblem(Log.WARN, msg); if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; // 如果没有设置 SCAN_CHECK_ONLY，记录本次改名！ mTransferedPackages.add(origPackage.name); &#125; // 清空 originPackage 属性！ pkgSetting.origPackage = null; &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; realName != null) &#123; mTransferedPackages.add(pkg.packageName); &#125; //【×】如果当前的系统 apk 被覆盖更新过，就添加 ApplicationInfo.FLAG_UPDATED_SYSTEM_APP 标签！ if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; updateSharedLibrariesLPw(pkg, null); &#125; if (mFoundPolicyFile) &#123; // 给当前的 Package 分配一个标签，用于 seLinux！ SELinuxMMAC.assignSeinfoValue(pkg); &#125; pkg.applicationInfo.uid = pkgSetting.appId; pkg.mExtras = pkgSetting; //【×】处理 keySet 更新和签名校验！ if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) &#123; if (checkUpgradeKeySetLP(pkgSetting, pkg)) &#123; // 签名正确，更新本地的签名信息！ pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; else &#123; // 签名异常处理 if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"Package \" + pkg.packageName + \" upgrade keys do not match the \" + \"previously installed version\"); &#125; else &#123; pkgSetting.signatures.mSignatures = pkg.mSignatures; String msg = \"System package \" + pkg.packageName + \" signature changed; retaining data.\"; reportSettingsProblem(Log.WARN, msg); &#125; &#125; &#125; else &#123; // 如果不检查 KetSet 更新的话，就直接校验签名！ try &#123; verifySignaturesLP(pkgSetting, pkg); pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; catch (PackageManagerException e) &#123; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw e; &#125; // 如果签名校验出现问题，这里会先恢复成本次解析的签名！ pkgSetting.signatures.mSignatures = pkg.mSignatures; // 但是如果是 sharedUser 的情况，就会报错！ if (pkgSetting.sharedUser != null) &#123; if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; throw new PackageManagerException( INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, \"Signature mismatch for shared user: \" + pkgSetting.sharedUser); &#125; &#125; String msg = \"System package \" + pkg.packageName + \" signature changed; retaining data.\"; reportSettingsProblem(Log.WARN, msg); &#125; &#125; ... ... ... ... // 同样的，只有系统 apk 才能进入该分支，用于权限继承！ if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; pkg.mAdoptPermissions != null) &#123; for (int i = pkg.mAdoptPermissions.size() - 1; i &gt;= 0; i--) &#123; final String origName = pkg.mAdoptPermissions.get(i); final PackageSetting orig = mSettings.peekPackageLPr(origName); if (orig != null) &#123; if (verifyPackageUpdateLPr(orig, pkg)) &#123; Slog.i(TAG, \"Adopting permissions from \" + origName + \" to \" + pkg.packageName); mSettings.transferPermissionsLPw(origName, pkg.packageName); &#125; &#125; &#125; &#125; &#125; ... ... ... // 如果是系统 package，设置 isOrphaned 的属性为 true！ if (isSystemApp(pkg)) &#123; pkgSetting.isOrphaned = true; &#125; ... ... ... Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, \"updateSettings\"); // 记录 trace 事件！ boolean createIdmapFailed = false; synchronized (mPackages) &#123; if (pkgSetting.pkg != null) &#123; // Note that |user| might be null during the initial boot scan. If a codePath // for an app has changed during a boot scan, it's due to an app update that's // part of the system partition and marker changes must be applied to all users. maybeRenameForeignDexMarkers(pkgSetting.pkg, pkg, (user != null) ? user : UserHandle.ALL); &#125; //【important】将新创建或者更新后的 PackageSetting 重新添加到 mSettings 中！ mSettings.insertPackageSettingLPw(pkgSetting, pkg); //【important】将本次扫描的 Package 添加到 PMS.mPackages 中去！ mPackages.put(pkg.applicationInfo.packageName, pkg); // 将当前的 package 从 mSettings.mPackagesToBeCleaned 中移除，防止数据清除！ final Iterator&lt;PackageCleanItem&gt; iter = mSettings.mPackagesToBeCleaned.iterator(); while (iter.hasNext()) &#123; PackageCleanItem item = iter.next(); if (pkgName.equals(item.packageName)) &#123; iter.remove(); &#125; &#125; // 处理 package 的第一次安装时间和最近更新时间！ if (currentTime != 0) &#123; if (pkgSetting.firstInstallTime == 0) &#123; pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime; &#125; else if ((scanFlags&amp;SCAN_UPDATE_TIME) != 0) &#123; pkgSetting.lastUpdateTime = currentTime; &#125; &#125; else if (pkgSetting.firstInstallTime == 0) &#123; pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime; &#125; else if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM_DIR) != 0) &#123; if (scanFileTime != pkgSetting.timeStamp) &#123; pkgSetting.lastUpdateTime = scanFileTime; &#125; &#125; ksms.addScannedPackageLPw(pkg); // 将 package 的 KeySets 添加到 KeySetManagerService 中！ // 处理四大组件！ //【1】处理该 Package 中 的 Provider 信息，添加到 PMS.mProviders 中！ int N = pkg.providers.size(); StringBuilder r = null; int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid); mProviders.addProvider(p); // 添加到 PMS.mProviders 中！ p.syncable = p.info.isSyncable; if (p.info.authority != null) &#123; ... ... ... ... &#125; if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Providers: \" + r); &#125; //【2】处理该 Package 中的 Service 信息，添加到 PMS.mService 中！ N = pkg.services.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Service s = pkg.services.get(i); s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid); mServices.addService(s); // 添加到 PMS.mServices 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(s.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Services: \" + r); &#125; //【3】处理该 Package 中的 BroadcastReceiver 信息,添加到 PMS.mReceivers 中。 N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); mReceivers.addActivity(a, \"receiver\"); // 添加到 PMS.mReceivers 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Receivers: \" + r); &#125; //【4】处理该 Package 中的 activity 信息，添加到 PMS.mActivities 中！ N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); mActivities.addActivity(a, \"activity\"); // 添加到 PMS.mActivities 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Activities: \" + r); &#125; //【5】处理该 Package 中的 PermissionGroups 信息，添加到 PMS.mPermissionGroups 中！ N = pkg.permissionGroups.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i); PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name); final String curPackageName = cur == null ? null : cur.info.packageName; //【5.1】如果 isPackageUpdate 为 true，说明要更新权限组的信息！ // 如果 cur 为 null，说明是新添加的权限组信息！ final boolean isPackageUpdate = pg.info.packageName.equals(curPackageName); if (cur == null || isPackageUpdate) &#123; mPermissionGroups.put(pg.info.name, pg); // 添加到 PMS.mPermissionGroups 中！ if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; if (isPackageUpdate) &#123; r.append(\"UPD:\"); &#125; r.append(pg.info.name); &#125; &#125; else &#123; Slog.w(TAG, \"Permission group \" + pg.info.name + \" from package \" + pg.info.packageName + \" ignored: original from \" + cur.info.packageName); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(\"DUP:\"); r.append(pg.info.name); &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Permission Groups: \" + r); &#125; //【6】处理该 Package 中的定义 Permission 和 Permission-tree 信息！ N = pkg.permissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Permission p = pkg.permissions.get(i); // 默认取消掉 PermissionInfo.FLAG_INSTALLED 标志位！ p.info.flags &amp;= ~PermissionInfo.FLAG_INSTALLED; //【6.1】设置权限所属的 group，前提是只有 Android5.1 以后才支持 Permission Groups！ if (pkg.applicationInfo.targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123; p.group = mPermissionGroups.get(p.info.group); if (p.info.group != null &amp;&amp; p.group == null) &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" in an unknown group \" + p.info.group); &#125; &#125; //【6.2】从 Settings 中获得权限管理集合，如果该权限是一个 Permission-tree， // 那就返回 mSettings.mPermissionTrees；否则，返回 mSettings.mPermissions！ ArrayMap&lt;String, BasePermission&gt; permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions; //【6.3】尝试获得上次安装时该权限对应的 BasePermission 对象！ BasePermission bp = permissionMap.get(p.info.name); //【6.4】允许系统应用来重新定义非系统权限！ // 如果上次安装时的 BasePermission 不为 null，但是当前解析的 package 不是上次安装时该权限的定义者！ if (bp != null &amp;&amp; !Objects.equals(bp.sourcePackage, p.info.packageName)) &#123; //【6.4.1】判断上一次安装时，定义该权限的 package 是否是系统应用！ // 如果是 currentOwnerIsSystem 为 true！ final boolean currentOwnerIsSystem = (bp.perm != null &amp;&amp; isSystemApp(bp.perm.owner)); // 如果当前解析的定义了该权限的 package 是系统 app，那么进入这里！ if (isSystemApp(p.owner)) &#123; // 如果上次安装时，该权限是一个 BasePermission.TYPE_BUILTIN 系统权限，且 bp.perm 为 null， // 即：拥有者未知，那么这里我们将这个 system package 分配给这个权限！ if (bp.type == BasePermission.TYPE_BUILTIN &amp;&amp; bp.perm == null) &#123; bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; &#125; else if (!currentOwnerIsSystem) &#123; // 如果上一次安装时，定义该权限的 package 不是系统应用，而定义相同权限的 // 本次解析的 package 是系统应用，那么该权限会被系统应用重新定义！ String msg = \"New decl \" + p.owner + \" of permission \" + p.info.name + \" is system; overriding \" + bp.sourcePackage; reportSettingsProblem(Log.WARN, msg); // 设置 bp 为 null！ bp = null; &#125; &#125; &#125; // 因为 bp 为 null，所谓我们会使用系统应用重新定义权限，如果是 permission-tree，会被添加到 // mSettings.mPermissionTrees 中！ if (bp == null) &#123; bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL); permissionMap.put(p.info.name, bp); &#125; // 重新分配拥有者为该系统应用！ if (bp.perm == null) &#123; if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) &#123; BasePermission tree = findPermissionTreeLP(p.info.name); if (tree == null || tree.sourcePackage.equals(p.info.packageName)) &#123; bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(p.info.name); &#125; &#125; else &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" ignored: base tree \" + tree.name + \" is from package \" + tree.sourcePackage); &#125; &#125; else &#123; Slog.w(TAG, \"Permission \" + p.info.name + \" from package \" + p.info.packageName + \" ignored: original from \" + bp.sourcePackage); &#125; &#125; else if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(\"DUP:\"); r.append(p.info.name); &#125; // 设置 protectionLevel！ if (bp.perm == p) &#123; bp.protectionLevel = p.info.protectionLevel; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Permissions: \" + r); &#125; N = pkg.instrumentation.size(); r = null; for (i=0; i&lt;N; i++) &#123; ... ... ... ...// 这里省略掉，暂时不看！ &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Instrumentation: \" + r); &#125; // 处理该 Package 中的 protectedBroadcasts 信息！ if (pkg.protectedBroadcasts != null) &#123; N = pkg.protectedBroadcasts.size(); for (i=0; i&lt;N; i++) &#123; mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i)); &#125; &#125; pkgSetting.setTimeStamp(scanFileTime); // Create idmap files for pairs of (packages, overlay packages). // Note: \"android\", ie framework-res.apk, is handled by native layers. if (pkg.mOverlayTarget != null) &#123; // This is an overlay package. if (pkg.mOverlayTarget != null &amp;&amp; !pkg.mOverlayTarget.equals(\"android\")) &#123; if (!mOverlays.containsKey(pkg.mOverlayTarget)) &#123; mOverlays.put(pkg.mOverlayTarget, new ArrayMap&lt;String, PackageParser.Package&gt;()); &#125; ArrayMap&lt;String, PackageParser.Package&gt; map = mOverlays.get(pkg.mOverlayTarget); map.put(pkg.packageName, pkg); PackageParser.Package orig = mPackages.get(pkg.mOverlayTarget); if (orig != null &amp;&amp; !createIdmapForPackagePairLI(orig, pkg)) &#123; createIdmapFailed = true; &#125; &#125; &#125; else if (mOverlays.containsKey(pkg.packageName) &amp;&amp; !pkg.packageName.equals(\"android\")) &#123; // This is a regular package, with one or more known overlay packages. createIdmapsForPackageLI(pkg); &#125; &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); if (createIdmapFailed) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, \"scanPackageLI failed to createIdmap\"); &#125; return pkg;&#125; 这里会将解析到的 Packages 和 PackageSetting 添加到对应的集合中！ 1234//【important】将新创建或者更新后的 PackageSetting 重新添加到 mSettings 中！mSettings.insertPackageSettingLPw(pkgSetting, pkg);//【important】将本次扫描的 Package 添加到 PMS.mPackages 中去！mPackages.put(pkg.applicationInfo.packageName, pkg); 8 更新权限信息在 PMS 的扫描最后阶段 PMS_SCAN_END，会更新权限信息： 123456789101112// 如果从我们上次启动，SDK 平台被改变了，我们需要重新授予应用程序权限。// 这里会有一些安全问题，就是可能会有应用通过这种方式获取那些用户没有显式允许的权限// 这里可能后续 google 会改善！int updateFlags = UPDATE_PERMISSIONS_ALL;if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, \"Platform changed from \" + ver.sdkVersion + \" to \" + mSdkVersion + \"; regranting permissions for internal storage\"); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;&#125;//【1】更新系统中的权限和权限树，移除无效的权限和权限树，同时更新应用的权限授予情况！updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags); 这里的最重要的方法是 updatePermissionsLPw 方法： 8.1 PMS.updatePermissionsLPwString changingPkg 表示指定的权限发生变化的 package name，可以为 null; PackageParser.Package pkgInfo 表示该 package 的解析信息！ 这里的 replaceVolumeUuid 传入的是 StorageManager.UUID_PRIVATE_INTERNAL！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private void updatePermissionsLPw(String changingPkg, PackageParser.Package pkgInfo, String replaceVolumeUuid, int flags) &#123; //【1】确保系统中没有失效的权限树； Iterator&lt;BasePermission&gt; it = mSettings.mPermissionTrees.values().iterator(); while (it.hasNext()) &#123; final BasePermission bp = it.next(); if (bp.packageSetting == null) &#123; // 如果 packageSetting 为 null，尝试查找定义的 package！ bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage); &#125; //【1.1】如果找不到定义该权限树的 package，那就移除该 permission-tree！ if (bp.packageSetting == null) &#123; Slog.w(TAG, \"Removing dangling permission tree: \" + bp.name + \" from package \" + bp.sourcePackage); it.remove(); &#125; else if (changingPkg != null &amp;&amp; changingPkg.equals(bp.sourcePackage)) &#123; // 根据参数，不进入这里，但是我们来分析下这部分代码的意思 // 如果权限的定义者不在定义这个权限了，那就移除该权限的上一次信息！ if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) &#123; Slog.i(TAG, \"Removing old permission tree: \" + bp.name + \" from package \" + bp.sourcePackage); flags |= UPDATE_PERMISSIONS_ALL; it.remove(); &#125; &#125; &#125; //【2】确保系统中所有的动态权限都已经分配给对应的 package，同时系统中也没有失效的权限! it = mSettings.mPermissions.values().iterator(); while (it.hasNext()) &#123; final BasePermission bp = it.next(); //【2.1】如果是动态权限，尝试找到其所属的 permission-tree，并绑定到定义了 tree 的 package 上！ if (bp.type == BasePermission.TYPE_DYNAMIC) &#123; if (DEBUG_SETTINGS) Log.v(TAG, \"Dynamic permission: name=\" + bp.name + \" pkg=\" + bp.sourcePackage + \" info=\" + bp.pendingInfo); if (bp.packageSetting == null &amp;&amp; bp.pendingInfo != null) &#123; final BasePermission tree = findPermissionTreeLP(bp.name); if (tree != null &amp;&amp; tree.perm != null) &#123; bp.packageSetting = tree.packageSetting; bp.perm = new PackageParser.Permission(tree.perm.owner, new PermissionInfo(bp.pendingInfo)); bp.perm.info.packageName = tree.perm.info.packageName; bp.perm.info.name = bp.name; bp.uid = tree.uid; &#125; &#125; &#125; //【2.2】如果权限的定义者为 null，尝试在系统中找到定义者！ if (bp.packageSetting == null) &#123; bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage); &#125; //【2.3】如果依然找不到定义该权限的 package，那就移除该 permission ！ if (bp.packageSetting == null) &#123; // 该权限无效，移除它！ Slog.w(TAG, \"Removing dangling permission: \" + bp.name + \" from package \" + bp.sourcePackage); it.remove(); &#125; else if (changingPkg != null &amp;&amp; changingPkg.equals(bp.sourcePackage)) &#123; // 根据参数，不进入这里，但是我们来分析下这部分代码的意思 // 如果权限的定义者不在定义这个权限了，那就移除该权限的上一次信息！ if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) &#123; Slog.i(TAG, \"Removing old permission: \" + bp.name + \" from package \" + bp.sourcePackage); flags |= UPDATE_PERMISSIONS_ALL; it.remove(); &#125; &#125; &#125; //【3】如果 flags 设置了 UPDATE_PERMISSIONS_ALL 标志位，那么就更新除了 changingPkg 以外的其他 // 所有的 package 的权限授予信息 ，特别是替换系统包的授予权限！ if ((flags &amp; UPDATE_PERMISSIONS_ALL) != 0) &#123; for (PackageParser.Package pkg : mPackages.values()) &#123; if (pkg != pkgInfo) &#123; final String volumeUuid = getVolumeUuidForPackage(pkg); final boolean replace = ((flags &amp; UPDATE_PERMISSIONS_REPLACE_ALL) != 0) &amp;&amp; Objects.equals(replaceVolumeUuid, volumeUuid); //【3.1】重新授予权限！ grantPermissionsLPw(pkg, replace, changingPkg); &#125; &#125; &#125; //【4】因为这里 pkgInfo 为 null，所以不进入这里！ // 这里的逻辑是，如果 changingPkg 不为 null，最后也会更新其权限的授予信息！ if (pkgInfo != null) &#123; // Only replace for packages on requested volume final String volumeUuid = getVolumeUuidForPackage(pkgInfo); final boolean replace = ((flags &amp; UPDATE_PERMISSIONS_REPLACE_PKG) != 0) &amp;&amp; Objects.equals(replaceVolumeUuid, volumeUuid); grantPermissionsLPw(pkgInfo, replace, changingPkg); &#125;&#125; 这里就分析到这里！ 9 持久化权限相关信息核心方法是在 Settings.writeLPr 中： 1Settings.writeLPr 下面我们来看下： 9.1 Settings.writeLPr将解析到的安装数据写回到 packages.xml 等文件中！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void writeLPr() &#123; Debug.startMethodTracing(\"/data/system/packageprof\", 8 * 1024 * 1024); //【1】下面会先将最新的数据写入到 packages-backup.xml 文件中！ if (mSettingsFilename.exists()) &#123; if (!mBackupSettingsFilename.exists()) &#123; if (!mSettingsFilename.renameTo(mBackupSettingsFilename)) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to backup package manager settings, \" + \" current changes will be lost at reboot\"); return; &#125; &#125; else &#123; mSettingsFilename.delete(); Slog.w(PackageManagerService.TAG, \"Preserving older settings backup\"); &#125; &#125; mPastSignatures.clear(); try &#123; FileOutputStream fstr = new FileOutputStream(mSettingsFilename); BufferedOutputStream str = new BufferedOutputStream(fstr); //XmlSerializer serializer = XmlUtils.serializerInstance(); XmlSerializer serializer = new FastXmlSerializer(); serializer.setOutput(str, StandardCharsets.UTF_8.name()); serializer.startDocument(null, true); serializer.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); serializer.startTag(null, \"packages\"); //【2】写入 \"packages\"！ ... ... ... ... serializer.startTag(null, \"permission-trees\"); //【3】写入 \"permission-trees\" for (BasePermission bp : mPermissionTrees.values()) &#123; writePermissionLPr(serializer, bp); &#125; serializer.endTag(null, \"permission-trees\"); serializer.startTag(null, \"permissions\"); //【4】写入 \"permissions\" for (BasePermission bp : mPermissions.values()) &#123; writePermissionLPr(serializer, bp); &#125; serializer.endTag(null, \"permissions\"); for (final PackageSetting pkg : mPackages.values()) &#123; //【5】写入 \"package\" writePackageLPr(serializer, pkg); &#125; for (final PackageSetting pkg : mDisabledSysPackages.values()) &#123; //【6】写入 \"updated-package\" writeDisabledSysPackageLPr(serializer, pkg); &#125; for (final SharedUserSetting usr : mSharedUsers.values()) &#123; //【7】写入 \"shared-user\" serializer.startTag(null, \"shared-user\"); serializer.attribute(null, ATTR_NAME, usr.name); serializer.attribute(null, \"userId\", Integer.toString(usr.userId)); usr.signatures.writeXml(serializer, \"sigs\", mPastSignatures); // 写入 shared-user 的安装时权限！ writePermissionsLPr(serializer, usr.getPermissionsState() .getInstallPermissionStates()); serializer.endTag(null, \"shared-user\"); &#125; ... ... ... serializer.endTag(null, \"packages\"); // 结束 packages-backup.xml 文件的写入！ ... ... ... ... writePackageListLPr(); // 写入 packageslist 文件！ writeAllUsersPackageRestrictionsLPr(); // 写入偏好设置信息； writeAllRuntimePermissionsLPr(); //【8】写入运行时权限授予信息！ return; &#125; catch(XmlPullParserException e) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to write package manager settings, \" + \"current changes will be lost at reboot\", e); &#125; catch(java.io.IOException e) &#123; Slog.wtf(PackageManagerService.TAG, \"Unable to write package manager settings, \" + \"current changes will be lost at reboot\", e); &#125; // Clean up partially written files if (mSettingsFilename.exists()) &#123; if (!mSettingsFilename.delete()) &#123; Slog.wtf(PackageManagerService.TAG, \"Failed to clean up mangled file: \" + mSettingsFilename); &#125; &#125;&#125; 这里我们可以看到，整个的写入顺序！ 10 默认运行时权限授予在开机的最后阶段，PMS 会通过 DefaultPermissionGrantPolicy.grantDefaultPermissions 方法来默认授予一些系统应用运行所必须的系统权限 12345678for (int userId : grantPermissionsUserIds) &#123; mDefaultPermissionPolicy.grantDefaultPermissions(userId);&#125;// 如果没有默认授予运行时权限给指定的 userId，那么我们会直接读取 default-permissions 目录中的文件// 初始化 mGrantExceptions，和上面的过程类似，不关注！if (grantPermissionsUserIds == EMPTY_INT_ARRAY) &#123; mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Permission权限管理","slug":"AndroidFramework源码分析/Permission权限管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Permission权限管理/"}],"tags":[{"name":"Permission权限管理","slug":"Permission权限管理","permalink":"https://coolqi.top/tags/Permission权限管理/"}]},{"title":"Permission第 1 篇 - Permission 配置和解析","slug":"Permission1-permissionSettingsAndParse","date":"2017-05-09T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/05/09/Permission1-permissionSettingsAndParse/","link":"","permalink":"https://coolqi.top/2017/05/09/Permission1-permissionSettingsAndParse/","excerpt":"","text":"[toc] 0 综述基于 Android 7.1.1，分析权限管理相关知识，下面关于 xml 配置的内容来自于 Android developer 文档，在加上我自身的理解！ 1 Application 的权限配置和解析1.1 权限配置1.1.1 manifest 配置和 Application 权限相关配置相关的内容主要有 2 部分： 一个是在 &lt;manifest&gt;&lt;/manifest&gt; 中定义的和权限相关的配置； 一个是在 &lt;application&gt;&lt;/application&gt; 中定义的和权限相关的配置； 123456789101112131415161718192021&lt;uses-permission android:name=\"string\" android:maxSdkVersion=\"integer\" /&gt;&lt;permission android:description=\"string resource\" android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permissionFlags=\"[costsMoney | removed | installed ]\" android:permissionGroup=\"string\" android:protectionLevel=\"[normal | dangerous | signature | ...]\" /&gt;&lt;permission-tree android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" /&gt; &lt;permission-group android:description=\"string resource\" android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:parsePermissionGroup=\"string\" android:priority=\"string\" /&gt; 下面我们来解释一下，每个标签的意思： uses-permission 用来申请应用要使用的权限，包括安装时权限和运行时权限！ 属性名 解释 android:name 表示申请的权限名，可以是应用自身通过 &lt;permission&gt; 元素定义的权限、另一个应用定义的权限，或者一个标准系统权限！ android:maxSdkVersion 不常用，表示应用需要申请该权限的最高 API 级别，高于这个值就无需申请权限！ permission 声明一个权限，可用于限制对此应用程序或其他应用程序的特定组件或功能的访问。 属性名 解释 android:description 用于显示给用户的权限描述，解释权限 android:icon 表示权限的图标 android:label 权限的可视化名称，用于显示给用户 android:name 权限的名称，用于在代码中引用该权限，例如， &lt;uses-permission&gt; 元素，应用组件的 android:permission 属性 android:permissionFlags 权限的额外标志位 android:permissionGroup 权限所属权限组的名称，必须是此应用程序或其他应用程序中的 &lt;permission-group&gt; 元素声明的组名 。如果未设置此属性，则权限不属于组 android:protectionLevel 权限保护级别，每个保护级别由基本权限类型和零个或多个标志组成。例如，”dangerous”保护级别没有标志。相反，保护级别 “signature\\ privileged” 是”signature”基本权限类型和 “privileged”标志的组合。 以上就是和 permission 相关的配置！ permission-group 为相关权限的逻辑分组声明一个名称。权限通过其 android:permissionGroup 属性加入权限组。权限组的所有权限会在用户界面中一起呈现。 其本身并未声明权限，只是申明了一个可以放置权限的类别。 属性名 解释 android:description 用于显示给用户的组描述 android:icon 表示权限组的图标 android:label 权限组的可视化名称，用于显示给用户 android:name 组的名称，用于在代码中引用该权限组，例如， &lt;permission&gt; 的 android:android:permissionGroup 属性 继续来看： permission-tree 权限树和权限组很类似，该标签用于声明权限树的基本名称，定义了权限树的应用程序拥有权限树名称的所有权，可以调用 PackageManager.addPermission() 向树中动态添加权限！ 此元素本身并未声明权限，只是定义了可以动态放置权限的名称空间。 属性名 解释 android:icon 表示树中所有权限的图标； android:label 用户可读的组名称； android:name 权限树的名称，为树中所有权限名称的前缀，用于在代码中引用该权限组，该名称的路径中必须包含至少两个以句点分隔的段 1.1.2 application 配置123&lt;application android:permission=\"\" &gt;&lt;/application&gt; android:permission permission 属性表示访问该 application 应该具有的权限！ 1.2 权限解析下面，我们深入到 PMS 中，看下 Application 权限信息是如何解析的，这部分从两方面来看： manifest 的属性配置解析； application 的属性配置解析； 1.2.1 PackageParser.parseBaseApkCommon我们先来看看 manifest 的属性配置解析！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155private Package parseBaseApkCommon(Package pkg, Set&lt;String&gt; acceptedTags, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; ... ... ... ... int outerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (acceptedTags != null &amp;&amp; !acceptedTags.contains(tagName)) &#123; Slog.w(TAG, \"Skipping unsupported element under &lt;manifest&gt;: \" + tagName + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; if (tagName.equals(TAG_APPLICATION)) &#123; //【1】解析 application 标签属性！ if (foundApp) &#123; if (RIGID_PARSER) &#123; outError[0] = \"&lt;manifest&gt; has more than one &lt;application&gt;\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; else &#123; Slog.w(TAG, \"&lt;manifest&gt; has more than one &lt;application&gt;\"); XmlUtils.skipCurrentTag(parser); continue; &#125; &#125; foundApp = true; //【*1.2.2】调用 parseBaseApplication 解析 application 属性！ if (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123; return null; &#125; &#125; else if ( ... ... ... &#125; else if (tagName.equals(TAG_PERMISSION_GROUP)) &#123; //【*1.2.1.1】解析 permission-group 标签属性 if (parsePermissionGroup(pkg, flags, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_PERMISSION)) &#123; //【*1.2.1.2】解析 permission 标签属性 if (parsePermission(pkg, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_PERMISSION_TREE)) &#123; //【*1.2.1.3】解析 permission-tree 标签属性 if (parsePermissionTree(pkg, res, parser, outError) == null) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_USES_PERMISSION)) &#123; //【*1.2.1.4】解析 uses-permission 标签属性 if (!parseUsesPermission(pkg, res, parser)) &#123; return null; &#125; &#125; else if (tagName.equals(TAG_USES_PERMISSION_SDK_M) || tagName.equals(TAG_USES_PERMISSION_SDK_23)) &#123; //【*1.2.1.4】解析 uses-permission-sdk-m/23 标签属性 if (!parseUsesPermission(pkg, res, parser)) &#123; return null; &#125; &#125; else if ( ... ... ... ... &#125; else if (tagName.equals(TAG_ADOPT_PERMISSIONS)) &#123; //【2】解析 adopt-permissions 标签 sa = res.obtainAttributes(parser, // 解析源包属性 com.android.internal.R.styleable.AndroidManifestOriginalPackage); String name = sa.getNonConfigurationString( // 解析权限名属性 com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); sa.recycle(); if (name != null) &#123; //【2.1】加入到 Package.mAdoptPermissions 集合中！ if (pkg.mAdoptPermissions == null) &#123; pkg.mAdoptPermissions = new ArrayList&lt;String&gt;(); &#125; pkg.mAdoptPermissions.add(name); &#125; XmlUtils.skipCurrentTag(parser); &#125; else if ( ... ... ... ... &#125; &#125; ... ... ... ... //【3】处理一些新添加的权限，如果当前应用的 targetSdkVersion 小于这些权限的 sdkVersion！ // 我们会默认将其添加到 Package.requestedPermissions 中！ final int NP = PackageParser.NEW_PERMISSIONS.length; StringBuilder implicitPerms = null; for (int ip = 0; ip &lt; NP; ip++) &#123; final PackageParser.NewPermissionInfo npi = PackageParser.NEW_PERMISSIONS[ip]; //【3.1】如果应用的 target SDK Version 高于权限的该权限的 version，不做处理 if (pkg.applicationInfo.targetSdkVersion &gt;= npi.sdkVersion) &#123; break; &#125; if (!pkg.requestedPermissions.contains(npi.name)) &#123; if (implicitPerms == null) &#123; implicitPerms = new StringBuilder(128); implicitPerms.append(pkg.packageName); implicitPerms.append(\": compat added \"); &#125; else &#123; implicitPerms.append(' '); &#125; implicitPerms.append(npi.name); pkg.requestedPermissions.add(npi.name); &#125; &#125; if (implicitPerms != null) &#123; Slog.i(TAG, implicitPerms.toString()); &#125; //【4】处理一些相互依赖的权限，这里除了有 sdkVersion 限制之外， // 还有一个判断 rootPerm 是否在 requestedPermissions 列表中的判断 ！ final int NS = PackageParser.SPLIT_PERMISSIONS.length; for (int is = 0; is &lt; NS; is++) &#123; final PackageParser.SplitPermissionInfo spi = PackageParser.SPLIT_PERMISSIONS[is]; //【4.1】如果应用的 target SDK Version 高于权限的该权限的 version，不做处理， // 或者应用没有请求这个根权限，不用处理！ if (pkg.applicationInfo.targetSdkVersion &gt;= spi.targetSdk || !pkg.requestedPermissions.contains(spi.rootPerm)) &#123; continue; &#125; for (int in=0; in &lt; spi.newPerms.length; in++) &#123; final String perm = spi.newPerms[in]; if (!pkg.requestedPermissions.contains(perm)) &#123; pkg.requestedPermissions.add(perm); &#125; &#125; &#125; ... ... ... return pkg;&#125; 最后，处理了下在指定版本中出现的新权限的添加！ 1234567public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] = new PackageParser.NewPermissionInfo[] &#123; new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE, android.os.Build.VERSION_CODES.DONUT, 0), new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE, android.os.Build.VERSION_CODES.DONUT, 0)&#125;; Build.VERSION_CODES.DONUT 的值为 4，表示 Android 1.6，意思是如果是 Android 1.6 之前话，应用如果没有申请 NEW_PERMISSIONS 的权限，那么我们会默认给他申请，因为我们关注的是 Android 7.1.1 那么这里我们不会进入！ 对于 SPLIT_PERMISSIONS 列表中的权限，保存了 root 权限和相互依赖的权限，以及首次出现的平台！ 举个例子，如果应用只是申请了 WRITE_EXTERNAL_STORAGE，即使其在 Manifest 中没有申明 READ_EXTERNAL_STORAGE 权限，我们也会将其主动加入到 Package.requestedPermissions！！123456789101112public static final PackageParser.SplitPermissionInfo SPLIT_PERMISSIONS[] = new PackageParser.SplitPermissionInfo[] &#123; new PackageParser.SplitPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE, new String[] &#123; android.Manifest.permission.READ_EXTERNAL_STORAGE &#125;, android.os.Build.VERSION_CODES.CUR_DEVELOPMENT+1), new PackageParser.SplitPermissionInfo(android.Manifest.permission.READ_CONTACTS, new String[] &#123; android.Manifest.permission.READ_CALL_LOG &#125;, android.os.Build.VERSION_CODES.JELLY_BEAN), new PackageParser.SplitPermissionInfo(android.Manifest.permission.WRITE_CONTACTS, new String[] &#123; android.Manifest.permission.WRITE_CALL_LOG &#125;, android.os.Build.VERSION_CODES.JELLY_BEAN)&#125;; Build.VERSION_CODES.JELLY_BEAN 的值为 16，表示 Android 4.1； Build.VERSION_CODES.CUR_DEVELOPMENT 值为 10000，表示开发者版本！ 这段代码的意思是：如果是 Android 4.1 之前，且应用申请了 SPLIT_PERMISSIONS 中指定的根权限，那么我们也会将其对应的子权限添加到其申请列表中，因为我们关注的是 Android 7.1.1 那么这里我们不会进入！ 1.2.1.1 PackageP.parsePermissionGroupparsePermissionGroup 用于处理 permission-group 的解析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private PermissionGroup parsePermissionGroup(Package owner, int flags, Resources res, XmlResourceParser parser, String[] outError) throws XmlPullParserException, IOException &#123; //【1】创建 PermissionGroup 对象！ PermissionGroup perm = new PermissionGroup(owner); TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPermissionGroup); if (!parsePackageItemInfo(owner, perm.info, outError, \"&lt;permission-group&gt;\", sa, true /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestPermissionGroup_name, com.android.internal.R.styleable.AndroidManifestPermissionGroup_label, com.android.internal.R.styleable.AndroidManifestPermissionGroup_icon, com.android.internal.R.styleable.AndroidManifestPermissionGroup_roundIcon, com.android.internal.R.styleable.AndroidManifestPermissionGroup_logo, com.android.internal.R.styleable.AndroidManifestPermissionGroup_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; perm.info.descriptionRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestPermissionGroup_description, 0); //【2】解析 permissionGroupFlags 属性； perm.info.flags = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermissionGroup_permissionGroupFlags, 0); //【3】解析 priority 属性； perm.info.priority = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermissionGroup_priority, 0); //【4】只有系统应用才能设置权限组的优先级 if (perm.info.priority &gt; 0 &amp;&amp; (flags &amp; PARSE_IS_SYSTEM) == 0) &#123; perm.info.priority = 0; &#125; sa.recycle(); if (!parseAllMetaData(res, parser, \"&lt;permission-group&gt;\", perm, outError)) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; owner.permissionGroups.add(perm); return perm;&#125; 只有系统应用才能设置权限组的优先级！ 创建了 PermissionGroup 对象！123456789101112131415161718192021222324public final static class PermissionGroup extends Component&lt;IntentInfo&gt; &#123; public final PermissionGroupInfo info; public PermissionGroup(Package _owner) &#123; super(_owner); info = new PermissionGroupInfo(); &#125; public PermissionGroup(Package _owner, PermissionGroupInfo _info) &#123; super(_owner); info = _info; &#125; public void setPackageName(String packageName) &#123; super.setPackageName(packageName); info.packageName = packageName; &#125; public String toString() &#123; return \"PermissionGroup&#123;\" + Integer.toHexString(System.identityHashCode(this)) + \" \" + info.name + \"&#125;\"; &#125;&#125; 最终的解析结果会保存到 Package.permissionGroups 中！ 1.2.1.2 PackageP.parsePermissionparsePermission 用于处理 permission 的解析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Permission parsePermission(Package owner, Resources res, XmlResourceParser parser, String[] outError) throws XmlPullParserException, IOException &#123; //【1】创建一个 Permission 对象，封装 permission-tree Permission perm = new Permission(owner); TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPermission); if (!parsePackageItemInfo(owner, perm.info, outError, \"&lt;permission&gt;\", sa, true /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestPermission_name, com.android.internal.R.styleable.AndroidManifestPermission_label, com.android.internal.R.styleable.AndroidManifestPermission_icon, com.android.internal.R.styleable.AndroidManifestPermission_roundIcon, com.android.internal.R.styleable.AndroidManifestPermission_logo, com.android.internal.R.styleable.AndroidManifestPermission_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; //【2】解析权限所属的组信息！ perm.info.group = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestPermission_permissionGroup); if (perm.info.group != null) &#123; perm.info.group = perm.info.group.intern(); &#125; perm.info.descriptionRes = sa.getResourceId( com.android.internal.R.styleable.AndroidManifestPermission_description, 0); //【3】解析权限的保护级别，默认为 normal！ perm.info.protectionLevel = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermission_protectionLevel, PermissionInfo.PROTECTION_NORMAL); //【4】解析权限的 flags，默认为 0！ perm.info.flags = sa.getInt( com.android.internal.R.styleable.AndroidManifestPermission_permissionFlags, 0); sa.recycle(); if (perm.info.protectionLevel == -1) &#123; outError[0] = \"&lt;permission&gt; does not specify protectionLevel\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; //【5】将 signatureOrSystem 转为 signature|privileged perm.info.protectionLevel = PermissionInfo.fixProtectionLevel(perm.info.protectionLevel); //【6】这里是检查保护级别的有效性！ // 如果 protectionLevel 设置了额外的标志位，那么其基本权限类型必须是 signature！！ if ((perm.info.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_FLAGS) != 0) &#123; if ((perm.info.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE) != PermissionInfo.PROTECTION_SIGNATURE) &#123; outError[0] = \"&lt;permission&gt; protectionLevel specifies a flag but is \" + \"not based on signature type\"; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; &#125; if (!parseAllMetaData(res, parser, \"&lt;permission&gt;\", perm, outError)) &#123; // 解析 meta-data 属性！ mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; owner.permissions.add(perm); return perm;&#125; 这里会涉及到 2 个标志位：12345// 用于获取基本权限类型public static final int PROTECTION_MASK_BASE = 0xf;// 用于获取额外的标志位public static final int PROTECTION_MASK_FLAGS = 0xff0; 我们可以通过如下方式获得基本权限类型和附加标志位：12protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE // 获取基本权限类型；protectionLevel &amp; PermissionInfo.PROTECTION_MASK_FLAGS // 获取额外的标志位； fixProtectionLevel 的意义就是将 signatureOrSystem 转为 signature|privileged 而已！1234567/** @hide */public static int fixProtectionLevel(int level) &#123; if (level == PROTECTION_SIGNATURE_OR_SYSTEM) &#123; level = PROTECTION_SIGNATURE | PROTECTION_FLAG_PRIVILEGED; &#125; return level;&#125; 如果 protectionLevel 设置了额外的标志位，那么其基本权限类型必须是 signature！！ 解析的结果会封装到一个 Permission 对象中！1234567891011121314151617181920212223242526public final static class Permission extends Component&lt;IntentInfo&gt; &#123; public final PermissionInfo info; // 用于保存该权限的信息！ public boolean tree; // 是否是权限树，是权限则为 false； public PermissionGroup group; public Permission(Package _owner) &#123; super(_owner); info = new PermissionInfo(); &#125; public Permission(Package _owner, PermissionInfo _info) &#123; super(_owner); info = _info; &#125; public void setPackageName(String packageName) &#123; super.setPackageName(packageName); info.packageName = packageName; &#125; public String toString() &#123; return \"Permission&#123;\" + Integer.toHexString(System.identityHashCode(this)) + \" \" + info.name + \"&#125;\"; &#125;&#125; 最终的解析结果会保存到 Package.permissions 中！ 1.2.1.3 PackageP.parsePermissionTreeparsePermissionTree 用于处理 permission-tree 的解析：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Permission parsePermissionTree(Package owner, Resources res, XmlResourceParser parser, String[] outError) throws XmlPullParserException, IOException &#123; //【1】创建一个 Permission 对象，封装 permission-tree Permission perm = new Permission(owner); TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPermissionTree); if (!parsePackageItemInfo(owner, perm.info, outError, \"&lt;permission-tree&gt;\", sa, true /*nameRequired*/, com.android.internal.R.styleable.AndroidManifestPermissionTree_name, com.android.internal.R.styleable.AndroidManifestPermissionTree_label, com.android.internal.R.styleable.AndroidManifestPermissionTree_icon, com.android.internal.R.styleable.AndroidManifestPermissionTree_roundIcon, com.android.internal.R.styleable.AndroidManifestPermissionTree_logo, com.android.internal.R.styleable.AndroidManifestPermissionTree_banner)) &#123; sa.recycle(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; sa.recycle(); //【2】校验权限树的名称合法性，必须是至少由两个 “.” 分割开的段！ int index = perm.info.name.indexOf('.'); if (index &gt; 0) &#123; index = perm.info.name.indexOf('.', index+1); &#125; if (index &lt; 0) &#123; outError[0] = \"&lt;permission-tree&gt; name has less than three segments: \" + perm.info.name; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; perm.info.descriptionRes = 0; perm.info.protectionLevel = PermissionInfo.PROTECTION_NORMAL; // 默认为 nomal perm.tree = true; // 设置 perm.tree，表示其为权限树！ if (!parseAllMetaData(res, parser, \"&lt;permission-tree&gt;\", perm, outError)) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; &#125; owner.permissions.add(perm); return perm;&#125; 我们看到，对于权限树，也是会创建一个 Permission 对象！ 最终的解析结果会保存到 Package.permissions 中！ 1.2.1.4 PackageP.parseUsesPermissionparseUsesPermission 用于处理 uses-permission 的解析： 123456789101112131415161718192021222324252627282930313233343536private boolean parseUsesPermission(Package pkg, Resources res, XmlResourceParser parser) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestUsesPermission); String name = sa.getNonResourceString( // 解析 name 属性； com.android.internal.R.styleable.AndroidManifestUsesPermission_name); int maxSdkVersion = 0; TypedValue val = sa.peekValue( // 解析 maxSdkVersion 属性； com.android.internal.R.styleable.AndroidManifestUsesPermission_maxSdkVersion); if (val != null) &#123; if (val.type &gt;= TypedValue.TYPE_FIRST_INT &amp;&amp; val.type &lt;= TypedValue.TYPE_LAST_INT) &#123; maxSdkVersion = val.data; &#125; &#125; sa.recycle(); if ((maxSdkVersion == 0) || (maxSdkVersion &gt;= Build.VERSION.RESOURCES_SDK_INT)) &#123; if (name != null) &#123; int index = pkg.requestedPermissions.indexOf(name); if (index == -1) &#123; // 将该 package pkg.requestedPermissions.add(name.intern()); &#125; else &#123; Slog.w(TAG, \"Ignoring duplicate uses-permissions/uses-permissions-sdk-m: \" + name + \" in package: \" + pkg.packageName + \" at: \" + parser.getPositionDescription()); &#125; &#125; &#125; XmlUtils.skipCurrentTag(parser); return true;&#125; 最终的解析结果会保存到 Package.requestedPermissions 中！ 1.2.2 PackageParser.parseBaseApplication我们先来看看 application 的属性配置解析！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private boolean parseBaseApplication(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; //【1.1】获得 package 的 ApplicationInfo 成员变量，封装 Application 标签的信息 final ApplicationInfo ai = owner.applicationInfo; final String pkgName = owner.applicationInfo.packageName; ... ... ... //【1.2】解析 android:permission 属性 String str; str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestApplication_permission, 0); ai.permission = (str != null &amp;&amp; str.length() &gt; 0) ? str.intern() : null; ... ... ... while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"activity\")) &#123; //【2】解析 activity 属性 Activity a = parseActivity(owner, res, parser, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); &#125; else if (tagName.equals(\"receiver\")) &#123; //【3】解析 receiver 属性 Activity a = parseActivity(owner, res, parser, flags, outError, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.receivers.add(a); &#125; else if (tagName.equals(\"service\")) &#123; //【4】解析 service 属性 Service s = parseService(owner, res, parser, flags, outError); if (s == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.services.add(s); &#125; else if (tagName.equals(\"provider\")) &#123; //【5】解析 provider 属性 Provider p = parseProvider(owner, res, parser, flags, outError); if (p == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.providers.add(p); &#125; else if ( ... ... ... &#125; &#125; modifySharedLibrariesForBackwardCompatibility(owner); if (hasDomainURLs(owner)) &#123; owner.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_HAS_DOMAIN_URLS; &#125; else &#123; owner.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_HAS_DOMAIN_URLS; &#125; return true;&#125; 最后，解析的 android:permission 属性会保存到 Provider.ApplicationInfo.permission 中去！ 2 Activity 的权限配置和解析2.1 权限配置在 Activity 中有如下的权限相关配置： 12android:exported=[&quot;true&quot; | &quot;false&quot;]android:permission=&quot;string&quot; exported 属性 exported 属性决定了该 activity 是否暴露给其他应用！ permission 属性 permission 属性表示启动该 activity 应该具有的权限 2.2 权限解析2.2.1 PackageParser.parseActivityActivity 使用是 parseActivity 方法解析，对于 Activity，boolean receiver 取值为 false： 123456789101112131415161718192021222324252627282930313233343536373839private Activity parseActivity(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError, boolean receiver, boolean hardwareAccelerated) throws XmlPullParserException, IOException &#123; ... ... ... //【1】创建了一个 Activity 对象，表示 Receiver 组件，创建了 ActivityInfo 对象，封装 Receiver 信息！ Activity a = new Activity(mParseActivityArgs, new ActivityInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; //【2】解析 android:exported 属性！ boolean setExported = sa.hasValue(R.styleable.AndroidManifestActivity_exported); if (setExported) &#123; a.info.exported = sa.getBoolean(R.styleable.AndroidManifestActivity_exported, false); &#125; ... ... ... //【3】解析 android:permission 属性！ String str; str = sa.getNonConfigurationString(R.styleable.AndroidManifestActivity_permission, 0); if (str == null) &#123; a.info.permission = owner.applicationInfo.permission; &#125; else &#123; a.info.permission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; ... ... ... if (!setExported) &#123; //【4】如果没有显式设置 android:exported，取决于是否设置了意图过滤器； s.info.exported = s.intents.size() &gt; 0; &#125; return a;&#125; 属性解析： android:exported 属性的值会保存到 Activity.ActivityInfo.exported 中； android:permission 会保存到 Activity.ActivityInfo.permission 中； android:permission 使用的权限必须在 permission 标签中定义才可以使用！ 3 Service 的权限配置和解析3.1 权限配置12345&lt;service android:exported=[\"true\" | \"false\"] android:permission=\"string\" &gt; . . .&lt;/service&gt; android:exported 其他应用程序的组件是否可以调用服务或与其进行交互，为 true 表示可以，为 false 表示不可以。 当值为 false 时，只有具有相同 uid 的应用程序或该应用程序的组件才能启动服务或绑定到该服务。 默认值取决于服务是否包含意图过滤器，如果包含，则为 true；否则为 false； android:permission 启动服务或绑定服务所必须具有的权限； 如果未设置此属性，则由该 application 元素 permission 属性设置的权限将 应用于该服务。如果两个属性均未设置，则该服务不受权限保护。 3.2 权限解析3.2.1 PackageParser.parseServiceService 使用是 parseService 方法解析: 123456789101112131415161718192021222324252627282930313233343536373839private Service parseService(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestService); ... ... ... //【1】创建 Service 对象，代表 Service 组件，创建 ServiceInfo 对象，封装 Service 的信息！ Service s = new Service(mParseServiceArgs, new ServiceInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; //【2】解析 android:exported 属性； boolean setExported = sa.hasValue( com.android.internal.R.styleable.AndroidManifestService_exported); if (setExported) &#123; s.info.exported = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestService_exported, false); &#125; //【3】解析 android:permission 属性； String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestService_permission, 0); if (str == null) &#123; s.info.permission = owner.applicationInfo.permission; &#125; else &#123; s.info.permission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; ... ... ... ... if (!setExported) &#123; //【4】如果没有显式设置 android:exported，取决于是否设置了意图过滤器； s.info.exported = s.intents.size() &gt; 0; &#125; return s;&#125; 4 Receiver 的权限配置和解析4.1 权限配置12345&lt;receiver android:exported=[\"true\" | \"false\"] android:permission=\"string\" &gt; . . .&lt;/receiver&gt; android:exported 广播接收器是否可以接收来自其应用程序之外的消息的消息 ，为 true 表示可以，为 false 表示不可以。 当值为 false 时，则广播接收器可以接收的唯一消息是由具有相同 uid 的应用程序或该应用程序自身的组件发送的消息。 默认值取决于广播接收者是否包含意图过滤器，如果包含，则为 true；否则为 false； android:permission 向该广播接收者发送消息必须具有的权限； 如果未设置此属性，则该 application 元素 permission 属性设置的权限将 应用于广播接收器。如果两个属性均未设置，则接收方不受权限保护。 4.2 权限解析我们回到 PMS 中去，看下应用程序的 Receiver 组件是如何被解析的，我们重点关注和权限相关的： 4.2.1 PackageParser.parseActivityReceiver 和 Activity 使用是同一个方法，对于 Receiver，boolean receiver 取值为 true； 123456789101112131415161718192021222324252627282930313233343536373839private Activity parseActivity(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError, boolean receiver, boolean hardwareAccelerated) throws XmlPullParserException, IOException &#123; ... ... ... //【1】创建了一个 Activity 对象，表示 Receiver 组件，创建了 ActivityInfo 对象，封装 Receiver 信息！ Activity a = new Activity(mParseActivityArgs, new ActivityInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; //【2】解析 android:exported 属性！ boolean setExported = sa.hasValue(R.styleable.AndroidManifestActivity_exported); if (setExported) &#123; a.info.exported = sa.getBoolean(R.styleable.AndroidManifestActivity_exported, false); &#125; ... ... ... //【3】解析 android:permission 属性！ String str; str = sa.getNonConfigurationString(R.styleable.AndroidManifestActivity_permission, 0); if (str == null) &#123; a.info.permission = owner.applicationInfo.permission; &#125; else &#123; a.info.permission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; ... ... ... if (!setExported) &#123; //【4】如果没有显式设置 android:exported，取决于是否设置了意图过滤器； s.info.exported = s.intents.size() &gt; 0; &#125; return a;&#125; 属性解析： android:exported 属性的值会保存到 Activity.ActivityInfo.exported 中； android:permission 会保存到 Activity.ActivityInfo.permission 中； 5 Provider 的权限配置和解析5.1 权限配置123456&lt;provider android:exported=[\"true\" | \"false\"] android:grantUriPermissions=[\"true\" | \"false\"] android:permission=\"string\" android:readPermission=\"string\" android:writePermission=\"string\" &gt;&lt;/provider&gt; 和 provider 相关的权限配置比较多，我们来分别看下： 5.1.1 android:exportedprovider 是否被其他应用程序使用： 如果为 true， provider 可被其他应用程序使用。任何应用程序都可以使用提供程序的内容 URI 来访问它，但必须持有 provider 指定的权限。 如果为 false，provider 不能被其他应用程序使用，只有具有与提供者相同的 uid 的应用程序或者自身才有权访问它。 因为此属性是在 API 级别 17 中引入的，在 API 17 及以后，默认为 false！ 5.1.2 android:permission应用程序读取或者写入 provider 必须要有的权限，readPermission和 writePermission 设置的权限优先级更高！ 如果 readPermission 属性也被设置，则它控制查询权限。如果 writePermission 属性被设置，它将控制访问权限。 5.1.3 android:readPermission应用程序读取 provider 数据必须要有的权限。 5.1.4 android:writePermission应用程序向 provider 写入数据必须要有的权限。 5.1.5 android:grantUriPermissions用于临时授予应用程序访问该 provider 的全部 uri 的权限！ 该属性默认为 false，通过该属性，那些没有被授予 permission/readPermission/writePermission 指定的权限的应用可以临时访问 provider！ 如果为 true，那么应用有权限临时访问该 provider 的所有数据； 如果为 false，那么应用将不会被授予临时权限，除非 provider 还设置 grant-uri-permission，那应用程序将有权限访问 grant-uri-permission 指定的特定数据子集！ 通过这种方式，可以让应用程序组件能够一次性地临时访问受权限保护的数据！ eg：当电子邮件包含附件时，邮件应用程序可能会调用适当的查看器来打开它，即使查看器没有一般的权限来查看所有内容提供者的数据。 可以通过设置 Intent.FLAG_GRANT_READ_URI_PERMISSION 和 Intent.FLAG_GRANT_WRITE_URI_PERMISSION 标志来授予对指定 Uri 的一次性的访问权限 。 eg：邮件应用程序会将 FLAG_GRANT_READ_URI_PERMISSION 标志位传递给 Context.startActivity() 的 Intent，被启动的 actitivity 会获得上面的标志位和 Uri，从而具有对 uri 的读权限！ 5.1.6 provider 子标签12345678910&lt;path-permission android:path=\"string\" android:pathPrefix=\"string\" android:pathPattern=\"string\" android:permission=\"string\" android:readPermission=\"string\" android:writePermission=\"string\" /&gt;&lt;grant-uri-permission android:path=\"string\" android:pathPrefix=\"string\" android:pathPattern=\"string\"/&gt; grant-uri-permission 和 path-permission 均为 provider 的子标签！ 5.1.6.1 grant-uri-permission用于临时授予应用程序访问 provider 中指定 uri 的权限！ 如果 provider 的 android:grantUriPermissions 属性为 true，那么应用程序可以临时访问该 provider 的所有 Uri 数据； 如果 android:grantUriPermissions 属性为 false，那么应用程序只能临时访问通过 grant-uri-permission 标签指定的特定 uri 子集！ 一个 provider 可以定义多个 grant-uri-permission，每一个 grant-uri-permission 申明一个特定 uri 数据子集！ 属性名 解释 android:path provider 的数据子集的完整 uri 路径 android:pathPrefix provider 数据子集的 uri 路径的初始部分 android:pathPattern provider 数据子集的完整 uri 路径，但可以使用通配符 如果设置了 android:path，临时访问权限只能被授予给 path 指定的数据子集； 如果设置了 android:pathPrefix，临时访问权限将会被授予给具有 pathPrefix 初始部分的所有数据子集； 5.1.6.2 path-permission定义 provider 中特定数据子集的路径和所需权限，用于开放部分 Uri 数据的读写权限！ 一个 provider 可以定义多个 path-permission，每一个 path-permission 申明一个特定 uri 数据子集！ 属性名 解释 android:path provider 数据子集的完整 uri 路径 android:pathPrefix provider 数据子集的 uri 路径的初始部分 android:pathPattern provider 数据子集的完整 uri 路径，但可以使用通配符 android:permission 读写权限，readPermission 和 writePermission 优先级 android:readPermission 读数据的权限 android:writePermission 写数据的权限 如果设置了 android:path，临时访问权限只能被授予给 path 指定的数据子集； 如果设置了 android:pathPrefix，临时访问权限将会被授予给具有 pathPrefix 初始部分的所有数据子集； 5.2 权限解析我们回到 PMS 中去，看下应用程序的 Provider 组件是如何被解析的，我们重点关注和权限相关的： 5.2.1 PackageParser.parseProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private Provider parseProvider(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestProvider); ... ... ... //【1】创建一个 Provider 对象和 ProviderInfo 对象！ Provider p = new Provider(mParseProviderArgs, new ProviderInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; boolean providerExportedDefault = false; if (owner.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; providerExportedDefault = true; &#125; //【2】解析 android:exported 属性！ p.info.exported = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_exported, providerExportedDefault); ... ... ... //【3】解析 android:permission 属性！ String permission = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_permission, 0); //【4】解析 android:readPermission 属性！ String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_readPermission, 0); if (str == null) &#123; str = permission; &#125; if (str == null) &#123; p.info.readPermission = owner.applicationInfo.permission; &#125; else &#123; p.info.readPermission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; //【5】解析 android:writePermission 属性！ str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestProvider_writePermission, 0); if (str == null) &#123; str = permission; &#125; if (str == null) &#123; p.info.writePermission = owner.applicationInfo.permission; &#125; else &#123; p.info.writePermission = str.length() &gt; 0 ? str.toString().intern() : null; &#125; //【6】解析 android:grantUriPermissions 属性！ p.info.grantUriPermissions = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestProvider_grantUriPermissions, false); ... ... ... //【*5.2.2】调用 parseProviderTags 来解析子标签！ if (!parseProviderTags(res, parser, p, outError)) &#123; return null; &#125; return p;&#125; 这里我们看到： 在 API 17 以前，exported 默认是 true，因为这个属性是在 API 17 才引入的！ readPermission 和 writePermission 的优先级高于 permission，如果没有定义 属性的处理： android:grantUriPermissions 属性的值会保存到 Provider.ProviderInfo.grantUriPermissions 中； android:exported 属性的值会保存到 Provider.ProviderInfo.exported 中； android:permission 属性和 android:readPermission 属性会保存到 Provider.ProviderInfo.readPermission 中； android:permission 属性和 android:writePermission 属性会保存到 Provider.ProviderInfo.writePermission 中； 5.2.2 PackageParser.parseProviderTags在 parseProviderTags 中会对 grant-uri-permission 和 path-permission 进行解析！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190private boolean parseProviderTags(Resources res, XmlResourceParser parser, Provider outInfo, String[] outError) throws XmlPullParserException, IOException &#123; int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; if (parser.getName().equals(\"intent-filter\")) &#123; ProviderIntentInfo intent = new ProviderIntentInfo(outInfo); if (!parseIntent(res, parser, true, false, intent, outError)) &#123; return false; &#125; outInfo.intents.add(intent); &#125; else if (parser.getName().equals(\"meta-data\")) &#123; if ((outInfo.metaData=parseMetaData(res, parser, outInfo.metaData, outError)) == null) &#123; return false; &#125; //【1】解析 grant-uri-permission &#125; else if (parser.getName().equals(\"grant-uri-permission\")) &#123; // 获得其所有属性！ TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestGrantUriPermission); //【1.1】这里创建了一个 PatternMatcher 对象，用于封装 grant-uri-permission 的解析内容； PatternMatcher pa = null; //【1.2】pathPattern 优先级最高，接下来是 pathPrefix，最后是 pathPattern，优先级高会覆盖优先级低： String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path, 0); // path 属性 if (str != null) &#123; pa = new PatternMatcher(str, PatternMatcher.PATTERN_LITERAL); &#125; str = sa.getNonConfigurationString( // pathPrefix 属性 com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix, 0); if (str != null) &#123; pa = new PatternMatcher(str, PatternMatcher.PATTERN_PREFIX); &#125; str = sa.getNonConfigurationString( // pathPattern 属性 com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern, 0); if (str != null) &#123; pa = new PatternMatcher(str, PatternMatcher.PATTERN_SIMPLE_GLOB); &#125; sa.recycle(); if (pa != null) &#123; //【1.3】如果 provider 设置了以上三个属性（至少是一个）， // 这里可以看出 provider 是支持多个 grant-uri-permission 的！ if (outInfo.info.uriPermissionPatterns == null) &#123; outInfo.info.uriPermissionPatterns = new PatternMatcher[1]; outInfo.info.uriPermissionPatterns[0] = pa; &#125; else &#123; final int N = outInfo.info.uriPermissionPatterns.length; PatternMatcher[] newp = new PatternMatcher[N+1]; System.arraycopy(outInfo.info.uriPermissionPatterns, 0, newp, 0, N); newp[N] = pa; outInfo.info.uriPermissionPatterns = newp; &#125; //【1.4】由于 provider 设置了 grant-uri-permission，也将 info.grantUriPermissions 置为 true； outInfo.info.grantUriPermissions = true; &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Unknown element under &lt;path-permission&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; outError[0] = \"No path, pathPrefix, or pathPattern for &lt;path-permission&gt;\"; return false; &#125; &#125; XmlUtils.skipCurrentTag(parser); //【2】解析 path-permission &#125; else if (parser.getName().equals(\"path-permission\")) &#123; //【2.1】获得其所有属性！ TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestPathPermission); //【2.2】这里创建了一个 PathPermission 对象，用于封装 path-permission 的解析内容； PathPermission pa = null; //【2.3】解析 readPermission 和 writePermission！ String permission = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestPathPermission_permission, 0); String readPermission = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission, 0); if (readPermission == null) &#123; readPermission = permission; &#125; String writePermission = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission, 0); if (writePermission == null) &#123; writePermission = permission; &#125; boolean havePerm = false; if (readPermission != null) &#123; readPermission = readPermission.intern(); havePerm = true; &#125; if (writePermission != null) &#123; writePermission = writePermission.intern(); havePerm = true; &#125; if (!havePerm) &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"No readPermission or writePermssion for &lt;path-permission&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; outError[0] = \"No readPermission or writePermssion for &lt;path-permission&gt;\"; return false; &#125; &#125; //【2.4】pathPattern 优先级最高，接下来是 pathPrefix，最后是 pathPattern，优先级高覆盖优先级低！ String path = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestPathPermission_path, 0); if (path != null) &#123; pa = new PathPermission(path, PatternMatcher.PATTERN_LITERAL, readPermission, writePermission); &#125; path = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix, 0); if (path != null) &#123; pa = new PathPermission(path, PatternMatcher.PATTERN_PREFIX, readPermission, writePermission); &#125; path = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern, 0); if (path != null) &#123; pa = new PathPermission(path, PatternMatcher.PATTERN_SIMPLE_GLOB, readPermission, writePermission); &#125; sa.recycle(); if (pa != null) &#123; //【2.5】如果 provider 设置了以上三个属性（至少是一个）， // 这里可以看出 provider 是支持多个 path-permission 的！ if (outInfo.info.pathPermissions == null) &#123; outInfo.info.pathPermissions = new PathPermission[1]; outInfo.info.pathPermissions[0] = pa; &#125; else &#123; final int N = outInfo.info.pathPermissions.length; PathPermission[] newp = new PathPermission[N+1]; System.arraycopy(outInfo.info.pathPermissions, 0, newp, 0, N); newp[N] = pa; outInfo.info.pathPermissions = newp; &#125; &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"No path, pathPrefix, or pathPattern for &lt;path-permission&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; outError[0] = \"No path, pathPrefix, or pathPattern for &lt;path-permission&gt;\"; return false; &#125; XmlUtils.skipCurrentTag(parser); &#125; else &#123; if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Unknown element under &lt;provider&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; &#125; else &#123; outError[0] = \"Bad element under &lt;provider&gt;: \" + parser.getName(); return false; &#125; &#125; &#125; return true;&#125; 5.2.2.1 解析 grant-uri-permission我们可以看到，三个属性中 pathPattern 优先级最高，接下来是 pathPrefix，最后是 pathPattern，优先级高的会覆盖优先级低的属性： 123456789101112131415161718//【1】path 属性；String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path, 0);if (str != null) &#123; pa = new PatternMatcher(str, PatternMatcher.PATTERN_LITERAL);&#125;//【2】pathPrefix 属性；str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix, 0);if (str != null) &#123; pa = new PatternMatcher(str, PatternMatcher.PATTERN_PREFIX);&#125;//【3】pathPattern 属性；str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern, 0);if (str != null) &#123; pa = new PatternMatcher(str, PatternMatcher.PATTERN_SIMPLE_GLOB);&#125; 最后会创建一个 PatternMatcher 对象！ 123456789public PatternMatcher(String pattern, int type) &#123; mPattern = pattern; mType = type; if (mType == PATTERN_ADVANCED_GLOB) &#123; mParsedPattern = parseAndVerifyAdvancedPattern(pattern); &#125; else &#123; mParsedPattern = null; &#125;&#125; 如果 provider 设置了 grant-uri-permission，也会将前面的 p.info.grantUriPermissions 置为 true，即使应用没有显式设置 android:grantUriPermissions 的值； 解析得到的 PatternMatcher 会保存到 Provider.ProviderInfo.uriPermissionPatterns 数组中； 5.2.2.2 解析 patch-permission同样的，三个属性中 pathPattern 优先级最高，接下来是 pathPrefix，最后是 pathPattern，优先级高的会覆盖优先级低的属性！ 最后会创建一个 PathPermission 对象，PathPermission 是 PatternMatcher 的子类！123456789public class PathPermission extends PatternMatcher &#123; public PathPermission(String pattern, int type, String readPermission, String writePermission) &#123; super(pattern, type); mReadPermission = readPermission; mWritePermission = writePermission; &#125;&#125; 所以，大家应该明白 String pattern, int type 是如何处理的了！ 解析得到的 PathPermission 会保存到 Provider.ProviderInfo.pathPermissions 数组中； 6 权限知识点总结我们知道，权限的 protectionLevel 分为基本权限类型和附加的标志位： 6.1 基本权限类型下表显示了所有基本权限类型： 基本权限类型 取值 解释 normal 0 默认值，这种权限是风险较低的权限，安装时，系统会自动授予这种类型的权限给请求应用程序。 dangerous 1 这种权限是风险较高的权限，因此系统可能不会自动将其授予请求的应用程序，而是需要应用显式的申请。 signature 2 仅当请求权限的应用程序使用与声明权限的应用程序相同的证书签名时，系统才会授予该权限。如果签名匹配，系统会自动授予权限，而不需要通知用户或要求用户明确批准；如果签名不匹配，一些 signature 权限需要用户显式申请。 signatureOrSystem 3 该权限只会授予和声明权限的应用程序相同的证书签名的应用或者系统分区应用，避免使用此选项，因为 signature 保护级别应该足以满足大多数需求，并且可以工作，而不管应用程序的安装位置。在 API 级别 23 中已弃用，现在用 “signature\\ privileged” 替代； “ signatureOrSystem” 许可用于某些特定情况，其中多个供应商将应用程序内置到系统映像中，并且需要明确地共享特定功能，因为它们正在构建在一起。 小小的思考： normal 类型的权限，无论是系统应用还是三方应用都会默认授予； dangerous 类型的权限，无论是系统应用还是三方应用都需要显式申请，但是系统会有一个类会给某些系统应用默认授予这些权限； 那么 signature 类型的权限的意义就很显然了，对于系统定义的 signature 权限，系统应用会默认授予；而对于三方应用，一些 signature 权限其无法申请，而另外一些 signature 权限，三方应用可以通过一定的方式申请，这些权限是一些特殊的权限！ 6.2 附加标志位对于 signature 类型的权限，可以配合下面的特殊的附加标志位： 附加标志位 取值 解释 appop 40 该权限与用于控制访问的 app op 密切相关，也就是我们说的 AppOpsManager。 development 20 此权限也可以授予（可选）给开发应用程序。 installer 100 此权限可以自动授予安装软件包的系统应用程序，就是我们的 PackageInstaller instant 1000 此权限可被授予给即时应用程序（instant app） oem 4000 pre23 80 此权限会自动授予低于 M（在引入运行时权限之前）的 API 级别的应用程序。 preinstalled 400 此权限可以自动授予 system 分区预先安装的任何应用程序（不仅仅是特权应用程序）。 privileged 10 此权限也可以授予安装在 system 分区的特权应用。请避免使用此标志位，因为 signature 保护级别已足以满足大多数需求，并且无论应用程序的安装位置如何，都能正常工作。 此权限标志用于某些特殊情况，其中多个供应商将应用程序内置到系统映像中，需要明确地共享特定功能。 runtime 2000 此权限只能被授予适用于运行时权限（M 及以上）的应用程序 setup 800 此权限可以被自动授予给开机向导应用程序（setup wizard app） system 10 在 API 级别 23 中已弃用，用 privileged 替代 textClassifier 10000 此权限可以被自动授予给系统默认的文本解析器 vendorPrivileged 8000 此权限可以被授予给供应商（vendor）分区中的特权应用程序。 verifier 200 此权限可以被自动授予给验证软件包的系统应用程序。 注：如果保护级别设置了额外的标志位，那么其基本权限类型必须是 signature！ 6.3 权限组任何权限都可以属于某个权限组，所有的 dangerous 权限都有所属的组，但是，权限组只有在申请的权限是 dangerous 权限是才会对用户体验有影响！ 在 Android 6.0 （API level 23）以及以上，如果应用的 targetSdkVersion &gt;= 23 ，系统是这样处理运行时权限的申请的： 如果应用程序没有被授予权限组中的任何运行时权限，在申请权限时，系统会向用户显示描述应用程序要访问的权限组的权限请求对话框。 但是该对话框不会描述该组中的特定权限的信息。如果用户同意授予权限，该权限将被授予。 如果应用程序已经被授予同一权限组中的某个权限，则对于其他权限，系统会立即授予权限，而不与用户进行任何交互。 例如：如果应用程序先前已请求并已获得READ_CONTACTS权限，然后它请求WRITE_CONTACTS，则系统会立即授予该权限，而不向用户显示权限对话框。 在 Android 5.1 （API level 22）以及以下，或者应用的 targetSdkVersion &lt;= 22： 系统会在应用安装的时候授予所有的运行时权限；同时，也是只会告诉用户应用程序需要哪些权限组，而不是单个权限。 6.4 特殊权限6.4.1 signature with appopsignature 权限中有几个权限特殊，signature 权限本身是安装时权限，但是当其设置了 appop 标志位的时候，其可以通过 appOps 动态管理。 Android7.1.1 提供了如下 signature appop 权限： 123456789101112&lt;permission android:name=\"android.permission.WRITE_SETTINGS\" android:label=\"@string/permlab_writeSettings\" android:description=\"@string/permdesc_writeSettings\" android:protectionLevel=\"signature|preinstalled|appop|pre23\" /&gt;&lt;permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" android:label=\"@string/permlab_systemAlertWindow\" android:description=\"@string/permdesc_systemAlertWindow\" android:protectionLevel=\"signature|preinstalled|appop|pre23|development\" /&gt;&lt;permission android:name=\"android.permission.PACKAGE_USAGE_STATS\" android:protectionLevel=\"signature|privileged|development|appop\" /&gt; 这三个权限，可以通过 AppOps 的方式来授予那些签名不匹配的应用！ 6.4.1 signature with bind servicesignature 内部还有一些权限的使用方式也很特殊，应用需要配置这个权限，但是应用自身并不是权限的申请方：12345678910111213141516171819202122BIND_ACCESSIBILITY_SERVICEBIND_AUTOFILL_SERVICEBIND_CARRIER_SERVICESBIND_CHOOSER_TARGET_SERVICEBIND_CONDITION_PROVIDER_SERVICEBIND_DEVICE_ADMINBIND_DREAM_SERVICEBIND_INCALL_SERVICEBIND_INPUT_METHODBIND_MIDI_DEVICE_SERVICEBIND_NFC_SERVICEBIND_NOTIFICATION_LISTENER_SERVICEBIND_PRINT_SERVICEBIND_SCREENING_SERVICEBIND_TELECOM_CONNECTION_SERVICEBIND_TEXT_SERVICEBIND_TV_INPUTBIND_VISUAL_VOICEMAIL_SERVICEBIND_VOICE_INTERACTIONBIND_VPN_SERVICEBIND_VR_LISTENER_SERVICEBIND_WALLPAPER 这些权限的使用后面会单独写一篇博文记录下！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Permission权限管理","slug":"AndroidFramework源码分析/Permission权限管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Permission权限管理/"}],"tags":[{"name":"Permission权限管理","slug":"Permission权限管理","permalink":"https://coolqi.top/tags/Permission权限管理/"}]},{"title":"UsageStats 第 3 篇 - UserUsageStatsService 逻辑分析","slug":"UsageStats3-userUsageStatsServiceLogicAnalysis","date":"2017-05-03T12:46:25.000Z","updated":"2018-11-20T16:54:06.000Z","comments":true,"path":"2017/05/03/UsageStats3-userUsageStatsServiceLogicAnalysis/","link":"","permalink":"https://coolqi.top/2017/05/03/UsageStats3-userUsageStatsServiceLogicAnalysis/","excerpt":"","text":"[toc] 基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理！ 0 综述UserUsageStatsService 用于保存每个设备用户下的数据信息！每一个 UserUsageStatsService 内部都会有一个 UsageStatsDatabase 对象用于访问本地持久化文件！ 本文主要分析 UserUsageStatsService 相关的接口，为 UsageStatsService 的分析提供帮助！ 1 new UserUsageStatsService - 创建参数 File usageStatsDir 传入的是 new File(mUsageStatsDir, Integer.toString(userId))。 mUsageStatsDir 就是 /data/system/usagestats，这里我们不考虑多用户，在默认用户下 usageStatsDir 为 /data/system/usagestats/0 12345678910111213UserUsageStatsService(Context context, int userId, File usageStatsDir, StatsUpdatedListener listener) &#123; mContext = context; //【1.1】用于日期的计算； mDailyExpiryDate = new UnixCalendar(0); //【1.2】数据库对象，用于加载和更新持久化文件； mDatabase = new UsageStatsDatabase(usageStatsDir); //【1.3】创建一个 IntervalStats 数组，大小为 4，用于加载每个时间类别的最新数据到内存中！ mCurrentStats = new IntervalStats[UsageStatsManager.INTERVAL_COUNT]; mListener = listener; mLogPrefix = \"User[\" + Integer.toString(userId) + \"] \"; mUserId = userId; // 对应的 userId&#125; 这里的 mListener 就是 UsageStatsService，前面我们知道 UsageStatsService 实现了 UserUsageStatsService.StatsUpdatedListener： 1234567private final StatsUpdatedListener mListener;interface StatsUpdatedListener &#123; void onStatsUpdated(); void onStatsReloaded(); void onNewUpdate(int mUserId);&#125; 这样，当 UserUsageStatsService 中的数据发生更新后，会通过 StatsUpdatedListener 的接口通知 UsageStatsService！ onStatsUpdated：当使用信息被更新后，触发该回调； onStatsReloaded：当使用信息重新加载后，触发该回调； onNewUpdate：当系统发生了升级后，触发该回调； 1.1 new UnixCalendar1234567891011121314151617181920212223242526272829303132333435public class UnixCalendar &#123; public static final long DAY_IN_MILLIS = 24 * 60 * 60 * 1000; public static final long WEEK_IN_MILLIS = 7 * DAY_IN_MILLIS; public static final long MONTH_IN_MILLIS = 30 * DAY_IN_MILLIS; public static final long YEAR_IN_MILLIS = 365 * DAY_IN_MILLIS; private long mTime; public UnixCalendar(long time) &#123; mTime = time; &#125; public void addDays(int val) &#123; mTime += val * DAY_IN_MILLIS; &#125; public void addWeeks(int val) &#123; mTime += val * WEEK_IN_MILLIS; &#125; public void addMonths(int val) &#123; mTime += val * MONTH_IN_MILLIS; &#125; public void addYears(int val) &#123; mTime += val * YEAR_IN_MILLIS; &#125; public void setTimeInMillis(long time) &#123; mTime = time; &#125; public long getTimeInMillis() &#123; return mTime; &#125;&#125; UnixCalendar 用于计算日期的变化，代码很简单，不多说了！ 1.2 new UsageStatsDatabase1234567891011121314public UsageStatsDatabase(File dir) &#123; //【1】创建了一个文件夹数组，对应了本地的四个不同的目录； mIntervalDirs = new File[] &#123; new File(dir, \"daily\"), new File(dir, \"weekly\"), new File(dir, \"monthly\"), new File(dir, \"yearly\"), &#125;; //【2】创建版本信息文件！ mVersionFile = new File(dir, \"version\"); //【3】创建一个 TimeSparseArray，长度为 4，用于对不同目录下的文件根据时间排序！ mSortedStatFiles = new TimeSparseArray[mIntervalDirs.length]; mCal = new UnixCalendar(0);&#125; 在默认用户下，这里的 dir 对应的目录是 /data/system/usagestats/0。 同时创建了一个文件夹数组，其实这里可以知道，数据是按 daily，monthly，weekly，yearly 四个文件夹存储的，而每个文件夹中又包含若干个以一个时间戳为名称的文件！ /data/system/usagestats/0/daily； /data/system/usagestats/0/weekly； /data/system/usagestats/0/monthly； /data/system/usagestats/0/yearly； 同时，又创建了数据库对应的 version 文件： /data/system/usagestats/0/version； 我们来看看 daily，monthly，weekly，yearly 四个文件夹中存储的是什么文件： 12/data/system/usagestats/0/daily ls1526928050937 1527014648681 1527101544569 1527188059056 1527277127932 1527364251915 1527450652825 可以看到，每一个文件的名字都是一个时间戳，这个时间戳的表示的是该文件开始记录的时间节点！ 我们来看下，这些文件内部的数据结构：12345678910111213141516&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;usagestats version=\"1\" endTime=\"62979335\"&gt; &lt;packages&gt; &lt;package lastTimeActive=\"1104580\" package=\"com.github.shadowsocks\" timeActive=\"119959\" lastEvent=\"2\" /&gt; &lt;/packages&gt; &lt;configurations&gt; &lt;config lastTimeActive=\"60709298\" timeActive=\"60690625\" count=\"3\" active=\"true\" fs=\"1065353216\" mcc=\"460\" mnc=\"65535\" locales=\"zh-CN\" touch=\"3\" key=\"1\" keyHid=\"1\" hardKeyHid=\"2\" nav=\"1\" navHid=\"2\" ori=\"1\" scrLay=\"268435810\" clrMod=\"5\" ui=\"17\" width=\"360\" height=\"685\" sw=\"360\" density=\"480\" app_bounds=\"0 0 1080 2136\" /&gt; &lt;/configurations&gt; &lt;event-log&gt; &lt;event time=\"1104580\" package=\"com.github.shadowsocks\" class=\"com.github.shadowsocks.MainActivity\" flags=\"0\" type=\"2\" /&gt; &lt;/event-log&gt;&lt;/usagestats&gt; 可以看到，一个文件主要包含三方面的内容： packages：应用的使用信息； configurations：配置的使用信息； event-log：时间上报的历史记录； 下面，会分析到解析过程！ 1.3 new IntervalStats123456789101112131415161718class IntervalStats &#123; public long beginTime; // 开始记录的时间 public long endTime; // 当前记录的最大时间 public long lastTimeSaved; // 最后一次将数据保存到持久化文件的时间！ // 内存中的 UsageStats 数据！ public final ArrayMap&lt;String, UsageStats&gt; packageStats = new ArrayMap&lt;&gt;(); // 内存中的 ConfigurationStats 数据！ public final ArrayMap&lt;Configuration, ConfigurationStats&gt; configurations = new ArrayMap&lt;&gt;(); public Configuration activeConfiguration; // 内存中的 Event 数据！ public TimeSparseArray&lt;UsageEvents.Event&gt; events; private final ArraySet&lt;String&gt; mStringCache = new ArraySet&lt;&gt;(); // 用于缓存包名！ ... ... ...&#125; IntervalStats 用于将持久化数据缓存到内存中，加快访问效率！ 应用的数据以 UsageStats 的形式保存在 packageStats 中； 配置的数据以 ConfigurationStats 的形式保存在 configurations 中； IntervalStats 内部也提供了一些 get，udpate 等等的方法，我们后面分析的时候再说！ IntervalStats 数组的长度为 4 ，和 UsageStatsDatabase 中的四个文件一一对应，分别用于保存对应文件的缓存数据！ 每一个 IntervalStats 都对应着一个名字为时间戳的文件！ 2 UserUsageStatsService.init - 初始化操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void init(final long currentTimeMillis) &#123; //【×2.1】初始化 UsageStatsDatabase 实例！ mDatabase.init(currentTimeMillis); //【2】加载本地持久化文件，初始化缓存数据：mCurrentStats！ int nullCount = 0; for (int i = 0; i &lt; mCurrentStats.length; i++) &#123; //【×2.2】将持久化文件的数据加载到内存中！ mCurrentStats[i] = mDatabase.getLatestUsageStats(i); if (mCurrentStats[i] == null) &#123; nullCount++; // 统计没有对应数据的类别！ &#125; &#125; if (nullCount &gt; 0) &#123; // 如果 nullCount 大于 0，说明 daily，monthly，weekly，yearly 这四个数据类型，至少有一个没有对应的数据！ if (nullCount != mCurrentStats.length) &#123; // 说明某个类别没有数据！ Slog.w(TAG, mLogPrefix + \"Some stats have no latest available\"); &#125; else &#123; // 第一次启动的情况！ &#125; //【×2.3】加载最新的使用信息！ loadActiveStats(currentTimeMillis); &#125; else &#123; //【×2.4】设置回滚日期！ updateRolloverDeadline(); &#125; // Now close off any events that were open at the time this was saved. //【2】初始化到这里，mCurrentStats 已经保存了每个时间类别下，对应的最新的使用信息！ // 接着，对 package 的 UsageStats.mLastEvent 取值做一个特殊处理！ for (IntervalStats stat : mCurrentStats) &#123; final int pkgCount = stat.packageStats.size(); for (int i = 0; i &lt; pkgCount; i++) &#123; UsageStats pkgStats = stat.packageStats.valueAt(i); //【2.1】如果该 package 的最后一个 event 是 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY // 更新其为 END_OF_DAY！ if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123; //【×2.5】更新所属 IntervalStats 的属性！ stat.update(pkgStats.mPackageName, stat.lastTimeSaved, UsageEvents.Event.END_OF_DAY); //【×2.6】延迟 20mins 通知 UsageStatsService 使用信息发生变化！ // 通知一次！ notifyStatsChanged(); &#125; &#125; //【×2.7】更新配置信息！ stat.updateConfigurationStats(null, stat.lastTimeSaved); &#125; //【×2.8】如果发生了系统升级，isNewUpdate 返回 true！ if (mDatabase.isNewUpdate()) &#123; notifyNewUpdate(); &#125;&#125; 2.1 UsageStatsDatabase.initinit 方法用于初始化 database，我们来看看具体的流程： 12345678910111213141516171819202122232425262728293031323334public void init(long currentTimeMillis) &#123; synchronized (mLock) &#123; //【1】创建 daily，monthly，weekly，yearly 四个文件夹！ for (File f : mIntervalDirs) &#123; f.mkdirs(); if (!f.exists()) &#123; throw new IllegalStateException(\"Failed to create directory \" + f.getAbsolutePath()); &#125; &#125; //【2.1.1】检查 version 变化！ checkVersionAndBuildLocked(); //【2.1.2】加载每个时间类别文件夹中的文件到 mSortedStatFiles 中！ indexFilesLocked(); //【3】删除那些日期在当前时间以后的文件！ for (TimeSparseArray&lt;AtomicFile&gt; files : mSortedStatFiles) &#123; //【3.1】根据当前时间确定删除文件的参考点！ final int startIndex = files.closestIndexOnOrAfter(currentTimeMillis); if (startIndex &lt; 0) &#123; continue; &#125; //【3.2】移除那些日期在当前时间之后的文件！ final int fileCount = files.size(); for (int i = startIndex; i &lt; fileCount; i++) &#123; files.valueAt(i).delete(); &#125; for (int i = startIndex; i &lt; fileCount; i++) &#123; files.removeAt(i); &#125; &#125; &#125;&#125; 方法很简单，不多说了！ 2.1.1 UsageStatsDatabase.checkVersionAndBuildLockedcheckVersionAndBuildLocked 用于检查版本变化！12345678910111213141516171819202122232425262728293031323334353637383940414243private void checkVersionAndBuildLocked() &#123; int version; String buildFingerprint; // 获得当前系统的 Fingerprint！ String currentFingerprint = getBuildFingerprint(); mFirstUpdate = true; mNewUpdate = true; try (BufferedReader reader = new BufferedReader(new FileReader(mVersionFile))) &#123; version = Integer.parseInt(reader.readLine()); //【1】从 /data/system/usagestats/0version 中读取数据库中记录的Fingerprint！ // 如果可以读取掉，说明不是第一次更新，那么 mFirstUpdate 为 false； // 如果当前系统的 Fingerprint 和数据库中的 Fingerprint 一样，说没有发生系统更新，mNewUpdate 为 false； buildFingerprint = reader.readLine(); if (buildFingerprint != null) &#123; mFirstUpdate = false; &#125; if (currentFingerprint.equals(buildFingerprint)) &#123; mNewUpdate = false; &#125; &#125; catch (NumberFormatException | IOException e) &#123; version = 0; &#125; //【2】如果 version 不等于 3，说明存在数据库升级！ if (version != CURRENT_VERSION) &#123; Slog.i(TAG, \"Upgrading from version \" + version + \" to \" + CURRENT_VERSION); //【2.1.1.1】升级数据库，删除旧文件！ doUpgradeLocked(version); &#125; //【3】当 如果 version 不等于 3 或者发生了系统更新，那就需要更新本地文件中的 Fingerprint！ if (version != CURRENT_VERSION || mNewUpdate) &#123; try (BufferedWriter writer = new BufferedWriter(new FileWriter(mVersionFile))) &#123; writer.write(Integer.toString(CURRENT_VERSION)); writer.write(\"\\n\"); writer.write(currentFingerprint); writer.write(\"\\n\"); writer.flush(); &#125; catch (IOException e) &#123; Slog.e(TAG, \"Failed to write new version\"); throw new RuntimeException(e); &#125; &#125;&#125; 这里我们不过多关注！ 1private static final int CURRENT_VERSION = 3; 我们可以看到 UsageStatsDatabase 中定义了 CURRENT_VERSION 值为 3，表示当前版本号！ 2.1.1.1 UsageStatsDatabase.doUpgradeLocked处理数据库升级！1234567891011121314private void doUpgradeLocked(int thisVersion) &#123; if (thisVersion &lt; 2) &#123; // 删除掉 version 小于 2 的数据库！ Slog.i(TAG, \"Deleting all usage stats files\"); for (int i = 0; i &lt; mIntervalDirs.length; i++) &#123; File[] files = mIntervalDirs[i].listFiles(); if (files != null) &#123; for (File f : files) &#123; f.delete(); &#125; &#125; &#125; &#125;&#125; 其实就是删除本地持久化文件！ 2.1.2 UsageStatsDatabase.indexFilesLockedindexFilesLocked 方法用于列出时间类别文件夹中的所有文件，并按照时间升序排序！ 1234567891011121314151617181920212223242526272829303132333435private void indexFilesLocked() &#123; //【1】创建一个文件过滤器，过滤掉那些文件后缀是 .bak 的备份文件！ final FilenameFilter backupFileFilter = new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return !name.endsWith(BAK_SUFFIX); &#125; &#125;; //【2】遍历四个时间类别的文件夹，获得那个类别文件夹下，除去后缀为 .bak 的所有文件， for (int i = 0; i &lt; mSortedStatFiles.length; i++) &#123; if (mSortedStatFiles[i] == null) &#123; mSortedStatFiles[i] = new TimeSparseArray&lt;&gt;(); &#125; else &#123; mSortedStatFiles[i].clear(); &#125; File[] files = mIntervalDirs[i].listFiles(backupFileFilter); if (files != null) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Found \" + files.length + \" stat files for interval \" + i); &#125; for (File f : files) &#123; final AtomicFile af = new AtomicFile(f); try &#123; //【2.1.2.1】调用 UsageStatsXml.parseBeginTime 计算文件的创建时间，然后 // 通过 time —&gt; AtomicFile 映射关系，保存到对应类别的 mSortedStatFiles[i] 中去！ mSortedStatFiles[i].put(UsageStatsXml.parseBeginTime(af), af); &#125; catch (IOException e) &#123; Slog.e(TAG, \"failed to index file: \" + f, e); &#125; &#125; &#125; &#125;&#125; 这里设置到了一个文件后缀：1private static final String BAK_SUFFIX = \".bak\"; UsageStatsDatabase 会自动过滤掉 .bak 结尾的文件，因为 .bak 是备份文件！！ 2.1.2.1 UsageStatsXml.parseBeginTime这里用到了 UsageStatsXml，他是用来专门解析 usage 文件的：123public static long parseBeginTime(AtomicFile file) throws IOException &#123; return parseBeginTime(file.getBaseFile());&#125; 继续调用：1234567891011121314public static long parseBeginTime(File file) throws IOException &#123; String name = file.getName(); //【1】如果文件名以 -c 结尾，返回去掉 -c 剩余的内容： while (name.endsWith(CHECKED_IN_SUFFIX)) &#123; name = name.substring(0, name.length() - CHECKED_IN_SUFFIX.length()); &#125; try &#123; return Long.parseLong(name); &#125; catch (NumberFormatException e) &#123; throw new IOException(e); &#125;&#125; 这里我们可以看到，其实每一个时间类别的文件夹中的所有文件都是以其创建日期来命名的！ 2.2 UsageStatsDatabase.getLatestUsageStats - 获得最新的使用信息返回指定时间类别 intervalType 的最新的使用状态信息！123456789101112131415161718192021222324252627public IntervalStats getLatestUsageStats(int intervalType) &#123; synchronized (mLock) &#123; //【1】校验 intervalType 的取值范围！ if (intervalType &lt; 0 || intervalType &gt;= mIntervalDirs.length) &#123; throw new IllegalArgumentException(\"Bad interval type \" + intervalType); &#125; final int fileCount = mSortedStatFiles[intervalType].size(); if (fileCount == 0) &#123; return null; &#125; try &#123; //【2】因为 mSortedStatFiles[intervalType] 是按照时间顺序排序的，所以最新的状态信息文件 // 一定是 fileCount - 1 对应的 AtomicFile! final AtomicFile f = mSortedStatFiles[intervalType].valueAt(fileCount - 1); IntervalStats stats = new IntervalStats(); //【2.2.1.1】调用 UsageStatsXml.read 从本地文件中读取信息，初始化 IntervalStats 对象！ UsageStatsXml.read(f, stats); return stats; &#125; catch (IOException e) &#123; Slog.e(TAG, \"Failed to read usage stats file\", e); &#125; &#125; return null;&#125; 2.2.1 UsageStatsXml.readread 读取文件！123456789101112131415161718192021222324public static void read(AtomicFile file, IntervalStats statsOut) throws IOException &#123; try &#123; FileInputStream in = file.openRead(); try &#123; //【2.1.2.1】调用 parseBeginTime 方法，初始化 statsOut.beginTime，可以看到 // 文件名的时间戳，就是 statsOut.beginTime 的值！ statsOut.beginTime = parseBeginTime(file); //【2.2.2】调用自身的 read 方法，继续解析； read(in, statsOut); // 获得文件上一次被更新的时间 statsOut.lastTimeSaved statsOut.lastTimeSaved = file.getLastModifiedTime(); &#125; finally &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; // Empty &#125; &#125; &#125; catch (FileNotFoundException e) &#123; Slog.e(TAG, \"UsageStats Xml\", e); throw e; &#125;&#125; 通过这个阶段，我们获得了： 12statsOut.beginTime; // 文件开始记录的时间statsOut.lastTimeSaved; // 文件最新修改的时间 以上两个属性！ 2.2.2 UsageStatsXml.read继续解析：123456789101112131415161718192021222324252627static void read(InputStream in, IntervalStats statsOut) throws IOException &#123; XmlPullParser parser = Xml.newPullParser(); try &#123; parser.setInput(in, \"utf-8\"); XmlUtils.beginDocument(parser, USAGESTATS_TAG); // 解析 usagestats 标签 String versionStr = parser.getAttributeValue(null, VERSION_ATTR); // 解析 version 属性 try &#123; switch (Integer.parseInt(versionStr)) &#123; case 1: //【2.2.3】调用 UsageStatsXmlV1.read 继续解析 // 只有 version 置为 1 时才会继续解析； UsageStatsXmlV1.read(parser, statsOut); break; default: Slog.e(TAG, \"Unrecognized version \" + versionStr); throw new IOException(\"Unrecognized version \" + versionStr); &#125; &#125; catch (NumberFormatException e) &#123; Slog.e(TAG, \"Bad version\"); throw new IOException(e); &#125; &#125; catch (XmlPullParserException e) &#123; Slog.e(TAG, \"Failed to parse Xml\", e); throw new IOException(e); &#125;&#125; 第二个 read 方法更像是 version 校验！ 这里对应的数据是： 12&lt;usagestats version=\"1\" endTime=\"62979335\"&gt;&lt;/usagestats&gt; 2.2.3 UsageStatsXmlV1.read最后，调用了 UsageStatsXmlV1 的 read 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041public static void read(XmlPullParser parser, IntervalStats statsOut) throws XmlPullParserException, IOException &#123; //【1】清空 IntervalStats 的内部的集合！ statsOut.packageStats.clear(); statsOut.configurations.clear(); statsOut.activeConfiguration = null; if (statsOut.events != null) &#123; statsOut.events.clear(); &#125; //【2】计算 statsOut.endTime，等于 statsOut.beginTime 加上 endTime 的值！ statsOut.endTime = statsOut.beginTime + XmlUtils.readLongAttribute(parser, END_TIME_ATTR); int eventCode; int outerDepth = parser.getDepth(); //【3】接下来，根据使用信息的类别，进行不同的处理！ while ((eventCode = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (eventCode != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (eventCode != XmlPullParser.START_TAG) &#123; continue; &#125; final String tag = parser.getName(); switch (tag) &#123; case PACKAGE_TAG: // package 标签 //【2.2.3.1】如果该使用信息是 package 的，调用 loadUsageStats 解析！ loadUsageStats(parser, statsOut); break; case CONFIG_TAG: // config 标签 //【2.2.3.2】如果该使用信息是 config 的，调用 loadConfigStats 解析！ loadConfigStats(parser, statsOut); break; case EVENT_TAG: // event 标签 //【2.2.3.3】如果该使用信息是 event 的，调用 loadEvent 解析！ loadEvent(parser, statsOut); break; &#125; &#125;&#125; 该阶段，我们得到了如下的属性： statsOut.endTime，表示该使用信息文件记录的截至时间点，取值为 statsOut.beginTime + XmlUtils.readLongAttribute(parser, END_TIME_ATTR)； 12&lt;usagestats version=\"1\" endTime=\"62979335\"&gt;&lt;/usagestats&gt; END_TIME_ATTR 对应着属性：endTime 属性，endTime 其实是一个时间间隔，距离 statsOut.beginTime 的时间间隔，statsOut.beginTime 和 statsOut.endTime 的时间段就是该文件能够记录的数据范围！ 接着，解析 package，config 和 event 相关的使用信息！ 2.2.3.1 UsageStatsXmlV1.loadUsageStats - 读取 UsageStats我们来看 package 标签和其属性：123&lt;packages&gt; &lt;package lastTimeActive=\"1104580\" package=\"com.github.shadowsocks\" timeActive=\"119959\" lastEvent=\"2\" /&gt;&lt;/packages&gt; 下面看看 解析 package 的使用信息！ 1234567891011121314151617181920private static void loadUsageStats(XmlPullParser parser, IntervalStats statsOut) throws IOException &#123; final String pkg = parser.getAttributeValue(null, PACKAGE_ATTR); if (pkg == null) &#123; throw new ProtocolException(\"no \" + PACKAGE_ATTR + \" attribute present\"); &#125; //【2.2.3.1.1】根据给定的 package，创建对应的 UsageStats！ final UsageStats stats = statsOut.getOrCreateUsageStats(pkg); //【1】解析 lastTimeActive 属性，表示的是距离 beginTime 的时间间隔， // 初始化 stats.mLastTimeUsed，表示该 package 最后是使用的时间； stats.mLastTimeUsed = statsOut.beginTime + XmlUtils.readLongAttribute( parser, LAST_TIME_ACTIVE_ATTR); //【2】解析 timeActive 属性，获得 package 在前台的总时间，初始化 stats.mTotalTimeInForeground！ stats.mTotalTimeInForeground = XmlUtils.readLongAttribute(parser, TOTAL_TIME_ACTIVE_ATTR); //【3】解析 lastEvent 属性，获得 package 在最后一次触发的 event，保存到 stats.mLastEvent 中！ stats.mLastEvent = XmlUtils.readIntAttribute(parser, LAST_EVENT_ATTR);&#125; 首先获得 pkg 对应的 UsageStats 对象，然后解析相关属性！ lastTimeActive 属性用于计算最后一次处于 activie 的时间，它是一个距离 statsOut.beginTime 的时间间隔！ 通过 lastTimeActive + statsOut.beginTime，就能够计算出上一次使用的时间 stats.mLastTimeUsed！ timeActive 属性表示其在处于 active 总时间，用于计算 stats.mTotalTimeInForeground； lastEvent 属性表示上一次该 package 上报的时间类型，用于初始化 stats.mLastEvent； 2.2.3.1.1 IntervalStats.getOrCreateUsageStats123456789101112131415161718192021UsageStats getOrCreateUsageStats(String packageName) &#123; //【1】先从 packageStats 中获取 package 对应的 UsageStats！ UsageStats usageStats = packageStats.get(packageName); if (usageStats == null) &#123; //【2】创建一个 UsageStats 对象！ usageStats = new UsageStats(); // 获得包名 usageStats.mPackageName = getCachedStringRef(packageName); //【3】很显然，该 package 的 usageStats.mBeginTimeStamp 和 usageStats.mEndTimeStamp // 和其所属的 IntervalStats 是一样的！ usageStats.mBeginTimeStamp = beginTime; usageStats.mEndTimeStamp = endTime; //【4】将其添加到 packageStats 中去！ packageStats.put(usageStats.mPackageName, usageStats); &#125; // 返回 return usageStats;&#125; 我们知道 IntervalStats.packageStats 中保存的是应用的使用信息！ getCachedStringRef 优先从 IntervalStats.mStringCache 内部缓存中获取！ 创建了一个 UsageStats 对象，封装该 package 的使用信息！ 计算 usageStats.mBeginTimeStamp 和 usageStats.mEndTimeStamp，等于所属 IntervalStats.beginTime 和 IntervalStats.beginTime！ 将新创建的 UsageStats 添加到 packageStats 中！ 2.2.3.2 UsageStatsXmlV1.loadConfigStats - 读取 ConfigStats我们来看看 config 的使用信息：12345678&lt;configurations&gt; &lt;config lastTimeActive=\"60709298\" timeActive=\"60690625\" count=\"3\" active=\"true\" fs=\"1065353216\" mcc=\"460\" mnc=\"65535\" locales=\"zh-CN\" touch=\"3\" key=\"1\" keyHid=\"1\"hardKeyHid=\"2\" nav=\"1\" navHid=\"2\" ori=\"1\" scrLay=\"268435810\" clrMod=\"5\" ui=\"17\" width=\"360\" height=\"685\" sw=\"360\"density=\"480\" app_bounds=\"0 0 1080 2136\" /&gt;&lt;/configurations&gt; 下面我们来出解析 Configuration 的使用信息！12345678910111213141516171819202122232425private static void loadConfigStats(XmlPullParser parser, IntervalStats statsOut) throws XmlPullParserException, IOException &#123; //【1】创建了一个 Configuration 对象，并 readXmlAttrs 解析和配置文件相关的信息！ final Configuration config = new Configuration(); Configuration.readXmlAttrs(parser, config); //【2.2.3.1.1】根据给定的 Configuration，创建对应的 ConfigurationStats！ final ConfigurationStats configStats = statsOut.getOrCreateConfigurationStats(config); //【1】解析 lastTimeActive 属性，表示的是距离 beginTime 的时间间隔， // 初始化 stats.mLastTimeUsed，表示该 package 最后是使用的时间； configStats.mLastTimeActive = statsOut.beginTime + XmlUtils.readLongAttribute( parser, LAST_TIME_ACTIVE_ATTR); //【2】解析 timeActive 属性，获得 Configuration 活跃的总时间，初始化 stats.mTotalTimeActive！ configStats.mTotalTimeActive = XmlUtils.readLongAttribute(parser, TOTAL_TIME_ACTIVE_ATTR); //【3】解析 count 属性，获得 Configuration 活跃的次数，初始化 stats.mActivationCount！ configStats.mActivationCount = XmlUtils.readIntAttribute(parser, COUNT_ATTR); //【4】解析 active 属性，判断该 Configuration 是否是活跃状态！ // 初始化 statsOut.activeConfiguration！ if (XmlUtils.readBooleanAttribute(parser, ACTIVE_ATTR)) &#123; statsOut.activeConfiguration = configStats.mConfiguration; &#125;&#125; 对于 Configuration，由于其属性配置很多，所以这里我们只关注和 UsageStats 相关的属性！ 创建了一个 Configuration 对象，表示该配置信息对象，用于保存配置相关的属性！ 创建该 config 对象的 ConfigurationStats 对象！ 2.2.3.2.1 IntervalStats.getOrCreateConfigurationStats获取或者创建 Configuration 对应的 ConfigurationStats 对象！123456789101112131415161718ConfigurationStats getOrCreateConfigurationStats(Configuration config) &#123; //【1】先从 configurations 中获取 package 对应的 ConfigurationStats！ ConfigurationStats configStats = configurations.get(config); if (configStats == null) &#123; //【2】如果没有，就创建一个 ConfigurationStats 对象！ configStats = new ConfigurationStats(); //【3】很显然，该 package 的 usageStats.mBeginTimeStamp 和 usageStats.mEndTimeStamp // 和其所属的 IntervalStats 是一样的！ configStats.mBeginTimeStamp = beginTime; configStats.mEndTimeStamp = endTime; //【4】设置 configStats.mConfiguration； configStats.mConfiguration = config; //【5】将其添加到 configurations 中！ configurations.put(config, configStats); &#125; // 返回 return configStats;&#125; 2.2.3.3 UsageStatsXmlV1.loadEvent - 读取 Event我们来看看 event 相关的数据 123456&lt;event-log&gt; &lt;event time=\"5852614\" package=\"com.tencent.mobileqq\" class=\"com.tencent.mobileqq.activity.QQLSActivity\" flags=\"0\" type=\"1\" /&gt; &lt;event time=\"5852617\" package=\"com.tencent.mobileqq\" class=\"com.tencent.mobileqq.activity.QQLSActivity\" flags=\"0\" type=\"2\" /&gt;&lt;/event-log&gt; 注意：只有 daily 类别的文件才有 event！ 解析 UsageEvents 的使用信息！1234567891011121314151617181920212223242526272829303132333435363738394041private static void loadEvent(XmlPullParser parser, IntervalStats statsOut) throws XmlPullParserException, IOException &#123; //【1】解析 package 属性，获得该 event 所属的 pacakge！ final String packageName = XmlUtils.readStringAttribute(parser, PACKAGE_ATTR); if (packageName == null) &#123; throw new ProtocolException(&quot;no &quot; + PACKAGE_ATTR + &quot; attribute present&quot;); &#125; //【2】解析 class 属性，获得该 event 所属的 pacakge final String className = XmlUtils.readStringAttribute(parser, CLASS_ATTR); //【2.2.3.3.1】根据给定的 packageName 和 className，创建对应的 Event！ final UsageEvents.Event event = statsOut.buildEvent(packageName, className); //【3】解析 lastTimeActive 属性，表示的是距离 statsOut.beginTime 的时间间隔， // 初始化 event.mTimeStamp，表示该 event 的上报时间； event.mTimeStamp = statsOut.beginTime + XmlUtils.readLongAttribute(parser, TIME_ATTR); //【4】解析 type 属性，初始化 event.mEventType，表示该 event 的类型； event.mEventType = XmlUtils.readIntAttribute(parser, TYPE_ATTR); //【5】如果 event type 类型为 CONFIGURATION_CHANGE 或者 SHORTCUT_INVOCATION // 还要解析其对应的 Configuration 和 shortcutId 属性！ switch (event.mEventType) &#123; case UsageEvents.Event.CONFIGURATION_CHANGE: event.mConfiguration = new Configuration(); Configuration.readXmlAttrs(parser, event.mConfiguration); break; case UsageEvents.Event.SHORTCUT_INVOCATION: final String id = XmlUtils.readStringAttribute(parser, SHORTCUT_ID_ATTR); event.mShortcutId = (id != null) ? id.intern() : null; break; &#125; if (statsOut.events == null) &#123; // 如果 IntervalStats.events 为 null，初始化！ statsOut.events = new TimeSparseArray&lt;&gt;(); &#125; //【6】将该 UsageEvents.Event 添加到 IntervalStats.events 中！ statsOut.events.put(event.mTimeStamp, event);&#125; 2.2.3.3.1 IntervalStats.buildEvent12345678910UsageEvents.Event buildEvent(String packageName, String className) &#123; //【1】创建一个 UsageEvents.Event 对象！ UsageEvents.Event event = new UsageEvents.Event(); //【2】初始化 event.mPackage 和 event.mClass 属性！ event.mPackage = getCachedStringRef(packageName); if (className != null) &#123; event.mClass = getCachedStringRef(className); &#125; return event;&#125; 该方法只是创建 UsageEvents.Event 对象，但是其并没有将其添加到对应的集合中！ 2.3 UserUsageStatsService.loadActiveStatsloadActiveStats 用于给没有最新使用信息的时间类别创建新的 IntervalStats！ 123456789101112131415161718192021222324252627282930313233343536373839private void loadActiveStats(final long currentTimeMillis) &#123; //【1】mCurrentStats 用于保存每个时间类别对应的最新的使用信息，这里开始遍历时间类别！ for (int intervalType = 0; intervalType &lt; mCurrentStats.length; intervalType++) &#123; //【2.2】通过 getLatestUsageStats 方法获得时间类别的最新使用信息！ final IntervalStats stats = mDatabase.getLatestUsageStats(intervalType); if (stats != null &amp;&amp; currentTimeMillis - 500 &gt;= stats.endTime &amp;&amp; currentTimeMillis &lt; stats.beginTime + INTERVAL_LENGTH[intervalType]) &#123; //【2】判断下当前时间是否在时间范围之内，如果是，该 IntervalStats 依然可以记录使用信息！ if (DEBUG) &#123; Slog.d(TAG, mLogPrefix + \"Loading existing stats @ \" + sDateFormat.format(stats.beginTime) + \"(\" + stats.beginTime + \") for interval \" + intervalType); &#125; mCurrentStats[intervalType] = stats; &#125; else &#123; //【3】当前时间已经超过最新的 IntervalStats 能够记录的时间范围！ // 或者某个时间类别没有对应的使用信息！ if (DEBUG) &#123; Slog.d(TAG, \"Creating new stats @ \" + sDateFormat.format(currentTimeMillis) + \"(\" + currentTimeMillis + \") for interval \" + intervalType); &#125; // 创建一个新的 IntervalStats 对象，初始化 beginTime 为当前时间，endTime 为当前时间 + 1 mCurrentStats[intervalType] = new IntervalStats(); mCurrentStats[intervalType].beginTime = currentTimeMillis; mCurrentStats[intervalType].endTime = currentTimeMillis + 1; &#125; &#125; //【2.3】将 mStatsChanged 置为 false； mStatsChanged = false; //【2.4】更新回滚时间！ updateRolloverDeadline(); //【×2.3.1】通知 UsageStatsService 该 userId 的最新使用信息重新加载了！ mListener.onStatsReloaded();&#125; UserUsageStatsService 内部有一个数组，用于表示每个时间类别对应的时间间隔长度：1234private static final long[] INTERVAL_LENGTH = new long[] &#123; UnixCalendar.DAY_IN_MILLIS, UnixCalendar.WEEK_IN_MILLIS, UnixCalendar.MONTH_IN_MILLIS, UnixCalendar.YEAR_IN_MILLIS&#125;; UnixCalendar 我们在 1.1 有分析过，这里就不在多说了！ 举个简单的例子，比如我们指定的时间类别是 daily，那么该 daily 类别下的最新数据要满足要求，当前时间必满足以下条件： 123currentTimeMillis &gt;= stats.endTime + 500currentTimeMillis &lt; stats.beginTime + 24 * 60 * 60 * 1000 stats.beginTime 表示的是该 IntervalStats 的创建时间，那么其最多能记录的信息是：stats.beginTime + 24 60 60 * 1000 之前的信息！ stats.endTime 表示的是该 IntervalStats 的目前已经记录的时间，那么如果该使用信息能够继续被更新，则有 currentTimeMillis - 500 &gt;= stats.endTime！ 其他类别的信息是同样的道理，所以 [stats.endTime + 500, stats.beginTime + 24 60 60 * 1000) 就是该 IntervalStats 还可以记录的时间范围！ 2.3.1 UsageStatsService.onStatsReloaded - 回调1234@Overridepublic void onStatsReloaded() &#123; postOneTimeCheckIdleStates();&#125; loadActiveStats 方法根据当前时间，重新加载最新的数据，然后触发 UsageStatsService.onStatsReloaded 回调！ 该方法会调用 postOneTimeCheckIdleStates 检查一次 idle 状态！ 2.4 UserUsageStatsService.updateRolloverDeadline更新回滚时间！12345678910private void updateRolloverDeadline() &#123; //【1】首先设置 mDailyExpiryDate 为 daily 时间类别下的最新日期的使用信息的开始记录时间点 mDailyExpiryDate.setTimeInMillis( mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime); //【2】然后再加一天时间！ mDailyExpiryDate.addDays(1); Slog.i(TAG, mLogPrefix + \"Rollover scheduled @ \" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis()) + \"(\" + mDailyExpiryDate.getTimeInMillis() + \")\");&#125; updateRolloverDeadline 方法中，将 mDailyExpiryDate 先设置为了 mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime，然后再加了一天！ 所以 updateRolloverDeadline 计算的是下一天使用信息的开始记录时间！mDailyExpiryDate 可以看作是否超过一天的临界时间点！ 2.5 IntervalStats.update我们看到，在 init 方法中：1234if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123; ... ... ...&#125; 只有满足以上条件，才会进入 IntervalStats.update 方法中！ update 用于跟更新 packageName 对应的 UsageStats 相关属性！ long timeStamp 传入的是 IntervalStats.lastTimeSaved，表示 IntervalStats 最后被修改/更新的时间点； int eventType 传入的是 UsageEvents.Event.END_OF_DAY，表示本次要设置的 eventType； 12345678910111213141516171819202122232425262728293031323334353637383940414243void update(String packageName, long timeStamp, int eventType) &#123; //【2.2.3.1.1】获得该 packageName 对应的 UsageStats 实例！ UsageStats usageStats = getOrCreateUsageStats(packageName); //【1】如果本次的 eventType 为 MOVE_TO_BACKGROUND 或者 END_OF_DAY，进入这个 if 条件！ if (eventType == UsageEvents.Event.MOVE_TO_BACKGROUND || eventType == UsageEvents.Event.END_OF_DAY) &#123; //【1.1】并且 UsageStats.mLastEvent 的取值为 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY // 的话，才修改 package 的 mTotalTimeInForeground！ if (usageStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || usageStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123; //【1.1.1】更新 package 在前台的总时间 mTotalTimeInForeground 为： // 在已有基础上再加上 timeStamp - usageStats.mLastTimeUsed usageStats.mTotalTimeInForeground += timeStamp - usageStats.mLastTimeUsed; &#125; &#125; //【2.5.1】如果 eventType 属于 Stateful Event // 那就更新该 pacakge 的 usageStats.mLastEvent（上一次事件）为 eventType； if (isStatefulEvent(eventType)) &#123; usageStats.mLastEvent = eventType; &#125; //【3】如果 eventType 不是 UsageEvents.Event.SYSTEM_INTERACTION，更新上次使用时间 // usageStats.mLastTimeUsed 为 timeStamp！ // 因为 SYSTEM_INTERACTION 本质上是系统对 package 的操作，不会统计进去！ if (eventType != UsageEvents.Event.SYSTEM_INTERACTION) &#123; usageStats.mLastTimeUsed = timeStamp; &#125; //【4】更新该 package 的 usageStats.mEndTimeStamp 为 timeStamp； usageStats.mEndTimeStamp = timeStamp; //【5】如果 eventType 为 MOVE_TO_FOREGROUND，该 package 的 usageStats.mLaunchCount（启动次数）加一； if (eventType == UsageEvents.Event.MOVE_TO_FOREGROUND) &#123; usageStats.mLaunchCount += 1; &#125; //【6】同时修改 IntervalStats.endTime 也为 timeStamp； endTime = timeStamp;&#125; 整个过程如下： 获得该 package 的 UsageStats 对象！ 如果本次要更新的 eventType 为 MOVE_TO_BACKGROUND / END_OF_DAY，并且该 package 的 LastEvent 为 MOVE_TO_FOREGROUND / CONTINUE_PREVIOUS_DAY 这种情况是 package 从前台退到了后台， 这是我们会更新 package 的在前台的总时间 mTotalTimeInForeground = mTotalTimeInForeground + timeStamp - mLastTimeUsed； 如果本次要更新的 eventType 为 Stateful Event，我们也会更新 package 的 mLastEvent 为 eventType； 如果本次要更新的 eventType 不是 SYSTEM_INTERACTION，那么我们会更新 package 的 mLastTimeUsed 为 timeStamp； 更新 package 的 mEndTimeStamp 为 timeStamp；同时更新对应的 IntervalStats 的 endTime 也为 timeStamp； 如果本次要更新的 eventType 不是 SYSTEM_INTERACTION，那么我们会更新 package 的 mLastTimeUsed 为 timeStamp；同时更新对应的 IntervalStats 的 endTime 也为 timeStamp； 2.5.1 IntervalStats.isStatefulEvent12345678910private boolean isStatefulEvent(int eventType) &#123; switch (eventType) &#123; case UsageEvents.Event.MOVE_TO_FOREGROUND: case UsageEvents.Event.MOVE_TO_BACKGROUND: case UsageEvents.Event.END_OF_DAY: case UsageEvents.Event.CONTINUE_PREVIOUS_DAY: return true; &#125; return false;&#125; 判断 eventType 是否是 stateful event！ 2.6 UserUsageStatsService.notifyStatsChanged123456789private void notifyStatsChanged() &#123; //【1】只有 mStatsChanged 为 false 时，才通知 UsageStatsService！ if (!mStatsChanged) &#123; //【1.1】设置 mStatsChanged 为 true； mStatsChanged = true; //【1.2】通知 UsageStatsService，IntervalStats 数据发生了变化！ mListener.onStatsUpdated(); &#125;&#125; mStatsChanged 表示的是使用信息是否发生变化！ 当 IntervalStats 的数据发生变化后，会触发 notifyStatsChanged 方法！ 2.6.1 UsageStatsService.onStatsUpdated - 回调1234@Overridepublic void onStatsUpdated() &#123; mHandler.sendEmptyMessageDelayed(MSG_FLUSH_TO_DISK, FLUSH_INTERVAL);&#125; UsageStatsService 的 onStatsUpdated 方法触发后，会延迟 20mins 后发送 MSG_FLUSH_TO_DISK 给 H！ 这样也保证了不会频繁的通知和保存！！ 2.7 IntervalStats.updateConfigurationStats更新指定配置的信息！ Configuration confi： 是要成为 active config 的配置对象，这里传入的是 null； long timeStamp：传入的是 stat.lastTimeSaved（IntervalStats 自身上一次被更新的时间）； 123456789101112131415161718192021222324252627void updateConfigurationStats(Configuration config, long timeStamp) &#123; //【1】如果 activeConfiguration 不为 null，说明已经有配置信息处于 active 状态！ // 那就更新其时间信息！ if (activeConfiguration != null) &#123; ConfigurationStats activeStats = configurations.get(activeConfiguration); //【1.1】更新 active config 总的活跃时间 mTotalTimeActive 为：在其基础上加上 // timeStamp 减去上一次活跃时间（mLastTimeActive） activeStats.mTotalTimeActive += timeStamp - activeStats.mLastTimeActive; //【1.2】更新上次活跃时间 mLastTimeActive 为上次被更新的时间（timeStamp）减去 1； activeStats.mLastTimeActive = timeStamp - 1; &#125; //【2】更新 config 指定的配置的信息。因为我们这里传入的是 null，所以不会进入； if (config != null) &#123; ConfigurationStats configStats = getOrCreateConfigurationStats(config); //【2.1】更新 config 上次活跃时间 mLastTimeActive 为 timeStamp configStats.mLastTimeActive = timeStamp; //【2.2】更新 config 的活跃次数； configStats.mActivationCount += 1; //【2.3】更新 IntervalStats.activeConfiguration 为指定的 config！ activeConfiguration = configStats.mConfiguration; &#125; //【3】更新 IntervalStats.endTime 为上一次被更新的时间 ！timeStamp endTime = timeStamp;&#125; 因为这里我们传入的是 Configuration config 为 null，所以只会尝试更新 activeConfiguration 的时间信息！ 2.8 UserUsageStatsService.notifyNewUpdate当系统发生了升级后，UserUsageStatsService 会调用 notifyNewUpdate 通知 UsageStatsService!1234private void notifyNewUpdate() &#123; //【*2.8.1】这里的 mListener 就是 UsageStatsService！ mListener.onNewUpdate(mUserId);&#125; 这里就不多说了！ 2.8.1 UsageStatsService.onNewUpdate - 回调1234@Overridepublic void onNewUpdate(int userId) &#123; initializeDefaultsForSystemApps(userId);&#125; 如果出现了系统升级的情况，那么 UsageStatsService 的 onNewUpdate 方法会调用，然后执行 initializeDefaultsForSystemApps 方法，对系统 App 的信息做初始化！ 2.9 流程总结3 UserUsageStatsService.onTimeChanged - 处理时间变化处理时间改变的情况！ 12345678void onTimeChanged(long oldTime, long newTime) &#123; //【×3.1】持久化处于内存中的最新数据！ persistActiveStats(); //【×3.2】通知数据库时间发生了变化！ mDatabase.onTimeChanged(newTime - oldTime); //【×2.3】再次加载最新日期的数据！ loadActiveStats(newTime);&#125; 整个方法的逻辑如下： 先将内存中的数据持久化到本地文件中； 然后处理下时间变化； 再次加载本地数据到内存中； 对于 loadActiveStats 方法，我们在前面是有分析过的，该过程的主要逻辑如下： 先将最新日期的内存数据写回本地持久化文件； 处理时间变化后，持久化文件的名称修改，然后对改名后的文件重新排序，加载到内存中； 重新加载最新日期的使用数据！ 3.0 调用时机在 UsageStatsService 的 checkAndGetTimeLocked 会计算当前的实际时间，判断是否有调时发生！ 如果有的话，会触发 UserUsageStatsService.onTimeChanged 方法！ 12345678910111213141516171819private long checkAndGetTimeLocked() &#123; final long actualSystemTime = System.currentTimeMillis(); final long actualRealtime = SystemClock.elapsedRealtime(); final long expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot; final long diffSystemTime = actualSystemTime - expectedSystemTime; if (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123; // The time has changed. Slog.i(TAG, \"Time changed in UsageStats by \" + (diffSystemTime / 1000) + \" seconds\"); final int userCount = mUserState.size(); for (int i = 0; i &lt; userCount; i++) &#123; final UserUsageStatsService service = mUserState.valueAt(i); //【×3】会触发 onTimeChanged 方法！ service.onTimeChanged(expectedSystemTime, actualSystemTime); &#125; mRealTimeSnapshot = actualRealtime; mSystemTimeSnapshot = actualSystemTime; &#125; return actualSystemTime;&#125; 对于 checkAndGetTimeLocked 的逻辑，这里不再多说！ 3.1 UserUsageStatsService.persistActiveStatspersistActiveStats 将最新的缓存数据保存到本地文件中！ 12345678910111213141516void persistActiveStats() &#123; //【1】只有当 mStatsChanged 为 true 是才会更新本地文件！ if (mStatsChanged) &#123; Slog.i(TAG, mLogPrefix + \"Flushing usage stats to disk\"); try &#123; //【×3.1.1】更新数据到本地文件！ for (int i = 0; i &lt; mCurrentStats.length; i++) &#123; mDatabase.putUsageStats(i, mCurrentStats[i]); &#125; //【2】更新完成后会将 mStatsChanged 置为 false！ mStatsChanged = false; &#125; catch (IOException e) &#123; Slog.e(TAG, mLogPrefix + \"Failed to persist active stats\", e); &#125; &#125;&#125; 执行 persistActiveStats 前，会先做一次判断，如果时间发生了变化，并且内存中的使用信息有更新过，即 mStatsChanged 为 true，才会触发回写本地文件的操作！ mCurrentStats 数组中保存的是当前最新的数据！ 3.1.1 UsageStatsDatabase.putUsageStats12345678910111213141516171819202122public void putUsageStats(int intervalType, IntervalStats stats) throws IOException &#123; if (stats == null) return; synchronized (mLock) &#123; //【1】校验 intervalType 的取值范围！ if (intervalType &lt; 0 || intervalType &gt;= mIntervalDirs.length) &#123; throw new IllegalArgumentException(\"Bad interval type \" + intervalType); &#125; //【2】获得 IntervalStats 对应的本地文件 AtomicFile 对象！ // 如果没有找到，就创建一个新的 AtomicFile，并添加到 mSortedStatFiles 中！ AtomicFile f = mSortedStatFiles[intervalType].get(stats.beginTime); if (f == null) &#123; f = new AtomicFile(new File(mIntervalDirs[intervalType], Long.toString(stats.beginTime))); mSortedStatFiles[intervalType].put(stats.beginTime, f); &#125; //【3.1.2】调用 UsageStatsXml 的 write 方法将数据写到本地文件中！ UsageStatsXml.write(f, stats); //【4】更新 stats.lastTimeSaved stats.lastTimeSaved = f.getLastModifiedTime(); &#125;&#125; 3.1.2 UsageStatsXml.write123456789101112public static void write(AtomicFile file, IntervalStats stats) throws IOException &#123; FileOutputStream fos = file.startWrite(); try &#123; // 调用另外一个 write 方法！ write(fos, stats); file.finishWrite(fos); fos = null; &#125; finally &#123; // When fos is null (successful write), this will no-op file.failWrite(fos); &#125;&#125; 调用了另外一个 write 方法：12345678910111213static void write(OutputStream out, IntervalStats stats) throws IOException &#123; FastXmlSerializer xml = new FastXmlSerializer(); xml.setOutput(out, \"utf-8\"); xml.startDocument(\"utf-8\", true); xml.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); xml.startTag(null, USAGESTATS_TAG); // 处理 usagestats 标签 xml.attribute(null, VERSION_ATTR, Integer.toString(CURRENT_VERSION)); // 处理 version 属性，值为 1； // 继续调用 UsageStatsXmlV1.write 方法写入！ UsageStatsXmlV1.write(xml, stats); xml.endTag(null, USAGESTATS_TAG); xml.endDocument();&#125; 3.1.3 UsageStatsXmlV1.write该方法最终写入本地文件！ 12345678910111213141516171819202122232425262728public static void write(XmlSerializer xml, IntervalStats stats) throws IOException &#123; XmlUtils.writeLongAttribute(xml, END_TIME_ATTR, stats.endTime - stats.beginTime); xml.startTag(null, PACKAGES_TAG); // 写入 packages 标签 final int statsCount = stats.packageStats.size(); for (int i = 0; i &lt; statsCount; i++) &#123; //【3.1.3.1】写入 package 的使用信息； writeUsageStats(xml, stats, stats.packageStats.valueAt(i)); &#125; xml.endTag(null, PACKAGES_TAG); xml.startTag(null, CONFIGURATIONS_TAG); // 写入 configurations 标签 final int configCount = stats.configurations.size(); for (int i = 0; i &lt; configCount; i++) &#123; //【3.1.3.2】写入 Configuration 的使用信息； boolean active = stats.activeConfiguration.equals(stats.configurations.keyAt(i)); writeConfigStats(xml, stats, stats.configurations.valueAt(i), active); &#125; xml.endTag(null, CONFIGURATIONS_TAG); xml.startTag(null, EVENT_LOG_TAG); // 写入 event-log 标签 final int eventCount = stats.events != null ? stats.events.size() : 0; for (int i = 0; i &lt; eventCount; i++) &#123; //【3.1.3.3】写入 Event 的上报信息； writeEvent(xml, stats, stats.events.valueAt(i)); &#125; xml.endTag(null, EVENT_LOG_TAG);&#125; 该过程主要是写入 package，Configuration，Event 的相关信息！ 3.1.3.1 UsageStatsXmlV1.writeUsageStatsIntervalStats stats 是使用信息记录文件的缓存对象；UsageStats usageStats 是该 package 的缓存对象！12345678910111213141516private static void writeUsageStats(XmlSerializer xml, final IntervalStats stats, final UsageStats usageStats) throws IOException &#123; xml.startTag(null, PACKAGE_TAG); // 写入 package 标签； // 写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime； XmlUtils.writeLongAttribute(xml, LAST_TIME_ACTIVE_ATTR, usageStats.mLastTimeUsed - stats.beginTime); // 写入 package 属性，取值为 usageStats.mPackageName； XmlUtils.writeStringAttribute(xml, PACKAGE_ATTR, usageStats.mPackageName); // 写入 timeActive 属性，取值为 usageStats.mTotalTimeInForeground； XmlUtils.writeLongAttribute(xml, TOTAL_TIME_ACTIVE_ATTR, usageStats.mTotalTimeInForeground); // 写入 lastEvent 属性，取值为 usageStats.mLastEvent； XmlUtils.writeIntAttribute(xml, LAST_EVENT_ATTR, usageStats.mLastEvent); xml.endTag(null, PACKAGE_TAG);&#125; 写入 package 的使用信息： 写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime； 写入 package 属性，取值为 usageStats.mPackageName； 写入 timeActive 属性，取值为 usageStats.mTotalTimeInForeground； 写入 lastEvent 属性，取值为 usageStats.mLastEvent； 3.1.3.2 UsageStatsXmlV1.writeConfigStatsIntervalStats stats 是使用信息记录文件的缓存对象；ConfigurationStats configStats 是该 config 的缓存对象，boolean isActive 表示该 config 是否是处于活跃状态！！123456789101112131415161718192021private static void writeConfigStats(XmlSerializer xml, final IntervalStats stats, final ConfigurationStats configStats, boolean isActive) throws IOException &#123; xml.startTag(null, CONFIG_TAG); // 写入 configurations 标签 // 写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime； XmlUtils.writeLongAttribute(xml, LAST_TIME_ACTIVE_ATTR, configStats.mLastTimeActive - stats.beginTime); // 写入 timeActive 属性，取值为 configStats.mTotalTimeActive； XmlUtils.writeLongAttribute(xml, TOTAL_TIME_ACTIVE_ATTR, configStats.mTotalTimeActive); // 写入 count 属性，取值为 configStats.mActivationCount； XmlUtils.writeIntAttribute(xml, COUNT_ATTR, configStats.mActivationCount); // 如果该 config 是当前处于 active 状态，写入 active 属性，true； if (isActive) &#123; XmlUtils.writeBooleanAttribute(xml, ACTIVE_ATTR, true); &#125; // 接着就是写入 Configuration 的配置信息了！ Configuration.writeXmlAttrs(xml, configStats.mConfiguration); xml.endTag(null, CONFIG_TAG);&#125; 写入 Config 的使用信息： 写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime； 写入 timeActive 属性，取值为 configStats.mTotalTimeActive； 写入 count 属性，取值为 configStats.mActivationCount； 如果该 config 是当前处于 active 状态，写入 active 属性，true； 接着就是写入 Configuration 的配置信息了！ 3.1.3.3 UsageStatsXmlV1.writeEventIntervalStats stats 是使用信息记录文件的缓存对象；UsageEvents.Event event 是该 event 的缓存对象！！1234567891011121314151617181920212223242526272829private static void writeEvent(XmlSerializer xml, final IntervalStats stats, final UsageEvents.Event event) throws IOException &#123; xml.startTag(null, EVENT_TAG); // 写入 event 标签 // 写入 time 属性，取值为 event.mTimeStamp - stats.beginTime； XmlUtils.writeLongAttribute(xml, TIME_ATTR, event.mTimeStamp - stats.beginTime); // 写入 package 属性和 class 属性，取值为 event.mPackage 和 event.mClass！ XmlUtils.writeStringAttribute(xml, PACKAGE_ATTR, event.mPackage); if (event.mClass != null) &#123; XmlUtils.writeStringAttribute(xml, CLASS_ATTR, event.mClass); &#125; // 写入 type 属性，取值为 event.mEventType！ XmlUtils.writeIntAttribute(xml, TYPE_ATTR, event.mEventType); // 根据 EventType，写入额外的信息！ switch (event.mEventType) &#123; case UsageEvents.Event.CONFIGURATION_CHANGE: if (event.mConfiguration != null) &#123; Configuration.writeXmlAttrs(xml, event.mConfiguration); &#125; break; case UsageEvents.Event.SHORTCUT_INVOCATION: if (event.mShortcutId != null) &#123; XmlUtils.writeStringAttribute(xml, SHORTCUT_ID_ATTR, event.mShortcutId); &#125; break; &#125; xml.endTag(null, EVENT_TAG);&#125; 写入 Event 的使用信息： 写入 time 属性，取值为 event.mTimeStamp - stats.beginTime； 写入 package 属性和 class 属性，取值为 event.mPackage 和 event.mClass！ 写入 type 属性，取值为 event.mEventType！ 根据 EventType，写入额外的信息！ Configuration 或者 SHORTCUT！ 3.2 UsageStatsDatabase.onTimeChangedlong timeDiffMillis 表示时间调整后的差值，因为时间调整了，所以我们同步修改文件的名称，同时删除那些无效的文件！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void onTimeChanged(long timeDiffMillis) &#123; synchronized (mLock) &#123; StringBuilder logBuilder = new StringBuilder(); logBuilder.append(\"Time changed by \"); TimeUtils.formatDuration(timeDiffMillis, logBuilder); logBuilder.append(\".\"); int filesDeleted = 0; int filesMoved = 0; //【1】处理 mSortedStatFiles 中所有的 AtomicFile 对象！ for (TimeSparseArray&lt;AtomicFile&gt; files : mSortedStatFiles) &#123; final int fileCount = files.size(); for (int i = 0; i &lt; fileCount; i++) &#123; //【1.1】通过 valueAt 获得要处理的 AtomicFile 文件，通过 keyAt 可以获得该文件的开始记录时间！ final AtomicFile file = files.valueAt(i); //【1.2】计算时间改变后的新时间！ final long newTime = files.keyAt(i) + timeDiffMillis; if (newTime &lt; 0) &#123; //【1.2.1】如果 newTime 小于 0，那么该文件无效，删除该文件！ filesDeleted++; file.delete(); &#125; else &#123; //【1.2.2】这种情况，我们要修改文件的名字，因为文件的名字就是其开始记录时间， // 我们会将文件名改为：newTime + \"-c\" 的形式！ try &#123; file.openRead().close(); &#125; catch (IOException e) &#123; // Ignore, this is just to make sure there are no backups. &#125; String newName = Long.toString(newTime); if (file.getBaseFile().getName().endsWith(CHECKED_IN_SUFFIX)) &#123; newName = newName + CHECKED_IN_SUFFIX; &#125; final File newFile = new File(file.getBaseFile().getParentFile(), newName); filesMoved++; file.getBaseFile().renameTo(newFile); &#125; &#125; files.clear(); &#125; logBuilder.append(\" files deleted: \").append(filesDeleted); logBuilder.append(\" files moved: \").append(filesMoved); Slog.i(TAG, logBuilder.toString()); //【×2.1.2】然后再次调用 indexFilesLocked，对改名后的文件进行重新排序，再次添加到 mSortedStatFiles 中！ indexFilesLocked(); &#125;&#125; indexFilesLocked 方法我们有讲过，这里就不多说了！ 3.3 流程总结4 UserUsageStatsService.rolloverStats - 数据回滚当我们在 report event 的时候，会判断此时记录的时间点是否已经超过了 mDailyExpiryDate 指定的日期，mDailyExpiryDate 前面我们有说过，其作为是否超过一天的临界点！ 1234if (event.mTimeStamp &gt;= mDailyExpiryDate.getTimeInMillis()) &#123; // Need to rollover rolloverStats(event.mTimeStamp);&#125; 如果超过了 1 天，那么我们要关闭当前最新的使用信息文件，这次的记录时间会做为今天的最后一个记录时间，然后下次 report event 时，会创建一个新的文件记录下一天的使用信息！ 当我们发现本次记录的时间超过了 mDailyExpiryDate，那么我们要关闭当前最新日期的使用信息文件了，rolloverStats 就发生在此时 ！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private void rolloverStats(final long currentTimeMillis) &#123; final long startTime = SystemClock.elapsedRealtime(); Slog.i(TAG, mLogPrefix + \"Rolling over usage stats\"); //【1】获得 dailay 时间类别使用信息中处于 active 状态的 config！ final Configuration previousConfig = mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration; //【2】continuePreviousDay 用于记录那些需要将设置为 CONTINUE_PREVIOUS_DAY 的 package ArraySet&lt;String&gt; continuePreviousDay = new ArraySet&lt;&gt;(); //【3】遍历当前每个时间类别下最新日期的使用信息！ for (IntervalStats stat : mCurrentStats) &#123; final int pkgCount = stat.packageStats.size(); for (int i = 0; i &lt; pkgCount; i++) &#123; UsageStats pkgStats = stat.packageStats.valueAt(i); //【3.1】如果 package 的 mLastEvent 是 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY！ // 将其 event 改为 END_OF_DAY 表示一天的记录结束了！ if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123; //【3.1.1】那么将该 package 添加到 continuePreviousDay 中！ continuePreviousDay.add(pkgStats.mPackageName); //【×4.1】同时更新 pacakge 对应的 UsageStats 的信息！ stat.update(pkgStats.mPackageName, mDailyExpiryDate.getTimeInMillis() - 1, UsageEvents.Event.END_OF_DAY); //【×2.6】延迟 20mins 通知 UsageStatsService 刷新本地数据， // mStatsChanged 会被设置为 true，只通知一次！ notifyStatsChanged(); &#125; &#125; //【×4.2】更新 Configuration 的状态信息！ stat.updateConfigurationStats(null, mDailyExpiryDate.getTimeInMillis() - 1); &#125; //【×3.1】将内存中的最新数据写回持久化文件！ //【×2.6】会将 mStatsChanged 设置为 false； persistActiveStats(); //【×4.2】移除那些日期太旧的本地文件，然后重新加载文件到内存中！ mDatabase.prune(currentTimeMillis); //【×2.3】加载最新使用信息到内存中！ // 对于 daily 时间类别，会创建一个新的 IntervalStats 对象！ // 对于其他类别，可能会创建一个新的 IntervalStats 对象！ // 这里也会将 mStatsChanged 设置为 false； loadActiveStats(currentTimeMillis); //【4】处理之前收集到的 package，将其设置为 CONTINUE_PREVIOUS_DAY！ final int continueCount = continuePreviousDay.size(); for (int i = 0; i &lt; continueCount; i++) &#123; String name = continuePreviousDay.valueAt(i); //【4.1】这里的 beginTime 是 daily 时间类别的新创建的 IntervalStats 的 beginTime 时间； // 同时也是其他类别的更新时间点！ final long beginTime = mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime; //【4.2】遍历每个时间类别下的最新使用数据 IntervalStats！ // 对于 daily 时间类别的数据，这里是将该 package 的使用信息更新到新创建的 IntervalStats！ // 对于其他类别的数据，可能是更新到了新创建的 IntervalStats 中，也可能是修改已有的最新 IntervalStats！ for (IntervalStats stat : mCurrentStats) &#123; //【4.2.1】这里再次调用了 update/updateConfigurationStats 方法更新 IntervalStats！ // 设置其 event 为 CONTINUE_PREVIOUS_DAY，表示继续前一天的记录！ stat.update(name, beginTime, UsageEvents.Event.CONTINUE_PREVIOUS_DAY); stat.updateConfigurationStats(previousConfig, beginTime); //【×2.6】延迟 20mins 通知 UsageStatsService 刷新本地数据， // mStatsChanged 会被设置为 true，只通知一次！ notifyStatsChanged(); &#125; &#125; //【×3.1】将内存中的最新数据写回持久化文件！ persistActiveStats(); final long totalTime = SystemClock.elapsedRealtime() - startTime; Slog.i(TAG, mLogPrefix + \"Rolling over usage stats complete. Took \" + totalTime + \" milliseconds\");&#125; 我们来分析下整个方法的逻辑： 我们来分析下一些细节处理： 这里要注意下 loadActiveStats： 加载最新使用信息到内存中，在加载最新数据时，会判断当前的时间是否在最新文件可以记录的范围内，如果在的话，就直接加载最新文件的数据，如果不在的话，那就会创建一个新的 IntervalStats，记录下一个时间段的使用信息； 因为我们当前的时间已经超过了 mDailyExpiryDate，而 mDailyExpiryDate 是以一天为临界点的，所以对于 daily 类别的最新文件来说，已经超过了其能够记录的范围，那么会创建一个新的 IntervalStats 对象！ 而对于 weekly，monthly，yearly 不一定超过了其最新文件能够记录的时间返回，所以可能返回的依然是当前最新文件的 IntervalStats 对象！ loadActiveStats 方法在加载完成数据后，会调用 updateRolloverDeadline 再次将 mDailyExpiryDate 设置到下一天！ 4.1 IntervalStats.update这里再次调用了 IntervalStats.update 方法，更新 package 的信息！ 同样的，必须满足一下条件才能进入： 1234if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123; ... ... ...&#125; 和 init 中传入的 timeStamp 不同，这里传入的是： long timeStamp： 本次更新时间 mDailyExpiryDate.getTimeInMillis() - 1； int eventType： 本次更新的事件 UsageEvents.Event.END_OF_DAY 1234567891011121314151617181920212223242526272829303132333435363738394041void update(String packageName, long timeStamp, int eventType) &#123; //【2.2.3.1.1】获得该 packageName 对应的 UsageStats 实例！ UsageStats usageStats = getOrCreateUsageStats(packageName); //【1】如果 eventType 为 MOVE_TO_BACKGROUND 或者 END_OF_DAY，进入这个 if 条件！ if (eventType == UsageEvents.Event.MOVE_TO_BACKGROUND || eventType == UsageEvents.Event.END_OF_DAY) &#123; //【1.1】这时判断如果 UsageStats.mLastEvent 的取值为 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY if (usageStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || usageStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123; //【1.2】更新 package 在前台的总时间 mTotalTimeInForeground 为： // 在已有基础上再加上 timeStamp - usageStats.mLastTimeUsed usageStats.mTotalTimeInForeground += timeStamp - usageStats.mLastTimeUsed; &#125; &#125; //【2.5.1】如果 eventType 属于 Stateful Event // 那就更新该 pacakge 的 usageStats.mLastEvent（上一次事件）为 eventType； if (isStatefulEvent(eventType)) &#123; usageStats.mLastEvent = eventType; &#125; //【3】如果 eventType 不是 UsageEvents.Event.SYSTEM_INTERACTION，更新 usageStats.mLastTimeUsed // 上次使用时间为 timeStamp！ if (eventType != UsageEvents.Event.SYSTEM_INTERACTION) &#123; usageStats.mLastTimeUsed = timeStamp; &#125; //【4】更新该 package 的 usageStats.mEndTimeStamp 为 timeStamp usageStats.mEndTimeStamp = timeStamp; //【5】如果 eventType 为 MOVE_TO_FOREGROUND，该 package 的 usageStats.mLaunchCount（启动次数）加一； if (eventType == UsageEvents.Event.MOVE_TO_FOREGROUND) &#123; usageStats.mLaunchCount += 1; &#125; //【6】同时修改 IntervalStats.endTime 也为 timeStamp endTime = timeStamp;&#125; 函数流程就不在分析了，我们直接看结论： usageStats.mTotalTimeInForeground += (mDailyExpiryDate.getTimeInMillis() - 1) - usageStats.mLastTimeUsed usageStats.mLastEvent = UsageEvents.Event.END_OF_DAY usageStats.mLastTimeUsed = (mDailyExpiryDate.getTimeInMillis() - 1) usageStats.mEndTimeStamp = (mDailyExpiryDate.getTimeInMillis() - 1) IntervalStats.endTime = (mDailyExpiryDate.getTimeInMillis() - 1) 4.2 IntervalStats.updateConfigurationStats再次调用 updateConfigurationStats 更新指定配置的信息！ Configuration config： 是要成为 active config 的配置对象，这里传入的是 null； long timeStamp：传入的是 mDailyExpiryDate.getTimeInMillis() - 1； 123456789101112131415161718192021222324252627void updateConfigurationStats(Configuration config, long timeStamp) &#123; //【1】如果 activeConfiguration 不为 null，说明已经有配置信息处于 active 状态！ // 那就更新其时间信息！ if (activeConfiguration != null) &#123; ConfigurationStats activeStats = configurations.get(activeConfiguration); //【1.1】更新 active config 总的活跃时间 mTotalTimeActive 为：在其基础上加上 // timeStamp 减去上一次活跃时间 mLastTimeActive！ activeStats.mTotalTimeActive += timeStamp - activeStats.mLastTimeActive; //【1.2】更新上次活跃时间 mLastTimeActive 为 timeStamp 减去 1； activeStats.mLastTimeActive = timeStamp - 1; &#125; //【2】更新 config 指定的配置的信息。因为我们这里传入的是 null，所以不会进入； if (config != null) &#123; ConfigurationStats configStats = getOrCreateConfigurationStats(config); //【2.1】更新 config 最新活跃时间 mLastTimeActive 为 timeStamp configStats.mLastTimeActive = timeStamp; //【2.2】更新 config 的活跃次数； configStats.mActivationCount += 1; //【2.3】更新 IntervalStats.activeConfiguration 为指定的 config！ activeConfiguration = configStats.mConfiguration; &#125; //【3】更新 IntervalStats.endTime 为上一次被更新的时间 ！timeStamp endTime = timeStamp;&#125; 因为这里我们传入的是 Configuration config 为 null，所以只会尝试更新 activeConfiguration 的时间信息！ 4.3 UsageStatsDatabase.pruneprune 方法会移除那些日期太旧的本地文件！123456789101112131415161718192021222324252627public void prune(final long currentTimeMillis) &#123; synchronized (mLock) &#123; //【1】删除 3 年以前的使用信息文件！ mCal.setTimeInMillis(currentTimeMillis); mCal.addYears(-3); pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_YEARLY], mCal.getTimeInMillis()); //【2】删除 6 个月以前的使用信息文件！ mCal.setTimeInMillis(currentTimeMillis); mCal.addMonths(-6); pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_MONTHLY], mCal.getTimeInMillis()); //【3】删除 4 周以前的使用信息文件！ mCal.setTimeInMillis(currentTimeMillis); mCal.addWeeks(-4); pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_WEEKLY], mCal.getTimeInMillis()); //【4】删除 7 天以前的使用信息文件！ mCal.setTimeInMillis(currentTimeMillis); mCal.addDays(-7); pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_DAILY], mCal.getTimeInMillis()); //【2.1.2】然后重新加载文件到内存中！ indexFilesLocked(); &#125;&#125; 删除 3 年以前的使用信息文件！ 删除 6 个月以前的使用信息文件！ 删除 4 周以前的使用信息文件！ 删除 7 天以前的使用信息文件！ 最后要重新加载最新文件到内存中，防止读取到已经被删除的文件！ 4.3.1 UsageStatsDatabase.pruneFilesOlderThan1234567891011121314151617181920212223private static void pruneFilesOlderThan(File dir, long expiryTime) &#123; File[] files = dir.listFiles(); if (files != null) &#123; for (File f : files) &#123; String path = f.getPath(); //【1】如果文件名中有 .bak 那么属于备份文件，去掉 .bak 得到非备份文件！ if (path.endsWith(BAK_SUFFIX)) &#123; f = new File(path.substring(0, path.length() - BAK_SUFFIX.length())); &#125; long beginTime; try &#123; //【2.1.2.1】调用 UsageStatsXml.parseBeginTime 获得文件的 beginTime = UsageStatsXml.parseBeginTime(f); &#125; catch (IOException e) &#123; beginTime = 0; &#125; //【2】当文件的开始记录时间早于 expiryTime，该文件过期了，删除！ if (beginTime &lt; expiryTime) &#123; new AtomicFile(f).delete(); &#125; &#125; &#125;&#125; 方法流程简单，不多说了！ 4.4 流程总结5 UserUsageStatsService.reportEvent - 上报事件这里我们来看看上报时间的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void reportEvent(UsageEvents.Event event) &#123; if (DEBUG) &#123; Slog.d(TAG, mLogPrefix + \"Got usage event for \" + event.mPackage + \"[\" + event.mTimeStamp + \"]: \" + eventToString(event.mEventType)); &#125; //【1】当前记录超过了 mDailyExpiryDate，那么我们要判断下当前的时间点是否超过了每个时间类别下最新文件能够记录的 // 时间范围，如果超过了，要创建新的 IntervalStats，用下一个阶段的记录！ if (event.mTimeStamp &gt;= mDailyExpiryDate.getTimeInMillis()) &#123; //【×4】对于数据的处理，在 rolloverStats 中！ rolloverStats(event.mTimeStamp); &#125; //【2】获得 daily 类别下的最新 IntervalStats，我们要将本次的数据写入到最新的 IntervalStats！！ final IntervalStats currentDailyStats = mCurrentStats[UsageStatsManager.INTERVAL_DAILY]; //【3】如果本次的 event 的类型为 CONFIGURATION_CHANGE，并且 currentDailyStats.activeConfiguration 不为 null // 那么调整该 event.mConfiguration！ final Configuration newFullConfig = event.mConfiguration; if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE &amp;&amp; currentDailyStats.activeConfiguration != null) &#123; event.mConfiguration = Configuration.generateDelta( currentDailyStats.activeConfiguration, newFullConfig); &#125; //【4】将本次 event 添加到 daily 的最新 IntervalStats 中！ // 如果 eventType 是 SYSTEM_INTERACTION，则不添加！ if (currentDailyStats.events == null) &#123; currentDailyStats.events = new TimeSparseArray&lt;&gt;(); &#125; if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) &#123; currentDailyStats.events.put(event.mTimeStamp, event); &#125; //【5】遍历所有时间类别下的最新使用信息 IntervalStats！ // 如果 event 类型为 CONFIGURATION_CHANGE，那就只更新 config // 如果是其他类型，只更新 UsageStats！ for (IntervalStats stats : mCurrentStats) &#123; if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) &#123; stats.updateConfigurationStats(newFullConfig, event.mTimeStamp); &#125; else &#123; stats.update(event.mPackage, event.mTimeStamp, event.mEventType); &#125; &#125; //【×2.6】通知 UsageStatsService，使用信息发生了变化！ notifyStatsChanged();&#125; 其实可以看到：event 相关的 log 只会记录到 daily 类别的文件中！ notifyStatsChanged 会将 mStatsChanged 置为 true，然后触发 mListener.onStatsUpdated 方法，UsageStatsService.onStatsUpdated 会回调 persistActiveStats 方法，将最新的使用信息保存到本地文件中，最后设置 mStatsChanged 为 false； 123456private void notifyStatsChanged() &#123; if (!mStatsChanged) &#123; mStatsChanged = true; mListener.onStatsUpdated(); &#125;&#125; 整个过程很简单，不多说了！ 6 UserUsageStatsService.query - 查询UserUsageStatsService 提供了三个查询接口： 123UserUsageStatsService.queryEventsUserUsageStatsService.queryUsageStatsUserUsageStatsService.queryStats 下面我们来分析下具体的查询过程！ 6.1 UserUsageStatsService.queryEvents6.2 UserUsageStatsService.queryUsageStats6.3 UserUsageStatsService.queryStats","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"UsageStats使用状态管理","slug":"AndroidFramework源码分析/UsageStats使用状态管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/UsageStats使用状态管理/"}],"tags":[{"name":"UsageStats使用状态管理","slug":"UsageStats使用状态管理","permalink":"https://coolqi.top/tags/UsageStats使用状态管理/"}]},{"title":"UsageStats 第 2 篇 - UsageStatsService 消息处理","slug":"UsageStats2-usageStatsServiceDealWithMessege","date":"2017-04-03T12:46:25.000Z","updated":"2018-11-20T16:54:06.000Z","comments":true,"path":"2017/04/03/UsageStats2-usageStatsServiceDealWithMessege/","link":"","permalink":"https://coolqi.top/2017/04/03/UsageStats2-usageStatsServiceDealWithMessege/","excerpt":"","text":"[toc] 基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理 UsageStatsService 定义的事件类型目前一共有 8 种类型，全部定义在 UsageEvents.java 中，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * An event type denoting that a component moved to the foreground. */public static final int MOVE_TO_FOREGROUND = 1;/** * An event type denoting that a component moved to the background. */public static final int MOVE_TO_BACKGROUND = 2;/** * An event type denoting that a component was in the foreground when the stats * rolled-over. This is effectively treated as a &#123;@link #MOVE_TO_BACKGROUND&#125;. * &#123;@hide&#125; */public static final int END_OF_DAY = 3;/** * An event type denoting that a component was in the foreground the previous day. * This is effectively treated as a &#123;@link #MOVE_TO_FOREGROUND&#125;. * &#123;@hide&#125; */public static final int CONTINUE_PREVIOUS_DAY = 4;/** * An event type denoting that the device configuration has changed. */public static final int CONFIGURATION_CHANGE = 5;/** * An event type denoting that a package was interacted with in some way by the system. * @hide */public static final int SYSTEM_INTERACTION = 6;/** * An event type denoting that a package was interacted with in some way by the user. */public static final int USER_INTERACTION = 7;/** * An event type denoting that an action equivalent to a ShortcutInfo is taken by the user. * * @see android.content.pm.ShortcutManager#reportShortcutUsed(String) */public static final int SHORTCUT_INVOCATION = 8; 0 综述UsageStatsService 的消息处理是在 H 中， 下面我们去看看具体的消息处理！ 1 消息：MSG_REPORT_EVENT - OK1.0 消息触发时机当 AcitivtyManagerService 调用 LocalService 的以下方法的时候，会发送 MSG_REPORT_EVENT 消息！ 12345678910111213141516171819private final class LocalService extends UsageStatsManagerInternal &#123; @Override public void reportEvent(ComponentName component, int userId, int eventType) &#123; if (component == null) &#123; Slog.w(TAG, \"Event reported without a component name\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = component.getPackageName(); event.mClass = component.getClassName(); // This will later be converted to system time. event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = eventType; mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget(); &#125; 还有其他的 report 方法：123456789 @Override public void reportEvent(String packageName, int userId, int eventType) &#123;...&#125; @Override public void reportConfigurationChange(Configuration config, int userId) &#123;...&#125; @Override public void reportShortcutUsage(String packageName, String shortcutId, int userId) &#123;...&#125;&#125; 这些方法会接收到传入的 event，然后发送 MSG_REPORT_EVENT 消息！ 123case MSG_REPORT_EVENT: reportEvent((UsageEvents.Event) msg.obj, msg.arg1); break; 该消息会携带 2 个重要数据：UsageEvents 和 userId！ 1.1 UsageStatsService.reportEvent123456789101112131415161718192021222324252627282930313233343536void reportEvent(UsageEvents.Event event, int userId) &#123; synchronized (mLock) &#123; //【*1.1.1】获得当前的实际时间点； final long timeNow = checkAndGetTimeLocked(); final long elapsedRealtime = SystemClock.elapsedRealtime(); //【*1.1.2】将 UsageEvents 的时间戳转为系统时间； convertToSystemTimeLocked(event); //【*1.1.3】获得 userId 的使用信息； final UserUsageStatsService service = getUserDataAndInitializeIfNeededLocked(userId, timeNow); //【*1.1.4】判断 event 所属应用当前是否处于 idle 状态！ final boolean previouslyIdle = mAppIdleHistory.isIdleLocked( event.mPackage, userId, elapsedRealtime); //【1】调用了 UserUsageStatsService 的 reportEvent 方法记录该 event！ service.reportEvent(event); //【2】如果本次的 event type 是如下类型，进入下面的 IF 分支！ if ((event.mEventType == Event.MOVE_TO_FOREGROUND || event.mEventType == Event.MOVE_TO_BACKGROUND || event.mEventType == Event.SYSTEM_INTERACTION || event.mEventType == Event.USER_INTERACTION)) &#123; //【×1.1.6】更新下 app idle 信息！ mAppIdleHistory.reportUsageLocked(event.mPackage, userId, elapsedRealtime); //【2.1】如果之前是 idle 状态，此时退出 idle 状态！ if (previouslyIdle) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, userId, /* idle = */ 0, event.mPackage)); notifyBatteryStats(event.mPackage, userId, false); &#125; &#125; &#125;&#125; 对于 UserUsageStatsService.reportEvent 方法，这里不再多说！ 1.1.1 UsageStatsService.checkAndGetTimeLockedcheckAndGetTimeLocked 方法用于计算当前的实际时间！ 1234567891011121314151617181920212223242526private long checkAndGetTimeLocked() &#123; //【1】获得当前的系统时间，可以被系统设置修改； final long actualSystemTime = System.currentTimeMillis(); //【2】获得自开机后，经过的时间，包括深度睡眠的时间； final long actualRealtime = SystemClock.elapsedRealtime(); final long expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot; final long diffSystemTime = actualSystemTime - expectedSystemTime; //【3】判断时间是否有发生变化， if (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123; // The time has changed. Slog.i(TAG, \"Time changed in UsageStats by \" + (diffSystemTime / 1000) + \" seconds\"); final int userCount = mUserState.size(); for (int i = 0; i &lt; userCount; i++) &#123; final UserUsageStatsService service = mUserState.valueAt(i); //【3.1】更新本地数据！ service.onTimeChanged(expectedSystemTime, actualSystemTime); &#125; //【3.2】记录本次的时间点到 mRealTimeSnapshot，mSystemTimeSnapshot！ mRealTimeSnapshot = actualRealtime; mSystemTimeSnapshot = actualSystemTime; &#125; //【4】返回当前的实际时间！ return actualSystemTime;&#125; 可以看到 checkAndGetTimeLocked 返回的时间是 actualSystemTime 的值，也就是 System.currentTimeMillis()，这个时间值可以被系统设置修改，然后值就会发生跳变，比如联网对时，手动调时！ 而 actualRealtime 的值为 System.elapsedRealtime 自开机后，经过的时间，包括深度睡眠的时间，这部分时间值是不会被修改； 如果判断时间是否有发生调时，对时情况呢？ mSystemTimeSnapshot 中保存的是上一次 check 时的系统时间； mRealTimeSnapshot 中保存的是上一次 check 时的自开机后，经过的时间； 先计算出期望的时间： 本次距离开机的时间 actualRealtime - 上次距离开机的时间 mRealTimeSnapshot，这个时间差值是正常情况下的时间差值； 然后再加上上一次 check 时的系统时间 mSystemTimeSnapshot，如果没有发生调时的话，这个应该是理想的时间点 expectedSystemTime； 如果发生了调时，对时的情况，actualSystemTime 一定是会发生变化的！ 计算 actualSystemTime 和 expectedSystemTime 的差值，如果大于 TIME_CHANGE_THRESHOLD_MILLIS，说明铁定发生了调时，对时； 如果发生上述情况，那就调用 UserUsageStatsService.onTimeChanged 更新本地持久化文件的日期！ 对于 UsageStatsService 是如何存储应用数据，如何更新本地持久化文件的，这里我先不关注，我们只需要知道，该方法返回的时间值是实际的时间（正常，手动调时，联网对时） 对于 service.onTimeChanged 方法，这里不再分析！ 1.1.2 AppIdleHistory.convertToSystemTimeLockedUsageEvents.Event 的 mTimeStamp 是在设置的时候，是通过 SystemClock.elapsedRealtime() 计算的；123private void convertToSystemTimeLocked(UsageEvents.Event event) &#123; event.mTimeStamp = Math.max(0, event.mTimeStamp - mRealTimeSnapshot) + mSystemTimeSnapshot;&#125; convertToSystemTimeLocked 的作用是： 将相对于开机的时间转为系统时间：SystemClock.elapsedRealtime() -&gt; SystemClock.currentTimeMillis()! 1.1.3 UsageStatsS.getUserDataAndInitializeIfNeededLocked尝试获得指定 userId 对应的 UserUsageStatsService 对象，封装了该 userId 的使用情况！ 1234567891011121314private UserUsageStatsService getUserDataAndInitializeIfNeededLocked(int userId, long currentTimeMillis) &#123; //【1】尝试获得 userId 对应的使用情况 UserUsageStatsService service = mUserState.get(userId); //【1.1.3.1】如果为 null，那就默认会初始化一个！ if (service == null) &#123; service = new UserUsageStatsService(getContext(), userId, new File(mUsageStatsDir, Integer.toString(userId)), this); service.init(currentTimeMillis); mUserState.put(userId, service); &#125; //【3】返回对应的 UserUsageStatsService 对象 return service;&#125; 这里要涉及到另外一个数据结构 UserUsageStatsService，UserUsageStatsService 用于保存每个 userId 的使用情况！ UsageStatsService 内部会通过 mUserState 来记录 userId 的使用情况：1private final SparseArray&lt;UserUsageStatsService&gt; mUserState = new SparseArray&lt;&gt;(); 1.1.3.1 new UserUsageStatsService创建一个 UserUsageStatsService 对象！12345678910UserUsageStatsService(Context context, int userId, File usageStatsDir, StatsUpdatedListener listener) &#123; mContext = context; mDailyExpiryDate = new UnixCalendar(0); mDatabase = new UsageStatsDatabase(usageStatsDir); mCurrentStats = new IntervalStats[UsageStatsManager.INTERVAL_COUNT]; mListener = listener; mLogPrefix = \"User[\" + Integer.toString(userId) + \"] \"; mUserId = userId;&#125; 1.1.4 AppIdleHistory.isIdleLocked判断在 elapsedRealtime 指定的时间点下，该 package 是否是 idle 状态！ 1234567891011121314public boolean isIdleLocked(String packageName, int userId, long elapsedRealtime) &#123; //【1.4.1】获得该 userId 下的历史信息！ ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId); //【1.4.2】获得该 pacakge 的历史信息 PackageHistory！ PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName, elapsedRealtime); //【3】如果 packageHistory，那就返回 false，默认为不处于 idle 状态！ if (packageHistory == null) &#123; return false; &#125; else &#123; //【1.1.4.1】判断该 package 是否属于 idle 状态！ return hasPassedThresholdsLocked(packageHistory, elapsedRealtime); &#125;&#125; 1.1.4.1 AppIdleHistory.hasPassedThresholdsLocked接下来看看系统是如何判断一个应用是否进入 idle 状态！123456private boolean hasPassedThresholdsLocked(PackageHistory packageHistory, long elapsedRealtime) &#123; return (packageHistory.lastUsedScreenTime &lt;= getScreenOnTimeLocked(elapsedRealtime) - mScreenOnTimeThreshold) &amp;&amp; (packageHistory.lastUsedElapsedTime &lt;= getElapsedTimeLocked(elapsedRealtime) - mElapsedTimeThreshold);&#125; 需要满足 2 个条件： 自开机时算起，当前时间距离应用上次被使用的时间（自开机时算起），超过了 24 小时！ 只算亮屏时间，当前时间距离应用上次被使用的时间（只算亮屏时间），超过了 12 小时！ 1.1.6 AppIdleHistory.reportUsageLocked根据 report event 的时间点，更新 app idle 相关的时间信息！ 12345678910111213public void reportUsageLocked(String packageName, int userId, long elapsedRealtime) &#123; ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId); PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName, elapsedRealtime); shiftHistoryToNow(userHistory, elapsedRealtime); //【1】自开机后，该应用最后一次使用的时间； packageHistory.lastUsedElapsedTime = mElapsedDuration + (elapsedRealtime - mElapsedSnapshot); //【2】在只计算亮屏时间的条件下，该应用最后一次使用的时间； packageHistory.lastUsedScreenTime = getScreenOnTimeLocked(elapsedRealtime); packageHistory.recent[HISTORY_SIZE - 1] = FLAG_LAST_STATE | FLAG_PARTIAL_ACTIVE;&#125; 我们看到，当每次 report event 后，会更新 PackageHistory 的如下两个变量： lastUsedElapsedTime：自开机后，应用最后一次被使用的时间； lastUsedScreenTime：只计算亮屏时间的情况下，应用最后一次被使用的时间； 2 消息：MSG_FLUSH_TO_DISK - OK2.0 消息触发时机在如下的情况下会触发 UsageStatsService.onStatsUpdated ： UserUsageStatsService.init 方法在加载完数据后，会将 LastEvent 为 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY 的 UsageStats 的 LastEvent 改为 END_OF_DAY，此时会触发 notifyStatsChanged 方法！ UserUsageStatsService.reportEvent 方法处理完上报的事件后，会触发 notifyStatsChanged 方法！ UserUsageStatsService.rolloverStats 方法一天时间过去会后，数据进行回滚后，会触发 notifyStatsChanged 方法！ 当 UserUsageStatsService 的 notifyStatsChanged 触发后，会触发 UsageStatsService.onStatsUpdated 方法：123456private void notifyStatsChanged() &#123; if (!mStatsChanged) &#123; mStatsChanged = true; mListener.onStatsUpdated(); &#125;&#125; 在 UsageStatsService.onStatsUpdated 方法中会发送 MSG_FLUSH_TO_DISK 消息！12345@Overridepublic void onStatsUpdated() &#123; //【1】延迟 20mins 发送 MSG_FLUSH_TO_DISK 消息！ mHandler.sendEmptyMessageDelayed(MSG_FLUSH_TO_DISK, FLUSH_INTERVAL);&#125; 这里延迟了 FLUSH_INTERVAL 时间间隔发送 MSG_FLUSH_TO_DISK 消息！12345static final boolean COMPRESS_TIME = false;private static final long TEN_SECONDS = 10 * 1000;private static final long TWENTY_MINUTES = 20 * 60 * 1000;private static final long FLUSH_INTERVAL = COMPRESS_TIME ? TEN_SECONDS : TWENTY_MINUTES; 由于 COMPRESS_TIME 为 false，所以是 20mins！ 最后进入 H：1234case MSG_FLUSH_TO_DISK: //【2.1】进入 flushToDisk 方法！ flushToDisk(); break; MSG_FLUSH_TO_DISK 消息用于将 App idle 的数据写入本地持久化文件！ 2.1 UsageStatsService.flushToDisk调用了 flushToDisk 方法：123456void flushToDisk() &#123; synchronized (mLock) &#123; //【2.2】调用了 flushToDiskLocked 方法！ flushToDiskLocked (); &#125;&#125; 继续来看： 2.2 UsageStatsService.flushToDiskLocked123456789101112131415161718private void flushToDiskLocked() &#123; final int userCount = mUserState.size(); for (int i = 0; i &lt; userCount; i++) &#123; UserUsageStatsService service = mUserState.valueAt(i); //【1】这里会调用 UserUsageStatsService.persistActiveStats 方法，将该 userId 下的最新 UsageStats 信息 // 持久化到本地文件！ service.persistActiveStats(); //【×2.3.1】将 app idle 的时间信息保存到本地文件！ mAppIdleHistory.writeAppIdleTimesLocked(mUserState.keyAt(i)); &#125; // Persist elapsed and screen on time. If this fails for whatever reason, the apps will be // considered not-idle, which is the safest outcome in such an event. //【×2.3.2】将 app idle 的时间间隔保存到本地文件！ mAppIdleHistory.writeAppIdleDurationsLocked(); mHandler.removeMessages(MSG_FLUSH_TO_DISK);&#125; 对于 UserUsageStatsService.persistActiveStats，这里我们不再分析，可以看 UserUsageStatsService 分析！ 2.2.1 AppIdleHistory.writeAppIdleTimesLocked将系统中的 app idle 信息保存到本地文件中！123456789101112131415161718192021222324252627282930313233343536373839public void writeAppIdleTimesLocked(int userId) &#123; FileOutputStream fos = null; //【1】目标文件 /data/system/users/&lt;userId&gt;/app_idle_stats.xml 文件 AtomicFile appIdleFile = new AtomicFile(getUserFile(userId)); try &#123; fos = appIdleFile.startWrite(); final BufferedOutputStream bos = new BufferedOutputStream(fos); FastXmlSerializer xml = new FastXmlSerializer(); xml.setOutput(bos, StandardCharsets.UTF_8.name()); xml.startDocument(null, true); xml.setFeature(\"http://xmlpull.org/v1/doc/features.html#indent-output\", true); xml.startTag(null, TAG_PACKAGES); // packages 标签 ArrayMap&lt;String,PackageHistory&gt; userHistory = getUserHistoryLocked(userId); final int N = userHistory.size(); for (int i = 0; i &lt; N; i++) &#123; //【1】遍历处理每一个 PackageHistory 对象！ String packageName = userHistory.keyAt(i); PackageHistory history = userHistory.valueAt(i); xml.startTag(null, TAG_PACKAGE); // package 标签 xml.attribute(null, ATTR_NAME, packageName); // name 标签 xml.attribute(null, ATTR_ELAPSED_IDLE, Long.toString(history.lastUsedElapsedTime)); // elapsedIdleTime 标签 xml.attribute(null, ATTR_SCREEN_IDLE, Long.toString(history.lastUsedScreenTime)); // screenIdleTime 标签 xml.endTag(null, TAG_PACKAGE); &#125; xml.endTag(null, TAG_PACKAGES); xml.endDocument(); appIdleFile.finishWrite(fos); &#125; catch (Exception e) &#123; appIdleFile.failWrite(fos); Slog.e(TAG, \"Error writing app idle file for user \" + userId); &#125;&#125; 我们来看看，保存后的文件内容：123&lt;packages&gt; &lt;package name=\"com.github.shadowsocks\" elapsedIdleTime=\"6836535861\" screenIdleTime=\"2173999944\" /&gt;&lt;/packages&gt; 2.2.2 AppIdleHistory.writeAppIdleDurationsLocked将系统中的屏幕亮灭时间信息保存到本地文件中！ 123456789public void writeAppIdleDurationsLocked() &#123; final long elapsedRealtime = SystemClock.elapsedRealtime(); // Only bump up and snapshot the elapsed time. Don't change screen on duration. mElapsedDuration += elapsedRealtime - mElapsedSnapshot; mElapsedSnapshot = elapsedRealtime; //【2.2.2.1】调用 writeScreenOnTimeLocked 方法！ writeScreenOnTimeLocked();&#125; 2.2.2.1 AppIdleHistory.writeScreenOnTimeLocked1234567891011121314private void writeScreenOnTimeLocked() &#123; //【1】目标文件： /data/system/screen_on_time AtomicFile screenOnTimeFile = new AtomicFile(getScreenOnTimeFile()); FileOutputStream fos = null; try &#123; fos = screenOnTimeFile.startWrite(); //【2】将 mScreenOnDuration 和 mElapsedDuration 写入到 screen_on_time 文件中！ fos.write((Long.toString(mScreenOnDuration) + \"\\n\" + Long.toString(mElapsedDuration) + \"\\n\").getBytes()); screenOnTimeFile.finishWrite(fos); &#125; catch (IOException ioe) &#123; screenOnTimeFile.failWrite(fos); &#125;&#125; 我们来看看 /data/system/screen_on_time 文件内容！1222013518826898458370 3 消息：MSG_REMOVE_USER - OK1234case MSG_REMOVE_USER: //【3.1】调用 onUserRemoved 方法！ onUserRemoved(msg.arg1); break; 3.0 消息触发机制UsageStatsService 内部有一个广播接收者 UserActionsReceiver，用于监听 User 相关的广播！ 1234567891011121314151617private class UserActionsReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1); final String action = intent.getAction(); //【1】监听到 User 被移除的广播！ if (Intent.ACTION_USER_REMOVED.equals(action)) &#123; if (userId &gt;= 0) &#123; mHandler.obtainMessage(MSG_REMOVE_USER, userId, 0).sendToTarget(); &#125; &#125; else if (Intent.ACTION_USER_STARTED.equals(action)) &#123; if (userId &gt;=0) &#123; postCheckIdleStates(userId); &#125; &#125; &#125;&#125; 当其接收到用户被移除的广播，接受到被启动的 UserId，会发送 MSG_REMOVE_USER 消息! 3.1 UsageStatsService.onUserRemoved这里调用了 onUserRemoved 方法，我们去看看该方法的逻辑：1234567891011void onUserRemoved(int userId) &#123; synchronized (mLock) &#123; Slog.i(TAG, \"Removing user \" + userId + \" and all data.\"); //【1】从 mUserState 中移除该 userId 对应的 UserUsageStatsService 实例； mUserState.remove(userId); //【3.1.1】从 AppIdleHistory 中移除该 userId 下的 app idle 信息； mAppIdleHistory.onUserRemoved(userId); //【3】清楚被移除的 userId 对应的 UsageStats 信息！ cleanUpRemovedUsersLocked(); &#125;&#125; 3.1.1 AppIdleHistory.onUserRemoved123public void onUserRemoved(int userId) &#123; mIdleHistory.remove(userId);&#125; 流程很简单，不多说了！ 4 消息：MSG_INFORM_LISTENERS - OK4.0 消息触发时机123case MSG_INFORM_LISTENERS: informListeners((String) msg.obj, msg.arg1, msg.arg2 == 1); break; 4.1 UsageStatsService.informListenersinformListeners 用于通知那件监听 app idle 的应用，app idle 状态的变化！12345void informListeners(String packageName, int userId, boolean isIdle) &#123; for (AppIdleStateChangeListener listener : mPackageAccessListeners) &#123; listener.onAppIdleStateChanged(packageName, userId, isIdle); &#125;&#125; 逻辑很见简单，不多说了！ 5 消息：MSG_FORCE_IDLE_STATE5.0 消息触发时机当 BinderService 的 setAppInactive 方法触发后！ 1234567891011121314151617181920212223242526private final class BinderService extends IUsageStatsManager.Stub &#123; @Override public void setAppInactive(String packageName, boolean idle, int userId) &#123; final int callingUid = Binder.getCallingUid(); try &#123; userId = ActivityManagerNative.getDefault().handleIncomingUser( Binder.getCallingPid(), callingUid, userId, false, true, \"setAppIdle\", null); &#125; catch (RemoteException re) &#123; throw re.rethrowFromSystemServer(); &#125; getContext().enforceCallingPermission(Manifest.permission.CHANGE_APP_IDLE_STATE, \"No permission to change app idle state\"); final long token = Binder.clearCallingIdentity(); try &#123; final int appId = getAppId(packageName); if (appId &lt; 0) return; //【1】调用了 UsageStatsService.setAppIdle 方法！ UsageStatsService.this.setAppIdle(packageName, idle, userId); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125;&#125; UsageStatsService.setAppIdle 会发送 MSG_FORCE_IDLE_STATE 消息给 H:123456void setAppIdle(String packageName, boolean idle, int userId) &#123; if (packageName == null) return; mHandler.obtainMessage(MSG_FORCE_IDLE_STATE, userId, idle ? 1 : 0, packageName) .sendToTarget();&#125; 我们来看看 H 对于消息 MSG_FORCE_IDLE_STATE 的处理：1234case MSG_FORCE_IDLE_STATE: //【5.1】调用 forceIdleState 将 app 设置为 idle 状态！ forceIdleState((String) msg.obj, msg.arg1, msg.arg2 == 1); break; 5.1 UsageStatsService.forceIdleState设置 app 进入 idle 状态： 12345678910111213141516171819202122232425262728void forceIdleState(String packageName, int userId, boolean idle) &#123; final int appId = getAppId(packageName); if (appId &lt; 0) return; synchronized (mLock) &#123; final long elapsedRealtime = SystemClock.elapsedRealtime(); //【×6.1.1】判断 app 之前是否处于 idle 状态！ final boolean previouslyIdle = isAppIdleFiltered(packageName, appId, userId, elapsedRealtime); //【×5.1.1】设置 app 的 idle 的状态！ mAppIdleHistory.setIdleLocked(packageName, userId, idle, elapsedRealtime); //【×6.1.1】判断 app 之前现在是否处于 idle 状态！ final boolean stillIdle = isAppIdleFiltered(packageName, appId, userId, elapsedRealtime); //【1】当前后 app idle 状态发生了变化，那就通知监听 app idle 的监听者！ if (previouslyIdle != stillIdle) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, userId, /* idle = */ stillIdle ? 1 : 0, packageName)); //【5.1.2】如果此时不处于 idle 状态，通知 PowerManagerService，此时退出了 idle 状态！ if (!stillIdle) &#123; notifyBatteryStats(packageName, userId, idle); &#125; &#125; &#125;&#125; 5.1.1 AppIdleHistory.setIdleLocked设置 package 的 idle 状态！123456789101112public void setIdleLocked(String packageName, int userId, boolean idle, long elapsedRealtime) &#123; //【1】同样先获得该 userId 下该 packageName 的 PackageHistory 对象！ ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId); PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName, elapsedRealtime); //【5.1.1.1】设置 package 上一次被使用的时间 packageHistory.lastUsedElapsedTime = getElapsedTimeLocked(elapsedRealtime) - mElapsedTimeThreshold; packageHistory.lastUsedScreenTime = getScreenOnTimeLocked(elapsedRealtime) - (idle ? mScreenOnTimeThreshold : 0) - 1000 /* just a second more */;&#125; 对于 getUserHistoryLocked 和 getPackageHistoryLocked 我们不再重新分析！ 5.1.1.1 AppIdleHistory.getElapsedTimeLocked123private long getElapsedTimeLocked(long elapsedRealtime) &#123; return (elapsedRealtime - mElapsedSnapshot + mElapsedDuration);&#125; 5.1.1.2 AppIdleHistory.getScreenOnTimeLocked获得亮屏的总时长！ 1234567public long getScreenOnTimeLocked(long elapsedRealtime) &#123; long screenOnTime = mScreenOnDuration; if (mScreenOn) &#123; screenOnTime += elapsedRealtime - mScreenOnSnapshot; &#125; return screenOnTime;&#125; 如果此时亮屏 mScreenOn 为 true，那么会在 mScreenOnDuration 基础上，再加上当前时间减去上次亮屏的时间点 mScreenOnSnapshot！ 5.1.2 UsageStatsService.notifyBatteryState通知 PowerManagerService，app 退出了 idle 状态！ 1234567891011121314private void notifyBatteryStats(String packageName, int userId, boolean idle) &#123; try &#123; final int uid = mPackageManager.getPackageUidAsUser(packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, userId); if (idle) &#123; mBatteryStats.noteEvent(BatteryStats.HistoryItem.EVENT_PACKAGE_INACTIVE, packageName, uid); &#125; else &#123; mBatteryStats.noteEvent(BatteryStats.HistoryItem.EVENT_PACKAGE_ACTIVE, packageName, uid); &#125; &#125; catch (NameNotFoundException | RemoteException e) &#123; &#125;&#125; 6 消息：MSG_CHECK_IDLE_STATES1234567case MSG_CHECK_IDLE_STATES: if (checkIdleStates(msg.arg1)) &#123; mHandler.sendMessageDelayed(mHandler.obtainMessage( MSG_CHECK_IDLE_STATES, msg.arg1, 0), mCheckIdleIntervalMillis); &#125; break; 6.0 消息触发机制UsageStatsService 内部有一个广播接收者 UserActionsReceiver，用于监听 User 相关的广播！ 1234567891011121314151617private class UserActionsReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1); final String action = intent.getAction(); if (Intent.ACTION_USER_REMOVED.equals(action)) &#123; if (userId &gt;= 0) &#123; mHandler.obtainMessage(MSG_REMOVE_USER, userId, 0).sendToTarget(); &#125; &#125; else if (Intent.ACTION_USER_STARTED.equals(action)) &#123; //【1】监听到 User 被启动的广播！ if (userId &gt;=0) &#123; postCheckIdleStates(userId); &#125; &#125; &#125;&#125; 当其接收到用户被启动的广播，接受到被启动的 UserId：123void postCheckIdleStates(int userId) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_CHECK_IDLE_STATES, userId, 0));&#125; MSG_CHECK_IDLE_STATES 用于检查指定 userid 下的 app idle 状态： 12345678case MSG_CHECK_IDLE_STATES: //【*6.1】调用 checkIdleStates 方法，检查 app idle 信息！ if (checkIdleStates(msg.arg1)) &#123; mHandler.sendMessageDelayed(mHandler.obtainMessage( MSG_CHECK_IDLE_STATES, msg.arg1, 0), mCheckIdleIntervalMillis); &#125; break; checkIdleStates 返回 true 表示检查操作完成，那么就会设置下一次的 check idle 的消息的发送时间，延迟 mCheckIdleIntervalMillis 8 hours 后再次发送 MSG_CHECK_IDLE_STATES 消息！ 关于 mCheckIdleIntervalMillis 的取值，可以看下 SettingsObserver 相关代码！ 6.1 UsageStatsService.checkIdleStatescheckIdleStates 方法用于检查当前时间系统中 app idle 的状态，同时更新 AppIdleHistory 中的数据！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667boolean checkIdleStates(int checkUserId) &#123; //【1】如果 mAppIdleEnabled 为 false，说明系统没有打开 device idle 状态！ if (!mAppIdleEnabled) &#123; return false; &#125; //【2】获得系统中正在运行中的 UserId！ // 如果要检查的 userId 不是 UserHandle.USER_ALL(所有用户)，并且也不是系统中正在运行的 userId // 那就返回 false； final int[] runningUserIds; try &#123; runningUserIds = ActivityManagerNative.getDefault().getRunningUserIds(); if (checkUserId != UserHandle.USER_ALL &amp;&amp; !ArrayUtils.contains(runningUserIds, checkUserId)) &#123; return false; &#125; &#125; catch (RemoteException re) &#123; throw re.rethrowFromSystemServer(); &#125; final long elapsedRealtime = SystemClock.elapsedRealtime(); //【3】遍历收集到的所有正在运行中的 userId，如果指定的是所有用户 USER_ALL，那就检查所有的 userId // 否则，跳过那些不是 checkUserId 的 uid！ for (int i = 0; i &lt; runningUserIds.length; i++) &#123; final int userId = runningUserIds[i]; if (checkUserId != UserHandle.USER_ALL &amp;&amp; checkUserId != userId) &#123; continue; &#125; if (DEBUG) &#123; Slog.d(TAG, \"Checking idle state for user \" + userId); &#125; //【3.1】获得 userId 下的所有的 package 信息！ List&lt;PackageInfo&gt; packages = mPackageManager.getInstalledPackagesAsUser( PackageManager.MATCH_DISABLED_COMPONENTS, userId); final int packageCount = packages.size(); //【3.2】遍历处理 for (int p = 0; p &lt; packageCount; p++) &#123; final PackageInfo pi = packages.get(p); final String packageName = pi.packageName; //【*6.1.1】判断当前时间下，该 package 是否处于 idle 状态！ final boolean isIdle = isAppIdleFiltered(packageName, UserHandle.getAppId(pi.applicationInfo.uid), userId, elapsedRealtime); //【*4】发送 MSG_INFORM_LISTENERS 消息给，通知 app idle 监听者！ mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, userId, isIdle ? 1 : 0, packageName)); if (isIdle) &#123; synchronized (mLock) &#123; //【*6.1.2】如果 package 应该处于 idle 状态的话，那就通过 AppIdleHistory 记录下来！ mAppIdleHistory.setIdle(packageName, userId, elapsedRealtime); &#125; &#125; &#125; &#125; if (DEBUG) &#123; Slog.d(TAG, \"checkIdleStates took \" + (SystemClock.elapsedRealtime() - elapsedRealtime)); &#125; return true;&#125; 6.1.1 UsageStatsService.isAppIdleFilteredisAppIdleFiltered 方法用于过滤一些特殊的条件！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private boolean isAppIdleFiltered(String packageName, int appId, int userId, long elapsedRealtime) &#123; if (packageName == null) return false; //【1】如果不允许应用进入 idle 状态，显然，没有应用会处于 idle 状态！ if (!mAppIdleEnabled) &#123; return false; &#125; //【2】如果 appId 小于 FIRST_APPLICATION_UID，说明是系统应用，系统应用不能进入 idle 状态！ if (appId &lt; Process.FIRST_APPLICATION_UID) &#123; return false; &#125; //【3】如果包名是 \"android\"，不能处于 idle 状态！ if (packageName.equals(\"android\")) &#123; return false; &#125; if (mSystemServicesReady) &#123; try &#123; //【4】如果 package 在 doze 模式的白名单中，那就不能进入 app idle (app standby) 状态 if (mDeviceIdleController.isPowerSaveWhitelistExceptIdleApp(packageName)) &#123; return false; &#125; &#125; catch (RemoteException re) &#123; throw re.rethrowFromSystemServer(); &#125; //【5】接着处理一些特殊情况，满足条件，也不能处于 idle 状态！ if (isActiveDeviceAdmin(packageName, userId)) &#123; return false; &#125; if (isActiveNetworkScorer(packageName)) &#123; return false; &#125; if (mAppWidgetManager != null &amp;&amp; mAppWidgetManager.isBoundWidgetPackage(packageName, userId)) &#123; return false; &#125; if (isDeviceProvisioningPackage(packageName)) &#123; return false; &#125; &#125; //【*6.1.1.1】进入 isAppIdleUnfiltered 方法！ if (!isAppIdleUnfiltered(packageName, userId, elapsedRealtime)) &#123; return false; &#125; //【7】如果是运营商特权应用，不能进入 idle 状态！ if (isCarrierApp(packageName)) &#123; return false; &#125; return true;&#125; 接着来看 isAppIdleUnfiltered 方法！ 6.1.1.1 UsageStatsService.isAppIdleUnfilteredisAppIdleUnfiltered 方法是不过滤条件，直接读取数据，判断 app 是否处于 idle 状态！一般是先调用 isAppIdleFiltered 过滤特殊情况，然后再调用该方法：123456private boolean isAppIdleUnfiltered(String packageName, int userId, long elapsedRealtime) &#123; synchronized (mLock) &#123; //【×1.4】调用 isIdleLocked 判断是否是 idle 状态！ return mAppIdleHistory.isIdleLocked(packageName, userId, elapsedRealtime); &#125;&#125; 我们看到，是直接调用 AppIdleHistory.isIdleLocked 方法读取数据！ 对于 AppIdleHistory.isIdleLocked 方法，这里不再分析！ 6.1.2 AppIdleHistory.setIdle12345678910111213public void setIdle(String packageName, int userId, long elapsedRealtime) &#123; //【1】从 mIdleHistory 读取该 userId 下的 app idle 数据，如果 userId 对应的数据为 null； // 会做一次初始化，从本地文件读取数据！ ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId); //【*6.1.2.1】获得 packageName 对应的 packageHistory！ PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName, elapsedRealtime); //【*6.1.2.2】根据周期调整数据！！ shiftHistoryToNow(userHistory, elapsedRealtime); packageHistory.recent[HISTORY_SIZE - 1] &amp;= ~FLAG_LAST_STATE;&#125; 6.1.2.1 AppIdleHistory.getPackageHistoryLocked从指定的 userId 的 userHistory 获得该 package 的 PackageHistory 对象，如果没有就重新创建一个！ 123456789101112131415private PackageHistory getPackageHistoryLocked(ArrayMap&lt;String, PackageHistory&gt; userHistory, String packageName, long elapsedRealtime) &#123; PackageHistory packageHistory = userHistory.get(packageName); //【1】如果没有该 package 的历史信息，那就初始化一个！ if (packageHistory == null) &#123; packageHistory = new PackageHistory(); //【*6.1.2.1.1】初始化 lastUsedElapsedTime packageHistory.lastUsedElapsedTime = getElapsedTimeLocked(elapsedRealtime); //【*6.1.2.1.2】初始化 lastUsedScreenTime packageHistory.lastUsedScreenTime = getScreenOnTimeLocked(elapsedRealtime); userHistory.put(packageName, packageHistory); &#125; return packageHistory;&#125; 6.1.2.1.1 AppIdleHistory.getElapsedTimeLocked123private long getElapsedTimeLocked(long elapsedRealtime) &#123; return (elapsedRealtime - mElapsedSnapshot + mElapsedDuration);&#125; 6.1.2.1.2 AppIdleHistory.getScreenOnTimeLocked获得亮屏的总时长！ 1234567public long getScreenOnTimeLocked(long elapsedRealtime) &#123; long screenOnTime = mScreenOnDuration; if (mScreenOn) &#123; screenOnTime += elapsedRealtime - mScreenOnSnapshot; &#125; return screenOnTime;&#125; 如果此时亮屏 mScreenOn 为 true，那么会在 mScreenOnDuration 基础上，再加上当前时间减去上次亮屏的时间点 mScreenOnSnapshot！ 6.1.2.2 AppIdleHistory.shiftHistoryToNow12345678910111213141516171819202122232425262728private void shiftHistoryToNow(ArrayMap&lt;String, PackageHistory&gt; userHistory, long elapsedRealtime) &#123; //【1】计算本次周期！ long thisPeriod = elapsedRealtime / PERIOD_DURATION; // Has the period switched over? Slide all users' package histories if (mLastPeriod != 0 &amp;&amp; mLastPeriod &lt; thisPeriod &amp;&amp; (thisPeriod - mLastPeriod) &lt; HISTORY_SIZE - 1) &#123; int diff = (int) (thisPeriod - mLastPeriod); final int NUSERS = mIdleHistory.size(); for (int u = 0; u &lt; NUSERS; u++) &#123; userHistory = mIdleHistory.valueAt(u); for (PackageHistory idleState : userHistory.values()) &#123; // Shift left System.arraycopy(idleState.recent, diff, idleState.recent, 0, HISTORY_SIZE - diff); // Replicate last state across the diff for (int i = 0; i &lt; diff; i++) &#123; idleState.recent[HISTORY_SIZE - i - 1] = (byte) (idleState.recent[HISTORY_SIZE - diff - 1] &amp; FLAG_LAST_STATE); &#125; &#125; &#125; &#125; //【2】 mLastPeriod = thisPeriod;&#125; mLastPeriod 用来记录能够更新的周期！ 7 消息：MSG_ONE_TIME_CHECK_IDLE_STATES - OK7.1 消息触发时机 UsageStatsService.onBootPhase 1234567891011121314@Overridepublic void onBootPhase(int phase) &#123; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; ... ... ... ... if (mPendingOneTimeCheckIdleStates) &#123; postOneTimeCheckIdleStates(); &#125; mSystemServicesReady = true; &#125; else if (phase == PHASE_BOOT_COMPLETED) &#123; setChargingState(getContext().getSystemService(BatteryManager.class).isCharging()); &#125;&#125; 在 UsageStatsService 开机初始化的时候，会进行一次 app idle check！ SettingsObserver.onChange 12345@Overridepublic void onChange(boolean selfChange) &#123; updateSettings(); postOneTimeCheckIdleStates();&#125; 当数据库时间属性变化后！ UsageStatsService.onStatsReloaded 1234@Overridepublic void onStatsReloaded() &#123; postOneTimeCheckIdleStates();&#125; 这几种情况下，都是开机初始化，或者数据库配置更新，使用状态重新加载的情况，这些情况会导致 app idle 发生变化，所以需要重新 check idle！ 12345case MSG_ONE_TIME_CHECK_IDLE_STATES: mHandler.removeMessages(MSG_ONE_TIME_CHECK_IDLE_STATES); //【1】处理所有用户下的 app idle 检查操作！ checkIdleStates(UserHandle.USER_ALL); break; 7.2 UsageStatsService.postOneTimeCheckIdleStates123456789void postOneTimeCheckIdleStates() &#123; if (mDeviceIdleController == null) &#123; // Not booted yet; wait for it! mPendingOneTimeCheckIdleStates = true; &#125; else &#123; mHandler.sendEmptyMessage(MSG_ONE_TIME_CHECK_IDLE_STATES); mPendingOneTimeCheckIdleStates = false; &#125;&#125; MSG_ONE_TIME_CHECK_IDLE_STATES 也用于检查 device idle 状态！ 1234case MSG_ONE_TIME_CHECK_IDLE_STATES: mHandler.removeMessages(MSG_ONE_TIME_CHECK_IDLE_STATES); checkIdleStates(UserHandle.USER_ALL); break; 和 MSG_CHECK_IDLE_STATES 的区别是： MSG_ONE_TIME_CHECK_IDLE_STATES 只会检测一次，而 MSG_CHECK_IDLE_STATES 会持续检查！ MSG_ONE_TIME_CHECK_IDLE_STATES 会检查所有 user 下的 app idle 状态，而 MSG_CHECK_IDLE_STATES 是检查指定的 userId 下的 app idle 状态； 8 消息：MSG_CHECK_PAROLE_TIMEOUT该消息用于进入下一次假释状态！ 8.1 消息触发时机我们在 DeviceStateReceiver 接收者中，当接收到 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED 广播后，即 doze 模式发生了变化，我们会调用 onDeviceIdleModeChanged 方法！ 1234567891011121314151617181920212223void onDeviceIdleModeChanged() &#123; final boolean deviceIdle = mPowerManager.isDeviceIdleMode(); if (DEBUG) Slog.i(TAG, \"DeviceIdleMode changed to \" + deviceIdle); synchronized (mLock) &#123; //【1】计算距离上次退出假释状态过去的时间！ final long timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime; if (!deviceIdle &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123; //【1.1】如果当前不处于 device idle 状态，并且当前距离上次退出假释状态超过了 24 小时 // 那么我们会进入假释状态！ if (DEBUG) Slog.i(TAG, \"Bringing idle apps out of inactive state due to deviceIdleMode=false\"); setAppIdleParoled(true); &#125; else if (deviceIdle) &#123; if (DEBUG) Slog.i(TAG, \"Device idle, back to prison\"); //【1.2】如果当前处于 device idle 状态，那么无法进入假释状态！ setAppIdleParoled(false); &#125; &#125;&#125; UsageStatsService.setAppIdleParoled setAppIdleParoled 方法用于将 app 在 idle 的状态下唤醒进入假释状态，参数 boolean paroled 表示当前是否进入假释状态！ mAppIdleTempParoled 用于保存假释状态，boolean paroled 表示是否进入假释状态！123456789101112131415161718192021222324void setAppIdleParoled(boolean paroled) &#123; synchronized (mLock) &#123; if (mAppIdleTempParoled != paroled) &#123; //【1】缓存本次假释状态！ mAppIdleTempParoled = paroled; if (DEBUG) Slog.d(TAG, \"Changing paroled to \" + mAppIdleTempParoled); if (paroled) &#123; //【1.1】如果本次是进入假释，设置退出假释的超时消息！ postParoleEndTimeout(); &#125; else &#123; //【1.2】如果本次是退出假释，设置下一次进入假释的消息，即 24Hours 后！ // 保存上次退出假释的时间！ mLastAppIdleParoledTime = checkAndGetTimeLocked(); //【*8.1.1】设置进入下一次假释的消息！ postNextParoleTimeout(); &#125; //【common】处理假释状态的变化！ postParoleStateChanged(); &#125; &#125;&#125; 最后，调用了 postNextParoleTimeout 方法！ 8.1.1 UsageStatsService.postNextParoleTimeout123456789101112131415private void postNextParoleTimeout() &#123; if (DEBUG) Slog.d(TAG, \"Posting MSG_CHECK_PAROLE_TIMEOUT\"); mHandler.removeMessages(MSG_CHECK_PAROLE_TIMEOUT); //【1】在上次退出假释的时间基础上，加上 mAppIdleParoleIntervalMillis（24Hours） // 然后减去当前时间，得到延迟时间 timeLeft！ long timeLeft = (mLastAppIdleParoledTime + mAppIdleParoleIntervalMillis) - checkAndGetTimeLocked(); if (timeLeft &lt; 0) &#123; timeLeft = 0; &#125; //【2】延迟 timeLeft 发送 MSG_CHECK_PAROLE_TIMEOUT 消息！ mHandler.sendEmptyMessageDelayed(MSG_CHECK_PAROLE_TIMEOUT, timeLeft);&#125; 我么你可以看到，延迟发送 MSG_CHECK_PAROLE_TIMEOUT 的时间是剩余的等待时间！！ 我们来看看 H 对 MSG_CHECK_PAROLE_TIMEOUT 消息的处理：1234case MSG_CHECK_PAROLE_TIMEOUT: //【8.2】调用了 checkParoleTimeout 方法！ checkParoleTimeout(); break; 8.2 UsageStatsService.checkParoleTimeout当该消息触发后，进入 checkParoleTimeout 方法！ 1234567891011121314151617181920void checkParoleTimeout() &#123; synchronized (mLock) &#123; //【1】mAppIdleTempParoled 为 false，说明当前没有进入假释状态！ if (!mAppIdleTempParoled) &#123; //【1.1】计算距离上次退出假释模式，经过的时间！ final long timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime; if (timeSinceLastParole &gt; mAppIdleParoleIntervalMillis) &#123; if (DEBUG) Slog.d(TAG, \"Crossed default parole interval\"); //【1.1.1】距离上次退出假释模式经过的时间如果超过了 24 hours // 进入假释模式！ setAppIdleParoled(true); &#125; else &#123; if (DEBUG) Slog.d(TAG, \"Not long enough to go to parole\"); //【*8.1.1】当前不能进入假释模式，继续延迟！ postNextParoleTimeout(); &#125; &#125; &#125;&#125; 当距离上次退出假释模式经过的时间如果超过了 24 hours 后，会调用 setAppIdleParoled 方法进入假释模式！ 整个流程很简单，不多说了！ 9 消息：MSG_PAROLE_END_TIMEOUT该消息用于退出当前的假释状态！ 9.1 消息触发时机当 app 进入了假释状态时，会触发 setAppIdleParoled 方法，此时 boolean paroled 为 true！ 1234567891011121314151617void setAppIdleParoled(boolean paroled) &#123; synchronized (mLock) &#123; if (mAppIdleTempParoled != paroled) &#123; //【1】更新 mAppIdleTempParoled mAppIdleTempParoled = paroled; if (DEBUG) Slog.d(TAG, \"Changing paroled to \" + mAppIdleTempParoled); if (paroled) &#123; //【1.1】调用 postParoleEndTimeout 设置退出假释状态的 postParoleEndTimeout(); &#125; else &#123; mLastAppIdleParoledTime = checkAndGetTimeLocked(); postNextParoleTimeout(); &#125; postParoleStateChanged(); &#125; &#125;&#125; UsageStatsService.postParoleEndTimeout123456private void postParoleEndTimeout() &#123; if (DEBUG) Slog.d(TAG, \"Posting MSG_PAROLE_END_TIMEOUT\"); //【1】延迟 10mins，发送 MSG_PAROLE_END_TIMEOUT 消息，退出假释模式！ mHandler.removeMessages(MSG_PAROLE_END_TIMEOUT); mHandler.sendEmptyMessageDelayed(MSG_PAROLE_END_TIMEOUT, mAppIdleParoleDurationMillis);&#125; mAppIdleParoleDurationMillis 值为 10mins！ 我们来看看 H 是如处理该消息的：12345case MSG_PAROLE_END_TIMEOUT: if (DEBUG) Slog.d(TAG, \"Ending parole\"); //【1】调用了 setAppIdleParoled 退出假释模式，同时设置下一次进入假释的消息！ setAppIdleParoled(false); break; 10 消息：MSG_REPORT_CONTENT_PROVIDER_USAGE - OK10.0 消息触发时机当 ActivityManagerService 触发了 LocalService 下面的方法时： 1234567891011121314 private final class LocalService extends UsageStatsManagerInternal &#123; @Override public void reportContentProviderUsage(String name, String packageName, int userId) &#123; SomeArgs args = SomeArgs.obtain(); args.arg1 = name; args.arg2 = packageName; args.arg3 = userId; //【1】发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 消息 mHandler.obtainMessage(MSG_REPORT_CONTENT_PROVIDER_USAGE, args) .sendToTarget(); &#125; &#125;&#125; 会发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 消息！上报 ContentProvider 的使用情况！ 12345678case MSG_REPORT_CONTENT_PROVIDER_USAGE: SomeArgs args = (SomeArgs) msg.obj; //【10.1】调用了 reportContentProviderUsage 方法！ reportContentProviderUsage((String) args.arg1, // authority name (String) args.arg2, // package name (int) args.arg3); // userId args.recycle(); break; 10.1 UsageStatsService.reportContentProviderUsage12345678910111213141516171819202122void reportContentProviderUsage(String authority, String providerPkgName, int userId) &#123; //【1】获得同步适配器！ String[] packages = ContentResolver.getSyncAdapterPackagesForAuthorityAsUser( authority, userId); for (String packageName: packages) &#123; //【2】如果同步适配器是系统 package，同时 provider 并没有在相同的 package 中 // 那么，我们需要强制将同步适配器所在的 package 设置为 active 状态！ try &#123; PackageInfo pi = mPackageManager.getPackageInfoAsUser( packageName, PackageManager.MATCH_SYSTEM_ONLY, userId); if (pi == null || pi.applicationInfo == null) &#123; continue; &#125; if (!packageName.equals(providerPkgName)) &#123; //【*5.1】调用了 forceIdleState 方法！ forceIdleState(packageName, userId, false); &#125; &#125; catch (NameNotFoundException e) &#123; // Shouldn't happen &#125; &#125;&#125; 对于 forceIdleState 方法，请看 5.1 节！ 11 消息：MSG_PAROLE_STATE_CHANGED当应用的假释状态发生变化后，会发送该消息！ 11.1 消息触发时机 UsageStatsService.setChargingState 当充电状态发生变化时，会触发 postParoleStateChanged 方法！123456789void setChargingState(boolean charging) &#123; synchronized (mLock) &#123; if (mCharging != charging) &#123; mCharging = charging; //【*11.1.1-common】当充电状态发生变化后，处理假释状态的变化！ postParoleStateChanged(); &#125; &#125;&#125; 我们在 UsageStatsService.onBootPhase 方法中会初始化下开机时的充电状态，这时候会调用 setChargingState 方法！ 同时，我们在 DeviceStateReceiver 接收者中，当接收到 Intent.ACTION_BATTERY_CHANGED 广播后，我们会调用 setChargingState 方法！ UsageStatsService.setAppIdleParoled 我们在 DeviceStateReceiver 接收者中，当接收到 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED 广播后，即 doze 模式发生了变化，我们会调用 onDeviceIdleModeChanged 方法！ 1234567891011121314151617181920void onDeviceIdleModeChanged() &#123; final boolean deviceIdle = mPowerManager.isDeviceIdleMode(); if (DEBUG) Slog.i(TAG, \"DeviceIdleMode changed to \" + deviceIdle); synchronized (mLock) &#123; final long timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime; if (!deviceIdle &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123; //【1】如果当前不处于 device idle 状态，并且当前距离上次假释状态超过了 24 小时 // 那么我们会进入假释状态！ if (DEBUG) Slog.i(TAG, \"Bringing idle apps out of inactive state due to deviceIdleMode=false\"); setAppIdleParoled(true); &#125; else if (deviceIdle) &#123; if (DEBUG) Slog.i(TAG, \"Device idle, back to prison\"); //【2】如果当前处于 device idle 状态，那么无法进入假释状态！ setAppIdleParoled(false); &#125; &#125;&#125; setAppIdleParoled 方法用于将 app 在 idle 的状态下唤醒进入假释状态，参数 boolean paroled 表示当前是否进入假释状态！ mAppIdleTempParoled 用于保存假释状态！12345678910111213141516171819202122void setAppIdleParoled(boolean paroled) &#123; synchronized (mLock) &#123; if (mAppIdleTempParoled != paroled) &#123; //【1】缓存本次假释状态！ mAppIdleTempParoled = paroled; if (DEBUG) Slog.d(TAG, \"Changing paroled to \" + mAppIdleTempParoled); if (paroled) &#123; //【1.1】如果本次是进入假释，设置退出假释的超时消息！ postParoleEndTimeout(); &#125; else &#123; //【1.2】如果本次是退出假释，设置下一次进入假释的消息！ // 保存上次假释的最后时间！ mLastAppIdleParoledTime = checkAndGetTimeLocked(); postNextParoleTimeout(); &#125; //【*11.1.1-common】处理假释状态的变化！ postParoleStateChanged(); &#125; &#125;&#125; 最后，调用了 postParoleStateChanged 方法！ 11.1.1 UsageStatsService.postParoleStateChangedpostParoleStateChanged 会发送 MSG_PAROLE_STATE_CHANGED 消息给 H：12345private void postParoleStateChanged() &#123; if (DEBUG) Slog.d(TAG, \"Posting MSG_PAROLE_STATE_CHANGED\"); mHandler.removeMessages(MSG_PAROLE_STATE_CHANGED); mHandler.sendEmptyMessage(MSG_PAROLE_STATE_CHANGED);&#125; 我们去看看 H 是如何处理 MSG_PAROLE_STATE_CHANGED 消息的：123456case MSG_PAROLE_STATE_CHANGED: if (DEBUG) Slog.d(TAG, \"Parole state: \" + mAppIdleTempParoled + \", Charging state:\" + mCharging); //【*11.2】处理 app 假释状态改变的消息！ informParoleStateChanged(); break; 11.2 UsageStatsService.informParoleStateChanged当假释状态改变后，会通知所有的监听者！123456void informParoleStateChanged() &#123; final boolean paroled = isParoledOrCharging(); for (AppIdleStateChangeListener listener : mPackageAccessListeners) &#123; listener.onParoleStateChanged(paroled); &#125;&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"UsageStats使用状态管理","slug":"AndroidFramework源码分析/UsageStats使用状态管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/UsageStats使用状态管理/"}],"tags":[{"name":"UsageStats使用状态管理","slug":"UsageStats使用状态管理","permalink":"https://coolqi.top/tags/UsageStats使用状态管理/"}]},{"title":"Handler篇 5 - Message 源码分析","slug":"Handler5-messageSourceCode","date":"2017-03-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/03/13/Handler5-messageSourceCode/","link":"","permalink":"https://coolqi.top/2017/03/13/Handler5-messageSourceCode/","excerpt":"","text":"基于 Android 7.1.1 源码，分析 Message 的架构和原理。 1 成员变量1public int what; 用于标识 Message！ 12public int arg1;public int arg2; 用于传递简单的整型数据，如果想传递复杂的数据使用 Bundle 1public Object obj; 用于发送任意对象，如果要用 Message 进行跨进程通信，obj 必须实现序列化接口！ 1public Messenger replyTo; 用于跨进程双向通信，接受到该 message 的进程，可以通过 Message.replyTo 向发送方进程发送 message，从而实现双向通信！ 这个在分析 Messenger 的时候会看到！ 1public int sendingUid = -1; 发送方的 uid，只有在通过 Messenger 跨进程通信的时候才有效，否则为 -1； 1int flags; Message 的标志位，可以取如下的值； static final int FLAG_IN_USE = 1 &lt;&lt; 0：用于标识当前的 Message 处于使用状态，当 Message 处于消息队列中、处于消息池中或者 Handler 正在处理该 Message 的时候，它就处于使用状态； static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1：用于标识当前的 Message 是异步的； static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE：当调用 copyFrom 方法的时候，会去掉 FLAG_IN_USE 标志位！ 1long when; Message 的分发时间； 1Bundle data; 用于传输比较复杂的数据； 1Handler target; 表示消息的目标处理 Handler！ 1Runnable callback; 表示要处理的任务 Runnable，通过 handler post Runnable 的时候，Runnable 会被封装成一个 Message，如果要用 Message 进行跨进程通信，callback 必须为 null，因为其不能序列化！！ 12// sometimes we store linked lists of these thingsMessage next; 1private static final Object sPoolSync = new Object(); 用于同步的锁对象！ 1private static Message sPool; 静态变量，我们知道 Handler 发送过的 message 会被缓存到消息池中，方便复用，其实消息池也是一个列表，sPool 是这个链表的头元素！！ 1private static int sPoolSize = 0; 静态变量，用于记录消息池中 Message 的数量，也就是链表的长度，其最大不能超过 MAX_POOL_SIZE 规定的大小！ 1private static final int MAX_POOL_SIZE = 50; 消息池中 Message 的最大数量！ 1private static boolean gCheckRecycle = true; 2 create Message想要发送 Message，首先要创建 Message，创建分为 2 种： 直接创建； 复用已有消息； 下面我们来分别看看； 2.1 new Message直接创建，能够保证我们每次创建的都是一个新的消息对象： 12public Message() &#123;&#125; 构造器很简单，没有多么复杂，我们可以创建一个 Message 对象，然后设置它的属性：123456Message msg = new Message();Bundle b = new Bundle();b.putString(\"name\", \"coolqi\");b.putString(\"face\", \"cool\");msg.setData(b);mHandler.sendMessage(msg); 这里就不多说了！ 2.2 Message.obtain复用已有消息，我们知道 handler 会将发送过的消息，保存到一个消息池中，便于复用！ Message 提供了多个 obtain 用于复用一个 Message！ 123456789101112131415public static Message obtain() &#123;...&#125;public static Message obtain(Message orig) &#123;...&#125;public static Message obtain(Handler h) &#123;...&#125;public static Message obtain(Handler h, Runnable callback) &#123;...&#125;public static Message obtain(Handler h, int what) &#123;...&#125;public static Message obtain(Handler h, int what, Object obj) &#123;...&#125;public static Message obtain(Handler h, int what, int arg1, int arg2) &#123;...&#125;public static Message obtain(Handler h, int what, int arg1, int arg2, Object obj) &#123;...&#125; 上面的多个 obtain 都会先尝试从消息池中获取一个缓存的消息，如果找不到，再创建一个新的消息，然后用传入的参数更新这个消息对应的属性值，并返回！ 12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; // 每次都复用消息池的头消息！ Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // 清空 flag，不再为使用状态 sPoolSize--; return m; &#125; &#125; return new Message(); // 如果没有就创建一个新的消息！&#125; 代码很简单，不多了！ 3 recycle Message回收一个 Message 分为 2 种情况，一种是安全的回收，一种是不安全的回收！ 3.1 safe recycle安全的回收： 12345678910public void recycle() &#123; if (isInUse()) &#123; // 判断是否在使用中! if (gCheckRecycle) &#123; throw new IllegalStateException(\"This message cannot be recycled because it \" + \"is still in use.\"); &#125; return; &#125; recycleUnchecked(); // 不再使用了，回收！&#125; 安全回收在回收 Message 之前会先检查 Message 是否处于使用状态，处于使用状态下是不能回收的！！ recycle() 在判断安全后，会调用 recycleUnchecked() 进行回收！ 123/*package*/ boolean isInUse() &#123; return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);&#125; 上面的方法用于判断 Message 是否在使用中！ gCheckRecycle 属性在 SDK 21 以及以后默认为 true，他用来决定在回收时如果正在使用，是否抛出异常！ 123456/** @hide */public static void updateCheckRecycle(int targetSdkVersion) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123; gCheckRecycle = false; &#125;&#125; 上面是具体的判断方法！ 3.2 unsafe recycle不安全的回收： 123456789101112131415161718192021void recycleUnchecked() &#123; flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; // 如果消息池未满，将回收后的消息加入到消息池中！ next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 可以看到 recycleUnchecked() 会重置掉 Message 的属性！ 4 跨进程传输由于 Message 实现了 Parcelable 接口，所以可以序列化，跨进程传输数据，我们知道信使 Messenger 就是通过 Message 来实现跨进程通信的！ 4.1 writeToParcel序列化方法： 12345678910111213141516171819202122232425public void writeToParcel(Parcel dest, int flags) &#123; if (callback != null) &#123; // 如果消息的 callback 不为，不能序列化！ throw new RuntimeException( \"Can't marshal callbacks across processes.\"); &#125; dest.writeInt(what); dest.writeInt(arg1); dest.writeInt(arg2); if (obj != null) &#123; // 如果要传递任意对象，必须实现 Parcelable 接口！ try &#123; Parcelable p = (Parcelable)obj; dest.writeInt(1); dest.writeParcelable(p, flags); &#125; catch (ClassCastException e) &#123; throw new RuntimeException( \"Can't marshal non-Parcelable objects across processes.\"); &#125; &#125; else &#123; dest.writeInt(0); &#125; dest.writeLong(when); dest.writeBundle(data); Messenger.writeMessengerOrNullToParcel(replyTo, dest); // 针对于 Messenger 的特殊处理！ dest.writeInt(sendingUid);&#125; 如果 Message 设置了 Runnable callback，那么不能序列化！ 4.2 readFromParcel反序列化方法： 123456789101112private void readFromParcel(Parcel source) &#123; what = source.readInt(); arg1 = source.readInt(); arg2 = source.readInt(); if (source.readInt() != 0) &#123; obj = source.readParcelable(getClass().getClassLoader()); &#125; when = source.readLong(); data = source.readBundle(); replyTo = Messenger.readMessengerOrNullFromParcel(source); // 针对于 Messenger 的特殊处理！ sendingUid = source.readInt();&#125; 对于 Messenger 的内容，我们会单独开一篇文章来分析！ 5 其他方法Message 提供了一些其他的方法： copyFrom 用于将一个 Message 的属性 copy 到另一个 Message 中： 123456789101112131415public void copyFrom(Message o) &#123; this.flags = o.flags &amp; ~FLAGS_TO_CLEAR_ON_COPY_FROM; // 去掉 FLAG_IN_USE 标志位！ this.what = o.what; this.arg1 = o.arg1; this.arg2 = o.arg2; this.obj = o.obj; this.replyTo = o.replyTo; this.sendingUid = o.sendingUid; if (o.data != null) &#123; this.data = (Bundle) o.data.clone(); &#125; else &#123; this.data = null; &#125;&#125; 异步相关的方法： 1234567891011public boolean isAsynchronous() &#123; return (flags &amp; FLAG_ASYNCHRONOUS) != 0;&#125;public void setAsynchronous(boolean async) &#123; if (async) &#123; flags |= FLAG_ASYNCHRONOUS; &#125; else &#123; flags &amp;= ~FLAG_ASYNCHRONOUS; &#125;&#125; 以及一些其他的用于 get 属性，打印属性的方法，这里就不多说了！！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Handler线程消息机制","slug":"AndroidFramework源码分析/Handler线程消息机制","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Handler线程消息机制/"}],"tags":[{"name":"Handler线程消息机制","slug":"Handler线程消息机制","permalink":"https://coolqi.top/tags/Handler线程消息机制/"}]},{"title":"Binder跨进程通信 - 信使 Messenger","slug":"BinderIPC-Messenger","date":"2017-03-06T12:46:25.000Z","updated":"2018-11-20T15:45:30.000Z","comments":true,"path":"2017/03/06/BinderIPC-Messenger/","link":"","permalink":"https://coolqi.top/2017/03/06/BinderIPC-Messenger/","excerpt":"","text":"Android 已经内置了一些模板和工具类来帮助我们更好的实现跨进程通信，除了 aidl 模板，还有一个就是信使 Messenger，下面我们来分析下信使的原理！ 1 Messenger 源码分析Messenger 本质上是实现了 aidl 模板，aidl 文件名为 IMessenger.aidl，位于 android/frameworks/base/core/java/android/os/IMessenger.aidl 目录下： 12345678package android.os;import android.os.Message;/** @hide */oneway interface IMessenger &#123; void send(in Message msg);&#125; 同样的，该 aidl 会生成一个用于跨进程通信的接口！！ 123456789101112131415161718192021222324package android.os;public interface IMessenger extends IInterface &#123; void send(Message var1) throws RemoteException; // 用于创建服务端桩对象！ public abstract static class Stub extends Binder implements IMessenger &#123; public Stub() &#123; throw new RuntimeException(\"stub\"); &#125; public static IMessenger asInterface(IBinder var0) &#123; throw new RuntimeException(\"stub\"); &#125; public IBinder asBinder() &#123; throw new RuntimeException(\"stub\"); &#125; public boolean onTransact(int var1, Parcel var2, Parcel var3, int var4) throws RemoteException &#123; throw new RuntimeException(\"stub\"); &#125; &#125;&#125; 一切又是那么熟悉，下面我们重点分析 Messenger 是如何封装的！ 1.1 Messenger create创建 Messenger 的方法有如下 2 种： 12public Messenger(IBinder target) &#123;...&#125;public Messenger(Handler target) &#123;...&#125; 参数不同，作用和目的也不同！ 1.1.1 create with IBinder下面我们来看第一个构造器： 123public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target);&#125; 第一个构造器很简单，和使用 aidl 模板很相似：1mTarget = IMessenger.Stub.asInterface(target); 其实就是通过 asInterface 将服务端转为一个代理对象，保存到内部的成员变量 mTarget 中！ 其实我们类比 aidl 模板，要实现跨进程通信，服务端需要有一个桩对象，客户端需要有其对应的代理对象！ 所以，以 IBinder target 为参数的构造器用于跨进程通信的客户端进程，用以生成客户端代理对象！ 1.1.2 create with Handler下面我们来看看第二个构造器： 123public Messenger(Handler target) &#123; mTarget = target.getIMessenger();&#125; 这里调用了 Handler.getIMessenger() 方法： 1234567891011final IMessenger getIMessenger() &#123; synchronized (mQueue) &#123; if (mMessenger != null) &#123; return mMessenger; &#125; //【1】这里会创建一个 MessengerImpl 实例！ mMessenger = new MessengerImpl(); return mMessenger; &#125;&#125; IMessenger mMessenger 是 Handler 内部的一个变量，getIMessenger() 方法会创建 MessengerImpl 实例！ 123456789private final class MessengerImpl extends IMessenger.Stub &#123; public void send(Message msg) &#123; msg.sendingUid = Binder.getCallingUid(); //【1】MessengerImpl 为 Handler 的内部类，持有外部类的引用！ // 调用 Handler.sendMessage 方法！ Handler.this.sendMessage(msg); &#125;&#125; 其实，可以看到 MessengerImpl 继承了 IMessenger.Stub 抽象类，并实现了其 send 方法，就是调用 Handler 的 sendMessage 方法！ 类比 aidl 模板，以 Handler target 为参数的构造器用于跨进程通信的服务端进程，用以生成服务端 “桩” 对象！ 123public IBinder getBinder() &#123; return mTarget.asBinder();&#125; 同时，Messenger 也会提供一个 getBinder()，用于获得用于通信的 IBinder 实例！ 1.2 Messenger sendMessenger 是通过 Message 来封装通信数据的，因为 Message 实现了 Parcelable 接口，可以序列化，跨进程传输！ 123public void send(Message message) throws RemoteException &#123; mTarget.send(message);&#125; send 方法很简单，只需要调用内部的 IMessenger mTarget 的 send 方法，那么服务端的 MessengerImpl.send 方法会调用，最终触发 2 Messenger 序列化处理Messenger 实现了 Parcelable 接口，因此可以序列化，而使用 Messenger 进行双向通信，正式依赖于序列化的特性，下面我们来看下： Messenger 内部定义了 2 个方法，来实现序列化！ 2.1 writeMessengerOrNullToParcel123456789public void writeToParcel(Parcel out, int flags) &#123; out.writeStrongBinder(mTarget.asBinder());&#125;public static void writeMessengerOrNullToParcel(Messenger messenger, Parcel out) &#123; out.writeStrongBinder(messenger != null ? messenger.mTarget.asBinder() : null);&#125; 我们可以看到，我们写入到 Parcel out 中的并不是我们的 Messenger 对象，而是 messenger.mTarget.asBinder()！！ 2.1 readMessengerOrNullFromParcel1234public static Messenger readMessengerOrNullFromParcel(Parcel in) &#123; IBinder b = in.readStrongBinder(); return b != null ? new Messenger(b) : null;&#125; 同样的，当我们从 Parcel out 中读取时，Messenger 又帮我们做了一些的处理，调用了构造器：Messenger(IBinder target)，通过传递过来的 IBinder 对象，创建客户端 Messenger 对象！ 可以看到，Messenger 序列化传递过程中，利用了序列化的特性，自动帮我们是实现了代理和装对象的转换！ 3 Messenger 的使用下面列出 Messenger 使用的核心代码，这里我会使用一个 3.1 服务端实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MServerService extends Service &#123; private static final String TAG = \"MServerService\"; private Messenger mSMessenger = null; private HandlerThread mThread = null; private MyHandler mHandler = null; @Override public void onCreate() &#123; super.onCreate(); mThread = new HandlerThread(\"Messenger\", Thread.MIN_PRIORITY); mThread.start(); mHandler = new MyHandler(mThread.getLooper()); //【关键代码】创建 Messenger 传入指定的 Handler！ mSMessenger = new Messenger(mHandler); &#125; @Override public IBinder onBind(Intent intent) &#123; if (mSMessenger == null) &#123; mSMessenger = new Messenger(mHandler); &#125; //【关键代码】调用 Messenger.getBinder() 方法！ return mSMessenger.getBinder(); &#125; class MyHandler extends Handler &#123; public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: Log.d(TAG, \"BIND SUCCESSFUL\"); //【关键代码】客户端注册，然后回调 Message msgR = new Message(); msgR.what = 2; try &#123; mtoCMessenger = msg.replyTo; mtoCMessenger.send(msgR); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: break; &#125; &#125; &#125;&#125; 3.2 客户端实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MClientActivity extends Activity &#123; private static final String TAG = \"MClientActivity\"; private Messenger mtoSProxy; private Messenger mCMessenger; private CHandler mHandler; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //【关键代码】bind 成功，同时客户端注册！ mtoSProxy = new Messenger(service); sendMessage(mtoSProxy); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mtoSProxy = null; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_aidl); //【关键代码】创建服务端的 Messenger！ mHandler = new CHandler(getMainLooper()); mCMessenger = new Messenger(mHandler); bindMServerService(); &#125; private void bindMServerService() &#123; Intent intent = new Intent(); intent.setClass(this, MServerService.class); bindService(intent, mConnection, BIND_AUTO_CREATE); &#125; private void sendMessage(Messenger proxy) &#123; try &#123; //【关键代码】bind 成功，注册客户端的 Messenger Message msg = new Message(); msg.what = 1; msg.replyTo = mCMessenger; proxy.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; static class CHandler extends Handler &#123; public CHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 2: Log.d(TAG, \"REGISTER SUCCESSFUL\"); break; default: break; &#125; &#125; &#125; 代码很简单，就不多说了！ 4 总结Messenger 本质上是对 AIDL 模板的封装，通过 Messenger 我们可以实现基于消息的跨进程通信！ 同样的，由于 Messenger 是基于消息的跨进程通信，通过 Handler 实现，所以无法实现并发的通信操作！！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Binder跨进程通信","slug":"AndroidFramework源码分析/Binder跨进程通信","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Binder跨进程通信/"}],"tags":[{"name":"Binder跨进程通信","slug":"Binder跨进程通信","permalink":"https://coolqi.top/tags/Binder跨进程通信/"}]},{"title":"Handler篇 4 - MessageQueue 源码分析","slug":"Handler4-messageQueueSourceCode","date":"2017-02-27T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/02/27/Handler4-messageQueueSourceCode/","link":"","permalink":"https://coolqi.top/2017/02/27/Handler4-messageQueueSourceCode/","excerpt":"","text":"基于 Android 7.1.1 源码，分析 handler 的架构和原理。 1 成员变量1private final boolean mQuitAllowed; 该变量表示 MessageQueue 是否可以退出，主线程的消息队列不可退出。 12@SuppressWarnings(\"unused\")private long mPtr; // used by native code java 层有一个 MessageQueue，同样的 native 层也有一个 MessageQueue，java 层 MessageQueue 在初始化是，也会初始化 native 层的 MessageQueue，这个变量用来保存 natvie 层的消息队列的句柄！ 1Message mMessages; MessageQueue 消息队列中的所有消息是通过链表联系在一起的，mMessages 是这个链表的头元素！ 1private IdleHandler[] mPendingIdleHandlers; 用于保存将要被执行的 IdleHandler，当消息队列要执行 IdleHandler 的时候，他会将 mIdleHandlers 中的所有 IdleHandler 拷贝到 mPendingIdleHandlers！ 1private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;(); 用于保存该线程的所有 IdleHandler！ 1private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords; 用于记录文件描述符 1private boolean mQuitting; 该变量表示 MessageQueue 是否正在关闭退出！ 1private boolean mBlocked; 该变量表示 MessageQueue 是否是阻塞的，当 MessageQueue 中没有任何消息的时候，消息队列会阻塞，等待消息的插入！ 1private int mNextBarrierToken; 这里要提及一个概念叫：障栅（Barrier）。 障栅是一个特殊的 Message，他的 target 为 null，并且其 Message.arg1 作为句柄，标识每一个独一无二的障栅！ 障栅的作用很重要，它能够拦截同步 Message，阻止同步消息被执行，放行异步 Message！后面我们会看到！ mNextBarrierToken 的作用是计算下一个 Barrier 的 token！ 2 create MessageQueue我们来回顾下 Looper 的创建：1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); // 这里创建了一个消息队列！ mThread = Thread.currentThread();&#125; 2.1 new MessageQueue这里会调用 MessageQueue 构造器，创建一个消息队列！ 1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); // 初始化 native 层的消息队列，并返回其指针！&#125; mQuitAllowed 成员变量表示该消息队列是否可以关闭，对于 ui 线程的消息队列，是不能退出的，我们可以回顾下，ui 线程的 Looper 创建： 123456789public static void prepareMainLooper() &#123; prepare(false); // prepare 方法的参数就是 quitAllowed，这里传入的是 false； synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; nativeInit 方法是一个 native 方法，他会初始化处于 native 层的 MessageQueue，他和 java 层的 MessageQueue 一一对应！ 在 Android 2.3 之前，只有 java 层才可以向 MessageQueue 中添加消息，在 Android 2.3 之后，MessageQueue 的核心部分移动到了 native 层。这样，java 层和 native 层都可以使用 MessageQueue！ 也就是说， Java 层的 MessageQueue 处理 Java 层的消息，natvie 层的 MessageQueue 负责处理 native 层的消息！ 3 enqueue Message我们回到 Handler 中，当我们通过 handler 发送消息的时候，会调用 Handler.enqueueMessage 方法： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; // 设置消息的目标 if (mAsynchronous) &#123; // 如果 Handler 是异步的，其内部消息都是异步的！ msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); // 将消息加入到队列中！&#125; 3.1 MessageQueue.enqueueMessage最终会调用 enqueueMessage 将消息插入到 MessageQueue 中，下面我们来看看 MessageQueue.enqueueMessage 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; //【1】校验下 Message 的有效性！ if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; //【2】如果 message 正在使用，抛出异常！ throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; // 如果 MessageQueue 正在关闭，抛出异常，我们不能 IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); // 设置 FLAG_IN_USE 标志位，表示正在使用中！ msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 新的 message 为消息队列的新头元素！ msg.next = p; mMessages = msg; needWake = mBlocked; // 此时是否唤醒消息队列，取决于是否阻塞！ &#125; else &#123; // 如果不是新的头元素，那就将其添加到正确的位置！ Message prev; for (;;) &#123; prev = p; // 确定 pre 和 next message！ p = p.next; if (p == null || when &lt; p.when) &#123; // 按照分发时间从小到大排序！ break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // 找到合适的位置并插入！ prev.next = msg; &#125; if (needWake) &#123; // 唤醒消息队列！ nativeWake(mPtr); &#125; &#125; return true;&#125; 这里来说下 MessageQueue 的成员变量 mMessages：在 MessageQueue 中，所有的 Message 是以链表的形式组织在一起的，mMessages 是链表的头元素！ 4 dispatch Message在前面 Looper 分析中，我们知道，Looper.loop() 方法会进入一个 for 死循环，不断的调用 MessageQueue.next 方法，返回下一个 Message。 4.1 MessageQueue.next下面我们来看看 MessageQueue.next 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Message next() &#123; //【1】当 mPtr == 0 的时候，说明消息队列关闭了，那么我们会返回一个 null 的 Message // 这样消息循环就会关闭！ final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // Looper 每次调用 MQ.next 方法，都会初始化为 -1； int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // 从链表头开始，分发 Message！ final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 如果 msg 不为 null，但是 msg.target，那说明这是障珊，根据障珊的特性，拦截同步，放行异步 // 那就顺序遍历，找到下一个异步 Message！ do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); // 如果消息是同步的，继续查找！ &#125; // 如果 msg 不为 null，说明我们找到了要分发的消息（异步/同步）！ if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. // 如果消息还没有到分发的时间，设置一个超时时间用于触发他！ nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 消息的分发时间已经到了，分发消息！ mBlocked = false; if (prevMsg != null) &#123; // 如果 prevMsg 不为 null，说明我们分发的是异步消息，这里要重新设置链表元素关系！ prevMsg.next = msg.next; &#125; else &#123; // 如果 prevMsg 为 null，说明我们分发的是同步消息，修改链表头！ mMessages = msg.next; &#125; // 设置 msg.next 为 null，并设置 msg 为正在使用状态； msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; nextPollTimeoutMillis = -1; // 没有要分发的 message！ &#125; // 如果 mQuitting 为 true，说明消息队列正在关闭，那就返回一个 null 的 Message， // 这样 Looper 就会结束消息循环！ if (mQuitting) &#123; dispose(); return null; &#125; // 能进入这里，说明前面我们没有找到分发的 message 或者消息触发事件未到！ // 如果本次 next 第一次进入空闲状态，即没有消息去分发，那就执行 IdleHandler！ // 执行的条件是：消息队列为空，或者消息队列的第一个消息还没有到执行时间！ if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); // 计算 IdleHandler 个数！ &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 如果连 IdleHandler 也没有，那么说明消息循环没有任何消息需要处理！ // 那就进入阻塞状态，设置 mBlocked 为 true！ mBlocked = true; continue; &#125; // 将 mIdleHandlers 中需要触发的 IdleHandler 拷贝到 mPendingIdleHandlers 中！ if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // 运行收集到的 IdleHandler for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // 取消引用！ boolean keep = false; try &#123; // queueIdle 返回值，表示是否保留该 IdleHandler！ keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); // keep 为 false，不保留，移除！ &#125; &#125; &#125; // 将 pendingIdleHandlerCount 重置为 0 ，本次 next 将不会再执行 IdleHandler！ pendingIdleHandlerCount = 0; // 我们在执行 IdleHandler 之后，会消耗一些时间，这时候消息队列里的可能有消息已经到达 // 可执行时间，所以重置该变量回去重新检查消息队列。 nextPollTimeoutMillis = 0; &#125;&#125; 方法逻辑： 查询下一个要触发的消息：next 方法会启动一个 for 循环，顺序遍历消息链表： 如果头消息是障栅，那就顺序查找下一个异步消息！ 如果头消息不是障栅，那么那其就是同步消息，也是我们即将分发的消息！ 如果消息链表中没有任何消息，或者消息的分发时间未到，那么消息循环会进入阻塞状态，其实就是不断的 for 循环；在进入阻塞状态之前，会查询是否有 idleHandler 触发，如果没有会立刻进入阻塞状态，否则，会触发 IdleHandler，然后在再进入阻塞状态！ 所谓的阻塞，实际上是不断地 for 循环，直到有消息被插入，idleHandler 触发只会在进入阻塞状态的第一次 for 循环执行！ 当 MessageQueue 退出关闭的时候，mQuitting 会被置为 true，这样 MessageQueue.next 会返回一个 null 的 Message，回顾 Looper.loop，消息循环就可以退出了！ 123/*package*/ void markInUse() &#123; flags |= FLAG_IN_USE;&#125; 将一个 message 设置为正在使用的状态！ 5 quit MessageQueue回顾 Looper.quit 方法：123public void quit() &#123; mQueue.quit(false);&#125; 当我们不想使用消息队列了，我们可以关闭它，最终调用的 MessageQueue.quit 方法: 5.1 MessageQueue.quit123456789101112131415161718192021222324void quit(boolean safe) &#123; // 如果 mQuitAllowed 为 false，说明消息队列不可以关闭！ if (!mQuitAllowed) &#123; throw new IllegalStateException(\"Main thread not allowed to quit.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; // 如果已经在退出了，不允许退出 2 次！ return; &#125; mQuitting = true; // 设置 mQuitting 为 true！ // 根据是否安全推出做不同处理！ if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 方法逻辑： 设置 mQuitting 为 true； 如果是安全关闭，调用 removeAllFutureMessagesLocked 移除当前时间点以后未分发的消息； 如果是非安全关闭，调用 removeAllMessagesLocked 移除所有的消息； 6 remove Message回顾 Handler。Handler 提供了 remove 方法： 123public final void removeMessages(int what) &#123; mQueue.removeMessages(this, what, null);&#125; 最终调用了 MessageQueue 的 removeMessages 方法！ MessageQueue 有多个 remove 方法，我们一个一个来看： 6.1 MessageQueue.removeMessages 移除 Messages： 123456789101112131415161718192021222324252627282930313233void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; //【1】从头消息开始移除，如果头消息匹配到了。更新头消息指向，并移除 what 对应的消息！ while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); // 非安全回收！ p = n; &#125; //【2】进入这里说明头消息现在已经不用被移除了，然后在非头消息的剩余消息中移除能够匹配的消息！ while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); // 非安全回收！ p.next = nn; continue; &#125; &#125; p = n; &#125; &#125;&#125; 移除 Runnable： 123456789101112131415161718192021222324252627282930313233void removeMessages(Handler h, Runnable r, Object object) &#123; if (h == null || r == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; //【1】从头消息开始移除，如果头消息匹配到了。更新头消息，并移除 Runnable 对应的消息！ while (p != null &amp;&amp; p.target == h &amp;&amp; p.callback == r &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); // 非安全回收！ p = n; &#125; //【2】进入这里说明头消息现在已经不用被移除了，然后在非头消息的剩余消息中移除能够匹配的消息！ while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.callback == r &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); // 非安全回收！ p.next = nn; continue; &#125; &#125; p = n; &#125; &#125;&#125; 不管是移除 Messages 还是移除 Runnable，流程都是一样的： 先从头消息开始进行第一阶段的匹配，如果能够匹配，就移除头消息，并更新链表头！ 当头消息无法匹配，那么我们就删除剩下的消息中能够匹配的消息！ 6.2 MessageQueue.removeCallbacksAndMessages1234567891011121314151617181920212223242526272829303132void removeCallbacksAndMessages(Handler h, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // Remove all messages at front. while (p != null &amp;&amp; p.target == h &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); // 非安全回收！ p = n; &#125; // Remove all messages after front. while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); // 非安全回收！ p.next = nn; continue; &#125; &#125; p = n; &#125; &#125;&#125; 6.3 MessageQueue.removeAllMessagesLocked移除消息队列中所有的 Message！ 123456789private void removeAllMessagesLocked() &#123; Message p = mMessages; while (p != null) &#123; Message n = p.next; p.recycleUnchecked(); // 回收消息！ p = n; &#125; mMessages = null; // 设置 mMessages 为 null；&#125; 方法很简单，不多说！ 6.4 MessageQueue.removeAllFutureMessagesLocked移除消息队列中当前时间下所有未分发的 Message！ 12345678910111213141516171819202122232425262728293031private void removeAllFutureMessagesLocked() &#123; // 计算当前时间！ final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) &#123; if (p.when &gt; now) &#123; // 如果消息链表中所有消息都没有分发，那就移除所有消息！ removeAllMessagesLocked(); &#125; else &#123; Message n; // 找到第一个还没到分发时间的消息！ for (;;) &#123; n = p.next; if (n == null) &#123; return; &#125; if (n.when &gt; now) &#123; break; &#125; p = n; &#125; p.next = null; // 移除所有未分发的消息！ do &#123; p = n; n = p.next; p.recycleUnchecked(); // 非安全回收！ &#125; while (n != null); &#125; &#125;&#125; 方法很简单，不多说！！ 7 障栅 Barrier我们知道障栅本质上是一个特殊的 Message，其 target 为 null，他能够拦截同步的消息，放行异步消息！！ 我们关心的是如何向消息队列中插入和移除障栅！！ 7.1 MessageQueue.postSyncBarrierMessageQueue 提供了 postSyncBarrier 来向消息队列中增加障栅 Barrier! 123456789101112131415161718192021222324252627282930313233public int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; synchronized (this) &#123; // 为障栅计算 token，mNextBarrierToken自增！ final int token = mNextBarrierToken++; final Message msg = Message.obtain(); // 优先复用 message！ msg.markInUse(); msg.when = when; msg.arg1 = token; // 设置 msg.arg1 为 token！ // 将障栅添加到合适的位置，可能是表头，也可能是中间某个节点！ Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; // 将障珊作为新的表头！ msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 参数 when 表示障栅的拦截时间点！ 可以看到，当我们插入障栅后，其要么是位于消息队列的头，要么是根据拦截时间 when，将障栅插入到消息队列的合适位置！ 这样，障栅就可以拦截其后的所有同步消息了！ 7.2 MessageQueue.removeSyncBarrierMessageQueue 提供了 removeSyncBarrier 来从消息队列中移除障栅 Barrier： 参数 token 用于识别指定的障珊！ 123456789101112131415161718192021222324252627282930313233public void removeSyncBarrier(int token) &#123; synchronized (this) &#123; Message prev = null; Message p = mMessages; // 顺序遍历链表，如果 p.target 不为 null，说明它不是障珊； // 如果 p.arg1 != token 说明他不是我们要删除的障珊； while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; // 如果队列中没有障珊，会抛出异常！ throw new IllegalStateException(\"The specified message queue synchronization \" + \" barrier token has not been posted or has already been removed.\"); &#125; final boolean needWake; if (prev != null) &#123; // pre 不为 null，说明障栅在消息队列的中间某个节点！ prev.next = p.next; needWake = false; // 这种情况不需要唤醒！ &#125; else &#123; // pre 为 null 说明障栅就是消息队列的头，那么设置新的头节点为下一个 message！ mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycleUnchecked(); // 回收障栅，加入消息池！ // 如果需要唤醒 native 层队列，并且 java 层队列没有关闭，那就唤醒！ if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125;&#125; 逻辑很简单，就是遍历消息队列，根据传入的 token，匹配合适的障栅！！ 我们为什么要 remove 掉障栅？ 道理很简单，由于障栅是一种特殊的 message，其 target 为 null，所以其不能被分发，意味着如果障栅后面没有异步消息，那么整个队列就会一直阻塞下去！！ 8 Native 层分析上面分析了 java 层的 MessageQueue 逻辑架构，但我们早已经知道 native 也有个 MessageQueue，java 层的消息队列可通过以下方法和 native 层的 MessageQueue 通信：123456private native static long nativeInit();private native static void nativeDestroy(long ptr);private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/private native static void nativeWake(long ptr);private native static boolean nativeIsPolling(long ptr);private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events); native 层的 MessageQueue 除了可以让 native 层实现消息通信机制，更重要的是，其能够保证 java 层的不会陷入死循环！！ 对应的 native 层方法位于 android/frameworks/base/core/jni/android_os_MessageQueue.cpp 文件中！ 12345678910111213141516171819202122static const JNINativeMethod gMessageQueueMethods[] = &#123; /* name, signature, funcPtr */ &#123; \"nativeInit\", \"()J\", (void*)android_os_MessageQueue_nativeInit &#125;, &#123; \"nativeDestroy\", \"(J)V\", (void*)android_os_MessageQueue_nativeDestroy &#125;, &#123; \"nativePollOnce\", \"(JI)V\", (void*)android_os_MessageQueue_nativePollOnce &#125;, &#123; \"nativeWake\", \"(J)V\", (void*)android_os_MessageQueue_nativeWake &#125;, &#123; \"nativeIsPolling\", \"(J)Z\", (void*)android_os_MessageQueue_nativeIsPolling &#125;, &#123; \"nativeSetFileDescriptorEvents\", \"(JII)V\", (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,&#125;;int register_android_os_MessageQueue(JNIEnv* env) &#123; int res = RegisterMethodsOrDie(env, \"android/os/MessageQueue\", gMessageQueueMethods, NELEM(gMessageQueueMethods)); jclass clazz = FindClassOrDie(env, \"android/os/MessageQueue\"); gMessageQueueClassInfo.mPtr = GetFieldIDOrDie(env, clazz, \"mPtr\", \"J\"); gMessageQueueClassInfo.dispatchEvents = GetMethodIDOrDie(env, clazz, \"dispatchEvents\", \"(II)I\"); return res;&#125; register_android_os_MessageQueue 用来注册静态方法！ 8.1 android_os_MessageQueue_nativeInit我们来看一下这个 nativeInit 对应的 native 方法： 1234567891011static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; //【1】创建 native 消息队列：NativeMessageQueue！ NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 这里创建了 native 层的消息队列：NativeMessageQueue！ 12345678NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 8.1 android_os_MessageQueue_nativePollOnce12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 9 总结下面我们来总结下 MessageQueue 的类图！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Handler线程消息机制","slug":"AndroidFramework源码分析/Handler线程消息机制","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Handler线程消息机制/"}],"tags":[{"name":"Handler线程消息机制","slug":"Handler线程消息机制","permalink":"https://coolqi.top/tags/Handler线程消息机制/"}]},{"title":"Handler篇 3 - Looper 源码分析","slug":"Handler3-looperSourceCode","date":"2017-01-27T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/01/27/Handler3-looperSourceCode/","link":"","permalink":"https://coolqi.top/2017/01/27/Handler3-looperSourceCode/","excerpt":"","text":"基于 Android 7.1.1 源码，分析 Looper 的架构和原理。 1 成员变量1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 线程本地变量，用于保存每个线程创建出来的 Looper 对象！ 1private static Looper sMainLooper; ui 线程的 Looper 对象！ 1final MessageQueue mQueue; 消息队列，每一个 Looper 有一个消息队列，Looper 会循环遍历该消息队列，分发消息！ 1final Thread mThread; 当前线程，也就是该 Looper 所属的线程！ 12private Printer mLogging;private long mTraceTag; 和调试监控相关的，我们不过多关注！ 2 Looper.prepare我们知道，如果要给一个指定的线程创建一个 handler，该线程必须要有一个 Looper，创建 looper 的方法就是 prepare： 12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; // 每个线程只能有一个 Looper！ throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); // 将创建的 Looper 加入到线程本地变量中！&#125; 该方法会给当前的线程创建一个 Looper 对象！ 注意第二个方法是私有方法！ 2.1 new Looper1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); // 为该 looper 创建一个消息队列！ mThread = Thread.currentThread();&#125; quitAllowed 表示该队列是否可以推出！ 2.2 Looper.prepareMainLooper对于 ui 主线程，Looper 有一个方法方法专门用于创建其对应的 Looper：123456789public static void prepareMainLooper() &#123; prepare(false); // 调用 prepare 方法，创建 Looper synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); // 将 ui 线程的 Looper 保存到 sMainLooper 中！ &#125;&#125; 可以看到，ui 线程的 MessageQueue 是不能退出的！ 2.2.1 Looper.myLooper这里调用了 myLooper 方法，用于返回和当前线程相关联的 Looper 对象！ 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 方法很简单，不多说了！ 3 Looper.loop当 Looper 创建好后，需要调用 loop 方法，使其进入消息循环中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void loop() &#123; final Looper me = myLooper(); // 获得当前线程的 Looper 对象，并校验其有效性！ if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // 获得对应的消息队列！ Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; //【1】通过 next 方法返回下一个要分发的 message，next 方法可能会阻塞！ Message msg = queue.next(); if (msg == null) &#123; // 如果 msg 为 null，说明消息队列正在推出，那就 return，结束消息循环！ return; &#125; final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; //【2】分发这个 message！ try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); // 回收 Message。 &#125;&#125; 其实方法流程很简单： 获得当前线程的 Looper 对象，如果为 null，那就要抛出异常 获得该 Looper 所有的消息队列 通过 MessageQueue.next 方法，获得下一个要分发的 message！ 调用 msg.target.dispatchMessage 方法，分发消息！ 回收 Message，我们知道 MessageQueue 中的 Message 可以复用的！ 注意： queue.next() 方法会从消息队列中取出消息对象 Message，如果 MessageQueue 中没有任何 Message 的话，该方法将会阻塞等待新的消息。 当我们想要退出消息循环的时候，调用 quit 方法，那么 queue.next() 会返回一个 null 的 Message，这样就退出了！ 4 Looper.quitLooper 提供了 quit 方法，用于结束消息循环： 1234567public void quit() &#123; mQueue.quit(false);&#125;public void quitSafely() &#123; mQueue.quit(true);&#125; 最终都调用了 MessageQueue 的 quit 方法，来结束消息循环！ quit 和 quitSafely 的区别是，quit 方法是不安全的，而 quitSafely 会在停止 Looper 的时候把当前时间点之后的已经达到处理时间点的消息处理完后才停止 Looper！ 5 其他方法Looper 提供了一些其他的方法： 获得主线程的 Looper 对象！ 12345public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125; 获得 Looper 对象所在的线程！ 123public @NonNull Thread getThread() &#123; return mThread;&#125; 获得 Looper 对象的消息队列！ 123public @NonNull MessageQueue getQueue() &#123; return mQueue;&#125; 判断 Looper 对象是否属于当前线程！123public boolean isCurrentThread() &#123; return Thread.currentThread() == mThread;&#125; 总体来看，Looper 的实现并不复杂，接下来，我们来看看 MessageQueue！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Handler线程消息机制","slug":"AndroidFramework源码分析/Handler线程消息机制","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Handler线程消息机制/"}],"tags":[{"name":"Handler线程消息机制","slug":"Handler线程消息机制","permalink":"https://coolqi.top/tags/Handler线程消息机制/"}]},{"title":"Handler篇 2 - Handler 源码分析","slug":"Handler2-handlerSourceCode","date":"2017-01-19T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/01/19/Handler2-handlerSourceCode/","link":"","permalink":"https://coolqi.top/2017/01/19/Handler2-handlerSourceCode/","excerpt":"","text":"基于 Android 7.1.1 源码，分析 handler 的架构和原理。 0 前言本片博客通过以下几个方面总结 Handler 源码的实现架构！ 1 create HandlerHandler 提供了如下的构造器方法： 12345678910111213141516171819202122232425//【方法1】默认使用当前的线程的 Looper 对象创建 Handler，如果当前线程的没有 Looper，那就会抛出异常！public Handler() &#123;...&#125;//【方法2】默认使用当前的线程的 Looper 对象创建 Handler，如果当前线程的没有 Looper，那就会抛出异常！// 同时传入一个 Callback 接口，用于处理消息回调！public Handler(Callback callback) &#123;...&#125;//【方法3】显示指定一个 Looper 对象，不能为 nullpublic Handler(Looper looper) &#123;...&#125;//【方法4】可以看成方法 2 和方法 3 的合并，其中 callback 可以为 null！public Handler(Looper looper, Callback callback) &#123;...&#125;//【方法5】默认使用当前的线程的 Looper 对象创建 Handler，并且显式指定 handler 是否是异步的！// handler 默认是同步的，除非显示的指定 async 为 true！// @hidepublic Handler(boolean async) &#123;...&#125;//【方法6】可以看成方法 2 和方法 5 的合并!!// @hidepublic Handler(Callback callback, boolean async) &#123;...&#125;//【方法7】 可以看成方法 2，方法 3 和方法 5 的合并!!// @hidepublic Handler(Looper looper, Callback callback, boolean async) &#123;...&#125; Handler 默认是同步的，如果我们显式的设置 async 为 true，那么其该 handler 会以异步的方式处理 message 和 runnable！ 关于异步的实现，我们后续会分析！ 其中，最核心的构造方法是方法 6 和方法 7，其他方法都是调用它们完成初始化的： 1.1 Handler(Callback, boolean)默认使用当前线程的 Looper 对象： 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); // 使用当前线程的 Looper 对象！ if (mLooper == null) &#123; // 如果当前线程没有 Looper throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 1.2 Handler(Looper，Callback, boolean)显示指定了 Looper 对象！ 123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 1.2 成员变量构造器中出现了 Handler 的主要成员变量，下面解释一下，也便于后续分析： 1final Looper mLooper; Looper 对象; 1final MessageQueue mQueue; 消息队列，来自 Looper 对象; 1final Callback mCallback; Callback 回调，该回调会被封装成 message； 1final boolean mAsynchronous; 该 handler 是否是异步的，默认为 false； 2 Handler.obtainMessageHandler 提供了多个 obtainMessage 方法，来复用一个 Message 对象！ 123456789public final Message obtainMessage() &#123;...&#125;public final Message obtainMessage(int what) &#123;...&#125;public final Message obtainMessage(int what, Object obj) &#123;...&#125;public final Message obtainMessage(int what, int arg1, int arg2) &#123;...&#125;public final Message obtainMessage(int what, int arg1, int arg2, Object obj) &#123;...&#125; Handler 允许我们复用 Message 对象，这样可以避免过多的创建 Message 对象！ Message 有一个静态变量 Message sPool 他是一个消息池链表的头元素，obtainMessage 会从该消息池中复用 Message，并用参数初始化复用的 Message！ obtainMessage 方法最终会调用 Message.obtain 方法： 123public final Message obtainMessage(int what, int arg1, int arg2) &#123; return Message.obtain(this, what, arg1, arg2);&#125; 关于 Message.obtain，我们后面会分析，这里我们只需要知道，复用的时候，会从消息池链表的头元素开始，复用消息！ 3 Handler.sendMessageHandler 提供了多个 sendMessage 方法，来发送一个 Message 对象！ 12345678910111213public final boolean sendMessage(Message msg) &#123;...&#125;public final boolean sendEmptyMessage(int what) &#123;...&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;...&#125;public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123;...&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123;...&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;...&#125;public final boolean sendMessageAtFrontOfQueue(c msg) &#123;...&#125; // 发生消息到消息队列的头部 通过这些方法我们可以实现立即或者延迟发送消息！ 如果指定的是延迟时间，那么会通过 SystemClock.uptimeMillis() + delayMillis 方式计算为绝对时间！ sendMessage 最后调用的是 Handler.enqueueMessage，就是将 Message 插入到消息队列中！！ 3.1 Handler.enqueueMessage我们来看看 enqueueMessage 方法：1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; // 如果 Handler 是异步的，那么 Message 也是异步的！ msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 通过 MessageQueue.enqueueMessage 方法，将消息压入到消息队列中！ 如果 uptimeMillis 为 0 ，会将消息插入到消息队列的头部；如果 uptimeMillis 不为 0 ，会按照 uptimeMillis 将消息插入到消息队列的指定位置； 4 Handler.postHandler 除了可以发送消息，进行线程间通信，还可以执行指定的任务 Runnable，Handler 提供了多个 post 方法供我们选择： 123456789public final boolean post(Runnable r) &#123;...&#125;public final boolean postAtTime(Runnable r, long uptimeMillis) &#123;...&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) &#123;...&#125;public final boolean postDelayed(Runnable r, long delayMillis) &#123;...&#125;public final boolean postAtFrontOfQueue(Runnable r) &#123;...&#125; 通过这些方法我们可以实现立即或者延迟执行任务！ Runnable 的执行很有意思： 123public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0); // 将 Runnable 封装为 Message！！&#125; 我们去看看 getPostMessage() 方法： 4.1 Handler.getPostMessagegetPostMessage 用于将 Runnable 封装为 Message！ 123456789101112private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; // 将 Runnable 保存到 Message 的属性中！ return m;&#125; 优先复用消息池中的消息！ 5 Handler.dispatchMessage回顾 Loop.loop() 方法，当 queue.next() 能够返回一个可以分发的 Message 后，会调用下面的逻辑，处理消息！ 1234567try &#123; msg.target.dispatchMessage(msg);&#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125;&#125; 这里的 msg.target 就是目标 Handler： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; // 处理 Runnbale handleCallback(msg); &#125; else &#123; // 处理 Message if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; // 如果设置了 Callback，就通过 Callback 处理消息！ return; &#125; &#125; handleMessage(msg); // 默认使用 handler 的方法处理消息！ &#125;&#125; 对于 Runable 来说，虽然其被封装为了 Message，但是由于其 what 的特殊性，无法按照一般的 Message 的去处理， 5.1 Handler.handleCallback对于 Runable，通过 handleCallback 方法处理，该方法会调用 Runnable.run() 方法来执行任务！ 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 不多说了！ 5.2 Callback.handleMessage对于 Message，如果我们指定了回调接口 Callback，那就通过 Callback 处理 Message：123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; mCallback 为 Handler 的成员变量，需要显式指定！ Callback 是 Handler 的内部接口！ 5.3 Handler.handleMessage对于 Message，默认使用 Handler 的 handleMessage 来处理： 12public void handleMessage(Message msg) &#123;&#125; 我们需要复写该方法，实现自己的逻辑！！ 6 handler.removeMessages同时 Handler 也提供了移除消息的操作；12345public final void removeMessages(int what) &#123;...&#125;public final void removeMessages(int what, Object object) &#123;...&#125;public final void removeCallbacksAndMessages(Object token) &#123;...&#125; 最终调用的是 MessageQueue 的 remove 方法; 12mQueue.removeMessages(this, what, object);mQueue.removeCallbacksAndMessages(this, token); MessageQueue 的 remove 操作的原理很简单，根据输入的参数，进行匹配即可！！ 7 跨进程通信Handler 也可以用于跨进程通信：Messenger Handler 有一个变量 IMessenger mMessenger 用于保存通过 Messenger 跨进程通信是服务端的桩对象！ 123456789final IMessenger getIMessenger() &#123; synchronized (mQueue) &#123; if (mMessenger != null) &#123; return mMessenger; &#125; mMessenger = new MessengerImpl(); // 创建桩对象 return mMessenger; &#125;&#125; Messenger 信使本质上实现了 Aidl 模板，下面是服务端桩的实现！ 123456private final class MessengerImpl extends IMessenger.Stub &#123; public void send(Message msg) &#123; msg.sendingUid = Binder.getCallingUid(); // 因为会跨进程通信，所以会设置 msg.sendingUid 为当前进程的 uid Handler.this.sendMessage(msg); &#125;&#125; 跨进程的分析会在单独的文章中，这里不再过多的介绍！！ 8 其他方法 判断消息队列中是否有指定的消息！ 1234567public final boolean hasMessages(int what, Object object) &#123; return mQueue.hasMessages(this, what, object);&#125;public final boolean hasCallbacks(Runnable r) &#123; return mQueue.hasMessages(this, r, null);&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Handler线程消息机制","slug":"AndroidFramework源码分析/Handler线程消息机制","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Handler线程消息机制/"}],"tags":[{"name":"Handler线程消息机制","slug":"Handler线程消息机制","permalink":"https://coolqi.top/tags/Handler线程消息机制/"}]},{"title":"Handler篇 1 - Handler 初识","slug":"Handler1-handlerInit","date":"2017-01-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2017/01/13/Handler1-handlerInit/","link":"","permalink":"https://coolqi.top/2017/01/13/Handler1-handlerInit/","excerpt":"","text":"基于 Android 7.1.1 源码，分析 handler 的架构和原理。 0 前言Android 中有 2 中常见的通信方式，进程间的通信使用 Binder，而线程间的通信则使用 Handler，该系列文章就来总结下和 Handler 相关的知识点！ 1 创建 Handler我们知道，每一个 Handler 都要和一个 Thread 的 Looper 对象相关联，一个线程可以有多个 Handler，下面来看看 Handler 的创建！ 1.1 主线程的 Handler通常，我们可以这样创建一个 Handler： 1Handler handler = new Handler(); 这种创建方式，默认会将 Handler 和当前线程的 Looper 对象相关联，这个我们后续分析！ 当然也可以显式的传入 Looper 对象！ 12Handler handler = new Handler(Looper.myLooper());Handler handler = new Handler(Looper.getMainLooper()); 这里涉及到几个 Looper 的几个方法： 12Looper.myLooper() // 当前线程的 Looper 对象！Looper.getMainLooper() // 主线程的 Looper 对象！ 对于 Looper 我们后续分析； 1.2 子线程的 Handler在 Ui 线程中直接创建 Handler 是没有问题的，因为 Ui 线程默认会创建 Looper 对象，对于子线程，默认是不会有 Looper 对象，直接创建是会报错的： 123456789101112131415161718E AndroidRuntime: FATAL EXCEPTION: AsyncTask #1E AndroidRuntime: Process: com.coolqi.papapa:ui, PID: 27199E AndroidRuntime: java.lang.RuntimeException: An error occurred while executing doInBackground()E AndroidRuntime: at android.os.AsyncTask$3.done(AsyncTask.java:353)E AndroidRuntime: at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:383)E AndroidRuntime: at java.util.concurrent.FutureTask.setException(FutureTask.java:252)E AndroidRuntime: at java.util.concurrent.FutureTask.run(FutureTask.java:271)E AndroidRuntime: at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:245)E AndroidRuntime: at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)E AndroidRuntime: at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)E AndroidRuntime: at java.lang.Thread.run(Thread.java:764)E AndroidRuntime: Caused by: java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()E AndroidRuntime: at android.os.Handler.&lt;init&gt;(Handler.java:204)E AndroidRuntime: at android.os.Handler.&lt;init&gt;(Handler.java:118)E AndroidRuntime: at com.coolqi.papapa.f.doInBackground(EntryActivity.java:2368)E AndroidRuntime: at android.os.AsyncTask$2.call(AsyncTask.java:333)E AndroidRuntime: at java.util.concurrent.FutureTask.run(FutureTask.java:266)E AndroidRuntime: ... 4 more 我们必须在创建之前，显式的调用 Looper.prepare() 方法，为了能使 Handler 正常工作，创建完 Handler 后要 Looper.loop() 启动消息循环！ 12345678new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); new Handler(Looper.myLooper()); Looper.loop(); &#125;&#125;).start(); 那么，我们可以不用调用 Looper.prepare() 吗？ 每次都调用，很麻烦，实际上是可以的，系统已经给我们内置了一个 HandlerThread，HandlerThread 和 Ui 线程一样，也会默认创建一个 Looper 对象！ 1234HandlerThread mWorkThread = new HandlerThread(\"handler\", android.os.Process.THREAD_PRIORITY_BACKGROUND);mWorkThread.start();Handler mHandler = new Handler(mWorkThread.getLooper()); 到这里，关于 Handler 的创建，就讲这么多！ 2 使用 HandlerHandler 的主要用途有 2 个： 进行线程间通信，能在其他线程中执行指定操作，比如一些异步，或者耗时的操作！ 能够指定在某个时间点执行一些任务！ 使用的方式很简单： send message post runnable Handler 本质上是作为线程的消息队列的管理者，不管是发送消息，还是执行任务，都其实是将其添加到队列中依次处理！ 2.1 send messsageHandler 和消息相关的方法有很多，这我们只看一些常见的： 发送消息： 12int MSG_FIRST = 1001;handler.sendEmptyMessage(MSG_FIRST); 这是发送一个空消息！ 延迟发送消息： 我们也可以延迟发送消息：12int MSG_FIRST = 1001;handler.sendMessageDelayed(MSG_FIRST, 1000); 指定某个时刻发送消息： 12int MSG_FIRST = 1001;handler.sendEmptyMessageAtTime(MSG_FIRST， System.currentTimeMillis() + 60 * 60 * 1000); 发送非空消息： 12345int MSG_FIRST = 1001;message.what = MSG_FIRST;Message message = new Message();handler.sendMessage(message)// handler.sendMessageDelayed(message, 2000) 用法和发送空消息很类似，可以立刻发送，也可以延迟发送！ 对于非空的消息 Message，我们可以携带一些数据： 12bundle.putFloat(\"cat\", 0.11f);message.setData(bundle); 对于 Bundle，这里就不多说了，以上是基本的用法！ 2.2 post runnablepost 操作其实本质上是将 Runnable 转化为了 message 和 callback，并不会指定消息的 what 属性，因为他的处理方式不同！ 执行任务： 123456handler.post(new Runnable() &#123; @Override public void run() &#123; // do something！ &#125;&#125;); 延迟执行任务： 1handler.postDelayed(...); 延迟执行任务： 1handler.postDelayed(Runnable r, long delayMillis) 2.3 handle message/runnable接下来，看看如何处理 Message 和 runnable： 处理 message，需要我们实现 handleMessage，在内部来根据 msg.what 来分别对 msg 进行处理！ 12public void handleMessage(Message msg) &#123;&#125; 处理 runnable 则不同，runnable 不需要我们像 message 那样处理，系统会自动调用下面的方法来帮我们执行 runnable： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 3 线程间通信的实现实现线程间通信的方法很简单，当前线程持有其他线程的 Handler，然后向其发送 message 即可！ 关于 Handler 的简单用法，到这里就分析结束了，后面会继续分析其源码的实现！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Handler线程消息机制","slug":"AndroidFramework源码分析/Handler线程消息机制","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Handler线程消息机制/"}],"tags":[{"name":"Handler线程消息机制","slug":"Handler线程消息机制","permalink":"https://coolqi.top/tags/Handler线程消息机制/"}]},{"title":"UsageStats 第 1 篇 - UsageStatsService 的启动","slug":"UsageStats1-usageStatsServiceStartProcess","date":"2017-01-03T12:46:25.000Z","updated":"2018-11-20T16:54:06.000Z","comments":true,"path":"2017/01/03/UsageStats1-usageStatsServiceStartProcess/","link":"","permalink":"https://coolqi.top/2017/01/03/UsageStats1-usageStatsServiceStartProcess/","excerpt":"","text":"[toc] 基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理！ 0 综述启动 UsageStatsService 服务，是从 SystemServer.startCoreServices 开始！123456789private void startCoreServices() &#123; mSystemServiceManager.startService(BatteryService.class); mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);&#125; 1 new UsageStatsService123public UsageStatsService(Context context) &#123; super(context);&#125; UsageStatsService 的构造器很简单，没有过多的数据！ 2 UsageStatsS.onStart12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void onStart() &#123; //【1】获得一些重要的服务管理对象！ mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE); mUserManager = (UserManager) getContext().getSystemService(Context.USER_SERVICE); mPackageManager = getContext().getPackageManager(); //【*2.1】创建 H 消息处理 Handler！ mHandler = new H(BackgroundThread.get().getLooper()); //【2】创建数据目录 File systemDataDir = new File(Environment.getDataDirectory(), \"system\"); mUsageStatsDir = new File(systemDataDir, \"usagestats\"); mUsageStatsDir.mkdirs(); if (!mUsageStatsDir.exists()) &#123; throw new IllegalStateException(\"Usage stats directory does not exist: \" + mUsageStatsDir.getAbsolutePath()); &#125; //【*2.2】动态注册一个广播接收者：UserActionsReceiver // 监听 Intent.ACTION_USER_STARTED 和 Intent.ACTION_USER_REMOVED 广播； IntentFilter filter = new IntentFilter(Intent.ACTION_USER_REMOVED); filter.addAction(Intent.ACTION_USER_STARTED); getContext().registerReceiverAsUser(new UserActionsReceiver(), UserHandle.ALL, filter, null, mHandler); //【2.3】动态注册一个广播接收者：PackageReceiver // 监听 Intent.ACTION_PACKAGE_ADDED，Intent.ACTION_PACKAGE_REMOVED 和 Intent.ACTION_PACKAGE_CHANGED 广播； IntentFilter packageFilter = new IntentFilter(); packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED); packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED); packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED); packageFilter.addDataScheme(\"package\"); getContext().registerReceiverAsUser(new PackageReceiver(), UserHandle.ALL, packageFilter, null, mHandler); //【*2.4】通过系统属性 config_enableAutoPowerModes 值来判断是否支持 app idle，注意 doze 模式也是通过这个值判断的 // 如果支持，创建一个动态注册的接收者：DeviceStateReceiver，用于接收 ACTION_BATTERY_CHANGED // ACTION_DISCHARGING，ACTION_DEVICE_IDLE_MODE_CHANGED（doze 模式的广播），监听设备状态！ mAppIdleEnabled = getContext().getResources().getBoolean( com.android.internal.R.bool.config_enableAutoPowerModes); if (mAppIdleEnabled) &#123; IntentFilter deviceStates = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); deviceStates.addAction(BatteryManager.ACTION_DISCHARGING); deviceStates.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED); getContext().registerReceiver(new DeviceStateReceiver(), deviceStates); &#125; synchronized (mLock) &#123; //【*2.5】清楚被移除的用户信息！ cleanUpRemovedUsersLocked(); //【*2.6】创建一个 AppIdleHistory 对象，用于加载和保存 app idle 的历史信息！ mAppIdleHistory = new AppIdleHistory(SystemClock.elapsedRealtime()); &#125; //【3】记录此时的系统时间到 mSystemTimeSnapshot，距离开始的时间间隔到 mRealTimeSnapshot // 后续时间检查时会用到！ mRealTimeSnapshot = SystemClock.elapsedRealtime(); mSystemTimeSnapshot = System.currentTimeMillis(); //【*2.7】注册 LocalService 服务对象，方便进程内部通信 // 同时将自身注册到 ServiceManager 中，用于跨进程通信！ publishLocalService(UsageStatsManagerInternal.class, new LocalService()); publishBinderService(Context.USAGE_STATS_SERVICE, new BinderService());&#125; 继续分析; 2.1 new H创建了一个 Handler 对，处理 UsageStatsService 中的一些重要的消息，下面我们先开看看有哪些消息！123456789101112131415161718192021222324252627282930313233343536class H extends Handler &#123; public H(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_REPORT_EVENT: //【1】处理其他进程传递的 UsageEvents； break; case MSG_FLUSH_TO_DISK: //【2】处理其他进程传递的 UsageEvents 时间； break; case MSG_REMOVE_USER: //【3】移除某个 user； break; case MSG_INFORM_LISTENERS: //【4】 break; case MSG_FORCE_IDLE_STATE: //【5】设置应用进入 idle 状态； break; case MSG_CHECK_IDLE_STATES: //【6】每隔一段时间检查 idle 状态； break; case MSG_ONE_TIME_CHECK_IDLE_STATES: //【7】只检查一次 idle 状态； break; case MSG_CHECK_PAROLE_TIMEOUT: //【8】 break; case MSG_PAROLE_END_TIMEOUT: //【9】 break; case MSG_REPORT_CONTENT_PROVIDER_USAGE: //【10】记录 content provider 的使用； break; case MSG_PAROLE_STATE_CHANGED: //【11】充电状态变化； break; default: super.handleMessage(msg); break; &#125; &#125;&#125; 在启动的过程中也会发送一些 MSG 给 H 进行处理，对于消息的处理，我们放在第四节分析！ 2.2 new UserActionsReceiver - 监听用户状态UserActionsReceiver 接收者用于监听 User 相关的广播！1234567891011121314151617181920private class UserActionsReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1); final String action = intent.getAction(); if (Intent.ACTION_USER_REMOVED.equals(action)) &#123; if (userId &gt;= 0) &#123; //【1】如果是用户被移除的广播，发送 MSG_REMOVE_USER 消息给 H！ mHandler.obtainMessage(MSG_REMOVE_USER, userId, 0).sendToTarget(); &#125; &#125; else if (Intent.ACTION_USER_STARTED.equals(action)) &#123; if (userId &gt;=0) &#123; //【*2.2.1】如果是用户被启动的广播，调用 postCheckIdleStates 方法，检查 idle 状态信息！ postCheckIdleStates(userId); &#125; &#125; &#125;&#125; 2.2.1 UsageStatsService.postCheckIdleStates123void postCheckIdleStates(int userId) &#123; mHandler.sendMessage(mHandler.obtainMessage(MSG_CHECK_IDLE_STATES, userId, 0));&#125; 如果是用户被启动的广播，调用 postCheckIdleStates 方法，发送 MSG_CHECK_IDLE_STATES 消息给 H，检查 idle 状态信息！ 2.3 new PackageReceiver - 监听包状态PackageReceiver 接收者用于监听 package 相关的广播！1234567891011121314151617181920private class PackageReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (Intent.ACTION_PACKAGE_ADDED.equals(action) || Intent.ACTION_PACKAGE_CHANGED.equals(action)) &#123; //【*2.3.1】清除运营商特权应用程序列表！ clearCarrierPrivilegedApps(); &#125; if ((Intent.ACTION_PACKAGE_REMOVED.equals(action) || Intent.ACTION_PACKAGE_ADDED.equals(action)) &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123; //【*2.3.2】清楚 package 的 idle 状态 clearAppIdleForPackage(intent.getData().getSchemeSpecificPart(), getSendingUserId()); &#125; &#125;&#125; 如果接收到的广播是：Intent.ACTION_PACKAGE_ADDED 或者 Intent.ACTION_PACKAGE_CHANGED，那就调用 clearCarrierPrivilegedApps 方法，清除运营商特权应用程序列表了； 如果接收到的广播是：Intent.ACTION_PACKAGE_REMOVED(移除应用) 或者 Intent.ACTION_PACKAGE_ADDED，且 Intent.EXTRA_REPLACING 为 false (新安装的应用)，那就会清楚 package 的 idle 状态！ 2.3.1 UsageStatsS.clearCarrierPrivilegedApps清除运营商特权应用程序列表!123456789void clearCarrierPrivilegedApps() &#123; if (DEBUG) &#123; Slog.i(TAG, \"Clearing carrier privileged apps list\"); &#125; synchronized (mLock) &#123; mHaveCarrierPrivilegedApps = false; mCarrierPrivilegedApps = null; // Need to be refetched. &#125;&#125; 这里涉及到 2 个变量： mHaveCarrierPrivilegedApps 表示是否持有运营商特权应用程序； mCarrierPrivilegedApps 是一个 list，保存了运营商特权应用程序； 当然了，有删除也就有添加的方法 fetchCarrierPrivilegedAppsLocked： 1234567891011private void fetchCarrierPrivilegedAppsLocked() &#123; // 调用了 TelephonyManager 的方法获得运营商特权应用程序列表！ // 同时设置 mHaveCarrierPrivilegedApps 为 true！ TelephonyManager telephonyManager = getContext().getSystemService(TelephonyManager.class); mCarrierPrivilegedApps = telephonyManager.getPackagesWithCarrierPrivileges(); mHaveCarrierPrivilegedApps = true; if (DEBUG) &#123; Slog.d(TAG, \"apps with carrier privilege \" + mCarrierPrivilegedApps); &#125;&#125; 至于运营商特权应用程序列表相关内容，我们后续在看！ 2.3.2 UsageStatsS.clearAppIdleForPackage清楚 package 的 idle 状态：123456void clearAppIdleForPackage(String packageName, int userId) &#123; synchronized (mLock) &#123; //【2.3.2.1】调用 AppIdleHistory.clearUsageLocked 方法！ mAppIdleHistory.clearUsageLocked(packageName, userId); &#125;&#125; 可以看到，调用的是 AppIdleHistory.clearUsageLocked 方法！ 2.3.2.1 AppIdleHistory.clearUsageLocked12345public void clearUsageLocked(String packageName, int userId) &#123; //【2.3.2.2】获得指定 userId 下的所有应用的历史信息，然后从中移除 packageName 的信息！ ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId); userHistory.remove(packageName);&#125; 2.3.2.2 AppIdleHistory.getUserHistoryLocked123456789101112private ArrayMap&lt;String, PackageHistory&gt; getUserHistoryLocked(int userId) &#123; //【1】从 mIdleHistory 中查找 userId 的数据，如果 userHistory 为 null。就从本地数据恢复！ ArrayMap&lt;String, PackageHistory&gt; userHistory = mIdleHistory.get(userId); if (userHistory == null) &#123; userHistory = new ArrayMap&lt;&gt;(); mIdleHistory.put(userId, userHistory); //【2.3.2.3】尝试从本地持久化文件中读取数据； readAppIdleTimesLocked(userId, userHistory); &#125; //【2】返回！ return userHistory;&#125; AppIdleHistory 内部有一个 mIdleHistory 集合，用于保存每个 userId 下的所有 package 的空闲历史信息！ 2.3.2.3 AppIdleHistory.readAppIdleTimesLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void readAppIdleTimesLocked(int userId, ArrayMap&lt;String, PackageHistory&gt; userHistory) &#123; FileInputStream fis = null; try &#123; //【1】准备读取 /data/system/users/&lt;userId&gt;/app_idle_stats.xml 文件 AtomicFile appIdleFile = new AtomicFile(getUserFile(userId)); fis = appIdleFile.openRead(); XmlPullParser parser = Xml.newPullParser(); parser.setInput(fis, StandardCharsets.UTF_8.name()); int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; &#125; if (type != XmlPullParser.START_TAG) &#123; Slog.e(TAG, \"Unable to read app idle file for user \" + userId); return; &#125; if (!parser.getName().equals(TAG_PACKAGES)) &#123; // packages 标签 return; &#125; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) &#123; if (type == XmlPullParser.START_TAG) &#123; final String name = parser.getName(); //【2】解析 package 标签和其属性！ if (name.equals(TAG_PACKAGE)) &#123; // 解析 “package” 标签 final String packageName = parser.getAttributeValue(null, ATTR_NAME); // 解析 “name” 属性 //【3】创建 PackageHistory 对象，封装解析到的信息； PackageHistory packageHistory = new PackageHistory(); packageHistory.lastUsedElapsedTime = // 解析 “screenIdleTime” 属性 Long.parseLong(parser.getAttributeValue(null, ATTR_ELAPSED_IDLE)); packageHistory.lastUsedScreenTime = // 解析 “elapsedIdleTime” 属性 Long.parseLong(parser.getAttributeValue(null, ATTR_SCREEN_IDLE)); //【4】添加到 userHistory 中，最后返回！ userHistory.put(packageName, packageHistory); &#125; &#125; &#125; &#125; catch (IOException | XmlPullParserException e) &#123; Slog.e(TAG, \"Unable to read app idle file for user \" + userId); &#125; finally &#123; IoUtils.closeQuietly(fis); &#125;&#125; 我们来看看 /data/system/users/0/app_idle_stats.xml 文件中的主要内容：1234&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;packages&gt; &lt;package name=\"com.github.shadowsocks\" elapsedIdleTime=\"6836535861\" screenIdleTime=\"2173999944\" /&gt;&lt;/packages&gt; getUserFile 方法返回的是：/data/system/users/&lt;userId&gt;/app_idle_stats.xml 文件对象：123456static final String APP_IDLE_FILENAME = \"app_idle_stats.xml\";private File getUserFile(int userId) &#123; return new File(new File(new File(mStorageDir, \"users\"), Integer.toString(userId)), APP_IDLE_FILENAME);&#125; #####2.3.2.3.1 new PackageHistory创建 PackageHistory 对象！12345private static class PackageHistory &#123; final byte[] recent = new byte[HISTORY_SIZE]; long lastUsedElapsedTime; long lastUsedScreenTime;&#125; 2.4 new DeviceStateReceiver - 监听设备状态DeviceStateReceiver 监听设备状态的变化！12345678910111213141516private class DeviceStateReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (Intent.ACTION_BATTERY_CHANGED.equals(action)) &#123; //【2.4.1】设置充电状态！ setChargingState(intent.getIntExtra(\"plugged\", 0) != 0); &#125; else if (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(action)) &#123; //【2.4.2】处理 device idle (doze)模式变化！ onDeviceIdleModeChanged(); &#125; &#125;&#125; 如果广播是 Intent.ACTION_BATTERY_CHANGED，说明此时正在充电，那么会调用 setChargingState 设置充电状态； 如果广播是 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED，说明此时 device idle 模式的状态发生了变化； 2.4.1 UsageStatsS.setChargingState - 充电状态变化12345678910void setChargingState(boolean charging) &#123; synchronized (mLock) &#123; if (mCharging != charging) &#123; // 更新 mCharging！ mCharging = charging; //【2.4.1.1】调用 postParoleStateChanged 方法！ postParoleStateChanged(); &#125; &#125;&#125; mCharging 表示当前设备是否正在充电，可以看到，只有当设备在未充电和充电状态之间变化！ 2.4.1.1 UsageStatsS.postParoleStateChanged123456private void postParoleStateChanged() &#123; if (DEBUG) Slog.d(TAG, \"Posting MSG_PAROLE_STATE_CHANGED\"); //【4.11】发送 MSG_PAROLE_STATE_CHANGED 消息给 H! mHandler.removeMessages(MSG_PAROLE_STATE_CHANGED); mHandler.sendEmptyMessage(MSG_PAROLE_STATE_CHANGED);&#125; 发送 MSG_PAROLE_STATE_CHANGED 消息给 H！ 2.4.2 UsageStatsS.onDeviceIdleModeChanged - doze 状态变化当 device idle (doze)模式发生了变化后，onDeviceIdleModeChanged 方法会被触发：123456789101112131415161718192021222324void onDeviceIdleModeChanged() &#123; //【1】调用 PowerManager.isDeviceIdleMode 方法，判断是否进入了 doze 模式！ final boolean deviceIdle = mPowerManager.isDeviceIdleMode(); if (DEBUG) Slog.i(TAG, \"DeviceIdleMode changed to \" + deviceIdle); synchronized (mLock) &#123; //【2】计算距离里上一次的应用假释时间，已经过去的时间！ final long timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime; if (!deviceIdle &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123; if (DEBUG) Slog.i(TAG, \"Bringing idle apps out of inactive state due to deviceIdleMode=false\"); //【2.1】如果已经退出了 device idle 模式，并且距离上一次的应用假释时间已经超过了 // mAppIdleParoleIntervalMillis，那么我们就进入假释状态！ setAppIdleParoled(true); &#125; else if (deviceIdle) &#123; if (DEBUG) Slog.i(TAG, \"Device idle, back to prison\"); //【2.2】如果当前处于 device idle 状态，那么不允许应用假释； setAppIdleParoled(false); &#125; &#125;&#125; 2.4.2.1 UsageStatsS.checkAndGetTimeLockedcheckAndGetTimeLocked 方法用于计算当前的时间！ 1234567891011121314151617181920212223242526private long checkAndGetTimeLocked() &#123; //【1】获得当前的系统时间，可以被系统设置修改； final long actualSystemTime = System.currentTimeMillis(); //【2】获得自开机后，经过的时间，包括深度睡眠的时间； final long actualRealtime = SystemClock.elapsedRealtime(); final long expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot; final long diffSystemTime = actualSystemTime - expectedSystemTime; //【3】判断时间是否有发生变化， if (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123; // The time has changed. Slog.i(TAG, \"Time changed in UsageStats by \" + (diffSystemTime / 1000) + \" seconds\"); final int userCount = mUserState.size(); for (int i = 0; i &lt; userCount; i++) &#123; final UserUsageStatsService service = mUserState.valueAt(i); //【3.1】更新本地数据！ service.onTimeChanged(expectedSystemTime, actualSystemTime); &#125; //【3.2】记录本次的时间点到 mRealTimeSnapshot，mSystemTimeSnapshot！ mRealTimeSnapshot = actualRealtime; mSystemTimeSnapshot = actualSystemTime; &#125; //【4】返回当前的实际时间！ return actualSystemTime;&#125; 可以看到 checkAndGetTimeLocked 返回的时间是 actualSystemTime 的值，也就是 System.currentTimeMillis()，这个时间值可以被系统设置修改，然后值就会发生跳变，比如联网对时，手动调时！ 而 actualRealtime 的值为 System.elapsedRealtime 自开机后，经过的时间，包括深度睡眠的时间，这部分时间值是不会被修改； 如果判断时间是否有发生调时，对时情况呢？ mSystemTimeSnapshot 中保存的是上一次 check 时的系统时间； mRealTimeSnapshot 中保存的是上一次 check 时的自开机后，经过的时间； 先计算出期望的时间： 本次距离开机的时间 actualRealtime - 上次距离开机的时间 mRealTimeSnapshot，这个时间差值是正常情况下的时间差值； 然后再加上上一次 check 时的系统时间 mSystemTimeSnapshot，如果没有发生调时的话，这个应该是理想的时间点 expectedSystemTime； 如果发生了调时，对时的情况，actualSystemTime 一定是会发生变化的！ 计算 actualSystemTime 和 expectedSystemTime 的差值，如果大于 TIME_CHANGE_THRESHOLD_MILLIS，说明铁定发生了调时，对时； 如果发生上述情况，那就调用 UserUsageStatsService.onTimeChanged 更新本地持久化文件的日期！ 对于 UsageStatsService 是如何存储应用数据，如何更新本地持久化文件的，这里我先不关注，我们只需要知道，该方法返回的时间值是实际的时间（正常，手动调时，联网对时） 2.5 UsageStatsS.cleanUpRemovedUsersLocked - 删除被移除的 User 使用数据删除已经被移除的 User 的使用数据！12345678910111213141516171819202122232425262728private void cleanUpRemovedUsersLocked() &#123; //【1】获得所有的 user 信息！ final List&lt;UserInfo&gt; users = mUserManager.getUsers(true); if (users == null || users.size() == 0) &#123; throw new IllegalStateException(\"There can't be no users\"); &#125; //【2】如果 /data/system/usagestats 目录下没有任何文件，不处理！ ArraySet&lt;String&gt; toDelete = new ArraySet&lt;&gt;(); String[] fileNames = mUsageStatsDir.list(); if (fileNames == null) &#123; // No users to delete. return; &#125; //【3】去除那些存在的 user 的使用信息！ toDelete.addAll(Arrays.asList(fileNames)); final int userCount = users.size(); for (int i = 0; i &lt; userCount; i++) &#123; final UserInfo userInfo = users.get(i); toDelete.remove(Integer.toString(userInfo.id)); &#125; //【4】移除剩下的没用的 user 信息； final int deleteCount = toDelete.size(); for (int i = 0; i &lt; deleteCount; i++) &#123; // 递归删除！ deleteRecursively(new File(mUsageStatsDir, toDelete.valueAt(i))); &#125;&#125; 2.6 new AppIdleHistory - 管理 App Idle 信息创建一个 AppIdleHistory 对象，保存 app idle 相关的状态和信息！ 12345678910111213AppIdleHistory(long elapsedRealtime) &#123; this(Environment.getDataSystemDirectory(), elapsedRealtime);&#125;@VisibleForTestingAppIdleHistory(File storageDir, long elapsedRealtime) &#123; //【1】可以看到，初始化时候 mElapsedSnapshot 等于 mScreenOnSnapshot mElapsedSnapshot = elapsedRealtime; mScreenOnSnapshot = elapsedRealtime; mStorageDir = storageDir; //【×2.6.1】读取亮屏时间信息！ readScreenOnTimeLocked();&#125; mStorageDir 指向 /data/system 目录！ 2.6.1 AppIdleHistory.readScreenOnTimeLocked12345678910111213141516private void readScreenOnTimeLocked() &#123; //【1】获得 /data/system/screen_on_time 文件 File screenOnTimeFile = getScreenOnTimeFile(); if (screenOnTimeFile.exists()) &#123; try &#123; BufferedReader reader = new BufferedReader(new FileReader(screenOnTimeFile)); //【2】读取 mScreenOnDuration 和 mElapsedDuration 时间值！ mScreenOnDuration = Long.parseLong(reader.readLine()); mElapsedDuration = Long.parseLong(reader.readLine()); reader.close(); &#125; catch (IOException | NumberFormatException e) &#123; &#125; &#125; else &#123; writeScreenOnTimeLocked(); &#125;&#125; 整个流程很简单，不多说了！ 2.7 publish LocalServiceLocalService 用于系统进程中服务间的相互通信，本地服务实现主要由ActivityManagerService 使用。ActivityManagerService 调用这些方法的时会持有自身的锁，不应该在这些方法中执行任何 IO 工作或其他长时间运行的任务。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133private final class LocalService extends UsageStatsManagerInternal &#123; //【1】向 UsageStatsService 发送应用的使用信息 UsageEvents； @Override public void reportEvent(ComponentName component, int userId, int eventType) &#123; if (component == null) &#123; Slog.w(TAG, \"Event reported without a component name\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = component.getPackageName(); event.mClass = component.getClassName(); // This will later be converted to system time. event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = eventType; //【1.1】发送 MSG_REPORT_EVENT 给 H； mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget(); &#125; @Override public void reportEvent(String packageName, int userId, int eventType) &#123; if (packageName == null) &#123; Slog.w(TAG, \"Event reported without a package name\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = packageName; event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = eventType; mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget(); &#125; //【2】向 UsageStatsService 发送配置的使用信息 UsageEvents； @Override public void reportConfigurationChange(Configuration config, int userId) &#123; if (config == null) &#123; Slog.w(TAG, \"Configuration event reported with a null config\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = \"android\"; event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = UsageEvents.Event.CONFIGURATION_CHANGE; event.mConfiguration = new Configuration(config); //【2.1】发送 MSG_REPORT_EVENT 给 H； mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget(); &#125; //【3】向 UsageStatsService 发送 Shortcut 的使用信息 UsageEvents； @Override public void reportShortcutUsage(String packageName, String shortcutId, int userId) &#123; if (packageName == null || shortcutId == null) &#123; Slog.w(TAG, \"Event reported without a package name or a shortcut ID\"); return; &#125; UsageEvents.Event event = new UsageEvents.Event(); event.mPackage = packageName.intern(); event.mShortcutId = shortcutId.intern(); event.mTimeStamp = SystemClock.elapsedRealtime(); event.mEventType = Event.SHORTCUT_INVOCATION; //【3.1】发送 MSG_REPORT_EVENT 给 H； mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget(); &#125; //【4】向 UsageStatsService 发送 ContentProvider 的使用信息； @Override public void reportContentProviderUsage(String name, String packageName, int userId) &#123; SomeArgs args = SomeArgs.obtain(); args.arg1 = name; args.arg2 = packageName; args.arg3 = userId; //【4.1】发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 给 H； mHandler.obtainMessage(MSG_REPORT_CONTENT_PROVIDER_USAGE, args) .sendToTarget(); &#125; //【5】判断应用是否处于 idle 状态； @Override public boolean isAppIdle(String packageName, int uidForAppId, int userId) &#123; return UsageStatsService.this.isAppIdleFiltered(packageName, uidForAppId, userId, SystemClock.elapsedRealtime()); &#125; //【6】获得指定 userId 下的处于 idle 状态的 uid； @Override public int[] getIdleUidsForUser(int userId) &#123; return UsageStatsService.this.getIdleUidsForUser(userId); &#125; //【7】获得指定 userId 下的处于 idle 状态的 uid； @Override public boolean isAppIdleParoleOn() &#123; return isParoledOrCharging(); &#125; //【8】关机时调用！ @Override public void prepareShutdown() &#123; shutdown(); &#125; //【9】添加和移除 app idle 状态改变监听器 @Override public void addAppIdleStateChangeListener(AppIdleStateChangeListener listener) &#123; UsageStatsService.this.addListener(listener); listener.onParoleStateChanged(isAppIdleParoleOn()); &#125; @Override public void removeAppIdleStateChangeListener( AppIdleStateChangeListener listener) &#123; UsageStatsService.this.removeListener(listener); &#125; @Override public byte[] getBackupPayload(int user, String key) &#123; // Check to ensure that only user 0's data is b/r for now if (user == UserHandle.USER_SYSTEM) &#123; final UserUsageStatsService userStats = getUserDataAndInitializeIfNeededLocked(user, checkAndGetTimeLocked()); return userStats.getBackupPayload(key); &#125; else &#123; return null; &#125; &#125; @Override public void applyRestoredPayload(int user, String key, byte[] payload) &#123; if (user == UserHandle.USER_SYSTEM) &#123; final UserUsageStatsService userStats = getUserDataAndInitializeIfNeededLocked(user, checkAndGetTimeLocked()); userStats.applyRestoredPayload(key, payload); &#125; &#125;&#125; 关于 LocalService 中的方法的触发，我们后面再看！ 2.8 publish BinderServiceBinderService 的所用是跨进程通信！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156private final class BinderService extends IUsageStatsManager.Stub &#123; //【1】判断调用者是否有 PACKAGE_USAGE_STATS 相关的权限！ private boolean hasPermission(String callingPackage) &#123; final int callingUid = Binder.getCallingUid(); if (callingUid == Process.SYSTEM_UID) &#123; return true; &#125; final int mode = mAppOps.checkOp(AppOpsManager.OP_GET_USAGE_STATS, callingUid, callingPackage); if (mode == AppOpsManager.MODE_DEFAULT) &#123; // The default behavior here is to check if PackageManager has given the app // permission. return getContext().checkCallingPermission(Manifest.permission.PACKAGE_USAGE_STATS) == PackageManager.PERMISSION_GRANTED; &#125; return mode == AppOpsManager.MODE_ALLOWED; &#125; //【2】查询应用的使用状态！ @Override public ParceledListSlice&lt;UsageStats&gt; queryUsageStats(int bucketType, long beginTime, long endTime, String callingPackage) &#123; if (!hasPermission(callingPackage)) &#123; return null; &#125; final int userId = UserHandle.getCallingUserId(); final long token = Binder.clearCallingIdentity(); try &#123; final List&lt;UsageStats&gt; results = UsageStatsService.this.queryUsageStats( userId, bucketType, beginTime, endTime); if (results != null) &#123; return new ParceledListSlice&lt;&gt;(results); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; return null; &#125; //【3】查询配置的使用状态！ @Override public ParceledListSlice&lt;ConfigurationStats&gt; queryConfigurationStats(int bucketType, long beginTime, long endTime, String callingPackage) throws RemoteException &#123; if (!hasPermission(callingPackage)) &#123; return null; &#125; final int userId = UserHandle.getCallingUserId(); final long token = Binder.clearCallingIdentity(); try &#123; final List&lt;ConfigurationStats&gt; results = UsageStatsService.this.queryConfigurationStats(userId, bucketType, beginTime, endTime); if (results != null) &#123; return new ParceledListSlice&lt;&gt;(results); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; return null; &#125; //【4】查询应用的使用事件信息！ @Override public UsageEvents queryEvents(long beginTime, long endTime, String callingPackage) &#123; if (!hasPermission(callingPackage)) &#123; return null; &#125; final int userId = UserHandle.getCallingUserId(); final long token = Binder.clearCallingIdentity(); try &#123; return UsageStatsService.this.queryEvents(userId, beginTime, endTime); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125; //【5】判断应用是否处于 inactive 状态！ @Override public boolean isAppInactive(String packageName, int userId) &#123; try &#123; userId = ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, true, \"isAppInactive\", null); &#125; catch (RemoteException re) &#123; throw re.rethrowFromSystemServer(); &#125; final long token = Binder.clearCallingIdentity(); try &#123; return UsageStatsService.this.isAppIdleFilteredOrParoled(packageName, userId, SystemClock.elapsedRealtime()); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125; //【5】判断应用是否处于 inactive 状态！ @Override public void setAppInactive(String packageName, boolean idle, int userId) &#123; final int callingUid = Binder.getCallingUid(); try &#123; userId = ActivityManagerNative.getDefault().handleIncomingUser( Binder.getCallingPid(), callingUid, userId, false, true, \"setAppIdle\", null); &#125; catch (RemoteException re) &#123; throw re.rethrowFromSystemServer(); &#125; getContext().enforceCallingPermission(Manifest.permission.CHANGE_APP_IDLE_STATE, \"No permission to change app idle state\"); final long token = Binder.clearCallingIdentity(); try &#123; final int appId = getAppId(packageName); if (appId &lt; 0) return; UsageStatsService.this.setAppIdle(packageName, idle, userId); &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125; //【6】将应用添加到 doze 模式临时白名单中！ @Override public void whitelistAppTemporarily(String packageName, long duration, int userId) throws RemoteException &#123; StringBuilder reason = new StringBuilder(32); reason.append(\"from:\"); UserHandle.formatUid(reason, Binder.getCallingUid()); mDeviceIdleController.addPowerSaveTempWhitelistApp(packageName, duration, userId, reason.toString()); &#125; //【7】运营商特权应用变化！ @Override public void onCarrierPrivilegedAppsChanged() &#123; if (DEBUG) &#123; Slog.i(TAG, \"Carrier privileged apps changed\"); &#125; getContext().enforceCallingOrSelfPermission( android.Manifest.permission.BIND_CARRIER_SERVICES, \"onCarrierPrivilegedAppsChanged can only be called by privileged apps.\"); UsageStatsService.this.clearCarrierPrivilegedApps(); &#125; //【8】用于 dumpsys！ @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123; if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) &#123; pw.println(\"Permission Denial: can't dump UsageStats from pid=\" + Binder.getCallingPid() + \", uid=\" + Binder.getCallingUid() + \" without permission \" + android.Manifest.permission.DUMP); return; &#125; UsageStatsService.this.dump(args, pw); &#125;&#125; 关于 BinderService 中的方法的触发，我们后面再看！ 3 UsageStatsS.onBootPhase1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void onBootPhase(int phase) &#123; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; //【*3.1】创建一个 SettingsObserver， 监听数据库变化！ SettingsObserver settingsObserver = new SettingsObserver(mHandler); settingsObserver.registerObserver(); settingsObserver.updateSettings(); //【2】获得系统中的一些其他重要服务管理对象：DeviceIdleController， // BatteryStats，DisplayManager 和 PowerManager！ mAppWidgetManager = getContext().getSystemService(AppWidgetManager.class); mDeviceIdleController = IDeviceIdleController.Stub.asInterface( ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER)); mBatteryStats = IBatteryStats.Stub.asInterface( ServiceManager.getService(BatteryStats.SERVICE_NAME)); mDisplayManager = (DisplayManager) getContext().getSystemService( Context.DISPLAY_SERVICE); mPowerManager = getContext().getSystemService(PowerManager.class); //【*3.2】注册 DisplayListener mDisplayManager.registerDisplayListener(mDisplayListener, mHandler); synchronized (mLock) &#123; //【*3.2.1】初始化 AppIdleHistory 的亮屏信息！ mAppIdleHistory.updateDisplayLocked(isDisplayOn(), SystemClock.elapsedRealtime()); &#125; //【*3.4】mPendingOneTimeCheckIdleStates 为 true 表示正在等待查询 idle 状态！ // 那么就会再次调用 postOneTimeCheckIdleStates 方法！ if (mPendingOneTimeCheckIdleStates) &#123; postOneTimeCheckIdleStates(); &#125; mSystemServicesReady = true; &#125; else if (phase == PHASE_BOOT_COMPLETED) &#123; //【*2.4.1】初始化充电状态信息； setChargingState(getContext().getSystemService(BatteryManager.class).isCharging()); &#125;&#125; onBootPhase 方法会在两个阶段下调用： PHASE_SYSTEM_SERVICES_READY：此时系统服务已经都启动了； PHASE_BOOT_COMPLETED：此时设备重启完成了； 3.1 new SettingsObserver - 监听数据库变化这里会创建一个 SettingsObserver 观察者，监听数据表变化！123456789 private class SettingsObserver extends ContentObserver &#123; private final KeyValueListParser mParser = new KeyValueListParser(','); SettingsObserver(Handler handler) &#123; super(handler); &#125; ... ... ...&#125; 3.1.1 SettingsObserver.registerObserver监听的 Settings 表单是 app_idle_constants！1234void registerObserver() &#123; getContext().getContentResolver().registerContentObserver(Settings.Global.getUriFor( Settings.Global.APP_IDLE_CONSTANTS), false, this);&#125; 3.1.2 SettingsObserver.onChange当数据库有变化后，会触发 onChange 方法：1234567@Overridepublic void onChange(boolean selfChange) &#123; //【3.1.3】初始化数据！ updateSettings(); //【3.4】调用 postOneTimeCheckIdleStates 方法进行一次 idle 检查！ postOneTimeCheckIdleStates();&#125; 3.1.3 SettingsObserver.updateSettings12345678910111213141516171819202122232425262728293031 void updateSettings() &#123; synchronized (mLock) &#123; try &#123; mParser.setString(Settings.Global.getString(getContext().getContentResolver(), Settings.Global.APP_IDLE_CONSTANTS)); &#125; catch (IllegalArgumentException e) &#123; Slog.e(TAG, \"Bad value for app idle settings: \" + e.getMessage()); &#125; // 值为 12 hours； mAppIdleScreenThresholdMillis = mParser.getLong(KEY_IDLE_DURATION, COMPRESS_TIME ? ONE_MINUTE * 4 : 12 * 60 * ONE_MINUTE); // 值为 48 hours； mAppIdleWallclockThresholdMillis = mParser.getLong(KEY_WALLCLOCK_THRESHOLD, COMPRESS_TIME ? ONE_MINUTE * 8 : 2L * 24 * 60 * ONE_MINUTE); // 值为 8 hours； mCheckIdleIntervalMillis = Math.min(mAppIdleScreenThresholdMillis / 4, COMPRESS_TIME ? ONE_MINUTE : 8 * 60 * ONE_MINUTE); // 置为 24 hours； mAppIdleParoleIntervalMillis = mParser.getLong(KEY_PAROLE_INTERVAL, COMPRESS_TIME ? ONE_MINUTE * 10 : 24 * 60 * ONE_MINUTE); // 置为 10 mins； mAppIdleParoleDurationMillis = mParser.getLong(KEY_PAROLE_DURATION, COMPRESS_TIME ? ONE_MINUTE : 10 * ONE_MINUTE); //【3.1.3.1】设置阈值到 AppIdleHistory 中！ mAppIdleHistory.setThresholds(mAppIdleWallclockThresholdMillis, mAppIdleScreenThresholdMillis); &#125; &#125;&#125; 这里涉及到几个重要的时间变量： mAppIdleScreenThresholdMillis：12 hours，是应用是否进入 idle 状态的临界值！ mAppIdleWallclockThresholdMillis：48 hours，是应用是否进入 idle 状态的临界值！ mCheckIdleIntervalMillis：表示执行 check idle 操作的时间间隔，8 hours！ mAppIdleParoleIntervalMillis：相邻 2 次进入假释状态的时间间隔，24 hours！ mAppIdleParoleDurationMillis：假释状态的持续时间，10mins！ 这里的 COMPRESS_TIME 的值恒定为 false！ 1static final boolean COMPRESS_TIME = false; 3.1.3.1 AppIdleHistory.setThresholds设置阈值信息，该阈值会用于判断应用是否处于 idle 状态！1234public void setThresholds(long elapsedTimeThreshold, long screenOnTimeThreshold) &#123; mElapsedTimeThreshold = elapsedTimeThreshold; mScreenOnTimeThreshold = screenOnTimeThreshold;&#125; 我们来解释下这两个阈值的作用： 3.2 register DisplayListener - 监听屏幕状态UsageStatsService 内部有一个 DisplayListener 实例：mDisplayListener，专门用于监听屏幕的状态，然后触发 AppIdleHistory 的更新！ 12345678910111213private final DisplayManager.DisplayListener mDisplayListener = new DisplayManager.DisplayListener() &#123; ... ... ... @Override public void onDisplayChanged(int displayId) &#123; if (displayId == Display.DEFAULT_DISPLAY) &#123; final boolean displayOn = isDisplayOn(); synchronized (UsageStatsService.this.mLock) &#123; //【3.3】更新 AppIdleHistory 中的屏幕信息！ mAppIdleHistory.updateDisplayLocked(displayOn, SystemClock.elapsedRealtime()); &#125; &#125; &#125;&#125;; 当屏幕的状态发生变化后，会触发 DisplayListener.onDisplayChanged 方法，紧接着触发 AppIdleHistory.updateDisplayLocked 方法！ 3.2.1 AppIdleHistory.updateDisplayLockedupdateDisplayLocked 方法用于更新屏幕状态信息！ 12345678910111213141516171819public void updateDisplayLocked(boolean screenOn, long elapsedRealtime) &#123; //【1】如果相等，无需更新！ if (screenOn == mScreenOn) return; //【2】更新 mScreenOn 的值； mScreenOn = screenOn; //【3】根据当前屏幕的状态，更新不同的值； if (mScreenOn) &#123; //【3.1】如果此时亮屏，记录亮屏时间点！ mScreenOnSnapshot = elapsedRealtime; &#125; else &#123; //【3.2】如果此时灭屏，记录本次亮屏时长，累加到 mScreenOnDuration； mScreenOnDuration += elapsedRealtime - mScreenOnSnapshot; // 计算距离上次灭屏时间点的时间间隔，累加到 mElapsedDuration； mElapsedDuration += elapsedRealtime - mElapsedSnapshot; // 记录最新灭屏时间点； mElapsedSnapshot = elapsedRealtime; &#125;&#125; 通过 isDisplayOn 方法，来判断当前是亮屏还是熄屏：1234private boolean isDisplayOn() &#123; return mDisplayManager .getDisplay(Display.DEFAULT_DISPLAY).getState() == Display.STATE_ON;&#125; AppIdleHistory 内部是有一个变量 mScreenOn，保存屏幕的状态信息，默认为 false： mScreenOnSnapshot 用于每次亮屏的时间点，mElapsedSnapshot 用于记录每次灭屏的时间点； mScreenOnDuration 用于累计所有亮屏的总时长，mElapsedDuration 用于了累计所有相邻两次灭屏的总时长！ 如果是此时是亮屏的话，会将时间记录到 mScreenOnSnapshot 中！ 3.4 UsageStatsS.postOneTimeCheckIdleStates12345678910void postOneTimeCheckIdleStates() &#123; if (mDeviceIdleController == null) &#123; mPendingOneTimeCheckIdleStates = true; &#125; else &#123; //【4.7】发送 MSG_ONE_TIME_CHECK_IDLE_STATES 消息给 H，触发 check idle 操作！ mHandler.sendEmptyMessage(MSG_ONE_TIME_CHECK_IDLE_STATES); mPendingOneTimeCheckIdleStates = false; &#125;&#125; 如果 mDeviceIdleController 为 null，说明 UsageStatsService 还没有启动完成，这里会先将 mPendingOneTimeCheckIdleStates 置为 true！等到启动完成后会判断该变量的值，如果为 true，那就会继续调用 postOneTimeCheckIdleStates 方法！ 如果 mDeviceIdleController 不为 null，发送 MSG_ONE_TIME_CHECK_IDLE_STATES 消息给 H，触发 check idle 操作！同时设置 mPendingOneTimeCheckIdleStates 为 false；","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"UsageStats使用状态管理","slug":"AndroidFramework源码分析/UsageStats使用状态管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/UsageStats使用状态管理/"}],"tags":[{"name":"UsageStats使用状态管理","slug":"UsageStats使用状态管理","permalink":"https://coolqi.top/tags/UsageStats使用状态管理/"}]},{"title":"Serivce 篇 8 - Service stopSelf 流程分析","slug":"Serivce8-serviceStopSelf","date":"2016-10-29T12:46:25.000Z","updated":"2018-11-20T16:35:15.000Z","comments":true,"path":"2016/10/29/Serivce8-serviceStopSelf/","link":"","permalink":"https://coolqi.top/2016/10/29/Serivce8-serviceStopSelf/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，转载请说明出处！ 0 综述对于 Service，我们除了可以调用 stopService 来停止服务，服务自身也可以调用 stopSelf 方法停止，下面我们来看看这几个方法！1234567891011121314151617181920212223242526public final void stopSelf() &#123; stopSelf(-1);&#125;public final void stopSelf(int startId) &#123; if (mActivityManager == null) &#123; return; &#125; try &#123; mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125;&#125;public final boolean stopSelfResult(int startId) &#123; if (mActivityManager == null) &#123; return false; &#125; try &#123; return mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125; return false;&#125; 这几个方法有什么区别呢？这里先简单的说一下： stopSelf() 方法，会调用第二个 stopSelf(int startId) 方法，如果服务之前通过 startService 方法启动过了，那该方法就等价于调用 stopService 方法！ stopSelf(int startId) 方法，是 stopSelfResult 方法的旧版本，不会返回任何结果！ stopSelfResult(int startId) 方法，通过指定启动项的 startId 来停止服务，该方法也等价于 stopService 方法，但是它能避免在停止服务时，服务仍没有接收到启动项！ 下面，我们来看看该方法的调用过程！ 1 系统进程这里省略了 Binder 调用的过程，Binder 客户端发送 STOP_SERVICE_TOKEN_TRANSACTION 到 Binder 服务端，进入系统进程中！！ 1.1 ActivityManagerS.stopServiceToken12345678@Overridepublic boolean stopServiceToken(ComponentName className, IBinder token, int startId) &#123; synchronized(this) &#123; return mServices.stopServiceTokenLocked(className, token, startId); &#125;&#125; 这里我们来解释一下参数： ComponentName className：服务对应的 ComponentName 对象。封装了组件信息，包括其所在的运行环境，对应的 .class 文件名！ IBinder token：ServiceRecord 对象，在启动服务时，会将该对象保存到 Service 的 int startId：启动项的 id 值； 1.2 ActiveServices.stopServiceToken123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657boolean stopServiceTokenLocked(ComponentName className, IBinder token, int startId) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"stopServiceToken: \" + className + \" \" + token + \" startId=\" + startId); //【1】尝试根据服务的信息，匹配到对应的 ServiceRecord 对象！ ServiceRecord r = findServiceLocked(className, token, UserHandle.getCallingUserId()); if (r != null) &#123; // 如果指定了启动项目的 Id，进入该分支！ if (startId &gt;= 0) &#123; //【2】从已经分发的启动项列表 deliveredStarts 中移除并返回找到 startId 对应的启动项 StartItem； ServiceRecord.StartItem si = r.findDeliveredStart(startId, false); if (si != null) &#123; while (r.deliveredStarts.size() &gt; 0) &#123; ServiceRecord.StartItem cur = r.deliveredStarts.remove(0); cur.removeUriPermissionsLocked(); if (cur == si) &#123; break; &#125; &#125; &#125; // 如果指定的启动项 id 不是最后自动服务的启动项目，那就不能停止服务！ if (r.getLastStartId() != startId) &#123; return false; &#125; if (r.deliveredStarts.size() &gt; 0) &#123; Slog.w(TAG, \"stopServiceToken startId \" + startId + \" is last, but have \" + r.deliveredStarts.size() + \" remaining args\"); &#125; &#125; synchronized (r.stats.getBatteryStats()) &#123; r.stats.stopRunningLocked(); &#125; // 将服务的 startRequested 置为 false，表示未请求启动； r.startRequested = false; if (r.tracker != null) &#123; r.tracker.setStarted(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); &#125; // 将服务的 callStart 置为false，表示未执行启动； r.callStart = false; final long origId = Binder.clearCallingIdentity(); //【3】停止服务！ bringDownServiceIfNeededLocked(r, false, false); Binder.restoreCallingIdentity(origId); return true; &#125; return false;&#125; 如果没指定启动项的 id，即：startId &gt;= 0，那就要判断下该 id 是否对应了最后一个启动项，如果是，才会立刻停止！！如果指定了启动项的 id，即：startId &lt; 0，那就立刻停止服务； 最后调用了 bringDownServiceIfNeededLocked 来停止服务，这里的逻辑就和 stopService 中的逻辑一样了！ 下面我们来看看其他的几个方法： 获得对应的 ServiceRecord 对象： 12345private final ServiceRecord findServiceLocked(ComponentName name, IBinder token, int userId) &#123; ServiceRecord r = getServiceByName(name, userId); return r == token ? r : null;&#125; 找到 id 对应的启动项 StartItem： 123456789101112public StartItem findDeliveredStart(int id, boolean remove) &#123; final int N = deliveredStarts.size(); for (int i=0; i&lt;N; i++) &#123; StartItem si = deliveredStarts.get(i); if (si.id == id) &#123; if (remove) deliveredStarts.remove(i); return si; &#125; &#125; return null;&#125; 这里就不在多书了，过程很清晰哦！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"Serivce 篇 7 - Service restart 流程分析","slug":"Serivce7-serviceRestart","date":"2016-09-21T12:46:25.000Z","updated":"2018-11-20T16:34:53.000Z","comments":true,"path":"2016/09/21/Serivce7-serviceRestart/","link":"","permalink":"https://coolqi.top/2016/09/21/Serivce7-serviceRestart/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，转载请说明出处！ 0 综述当服务被 kill 掉后，会根据 onStartCommand 方法的返回值，来决定是否对服务进行重启，我们先来回顾下返回值类型： START_STICKY： START_STICKY_COMPATIBILITY： 删除本次启动的 startId 对应的启动项； 设置服务的 stopIfKilled 为 false； START_NOT_STICKY： 删除本次启动的服务的 startId 对应的启动项； 如果最后一次启动的启动项的 id(lastStartId) 等于本次启动的启动项的 id； 设置服务的 stopIfKilled 为 true； START_REDELIVER_INTENT： 不删除本次启动的 startId 对应的启动项； 如果本次启动的启动项不为 null； 设置启动项的 deliveryCount 为 0； 设置启动项的 doneExecutingCount 加 1； 设置服务的 stopIfKilled 为 true； 下面，我们来分析下服务的重启过程，有两种情况会出现服务的重启： 第一种是，在拉起 Service 的 onCreate 方法时出现异常，这时如果服务没有被 destroy 掉，那就会尝试重新启动服务！ 第二种是，服务所在的进程被 kill 掉了，这是会尝试重启服务！ 1 第一种情况1.1 ActiveServices.realStartServiceLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; ... ... ... ... try &#123; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); // 更新服务的 state！ app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); // 拉起服务的 onCreate 方法 app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; Slog.w(TAG, \"Application dead when creating service \" + r); mAm.appDiedLocked(app); throw e; &#125; finally &#123; if (!created) &#123; // created 为 false，表示拉起失败！ final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); if (newService) &#123; app.services.remove(r); r.app = null; &#125; //【1】如果服务没有被销毁掉，那就尝试重新启动服务！ if (!inDestroying) &#123; scheduleServiceRestartLocked(r, false); &#125; &#125; &#125; ... ... ... ...&#125; 我们继续来看！ 1.2 ActiveServices.scheduleServiceRestartLocked参数传递： ServiceRecord r：要被重启的服务； boolean allowCancel：这里传入 false； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167private final boolean scheduleServiceRestartLocked(ServiceRecord r, boolean allowCancel) &#123; // 变量 cancel 用于表示是否放弃重启服务！ boolean canceled = false; //【1】如果系统在关机，那就不重启！ if (mAm.isShuttingDownLocked()) &#123; Slog.w(TAG, \"Not scheduling restart of crashed service \" + r.shortName + \" - system is shutting down\"); return false; &#125; ServiceMap smap = getServiceMap(r.userId); //【1】再次和服务集合中的服务匹配校验，如果不是同一个，那就停止重启！ if (smap.mServicesByName.get(r.name) != r) &#123; ServiceRecord cur = smap.mServicesByName.get(r.name); Slog.wtf(TAG, \"Attempting to schedule restart of \" + r + \" when found in map: \" + cur); return false; &#125; final long now = SystemClock.uptimeMillis(); //【1.1】对于非常驻类型的服务，进入这个分支！ if ((r.serviceInfo.applicationInfo.flags &amp;ApplicationInfo.FLAG_PERSISTENT) == 0) &#123; // minDuration 是被系统重启的时间间隔 long minDuration = SERVICE_RESTART_DURATION; // resetTime 是重置这个重启时间的间隔 long resetTime = SERVICE_RESET_RUN_DURATION; // 便利该服务的 deliveredStarts 集合，获得所有已经被分发的启动项！！ // 对于那些之前已经分发但是没有完成的启动项，要重新加入到 pendingStarts 队列中！ final int N = r.deliveredStarts.size(); if (N &gt; 0) &#123; for (int i=N-1; i&gt;=0; i--) &#123; ServiceRecord.StartItem si = r.deliveredStarts.get(i); si.removeUriPermissionsLocked(); if (si.intent == null) &#123; &#125; else if (!allowCancel || (si.deliveryCount &lt; ServiceRecord.MAX_DELIVERY_COUNT &amp;&amp; si.doneExecutingCount &lt; ServiceRecord.MAX_DONE_EXECUTING_COUNT)) &#123; // 如果不允许取消，显然这里 allowCancel 为 false； // 或者该启动项的分发次数小于最大值 3 次，且处理次数小于最大值 6 次 // 才会把该启动项重新添加到 pendingStarts 列表中！ r.pendingStarts.add(0, si); long dur = SystemClock.uptimeMillis() - si.deliveredTime; dur *= 2; if (minDuration &lt; dur) minDuration = dur; if (resetTime &lt; dur) resetTime = dur; &#125; else &#123; Slog.w(TAG, \"Canceling start item \" + si.intent + \" in service \" + r.name); // 置 canceled 为 true，表示放弃重启服务！ canceled = true; &#125; &#125; r.deliveredStarts.clear(); &#125; // 服务的重启次数加一； r.totalRestartCount++; // 计算服务的重启延迟时间； if (r.restartDelay == 0) &#123; // 如果没有重启过，restartDelay 为 0； // 那么重启延迟时间为 minDuration； r.restartCount++; r.restartDelay = minDuration; &#125; else &#123; // 如果已经重启过了，进入以下分支； // restartTime 是上一次重启的时间； if (now &gt; (r.restartTime+resetTime)) &#123; // 并且当前时间距离上次重启时间超过了 resetTime， // 则把 restartCount 重置为 1，restartDelay 设为 minDuration！ r.restartCount = 1; r.restartDelay = minDuration; &#125; else &#123; // 并且当前时间距离上次重启时间没有超过 resetTime，则调大 restartDelay！ r.restartDelay *= SERVICE_RESTART_DURATION_FACTOR; if (r.restartDelay &lt; minDuration) &#123; r.restartDelay = minDuration; &#125; &#125; &#125; // 计算服务的下一次重启时间 r.nextRestartTime = now + r.restartDelay; // 设置所有服务的重启时间差最小为 10 秒！ // 一个服务重启后，下一个服务至少 10 后才能被重启！ boolean repeat; do &#123; repeat = false; for (int i=mRestartingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord r2 = mRestartingServices.get(i); if (r2 != r &amp;&amp; r.nextRestartTime &gt;= (r2.nextRestartTime-SERVICE_MIN_RESTART_TIME_BETWEEN) &amp;&amp; r.nextRestartTime &lt; (r2.nextRestartTime+SERVICE_MIN_RESTART_TIME_BETWEEN)) &#123; r.nextRestartTime = r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN; r.restartDelay = r.nextRestartTime - now; repeat = true; break; &#125; &#125; &#125; while (repeat); &#125; else &#123; //【1.2】常驻进程的服务要被立刻重启！ r.totalRestartCount++; r.restartCount = 0; r.restartDelay = 0; r.nextRestartTime = now; &#125; //【2】如果 mRestartingServices 列表中服务该服务，将该服务添加进去！ if (!mRestartingServices.contains(r)) &#123; r.createdFromFg = false; mRestartingServices.add(r); r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(), now); &#125; //【3】取消前台的 notification，这个是通过 startForegroud 的方式设置的！ cancelForegroudNotificationLocked(r); //【4】这里是最关键的地方，执行重启服务的操作！！ // 这里会使用 AMS.MainHandler 来执行重启任务 mAm.mHandler.removeCallbacks(r.restarter); mAm.mHandler.postAtTime(r.restarter, r.nextRestartTime); // 计算下次重启时间！ r.nextRestartTime = SystemClock.uptimeMillis() + r.restartDelay; Slog.w(TAG, \"Scheduling restart of crashed service \" + r.shortName + \" in \" + r.restartDelay + \"ms\"); EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART, r.userId, r.shortName, r.restartDelay); return canceled; &#125; 这里涉及了几个常量： ActiveServices 1234567891011// 两个服务的重启间隔的最小值！static final int SERVICE_MIN_RESTART_TIME_BETWEEN = 10*1000;// 服务延迟重启的时间间隔static final int SERVICE_RESTART_DURATION = 1*1000;// 重置服务的重启时间的时间间隔static final int SERVICE_RESET_RUN_DURATION = 60*1000;// 用于扩大服务重启的时间间隔的乘法因子static final int SERVICE_RESTART_DURATION_FACTOR = 4; ServiceRecord 12345// 放弃重启操作前，启动项分发的最大次数static final int MAX_DELIVERY_COUNT = 3;// 放弃重启操作前，启动项执行的最大次数static final int MAX_DONE_EXECUTING_COUNT = 6; 还记得 ServiceRestarter，在启动服务前，会创建一个 ServiceRestarter 对象，用于重启服务！ 我们看到，如果服务之前重启过，并且当前时间距离上次重启时间没有超过 resetTime，则调大 restartDelay！ 这是为了防止 service 被在内存不足的情况下被频繁重启，第一次内存不足时杀掉 service，1s 后重启该 service，重启后又消耗了一部分内存造成内存再次不足再次杀掉 service，这时1s后就不应该重启了，要往后推迟一段时间再尝试重启。 3 ServiceRestarter.run123456789101112131415private class ServiceRestarter implements Runnable &#123; private ServiceRecord mService; void setService(ServiceRecord service) &#123; mService = service; &#125; public void run() &#123; synchronized(mAm) &#123; //【1】重启服务！ performServiceRestartLocked(mService); &#125; &#125;&#125; 继续看！ 4 ActiveServices.performServiceRestartLocked1234567891011121314151617181920final void performServiceRestartLocked(ServiceRecord r) &#123; // 如果服务没有在重启列表中，就不重启！ if (!mRestartingServices.contains(r)) &#123; return; &#125; // 如果服务不再需要，就不重启！ if (!isServiceNeeded(r, false, false)) &#123; Slog.wtf(TAG, \"Restarting service that is not needed: \" + r); return; &#125; try &#123; //【1】进入 bringUpServiceLocked 方法，执行重启服务操作！ bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false); &#125; catch (TransactionTooLargeException e) &#123; // Ignore, it's been logged and nothing upstack cares. &#125;&#125; 这里和前面的 startService 的逻辑是一样的！但是我们重点要看的是，对于 onStartCommand 方法的返回值，在重启的时候，系统是如何处理的！！ 5 onStartCommand 返回值的不同处理5.1 START_STICKY（默认返回值）对于 Service.START_STICKY 的返回值，服务所在进程被 kill 后，系统会重新启动该服务以及所在进程！ onStartCommand 方法在返回 Service.START_STICKY 后，系统会做如下处理： 从 r.deliveredStarts 中删除 startId 对应的启动项 设置 r.stopIfKilled = false 设置 r.callStart = true 对于这种返回值，服务的 r.deliveredStarts 和 r.pendingStarts 中的启动项都为空，所以在 scheduleServiceRestartLocked 方法中，不会遍历 deliveredStarts 集合，所以 scheduleServiceRestartLocked 的返回值 canceled 为 false； sr.startRequested 在开始启动时就被设置成了 true！这样，scheduleServiceRestartLocked 方法返回后，就不会进入这个分支：1234567// sr.startRequested: true sr.stopIfKilled: false canceled: false，不进入该分支！if (sr.startRequested &amp;&amp; (sr.stopIfKilled || canceled)) &#123; ... ... ... bringDownServiceLocked(sr);&#125; 接下来，就是服务的重启了，这时就进入 bringUpServiceLocked 方法，因为对于 Service.START_STICKY 的返回值：12if(r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123;&#125; 这个的条件是满足的，那就会创建一个 Intent 为 null 启动项，添加到 r.pendingStarts 中，如果你在 onStartCommand 方法中，对参数 Intent 做一个非空判断，你会发现，这个 Intent 为 null！！1234567@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; if (intent == null) &#123; Log.d(TAG, \"the intent is null!\"); &#125; return Service.START_STICKY;&#125; 5.2 START_NOT_STICKY对于 Service.START_NOT_STICKY 的返回值，服务所在进程被 kill 后，系统不会重新启动该服务以及所在进程！ onStartCommand 方法在返回 Service.START_NOT_STICKY 后，系统会做如下处理： 从 r.deliveredStarts 中删除 startId 对应的启动项； 如果 r.getLastStartId() == startId，设置 r.stopIfKilled = true；（和 START_STICKY 的不同之处） r.callStart = true； 对于这种返回值，服务的 r.deliveredStarts 和 r.pendingStarts 中的启动项也都为空，所以在 scheduleServiceRestartLocked 方法中，不会遍历 deliveredStarts 集合，所以 scheduleServiceRestartLocked 的返回值 canceled 同样也为 false； 而 sr.startRequested 在开始启动时就被设置成了 true！这样，scheduleServiceRestartLocked 返回后，根据结果，就会进入这个分支：12345678910111213141516// sr.startRequested: true sr.stopIfKilled: true canceled: falseif(r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; // 同样的 sr.pendingStarts.size() == 0 满足条件，进入该分支！ if (sr.pendingStarts.size() == 0) &#123; sr.startRequested = false; if (sr.tracker != null) &#123; sr.tracker.setStarted(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); &#125; // 如果之前服务没有自动创建的连接，就停止服务！ if (!sr.hasAutoCreateConnections()) &#123; bringDownServiceLocked(sr); &#125; &#125;&#125; 如果我们之前只是通过 startService 的方式，启动了服务，那么，这里就会调用 bringDownServiceLocked 停止服务，所以，单纯的 startService，如果 onStartCommand 返回值为 Service.START_NOT_STICKY，那么服务是不会重启的！ 但是如果还通过 bindSerivce（Service.BIND_AUTO_CREATE）的方式创建了连接，那么还是会重启服务！ 5.2 START_REDELIVER_INTENT对于 Service.START_REDELIVER_INTENT 的返回值，服务所在进程被 kill 后，系统会重新启动该服务以及所在进程，并且会将最后启动（startService）分发过的 Intent 再次通过 onStartCommand 方法传递给服务！ onStartCommand 方法在返回 START_REDELIVER_INTENT 后，系统会做如下处理: 从 r.deliveredStarts 中获得 startId 对应的启动项 StartItem si ，【不删除】； 如果 si != null： si.deliveryCount = 0; si.doneExecutingCount++;（这样设置，在 7.2.3 的时候，flags 就会被设置 START_FLAG_REDELIVER 的标签） r.stopIfKilled = true; r.callStart = true; 因为没有删除 r.deliveredStarts 中已经被分发的启动项，所以也就意味着，如果是多次 startSerivce，那么 r.deliveredStarts 会将所有的启动项都保留下来！ 对于这种返回值，服务的 r.deliveredStarts 保存了所有的被分发的启动项，而 r.pendingStarts 中的启动项为空，我们先到 scheduleServiceRestartLocked 方法中去！ 在 scheduleServiceRestartLocked 方法中，会将服务的 r.deliveredStarts 中所有的启动项，添加到 r.pendingStarts 中，用于重启后分发！ scheduleServiceRestartLocked 方法返回后，由于 sr.startRequested 为 true，sr.stopIfKilled 为 true， 且 canceled 为 false 满足条件，则会进入以下分支：1234567// sr.startRequested: true sr.stopIfKilled: true canceled: falseif(r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; // 然而 sr.pendingStarts.size() ！= 0 ，不进入分支！ if (sr.pendingStarts.size() == 0) &#123; &#125;&#125; 但是由于此时，sr.pendingStarts.size() 是不为 0 的，所以就不会停止服务，而是重启服务！因为所有的启动项 si.doneExecutingCount 都大于 0，所以 onStartCommand 方法的参数 flags 会设置 Service.START_FLAG_REDELIVERY 标志位！ 当 onStartCommand 方法被拉起后，传入的 Intent 就是之前 startService 时传入的 Intent，如果之前多次调用了 startService 方法，那么当服务被重启后，onStartCommand 方法会被拉起多次，传入的 Intent 则是按照之前多次调用 startService 的 startId 顺序进行传入！ 第二种是，当服务所在的进程因内存不足而被 kill 掉，会触发 AMS.cleanUpApplicationRecordLocked 方法，用于清理进程的资源： 123456789101112private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) &#123; Slog.d(TAG, \"cleanUpApplicationRecord -- \" + app.pid); ... ... ... ... //【1】这里会杀掉该进程中的所有服务，allownRestart 方式是否允许服务重启！ mServices.killServicesLocked(app, allowRestart); ... ... ... ... &#125; 1 ActiveServices.killServicesLocked参数传递： ProcessRecord app：被 kill 掉的进程！ boolean allowRestart：表示是否重启服务，当进程被杀掉后，传入 true！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210final void killServicesLocked(ProcessRecord app, boolean allowRestart) &#123; // 默认不进入该分支，我们不看！ if (false) &#123; ... ... ... &#125; // 清楚这个进程持有的所有的连接对象 ConnectionRecord！ for (int i = app.connections.size() - 1; i &gt;= 0; i--) &#123; ConnectionRecord r = app.connections.valueAt(i); // 这里和调用 unbindService 方法很类似，主要是解除该进程对其他服务的绑定！ removeConnectionLocked(r, app, null); &#125; updateServiceConnectionActivitiesLocked(app); app.connections.clear(); app.whitelistManager = false; //【1】遍历被 kill 掉的进程中的所有服务! for (int i = app.services.size() - 1; i &gt;= 0; i--) &#123; ServiceRecord sr = app.services.valueAt(i); synchronized (sr.stats.getBatteryStats()) &#123; sr.stats.stopLaunchedLocked(); &#125; // 如果该服务所在进程不是当前进程，并且进程仍在运行，且不是常驻进程 // 那就从服务所在进程中移除该服务！ if (sr.app != app &amp;&amp; sr.app != null &amp;&amp; !sr.app.persistent) &#123; sr.app.services.remove(sr); &#125; sr.app = null; sr.isolatedProc = null; sr.executeNesting = 0; sr.forceClearTracker(); if (mDestroyingServices.remove(sr)) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"killServices remove destroying \" + sr); &#125; // 在 ServiceRecord.bindings 中保存了绑定该服务的所有 intent 和 IntentBindRecord 的映射关系！ final int numClients = sr.bindings.size(); for (int bindingi=numClients-1; bindingi&gt;=0; bindingi--) &#123; IntentBindRecord b = sr.bindings.valueAt(bindingi); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Killing binding \" + b + \": shouldUnbind=\" + b.hasBound); // 初始化 IntentBindRecord 一切属性！ b.binder = null; b.requested = b.received = b.hasBound = false; // If this binding is coming from a cached process and is asking to keep // the service created, then we'll kill the cached process as well -- we // don't want to be thrashing around restarting processes that are only // there to be cached. // 遍历 IntentBindRecord 对象的 apps 哈希表，该哈希表保存了使用该 Intent 绑定该服务的所有进程 // ProcessRecord 和进程绑定信息 AppBindRecord 的映射关系！ for (int appi=b.apps.size()-1; appi&gt;=0; appi--) &#123; final ProcessRecord proc = b.apps.keyAt(appi); // 如果进程被杀了或者没有启动，就跳过处理！ if (proc.killedByAm || proc.thread == null) &#123; continue; &#125; // Only do this for processes that have an auto-create binding; // otherwise the binding can be left, because it won't cause the // service to restart. // 判断该进程持有的所有连接对象 ConnectionRecord 是否是通过 BIND_FLAG_AUTO 方式创建的！ final AppBindRecord abind = b.apps.valueAt(appi); boolean hasCreate = false; for (int conni=abind.connections.size()-1; conni&gt;=0; conni--) &#123; ConnectionRecord conn = abind.connections.valueAt(conni); if ((conn.flags&amp;(Context.BIND_AUTO_CREATE|Context.BIND_ALLOW_OOM_MANAGEMENT |Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) &#123; // 设 hasCreate 为 true，表示存在自动创建的绑定！ hasCreate = true; break; &#125; &#125; if (!hasCreate) &#123; // 不存在自动创建的连接，就跳过这个服务！ continue; &#125; // 如果存在自动创建的连接，如果该进程不是常驻进程，并且该进程在运行中， // 该进程的 pid 不等于 0，也不等于系统进程 pid，且进程的状态不低于 PROCESS_STATE_LAST_ACTIVITY // 那就要尝试杀掉进程，解除绑定！ if (false &amp;&amp; proc != null &amp;&amp; !proc.persistent &amp;&amp; proc.thread != null &amp;&amp; proc.pid != 0 &amp;&amp; proc.pid != ActivityManagerService.MY_PID &amp;&amp; proc.setProcState &gt;= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; proc.kill(\"bound to service \" + sr.name.flattenToShortString() + \" in dying proc \" + (app != null ? app.processName : \"??\"), true); &#125; &#125; &#125; &#125; ServiceMap smap = getServiceMap(app.userId); //【2】开始处理被 kill 的进程中的服务！ for (int i=app.services.size()-1; i&gt;=0; i--) &#123; ServiceRecord sr = app.services.valueAt(i); // 如果该进程不是常驻进程，就要从进程的 services 中移除该服务！ if (!app.persistent) &#123; app.services.removeAt(i); &#125; // 如果当前的服务和服务集合中的服务无法匹配，就跳过不处理！ final ServiceRecord curRec = smap.mServicesByName.get(sr.name); if (curRec != sr) &#123; if (curRec != null) &#123; Slog.wtf(TAG, \"Service \" + sr + \" in process \" + app + \" not same as in map: \" + curRec); &#125; continue; &#125; if (allowRestart &amp;&amp; sr.crashCount &gt;= 2 &amp;&amp; (sr.serviceInfo.applicationInfo.flags &amp;ApplicationInfo.FLAG_PERSISTENT) == 0) &#123; // 如果允许重启，且服务的 crash 次数大于 2，并且服务不是常驻服务，停止服务！ Slog.w(TAG, \"Service crashed \" + sr.crashCount + \" times, stopping: \" + sr); EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH, sr.userId, sr.crashCount, sr.shortName, app.pid); bringDownServiceLocked(sr); &#125; else if (!allowRestart || !mAm.mUserController.isUserRunningLocked(sr.userId, 0)) &#123; // 如果不允许重启或者服务所在的设备用户不再运行状态，就停止服务！ bringDownServiceLocked(sr); &#125; else &#123; //【2.1】尝试重启服务！ boolean canceled = scheduleServiceRestartLocked(sr, true); // 根据尝试重启的结果，看是否需要停止服务！ if (sr.startRequested &amp;&amp; (sr.stopIfKilled || canceled)) &#123; if (sr.pendingStarts.size() == 0) &#123; sr.startRequested = false; if (sr.tracker != null) &#123; sr.tracker.setStarted(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); &#125; // 如果之前服务没有自动创建的连接，就停止服务！ if (!sr.hasAutoCreateConnections()) &#123; bringDownServiceLocked(sr); &#125; &#125; &#125; &#125; &#125; // 清理完成后！ // 如果不允许重启，就把服务从 ServiceRecord 从 mRestartingServices 和 mPendingServices 中删除！ if (!allowRestart) &#123; app.services.clear(); for (int i=mRestartingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord r = mRestartingServices.get(i); if (r.processName.equals(app.processName) &amp;&amp; r.serviceInfo.applicationInfo.uid == app.info.uid) &#123; mRestartingServices.remove(i); clearRestartingIfNeededLocked(r); &#125; &#125; for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord r = mPendingServices.get(i); if (r.processName.equals(app.processName) &amp;&amp; r.serviceInfo.applicationInfo.uid == app.info.uid) &#123; mPendingServices.remove(i); &#125; &#125; &#125; // 从 mDestroyingServices 中删除该服务！ int i = mDestroyingServices.size(); while (i &gt; 0) &#123; i--; ServiceRecord sr = mDestroyingServices.get(i); if (sr.app == app) &#123; sr.forceClearTracker(); mDestroyingServices.remove(i); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"killServices remove destroying \" + sr); &#125; &#125; app.executingServices.clear();&#125; 这里会调用 scheduleServiceRestartLocked 方法来重启服务，我们继续看！ 10 总结10.1 相关 Log12345678910111213141516171819202122232425262701-04 19:28:23.824 1765 3962 W ActiveServices: scheduleServiceRestartLocked N 0 now 7648574 r ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125;01-04 19:28:23.824 1765 3962 W ActiveServices: scheduleServiceRestartLocked r.totalRestartCount 2 r ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125;01-04 19:28:23.824 1765 3962 W ActiveServices: r.name ComponentInfo&#123;com.cooqi.servicedemo/com.cooqi.servicedemo.service.AService&#125; N 0 minDuration 1000 resetTime 60000 now 7648574 r.restartDelay 0 r.restartTime+resetTime 7605288 allowCancel true01-04 19:28:23.825 1765 3962 W ActiveServices: r.name ComponentInfo&#123;com.cooqi.servicedemo/com.cooqi.servicedemo.service.AService&#125; N 0 minDuration 1000 resetTime 60000 now 7648574 r.restartDelay 1000 r.restartTime+resetTime 7605288 r.nextRestartTime 7649574 allowCancel true01-04 19:28:23.825 1765 3962 W ActiveServices: r ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; r.restartDelay 1000 r.nextRestartTime 764957401-04 19:28:23.825 1765 3962 W ActiveServices: r ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; r.restartDelay 1000 r.nextRestartTime 764957501-04 19:28:23.825 1765 3962 W ActiveServices: Scheduling restart of crashed service com.cooqi.servicedemo/.service.AService in 1000ms01-04 19:28:23.825 1765 3962 W ActiveServices: Restarting list - i 0 r2.nextRestartTime 7649575 r2.name ComponentInfo&#123;com.cooqi.servicedemo/com.cooqi.servicedemo.service.AService&#125;01-04 19:28:23.826 1765 3962 V ActiveServices: scheduleServiceRestartLocked r ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; call by com.android.server.am.ActiveServices.killServicesLocked:3066 com.android.server.am.ActivityManagerService.cleanUpApplicationRecordLocked:19081 com.android.server.am.ActivityManagerService.handleAppDiedLocked:5813 com.android.server.am.ActivityManagerService.appDiedLocked:5988 com.android.server.am.ActivityManagerService$AppDeathRecipient.binderDied:1656 android.os.BinderProxy.sendDeathNotice:688 &lt;bottom of call stack&gt; &lt;bottom of call stack&gt;01-04 19:28:24.827 1765 1788 V ActiveServices: Bringing up ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; android.content.Intent$FilterComparison@7df9497b01-04 19:28:24.828 1765 1788 V ActiveServices_MU: bringUpServiceLocked: appInfo.uid=10106 app=null01-04 19:28:24.943 1765 1804 V ActiveServices_MU: realStartServiceLocked, ServiceRecord.uid = 10106, ProcessRecord.uid = 1010601-04 19:28:24.943 1765 1804 V ActiveServices: &gt;&gt;&gt; EXECUTING create of ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;ea46ad6 9319:com.cooqi.servicedemo/u0a106&#125;01-04 19:28:24.943 1765 1804 V ActiveServices: bumpServiceExecutingLocked r.executeNesting 001-04 19:28:24.943 1765 1804 V ActiveServices: bumpServiceExecutingLocked r.app.executingServices.size() 101-04 19:28:24.962 1765 1804 V ActiveServices: Sending arguments to: ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; android.content.Intent$FilterComparison@7df9497b args=null01-04 19:28:24.962 1765 1804 V ActiveServices: &gt;&gt;&gt; EXECUTING start of ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;ea46ad6 9319:com.cooqi.servicedemo/u0a106&#125;01-04 19:28:24.962 1765 1804 V ActiveServices: bumpServiceExecutingLocked r.executeNesting 101-04 19:28:25.112 9319 9319 D ServiceTest: AService: onCreate01-04 19:28:25.112 1765 3964 V ActiveServices: serviceDoneExecutingLocked ServiceRecord= ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; type= 0 startId= 0 res= 001-04 19:28:25.112 9319 9319 D ServiceTest: AService: onStartCommand01-04 19:28:25.113 1765 3964 V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=2, inDestroying=false, app=ProcessRecord&#123;ea46ad6 9319:com.cooqi.servicedemo/u0a106&#125;01-04 19:28:25.113 1765 3964 V ActiveServices: serviceDoneExecutingLocked ServiceRecord= ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125; type= 1 startId= 6 res= 101-04 19:28:25.113 1765 3964 V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;9463951 u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=1, inDestroying=false, app=ProcessRecord&#123;ea46ad6 9319:com.cooqi.servicedemo/u0a106&#125;01-04 19:28:25.113 1765 3964 V ActiveServices: Nesting at 0 of com.cooqi.servicedemo/.service.AService01-04 19:28:25.113 1765 3964 V ActiveServices: r.app.executingServices.size(): 001-04 19:28:25.113 1765 3964 V ActiveServices: No more executingServices of com.cooqi.servicedemo/.service.AService","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结","slug":"BroadcastReceiver7-broadcastReceiverSummary","date":"2016-08-13T12:46:25.000Z","updated":"2018-11-20T16:26:07.000Z","comments":true,"path":"2016/08/13/BroadcastReceiver7-broadcastReceiverSummary/","link":"","permalink":"https://coolqi.top/2016/08/13/BroadcastReceiver7-broadcastReceiverSummary/","excerpt":"","text":"基于 Android 7.1.1 分析 BroadcastReceiver 组件的机制，本文为作者原创，转载请说明出处！ 0 综述本篇文章总结一下广播和广播接收者相关的知识点，广播是 Android 组件间的通信方式，本质上是 Intent 意图，可用于以下场景： 同一应用内部的同一进程间； 同一应用内部的不同进程间的不同组件的通信； 1 广播的使用Android 系统的广播，本质上就是 Intent，对其熟悉的朋友都知道，Intent 可以携带一些重要的数据，下面，我列举些和广播相关的参数，对于 Intent 的具体分析，请看其他的博文！ 1.1 广播的类型按照前台和后台来区分，会有前台广播和后台广播，AMS 内部有 2 个队列来管理前台和后台广播：12BroadcastQueue mFgBroadcastQueue;BroadcastQueue mBgBroadcastQueue; 按照有序和无序来区分，分为无序发送广播和有序发送广播，前台和后台队列中都有如下两个列表：12final ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = new ArrayList&lt;&gt;();final ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;(); mParallelBroadcasts 是并发发送列表，mOrderedBroadcasts 是有序发送列表； 按照发送的方式来分，又可以分为以下的几种： 普通广播 发送的接口为：sendBroadcast(intent)，对于普通类型的广播，如果他的目标接收者是动态接收者，那就会添加到 mParallelBroadcasts列表中并发发送，如果他的目标接收者是静态接收者，那就会添加到 mOrderedBroadcasts中有序发送； 有序广播 发送的接口为：sendOrderedBroadcast(intent)，对于有序类型的广播，不管是静态接收者，还是动态接收者，都会被添加到 mOrderedBroadcasts中有序发送； 粘性广播 粘性有序广播 粘性广播很特殊，系统会将其保存到一个列表 mStickyBroadcasts中，当还有新的接收者注册后，系统会将其发送给接收者！！但是，在 Android5.0/API level 21 开始粘性广播和粘性有序广播都不再建议使用了，主要还是安全性问题； 除此之外，还有以下类型的广播： 系统广播：安卓系统内置了很多的广播，用于满足系统功能的基本需求，比如：熄屏亮屏广播，开关机广播的等等，都是由系统发送的； 本地广播：本地广播也叫做应用内部广播，为什么会有这种广播呢，主要也是为了安全，防止其他应用通过一些途径平凡的拉起接收者的方法，或者伪装成接收者接收者指定的广播，为了解决这种问题，可以有如下几种方法： 将接收者的 android：exported 属性改为 false，但是这样就只能接受来自应用内部的广播了； 发送方和接收者都指定权限信息，权限不匹配，就不能发送和接受； 对于广播可以显示指定包名和组件名； 最后一种方式，就是使用本地广播，有一个专门的实现类 LocalBroadcastManager，这个我后面会单独分析！ 1.2 Flags 标志位Android 7.1.1 一共提供了以下几种和 Receiver 相关的 flags，我们来看一下： 12345678public static final int FLAG_RECEIVER_REGISTERED_ONLY = 0x40000000;public static final int FLAG_RECEIVER_REPLACE_PENDING = 0x20000000;public static final int FLAG_RECEIVER_FOREGROUND = 0x10000000;public static final int FLAG_RECEIVER_NO_ABORT = 0x08000000;public static final int FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = 0x04000000;public static final int FLAG_RECEIVER_BOOT_UPGRADE = 0x02000000;public static final int FLAG_RECEIVER_INCLUDE_BACKGROUND = 0x01000000;public static final int FLAG_RECEIVER_EXCLUDE_BACKGROUND = 0x00800000; 下面我逐个解释一下每个标签的作用，和他们在系统中是如何处理的： FLAG_RECEIVER_REGISTERED_ONLY：只有动态注册的接收者才能接受该广播，静态接收者无法接受； 12345678// Figure out who all will receive this broadcast.List receivers = null;List&lt;BroadcastFilter&gt; registeredReceivers = null;// Need to resolve the intent to interested receivers...if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);&#125; AMS 内部会做处理，如果广播设置了 FLAG_RECEIVER_REGISTERED_ONLY 标签，那他就不会收集静态注册的接收者； FLAG_RECEIVER_REPLACE_PENDING：新发送的广播会取代之前的已发送但未处理的相同广播，广播是否相同，是通过 Intent.filterEquals 方法进行匹配的；如果匹配成功，新广播会取代旧广播，但在等待列表中的位置不变，该 flags 常常被粘性广播使用，只保证将最新的广播发送给对应的接收者； 123456789101112131415final boolean replacePending = (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;... ... ... if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; ... ... ... boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125;&#125; else &#123;&#125; 这里，省略了一下重要的代码，可以看到，如果广播设置了 FLAG_RECEIVER_REPLACE_PENDING，他会取代之前的旧的未被处理的相同广播，这里就不多说了！！ FLAG_RECEIVER_FOREGROUND：设置该标志位后，广播的接收者会以前台的优先级运行，超时时间会变短，正常的接收者是后台优先级的，是不会被自动提升的！1234567BroadcastQueue broadcastQueueForIntent(Intent intent) &#123; final boolean isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0; if (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST, \"Broadcast intent \" + intent + \" on \" + (isFg ? \"foreground\" : \"background\") + \" queue\"); return (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;&#125; 在 AMS 中，有两个广播队列：前台队列和后台队列，可以看到，默认情况下，不设置该标志位，广播都是被添加到后台队列中的！！ FLAG_RECEIVER_NO_ABORT：设置该标志位后，如果该广播是一个有序发送的广播，不允许接收者过滤不处理该广播； 1234567if (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == 0) &#123; r.resultAbort = resultAbort;&#125; else &#123; r.resultAbort = false;&#125; 可以看到这里，会对该 flags 做一个判断，看是否过滤不处理该广播； FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT：设置该标志位后，当在开机完成之前发送该广播，只有已经被注册的接收者（静态）会被调用；如果是粘性广播，仍然会被系统保留下来，即使没有接收者被调用；如果设置了 FLAG_RECEIVER_REGISTERED_ONLY 标志位，该标志位无效！ 123456789101112131415161718final Intent verifyBroadcastLocked(Intent intent) &#123; ... ... ... ... //【1】mProcessesReady 表示系统进程是否准备好！ if (!mProcessesReady) &#123; if ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT) != 0) &#123; // This will be turned into a FLAG_RECEIVER_REGISTERED_ONLY later on if needed. &#125; else if ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; Slog.e(TAG, \"Attempt to launch receivers of broadcast intent \" + intent + \" before boot completion\"); throw new IllegalStateException(\"Cannot broadcast before boot completed\"); &#125; &#125; return intent;&#125; 可以看到，如果在系统进程没有准备好时，如果广播设置了 FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT，但如果此时没有设置 FLAG_RECEIVER_REGISTERED_ONLY 标签，那会报出异常。 FLAG_RECEIVER_BOOT_UPGRADE： 12 FLAG_RECEIVER_INCLUDE_BACKGROUND：如果设置了该标签，该广播将始终发送给后台（缓存或不运行）应用程序的静态接收者； FLAG_RECEIVER_EXCLUDE_BACKGROUND：如果设置了该标签，该广播将始终不会发送给后台（缓存或不运行）应用程序的静态接收者，但是如果发送者显示指定了接收者的组件名或者包名，那么后台接收者仍然可以接收到该广播！！ 这两个标签的处理如下，这里的 info 是静态接收者的数据对象！12345678910111213141516171819202122232425262728293031if (!skip) &#123; //【1】判断是否允许后台启动！ final int allowed = mService.checkAllowBackgroundLocked( info.activityInfo.applicationInfo.uid, info.activityInfo.packageName, -1, false); if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123; //【2】如果是禁止启动，就跳过该应用程序，但 checkAllowBackgroundLocked 不会返回该值； if (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123; Slog.w(TAG, \"Background execution disabled: receiving \" + r.intent + \" to \" + component.flattenToShortString()); skip = true; //【3】如果是延迟启动，那其属于一个后台的接收者，那就要判断下标志位； &#125; else if (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null &amp;&amp; ((r.intent.getFlags() &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) &#123; Slog.w(TAG, \"Background execution not allowed: receiving \" + r.intent + \" to \" + component.flattenToShortString()); skip = true; &#125; &#125;&#125; Android 系统在发送广播时会判断是否会跳过一些接收者！如果 checkAllowBackgroundLocked 返回值，返回值为 ActivityManager.APP_START_MODE_DELAYED，表示接收者是需要后台启动的！ 这种情况下： 如果设置了 FLAG_RECEIVER_EXCLUDE_BACKGROUND 标签，那就会逃过该后台的静态接收者； 如果没设置 FLAG_RECEIVER_INCLUDE_BACKGROUND 标签，且没有设置 Component 或者 Package，那就会跳过该后台的静态接收者； 对于标志位的分析，我们就简单的提一下，详细的分析，大家可以去看 sendBroadcast 过程！！ 1.3 广播的发送方法对于广播的发送，很简单，有很多的方法，来发送不同类型的广播： 普通广播： 12 有序广播： 12 粘性广播： 12 粘性有序广播： 12 2 接收者的使用广播接收者分为 2 种，静态接收者，动态接收者： 动态注册的接收者不是常驻型，也就是说广播跟随 Activity 的生命周期。注意在 Activity 结束前，移除广播接收器。 静态注册的接收者不是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 下面我们来看看他们的使用方法： 2.1 静态注册的接收者静态接收者需要单独存在于一个 .java 文件：12345678910public class InstallResultReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent == null) &#123; OppoLog.i (TAG, \"ota intent is null!\"); return; &#125; &#125;&#125; 并且在 AndroidManifest.xml 需要说明该组件的存在： 1234567&lt;receiver android:name=\".install.InstallResultReceiver\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"coolqi.intent.action.package_install_success\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; AndroidManifest.xml 可以对接收者配置很多的属性，这里列举几个比较重要的： 123456android:name=\".install.InstallResultReceiver\"android:singleUser=\"true\"android:process=\"com.demo.coolqi\"android:enabled=\"true\"android:permission=\"coolqi.send.package_install_success\"android:exported=\"true\"&gt; 解释说明下： name：接收者的全名； singleUser：该接收者是否在所有； process：该接收者所在的进程名； enabled：该接收者是否为单用户模式，如果为 true，所有用户使用的 BroadcastReceiver 是同一个； permission：该接收者指定发送者应具有的权限； exported：该接收者是否对其他应用暴露； 初次之外：intent-filter 也可以设置一些属性，这里列举一些重要的属性：1android:priority=\"\" 解释说明下： priority：表示接收者的优先级，对于有序发送的广播，接收者优先级越高，越先接受到广播； 关于优先级对于广播接受的影响，我们后面会谈到； 2.2 动态注册的接收者动态接收者不能单独存在于一个独立的 .java 文件中，他需要最为其他类的内部类来定义，它依附于其他的类： 123456789101112public class InstallResultReceiver extends AppCompatActivity &#123; private InstallResultReceiver resultReceiver; class InstallResultReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; &#125; &#125;&#125; 需要在代码中实时注册： 12345IntentFilter filter = new IntentFilter();filter.addAction(&quot;coolqi.intent.action.package_install_success&quot;);reReceiver = new InstallResultReceiver();registerReceiver(reReceiver, filter); 同时在不需要该接收者时，需要动态取消注册： 1unregisterReceiver(reReceiver); 对于动态注册的接收者，也可以设置他的优先级： 1filter.setPriority(100); 3 广播的发送和处理接下来，总结一下，广播的发送和处理流程！ 3.1 接收者的收集流程我们先通过一张图来看看广播接收者的收集流程： 我们可以看到，发送过程中，首先会发送目标为动态注册的接收者的普通广播，发送方式是并发！ 接下来会收集静态接收者和动态接收者，注意如果是普通广播，这里只收集静态注册的接收者，然后根据优先级对接收者进行排序，排序的算法如下： 123456789101112131415161718while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); // 静态 &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); // 动态 &#125; if (curr.getPriority() &gt;= curt.priority) &#123; receivers.add(it, curr); ir++; curr = null; it++; NT++; &#125; else &#123; it++; curt = null; &#125;&#125; 其中：NT 是静态接收者的数量， NR 是动态注册的接收者的数量! 对于普通广播，由于 NR 是 0，目标接收者只有静态接收者，所以这里是不会进行优先级排序的； 对于有序广播，由于其既存在动态接收者，又存在静态接收者，所以这会进行优先级排序，排序的方式如下： 如果动态接收者的优先级 Priority 大于等于静态接收者的优先级，动态接收者排在前面； 否则，静态接收者在前！ 通过上面，我们可以看出： 对于普通广播，动态接收者是要比静态接收者先接受到广播的，无视优先级！ 对于有序广播，则是按照优先级来处理！ 3.2 广播发送流程接下来，我们来分析下广播的发送过程！ 在发送的过程中，我们需要注意一些细节问题： 发送的广播 Intent 会被强制添加 Intent.FLAG_EXCLUDE_STOPPED_PACKAGES，禁止广播发送给被强制停止的接收者！该标志位是从 Android 3.1 开始新增了： 12public static final int FLAG_EXCLUDE_STOPPED_PACKAGES = 0x00000010;public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020; 下面我来解释一下： FLAG_EXCLUDE_STOPPED_PACKAGES：如果设置了该标志位，该 Intent 将不会匹配那些被强制停止的应用中的组件，如果不设置该标志位，默认是会匹配被强制停止的应用的组件的！ FLAG_INCLUDE_STOPPED_PACKAGES：：如果设置了该标志位，该 Intent 将会匹配那些被强制停止的应用中的组件，如果不设置 FLAG_EXCLUDE_STOPPED_PACKAGES 标志位，将会默认设置该标志位，如果两个标志位都被设置了，该标志位才生效！ 对于系统广播，一般是无法更改标志位的，当然，系统开发者除外；对于应用的自定义的广播，可以设置 FLAG_INCLUDE_STOPPED_PACKAGES，使其能够发送给被停止的接收者！ 这里简单提一下，有 2 种情况，应用会处于停止状态： 应用第一次安装并且没有被启动过； 用户在应用管理中强制停止了该应用； 在收集完接收者后，就会创建对应的广播，封装接收者列表，然后，将广播添加到指定队列的列表中，触发发送，我们来简单的回顾下； 广播分发的调用链如下:1queue.scheduleBroadcastsLocked(); -&gt; send BROADCAST_INTENT_MSG -&gt; processNextBroadcast(); 我们用一张图来直观的看一下: 可以看到，每次分发，都会率先的处理 BroadcastQueue 队列中的并发集合 mParallelBroadcasts 中的所有广播：目标为动态接收者的普通广播，直到 mParallelBroadcasts 为空！ 然后，接着是，处理那些正在等待目标进程启动的广播 mPendingBroadcast，如果目标进程没有启动完成或者没有死亡，那就不能继续发送广播，因为需要的等待进程启动后处理该广播！ 接着是，处理有序列表 mOrderedBroadcasts 中的广播，首先会遍历 mOrderedBroadcasts，移除那些没有接收者 / 接收者都已经接收完成 / 被终止 / 超时的广播，定位到下一次需要发送的广播，进行分发； 这里要重点说一下：mOrderedBroadcasts 中的广播有 2 中：一种是目标是静态接收者的普通广播；另一种是有序广播，这二种广播都采用的是有序的发送方式； 4 总结","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"BroadcastReceiver广播接收者","slug":"AndroidFramework源码分析/BroadcastReceiver广播接收者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/"}],"tags":[{"name":"BroadcastReceiver广播接收者","slug":"BroadcastReceiver广播接收者","permalink":"https://coolqi.top/tags/BroadcastReceiver广播接收者/"}]},{"title":"Serivce 篇 6 - startForeground 和 stopForeground 分析","slug":"Serivce6-startForegroundAndstopForeground","date":"2016-08-11T12:46:25.000Z","updated":"2018-11-20T16:34:37.000Z","comments":true,"path":"2016/08/11/Serivce6-startForegroundAndstopForeground/","link":"","permalink":"https://coolqi.top/2016/08/11/Serivce6-startForegroundAndstopForeground/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，转载请说明出处！ 0 综述我们可以通过 startForeground 方法来将一个服务设置成前台服务，具体的使用如下：123456789101112131415161718192021222324252627private void initNotification(Context context) &#123; Notification.Builder builder = new Notification.Builder(context); builder.setOngoing(true).setSmallIcon(R.drawable.ic_launcher) .setContentTitle(context.getResources().getText(R.string.ticker_text)) .setContentText(context.getResources().getText(R.string.ticker_text)); builder.setPriority(Notification.PRIORITY_HIGH); mNotification = builder.build(); mNotification.flags = mNotification.flags | Notification.FLAG_AUTO_CANCEL;&#125;@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; OppoLog.d(TAG, \"onStartCommand\"); initNotification(this); startForeground(ID, mNotification); return super.onStartCommand(intent, flags, startId);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); OppoLog.d(TAG, \"onDestroy\"); stopForeground(true);&#125; 其中，涉及到的方法有如下几个：1234567// 将服务设置到前台，如果 id 为 0，那就取消设置前台服务；startForeground(int id, Notification notification) // 取消前台设置，removeNotification 表示是否移除通知；stopForeground(boolean removeNotification)// 取消前台设置，flags 可选 STOP_FOREGROUND_REMOVE 或者 STOP_FOREGROUND_DETACHstopForeground(int flags) 我们来具体分析下，startForeground 方法的处理流程！ 1 服务所在进程1.1 Service.startForeground我们先来看看 startForeground 方法！1234567891011public final void startForeground(int id, Notification notification) &#123; try &#123; // 调用 AMS 的 setServiceForeground 方法！ mActivityManager.setServiceForeground( new ComponentName(this, mClassName), mToken, id, notification, 0); &#125; catch (RemoteException ex) &#123; &#125;&#125; 这里的 mToken，在之前 Service 的创建时，系统进程赋给 Service 的，是一个 IBinder 对象，是 ServiceRecord 对象的引用！ 这里的 mActivityManager 也是 Service 在创建后，内部保存的 AMS 的代理对象！ 接着进入 ActivityManagerProxy 代理对象中：1234567891011121314151617181920212223public void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, int flags) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); ComponentName.writeToParcel(className, data); data.writeStrongBinder(token); data.writeInt(id); if (notification != null) &#123; data.writeInt(1); notification.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; data.writeInt(flags); mRemote.transact(SET_SERVICE_FOREGROUND_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 接着进入系统进程！ 2 系统进程2.1 ActivityManagerN.onTransact123456789101112131415161718case SET_SERVICE_FOREGROUND_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); ComponentName className = ComponentName.readFromParcel(data); IBinder token = data.readStrongBinder(); int id = data.readInt(); Notification notification = null; if (data.readInt() != 0) &#123; notification = Notification.CREATOR.createFromParcel(data); &#125; // 传入 0； int sflags = data.readInt(); // 进入 AMS！ setServiceForeground(className, token, id, notification, sflags); reply.writeNoException(); return true;&#125; 接着，进入 AMS: 2.2 ActivityManagerS.setServiceForeground123456789@Overridepublic void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, int flags) &#123; synchronized(this) &#123; // 进入 AS! mServices.setServiceForegroundLocked(className, token, id, notification, flags); &#125;&#125; 接着，进入 ActiveServices: 2.3 ActiveServices.setServiceForegroundLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void setServiceForegroundLocked(ComponentName className, IBinder token, int id, Notification notification, int flags) &#123; final int userId = UserHandle.getCallingUserId(); final long origId = Binder.clearCallingIdentity(); try &#123; //【1】根据传入的 className，token 和 userId，找到对应的 ServiceRecord 对象！ ServiceRecord r = findServiceLocked(className, token, userId); if (r != null) &#123; if (id != 0) &#123; if (notification == null) &#123; // 如果 notification 为 null，抛出异常！ throw new IllegalArgumentException(\"null notification\"); &#125; //【2】如果服务的 foregroundId 和传入的 id 不一样，就取消 foregroundId 对应的旧的 notification // 将 foregroundId 设置为本次传入的新的 id if (r.foregroundId != id) &#123; cancelForegroudNotificationLocked(r); r.foregroundId = id; &#125; notification.flags |= Notification.FLAG_FOREGROUND_SERVICE; // 设置服务 r.foregroundNoti 为创建的 notification； // 设置服务 r.isForeground 为 true，表示该服务为前台服务； r.foregroundNoti = notification; r.isForeground = true; //【3】显示 notification！ r.postNotification(); //【4】这里是重点，更新服务的优先级和 oomAdj，设置服务为前台服务！！ if (r.app != null) &#123; updateServiceForegroundLocked(r.app, true); &#125; //【5】让服务不再后台执行，同时也不让服务延迟启动！ getServiceMap(r.userId).ensureNotStartingBackground(r); mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE); &#125; else &#123; if (r.isForeground) &#123; r.isForeground = false; if (r.app != null) &#123; mAm.updateLruProcessLocked(r.app, false, null); updateServiceForegroundLocked(r.app, true); &#125; &#125; if ((flags &amp; Service.STOP_FOREGROUND_REMOVE) != 0) &#123; cancelForegroudNotificationLocked(r); r.foregroundId = 0; r.foregroundNoti = null; &#125; else if (r.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; r.stripForegroundServiceFlagFromNotification(); if ((flags &amp; Service.STOP_FOREGROUND_DETACH) != 0) &#123; r.foregroundId = 0; r.foregroundNoti = null; &#125; &#125; &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 2.3.1 ActiveServices.findServiceLocked找到对应的 ServiceRecord 对象！12345private final ServiceRecord findServiceLocked(ComponentName name, IBinder token, int userId) &#123; ServiceRecord r = getServiceByName(name, userId); return r == token ? r : null;&#125; 根据组件名和设别用户id，在 ActiveServices 的 mServiceMap 稀疏数组中，找到对应的 ServiceRecord 对象，然后和 Service 进程传递过来的 token，二者必须相等才行！ 这里就不多说了！ 2.3.2 ActiveServices.cancelForegroudNotificationLocked12345678910111213141516171819private void cancelForegroudNotificationLocked(ServiceRecord r) &#123; if (r.foregroundId != 0) &#123; ServiceMap sm = getServiceMap(r.userId); if (sm != null) &#123; for (int i = sm.mServicesByName.size()-1; i &gt;= 0; i--) &#123; ServiceRecord other = sm.mServicesByName.valueAt(i); if (other != r &amp;&amp; other.foregroundId == r.foregroundId &amp;&amp; other.packageName.equals(r.packageName)) &#123; // Found one! Abort the cancel. return; &#125; &#125; &#125; r.cancelNotification(); &#125;&#125; ServiceRecord r 是本次需要设置为前台的服务，r.foregroundId 为前台 notification 的 id，这个函数的主要作用是，判断本次需要设置为前台的服务所属的应用是否有其他服务的 foregroundId 和 r.foregroundId 相同，如果相同，那就不能取消这个通知！ 如果只有当前服务在使用这个通知的 id，那就取消这个旧的通知： 2.3.2.1 ServiceRecord.cancelNotification1234567891011121314151617181920212223public void cancelNotification() &#123; // Do asynchronous communication with notification manager to // avoid deadlocks. final String localPackageName = packageName; final int localForegroundId = foregroundId; ams.mHandler.post(new Runnable() &#123; public void run() &#123; INotificationManager inm = NotificationManager.getService(); if (inm == null) &#123; return; &#125; try &#123; // 调用 NotificationManager 取消这个通知！ inm.cancelNotificationWithTag(localPackageName, null, localForegroundId, userId); &#125; catch (RuntimeException e) &#123; Slog.w(TAG, \"Error canceling notification for service\", e); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125;);&#125; 调用 NotificationManager 取消这个通知！ 2.3.3 ServiceRecord.postNotification123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public void postNotification() &#123; final int appUid = appInfo.uid; final int appPid = app.pid; if (foregroundId != 0 &amp;&amp; foregroundNoti != null) &#123; // Do asynchronous communication with notification manager to // avoid deadlocks. final String localPackageName = packageName; final int localForegroundId = foregroundId; final Notification _foregroundNoti = foregroundNoti; // 通过 AMS.MainHandler，在系统进程主线程执行任务！ ams.mHandler.post(new Runnable() &#123; public void run() &#123; NotificationManagerInternal nm = LocalServices.getService( NotificationManagerInternal.class); if (nm == null) &#123; return; &#125; Notification localForegroundNoti = _foregroundNoti; try &#123; if (localForegroundNoti.getSmallIcon() == null) &#123; Slog.v(TAG, \"Attempted to start a foreground service (\" + name + \") with a broken notification (no icon: \" + localForegroundNoti + \")\"); CharSequence appName = appInfo.loadLabel( ams.mContext.getPackageManager()); if (appName == null) &#123; appName = appInfo.packageName; &#125; Context ctx = null; try &#123; //【1】创建一个上下文运行环境 Context，用于创建通知！ ctx = ams.mContext.createPackageContextAsUser( appInfo.packageName, 0, new UserHandle(userId)); //【2】创建通知建造者，并设置通知相关属性！ Notification.Builder notiBuilder = new Notification.Builder(ctx); // it's ugly, but it clearly identifies the app notiBuilder.setSmallIcon(appInfo.icon); // 设置 notification 的标志位 Notification.FLAG_FOREGROUND_SERVICE！ // 表示该通知代表一个在前台运行的服务！ notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE, true); // 设置通知的优先级为 Notification.PRIORITY_MIN！ notiBuilder.setPriority(Notification.PRIORITY_MIN); Intent runningIntent = new Intent( Settings.ACTION_APPLICATION_DETAILS_SETTINGS); runningIntent.setData(Uri.fromParts(\"package\", appInfo.packageName, null)); PendingIntent pi = PendingIntent.getActivity(ams.mContext, 0, runningIntent, PendingIntent.FLAG_UPDATE_CURRENT); notiBuilder.setColor(ams.mContext.getColor( com.android.internal .R.color.system_notification_accent_color)); notiBuilder.setContentTitle( ams.mContext.getString( com.android.internal.R.string .app_running_notification_title, appName)); notiBuilder.setContentText( ams.mContext.getString( com.android.internal.R.string .app_running_notification_text, appName)); notiBuilder.setContentIntent(pi); localForegroundNoti = notiBuilder.build(); &#125; catch (PackageManager.NameNotFoundException e) &#123; &#125; &#125; //【3】校验 notification 的 SmallIcon 是否仍然为 null，如果仍然为 null // 抛出运行时异常！ if (localForegroundNoti.getSmallIcon() == null) &#123; throw new RuntimeException(\"invalid service notification: \" + foregroundNoti); &#125; int[] outId = new int[1]; //【4】显示 notification！ nm.enqueueNotification(localPackageName, localPackageName, appUid, appPid, null, localForegroundId, localForegroundNoti, outId, userId); foregroundNoti = localForegroundNoti; // save it for amending next time &#125; catch (RuntimeException e) &#123; Slog.w(TAG, \"Error showing notification for service\", e); // 如果出现异常，就不会设置服务为前台服务，同时抛出 Crash 异常！ ams.setServiceForeground(name, ServiceRecord.this, 0, null, 0); ams.crashApplication(appUid, appPid, localPackageName, \"Bad notification for startForeground: \" + e); &#125; &#125; &#125;); &#125;&#125; 这个方法的主要作用是显示 notification！ 2.3.4 ActiveServices.updateServiceForegroundLocked这里是重点，更新服务的优先级和 oomAdj，设置服务为前台服务，参数分析： ProcessRecord proc：服务所在的进程！ boolean oomAdj：传入 true，表示需要更新 oomAdj 值！ 12345678910111213141516private void updateServiceForegroundLocked(ProcessRecord proc, boolean oomAdj) &#123; boolean anyForeground = false; // 遍历进程，如果该进程中有服务 sr.isForeground 为 true 了， // 表示该进程存在前台服务，所以 anyForeground 为 true，跳出循环！ for (int i=proc.services.size()-1; i&gt;=0; i--) &#123; ServiceRecord sr = proc.services.valueAt(i); if (sr.isForeground) &#123; anyForeground = true; break; &#125; &#125; // 进入这里进行进程的优先级和 oomAdj 的设置！ mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);&#125; 显然，根据前面的属性设置 anyForeground 为 true ！ 下面就是更新服务所在进程的优先级和 oomAdj 的值了！ 2.3.5 ServiceMap.ensureNotStartingBackground123456789101112131415void ensureNotStartingBackground(ServiceRecord r) &#123; //【1】从 AS.mStartingBackground 中尝试删除该服务，不让服务在后台运行！ if (mStartingBackground.remove(r)) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"No longer background starting: \" + r); rescheduleDelayedStarts(); &#125; //【2】从 AS.mDelayedStartList 中尝试删除该服务，不让服务延迟启动！ if (mDelayedStartList.remove(r)) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"No longer delaying start: \" + r); &#125;&#125; 这里和 startService 中的一样的，目的是将当前服务从 mStartingBackground 和 mDelayedStartList 中删除，因为服务被设置成了前台服务，如果当前服务从 mStartingBackground 中删除成功了，就要调用 rescheduleDelayedStarts 方法，继续发送 MSG_BG_START_TIMEOUT 消息！ 这里具体的分析，请去看 startService 博文的第 2.3 节！ 通过上面的分析，关键的地方是这里：1234567private void updateServiceForegroundLocked(ProcessRecord proc, boolean oomAdj) &#123; ... ... ... ... // 进入这里进行进程的优先级和 oomAdj 的设置！ mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);&#125; 这里调用了 AMS 的 updateProcessForegroundLocked 方法来更新 Service 的进程优先级和 oomAdj 的值。我们继续来看！ 2.4 ActivityManagerS.updateProcessForegroundLocked参数传递： ProcessRecord proc：服务所在的进程； boolean isForeground：传入 true； boolean oomAdj：传入 true； 这里我们假设之前服务所在进程没有运行任何的前台服务！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void updateProcessForegroundLocked(ProcessRecord proc, boolean isForeground, boolean oomAdj) &#123; // proc.foregroundServices 表示进程是否运行前台服务！ // 如果 isForeground 不等于 proc.foregroundServices，说明进程的 if (isForeground != proc.foregroundServices) &#123; // 将 proc.foregroundServices 设置为 isForeground 的值！ proc.foregroundServices = isForeground; // mForegroundPackages 集合用来保存所有当前正在运行着前台服务的应用程序包信息 // curProcs 则是运行着前台服务的进程对象 ProcessRecord! ArrayList&lt;ProcessRecord&gt; curProcs = mForegroundPackages.get(proc.info.packageName, proc.info.uid); // 因为我们现在是设置服务为前台服务，所以 isForeground 是 true！ if (isForeground) &#123; // 将进程所属的应用程序包，添加到 mForegroundPackages 集合中； // 并将服务所在的进程也添加到 mForegroundPackages 中； if (curProcs == null) &#123; curProcs = new ArrayList&lt;ProcessRecord&gt;(); mForegroundPackages.put(proc.info.packageName, proc.info.uid, curProcs); &#125; if (!curProcs.contains(proc)) &#123; curProcs.add(proc); // 通知 BatteryStatsService 服务，有应用在前台执行服务！ mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_FOREGROUND_START, proc.info.packageName, proc.info.uid); &#125; &#125; else &#123; if (curProcs != null) &#123; if (curProcs.remove(proc)) &#123; mBatteryStatsService.noteEvent( BatteryStats.HistoryItem.EVENT_FOREGROUND_FINISH, proc.info.packageName, proc.info.uid); if (curProcs.size() &lt;= 0) &#123; mForegroundPackages.remove(proc.info.packageName, proc.info.uid); &#125; &#125; &#125; &#125; // 这里为 true，更新进程的 oomAdj 的值！ if (oomAdj) &#123; updateOomAdjLocked(); &#125; &#125;&#125; 这里有一些数据结构，我们来简单是说一下： ProcessRecord.foregroundServices 表示该进程中是否在运行前台服务； 初次之外，还有一个 mForegroundPackages，用来保存运行着前台服务的应用程序包信息：12final ProcessMap&lt;ArrayList&lt;ProcessRecord&gt;&gt; mForegroundPackages = new ProcessMap&lt;ArrayList&lt;ProcessRecord&gt;&gt;(); 他是 ProcessMap 类的对象，ProcessMap 是一个模板类：123456789101112131415161718192021public class ProcessMap&lt;E&gt; &#123; final ArrayMap&lt;String, SparseArray&lt;E&gt;&gt; mMap = new ArrayMap&lt;String, SparseArray&lt;E&gt;&gt;(); public E get(String name, int uid) &#123; SparseArray&lt;E&gt; uids = mMap.get(name); if (uids == null) return null; return uids.get(uid); &#125; public E put(String name, int uid, E value) &#123; SparseArray&lt;E&gt; uids = mMap.get(name); if (uids == null) &#123; uids = new SparseArray&lt;E&gt;(2); mMap.put(name, uids); &#125; uids.put(uid, value); return value; &#125; ... ... ...&#125; ProcessMap 的内部变量 mMap 是一个 ArrayMap 类型的集合，其中 key 是应用程序的报名，而 value 是 SparseArray 类型的稀疏数组，其中数组下标是应用在指定设备用户下的 uid，而下标对应的值是 uid 对应的运行着前台服务的进程对象 ProcessRecord，这里就不多说了！！ 这里我们就先看到这里，关于 updateOomAdjLocked 的逻辑处理，请去看。。。。 3 stopForeground 分析上面分析了一些 startForeground 方法的主要流程，下面分析下 stopForeground 方法，stopForeground 方法一共有两个：1234567891011public final void stopForeground(boolean removeNotification) &#123; stopForeground(removeNotification ? STOP_FOREGROUND_REMOVE : 0);&#125;public final void stopForeground(int flags) &#123; try &#123; mActivityManager.setServiceForeground( new ComponentName(this, mClassName), mToken, 0, null, flags); &#125; catch (RemoteException ex) &#123; &#125;&#125; 第一个方法最后还是会调用第二个方法！这里我们先来解释两个参数变量：1public static final int STOP_FOREGROUND_REMOVE = 1&lt;&lt;0; 如果设置了这个标志位，取消前台服务的同时，还会移除对应的通知，但是如果同一个应用中有其他前台服务关联着相同的通知，就不会移除该通知； 如果不设置这个标志位，通知只能通过 startForeground(int, Notification) 或者 stopForeground(int)，或者服务被销毁的方式移除！ 1public static final int STOP_FOREGROUND_DETACH = 1&lt;&lt;1; 如果设置了这个标志位，取消前台服务的同时，不会移除对应的通知，但是会将通知和服务完全解除绑定，这时通知只有通过 NotificationManager 才能被取消！该标志位不能和 STOP_FOREGROUND_REMOVE 混合使用哦！ 方法调用和 startForeground 方法很类似，最后会进入 ActiveSerivces 中去： 3.1 ActiveSerivces.setServiceForegroundLocked参数传递： ComponentName className：服务的类名； IBinder token；服务的 ServiceRecord 对象； int id：传入 0； Notification notification：传入 null； int flags：传入具体的 flags； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void setServiceForegroundLocked(ComponentName className, IBinder token, int id, Notification notification, int flags) &#123; final int userId = UserHandle.getCallingUserId(); final long origId = Binder.clearCallingIdentity(); try &#123; //【1】根据传入的 className，token 和 userId，找到对应的 ServiceRecord 对象！ ServiceRecord r = findServiceLocked(className, token, userId); if (r != null) &#123; if (id != 0) &#123; ... ... ... ...// 这里不进入该分支； &#125; else &#123; // 如果服务 r.isForeground 为 true，就设置 r.isForeground 为 false； // 同时调用 AMS.updateLruProcessLocked 和 updateServiceForegroundLocked // 更新进程状态！ if (r.isForeground) &#123; r.isForeground = false; if (r.app != null) &#123; mAm.updateLruProcessLocked(r.app, false, null); updateServiceForegroundLocked(r.app, true); &#125; &#125; // 如果 flags 设置了 STOP_FOREGROUND_REMOVE 标志位，就移除通知！！ if ((flags &amp; Service.STOP_FOREGROUND_REMOVE) != 0) &#123; // 尝试移除该通知，如果当前服务所属的应用程序有其他前台服务 // 也关联着同一个通知，那就不移除通知！ cancelForegroudNotificationLocked(r); r.foregroundId = 0; r.foregroundNoti = null; &#125; else if (r.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; // 将服务和通知解除绑定！！ r.stripForegroundServiceFlagFromNotification(); // 如果 flags 设置了 STOP_FOREGROUND_DETACH 标志位， // 就清除服务的 r.foregroundId 和 r.foregroundNoti； if ((flags &amp; Service.STOP_FOREGROUND_DETACH) != 0) &#123; r.foregroundId = 0; r.foregroundNoti = null; &#125; &#125; &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 这里就先分析这么多，其他内容后续在补充！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"BroadcastReceiver篇 6 - LocalBroadcastManager 分析","slug":"BroadcastReceiver6-LocalBroadcastManager 分析","date":"2016-07-13T12:46:25.000Z","updated":"2018-11-20T16:25:59.000Z","comments":true,"path":"2016/07/13/BroadcastReceiver6-LocalBroadcastManager 分析/","link":"","permalink":"https://coolqi.top/2016/07/13/BroadcastReceiver6-LocalBroadcastManager 分析/","excerpt":"","text":"[toc] 本文基于 Android 7.1.1 源码，分析 LocalBroadcastManager 机制！ 0 前言BroadcastReceiver 是基于 Binder 通信的，其可以用于跨进程的通信，而 LocalBroadcastManager 是基于 Handler 的，其适用于进程内的通信，在进程内进行局部广播发送与注册。 相比 BroadcastReceiver 的广播，LocalBroadcastManager 有以下几点优点。 广播数据只在本应用内传播，不用担心数据泄露； 广播数据不用担心别的应用伪造广播，更加安全； 因为只在应用内广播，所以更加的高效； LocalBroadcastManager 位于 android.support.v4.content 包中，适用于动态注册的广播： 1 基本使用注册接收者到 LocalBroadcastManager： 1234filter = new IntentFilter();filter.addAction(action);mLocalBroadcastManager = LocalBroadcastManager.getInstance(this); // 获得实例；mLocalBroadcastManager.registerReceiver(receiver, filter); // 注册监听； 解除注册： 1mLocalBroadcastManager.unregisterReceiver(receiver); // 取消监听； 然后就是发送广播： 1mLocalBroadcastManager.sendBroadcast(intent); // 发送广播； 2 源码分析2.1 LocalBroadcastManager.getInstance - 创建单例LocalBroadcastManager 采用的是单例模式： 123456789public static LocalBroadcastManager getInstance(Context context) &#123; synchronized (mLock) &#123; if (mInstance == null) &#123; //【2.1.1】创建单例！ mInstance = new LocalBroadcastManager(context.getApplicationContext()); &#125; return mInstance; &#125;&#125; getInstance 方法中会调用 LocalBroadcastManager 构造器：123456789101112131415161718private LocalBroadcastManager(Context context) &#123; mAppContext = context; //【1】创建主线程对应的 Handler！ mHandler = new Handler(context.getMainLooper()) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //【1.2】接收到 MSG_EXEC_PENDING_BROADCASTS 消息！ case MSG_EXEC_PENDING_BROADCASTS: //【2.6】触发 executePendingBroadcasts 方法！ executePendingBroadcasts(); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125; context.getMainLooper() 会返回当前进程主线程的 Looper 对象！ 继续分析！ 2.2 LocalBroadcastManager.registerReceiver - 注册注册接收者： 1234567891011121314151617181920212223public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; synchronized (mReceivers) &#123; //【2.2.1】创建了一个 ReceiverRecord 实例，封装注册的接收者的信息！ ReceiverRecord entry = new ReceiverRecord(filter, receiver); //【1】添加 receiver 和 intentfilter 的映射关系！ ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;IntentFilter&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(filter); //【2】解析该 filter 能过滤处理的 action，并添加 action 和 receiver 的映射关系！ for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125;&#125; 在 LocalBroadcastManager 有如下两个 hash 表： 123456// 存储 BroadcastReceiver 和其 IntentFilter 的映射关系！private final HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt; mReceivers = new HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt;();// 存储 filter action 和 BroadcastReceiver 的映射关系！private final HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions = new HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt;(); 不多说了！ 2.2.1 new ReceiverRecordReceiverRecord 的代码很简单，不多说了！ 1234567891011private static class ReceiverRecord &#123; final IntentFilter filter; // intent filter final BroadcastReceiver receiver; // 接收者 boolean broadcasting; // 表示 receiver 是否被收集到目标列表中！ ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver) &#123; filter = _filter; receiver = _receiver; &#125; ... ... ...&#125; 2.3 LocalBroadcastManager.unregisterReceiver - 取消注册取消注册： 123456789101112131415161718192021222324252627282930public void unregisterReceiver(BroadcastReceiver receiver) &#123; synchronized (mReceivers) &#123; //【1】移除 receiver 以及和 intentfilter 的映射关系！ ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver); if (filters == null) &#123; return; &#125; //【2】处理 filter 能够过滤的所有 action！ for (int i=0; i&lt;filters.size(); i++) &#123; IntentFilter filter = filters.get(i); for (int j=0; j&lt;filter.countActions(); j++) &#123; String action = filter.getAction(j); //【2.1】移除 action 和该 BroadcastReceiver 的映射关系！ ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action); if (receivers != null) &#123; for (int k=0; k&lt;receivers.size(); k++) &#123; if (receivers.get(k).receiver == receiver) &#123; receivers.remove(k); k--; &#125; &#125; //【2.2】如果没有 receiver 接收该 action，那就移除映射集合！ if (receivers.size() &lt;= 0) &#123; mActions.remove(action); &#125; &#125; &#125; &#125; &#125;&#125; 不多说了！ 2.4 LocalBroadcastManager.sendBroadcast - 异步广播sendBroadcast 用于发送异步的广播，该方法在调用会后立刻返回！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public boolean sendBroadcast(Intent intent) &#123; synchronized (mReceivers) &#123; //【1】解析 intent 的相关属性！ final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); final boolean debug = DEBUG || ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); if (debug) Log.v( TAG, \"Resolving type \" + type + \" scheme \" + scheme + \" of intent \" + intent); //【2】从 mActions 映射表中找到能够处理该 intent 的接收者列表！ ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) &#123; if (debug) Log.v(TAG, \"Action list: \" + entries); ArrayList&lt;ReceiverRecord&gt; receivers = null; // 保存目标 receiver 实例； for (int i=0; i&lt;entries.size(); i++) &#123; //【2.1】处理每一个 ReceiverRecord 实例； ReceiverRecord receiver = entries.get(i); if (debug) Log.v(TAG, \"Matching against filter \" + receiver.filter); //【2.2】如果 receiver.broadcasting 为 true，说明目标 receiver 已经添加到目标集合中了； if (receiver.broadcasting) &#123; if (debug) &#123; Log.v(TAG, \" Filter's target already added\"); &#125; continue; &#125; //【2.3】匹配 receiver！ int match = receiver.filter.match(action, type, scheme, data, categories, \"LocalBroadcastManager\"); //【2.4】匹配成功，将目标 receiver 加入到目标列表中！ if (match &gt;= 0) &#123; if (debug) Log.v(TAG, \" Filter matched! match=0x\" + Integer.toHexString(match)); if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; // 设置 broadcasting 为 true！ &#125; else &#123; if (debug) &#123; String reason; switch (match) &#123; case IntentFilter.NO_MATCH_ACTION: reason = \"action\"; break; case IntentFilter.NO_MATCH_CATEGORY: reason = \"category\"; break; case IntentFilter.NO_MATCH_DATA: reason = \"data\"; break; case IntentFilter.NO_MATCH_TYPE: reason = \"type\"; break; default: reason = \"unknown reason\"; break; &#125; Log.v(TAG, \" Filter did not match: \" + reason); &#125; &#125; &#125; //【3】收集完所有匹配的 receiver，开始发送广播！ if (receivers != null) &#123; //【3.1】将所有 receiver 的 broadcasting 置为 false； for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; //【2.4.1】创建 BroadcastRecord 实例，将其添加到 mPendingBroadcasts 列表中！ mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; //【3.1】发送 MSG_EXEC_PENDING_BROADCASTS，处理广播！ mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false;&#125; 在 LocalBroadcastManager 还有如下的一个 list 表：123// 保存所有等待发送的 broadcast！private final ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts = new ArrayList&lt;BroadcastRecord&gt;(); 其实，sendBroadcast 方法，本质上是将 BroadcastRecord 添加到内部的 mPendingBroadcasts 集合中，然后发送 MSG_EXEC_PENDING_BROADCASTS 消息，处理广播！ 之所以是异步的原因是，sendBroadcast 方法只是将广播加入到了 mPendingBroadcasts 中后，会立刻返回； 而广播的分发是在主线程，如果我们在子线程中 sendBroadcast 的话，整个过程显然是异步的！ 继续分析： 2.4.1 new BroadcastRecord用于表示一个广播实例： 123456789private static class BroadcastRecord &#123; final Intent intent; // 意图 final ArrayList&lt;ReceiverRecord&gt; receivers; // 目标 receiver 列表； BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers) &#123; intent = _intent; receivers = _receivers; &#125;&#125; 不用多说了！ 2.5 LocalBroadcastManager.sendBroadcastSync - 同步广播sendBroadcastSync 用于同步发送广播： 1234567public void sendBroadcastSync(Intent intent) &#123; //【2.4】将广播添加到 mPendingBroadcasts 列表中！ if (sendBroadcast(intent)) &#123; //【2.6】立刻触发广播的接收！ executePendingBroadcasts(); &#125;&#125; sendBroadcastSync 方法之所以是同步的是因为，当我们 sendBroadcast 将广播加入到 mPendingBroadcasts 列表中后，会立刻调用 executePendingBroadcasts 分发广播，整个流程都是在同一个线程中执行的！ 注意： 按照以往认知：BroadcastReceiver 的 onReceive 应该是在主线程中调用的，但是在这里，BroadcastReceiver 的 onReceive 方法却可以在非主线程中调用！ 主要差别是：两种情况下的实现方式不同，前者是跨进程通信，所以 onReceive 始终是在主线程中拉起的；而后者由于实质上只是一个回调，所以可以在任何线程中拉起！ 2.6 LocalBroadcastManager.executePendingBroadcasts - 接收广播executePendingBroadcasts 用于分发和接收广播！ 1234567891011121314151617181920212223private void executePendingBroadcasts() &#123; while (true) &#123; //【1】将 mPendingBroadcasts 中待处理的广播拷贝到临时分发数组 brs 中 // 并清空 mPendingBroadcasts； BroadcastRecord[] brs = null; synchronized (mReceivers) &#123; final int N = mPendingBroadcasts.size(); if (N &lt;= 0) &#123; return; // 如果 mPendingBroadcasts 为 null，那就结束发送； &#125; brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); &#125; //【2】拉起所有 receiver 的 onReceive 方法，处理广播； for (int i=0; i&lt;brs.length; i++) &#123; BroadcastRecord br = brs[i]; for (int j=0; j&lt;br.receivers.size(); j++) &#123; br.receivers.get(j).receiver.onReceive(mAppContext, br.intent); &#125; &#125; &#125;&#125; 逻辑也很清楚！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"BroadcastReceiver广播接收者","slug":"AndroidFramework源码分析/BroadcastReceiver广播接收者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/"}],"tags":[{"name":"BroadcastReceiver广播接收者","slug":"BroadcastReceiver广播接收者","permalink":"https://coolqi.top/tags/BroadcastReceiver广播接收者/"}]},{"title":"Serivce 篇 5 - unbindService 流程分析","slug":"Serivce5-unbindService","date":"2016-06-23T12:46:25.000Z","updated":"2018-11-20T16:34:21.000Z","comments":true,"path":"2016/06/23/Serivce5-unbindService/","link":"","permalink":"https://coolqi.top/2016/06/23/Serivce5-unbindService/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，转载请说明出处！ 0 综述我们通过 bindService 绑定的服务，需要通过 unbindService 来解除绑定： 1context.unbindService(conn); 以前我们只是会调用，但是其底层的调用到底是什么样的呢？知其然知其所以然，今天我们就来学习下 unbindService 的过程！ 1 发起端进程1.1 ContextWrapper.unbindService12345@Overridepublic void unbindService(ServiceConnection conn) &#123; mBase.unbindService(conn);&#125; ContextWrapper 提供了两个方法来启动 Service，其中一个是隐藏方法：startServiceAsUser！ mBase 是 ContextImpl 对象，继续看！ 1.2 ContextImpl.unbindService123456789101112131415161718192021222324252627282930class ContextImpl extends Context &#123; @Override public void unbindService(ServiceConnection conn) &#123; if (conn == null) &#123; throw new IllegalArgumentException(\"connection is null\"); &#125; if (mPackageInfo != null) &#123; //【1】这里的 mPackageInfo 是 LoadedApk 类型的！ // 获得 ServiceConnection 对应的 InnerConnection IServiceConnection sd = mPackageInfo.forgetServiceDispatcher( getOuterContext(), conn); try &#123; //【2】进入系统进程！ ActivityManagerNative.getDefault().unbindService(sd); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; else &#123; throw new RuntimeException(\"Not supported in system context\"); &#125; &#125;&#125; ContextImpl 和 ContextWrapper 的具体关系，请来看另一博文：Android 系统的 Context 分析，这里我们不再详细说明！ mUser：表示的是当前的设备 user！ 1.2.1 LoadedApk.forgetServiceDispatcher参数传入： ServiceConnection c：应用程序的链接对象！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public final IServiceConnection forgetServiceDispatcher(Context context, ServiceConnection c) &#123; synchronized (mServices) &#123; //【1】获得当前进程中 Context 运行环境对应的连接映射关系集合！ ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); LoadedApk.ServiceDispatcher sd = null; if (map != null) &#123; //【2】获得当前 ServiceConnection 对应的 ServiceDispatcher 服务分发对象！ sd = map.get(c); if (sd != null) &#123; // 移除对应 ServiceDispatcher 服务分发对象！ map.remove(c); //【2.1】设置 mForgotten 的值为 true！ sd.doForget(); if (map.size() == 0) &#123; // 当 Context 运行环境下已经没有连接映射，那就从 LoadkedApk.mServices 移除！ mServices.remove(context); &#125; // Context.BIND_DEBUG_UNBIND 标志是在 bindService 时设置的，用于 unbind 的 debug 调试！ // 这里我们不看！ if ((sd.getFlags()&amp;Context.BIND_DEBUG_UNBIND) != 0) &#123; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; holder = mUnboundServices.get(context); if (holder == null) &#123; holder = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mUnboundServices.put(context, holder); &#125; RuntimeException ex = new IllegalArgumentException( \"Originally unbound here:\"); ex.fillInStackTrace(); sd.setUnbindLocation(ex); holder.put(c, sd); &#125; // 返回 InnerConnection 对象！ return sd.getIServiceConnection(); &#125; &#125; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; holder = mUnboundServices.get(context); if (holder != null) &#123; sd = holder.get(c); if (sd != null) &#123; RuntimeException ex = sd.getUnbindLocation(); throw new IllegalArgumentException( \"Unbinding Service \" + c + \" that was already unbound\", ex); &#125; &#125; if (context == null) &#123; throw new IllegalStateException(\"Unbinding Service \" + c + \" from Context that is no longer in use: \" + context); &#125; else &#123; throw new IllegalArgumentException(\"Service not registered: \" + c); &#125; &#125;&#125; 这里逻辑很简单，其中，调用了 ServiceDispatcher.doForget 方法！ 1234567891011121314151617void doForget() &#123; synchronized(this) &#123; for (int i=0; i&lt;mActiveConnections.size(); i++) &#123; ServiceDispatcher.ConnectionInfo ci = mActiveConnections.valueAt(i); //【1】取消死亡监控器 ci.binder.unlinkToDeath(ci.deathMonitor, 0); &#125; // 清楚这个连接对应的 mActiveConnections 集合！ mActiveConnections.clear(); // 置 mForgotten 为 true！ mForgotten = true; &#125;&#125; 我们继续看！！ 接着，调用 ActivityManagerNative.getDefault() 方法，获得 AMS 的代理对象 ActivityManagerProxy！ ActivityManagerProxy 是 ActivityManagerN 的内部类，通过 getDefault 方法创建了对应的单例模式，保存在 ActivityManagerNative 的类变量 getDefault 中！ 1.3 ActivityManagerP.unbindService123456789101112131415public boolean unbindService(IServiceConnection connection) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(connection.asBinder()); //【1】传递 UNBIND_SERVICE_TRANSACTION，flags 为 0，是阻塞式通信！ mRemote.transact(UNBIND_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); boolean res = reply.readInt() != 0; data.recycle(); reply.recycle(); return res;&#125; 通过 binder 进程间通信，进入系统进程，参数分析： IServiceConnection connection：InnerConnection 对象！ 2 系统进程首先，进入 ActivityManagerN 中去看看：1234567891011121314case UNBIND_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); //【1】这里是转换为 IServiceConnection.proxy 对象！ IServiceConnection conn = IServiceConnection.Stub.asInterface(b); boolean res = unbindService(conn); reply.writeNoException(); reply.writeInt(res ? 1 : 0); return true;&#125; 2.1 ActivityManagerP.unbindService继续来看：12345678public boolean unbindService(IServiceConnection connection) &#123; synchronized (this) &#123; //【1】进入 ActiveServices 方法！ return mServices.unbindServiceLocked(connection); &#125;&#125; 2.2 ActiveServices.unbindServiceLocked解除服务 bind，参数传入如下： IServiceConnection connection：是 IServiceConnection.Proxy 类型的对象，是 InnerConnection 在系统进程中的 Binder实体对象！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263boolean unbindServiceLocked(IServiceConnection connection) &#123; IBinder binder = connection.asBinder(); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"unbindService: conn=\" + binder); //【1】从 mServiceConnections 中获得对应的 ConnectionRecord 集合！ // 表示 IServiceConnection 对象对应的所有连接对象！ ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder); if (clist == null) &#123; Slog.w(TAG, \"Unbind failed: could not find connection for \" + connection.asBinder()); return false; &#125; final long origId = Binder.clearCallingIdentity(); try &#123; while (clist.size() &gt; 0) &#123; // 遍历 ConnectionRecord 列表！ ConnectionRecord r = clist.get(0); //【2】移除连接，并拉起被绑定服务的 unbind 方法，这个我们后面看！ removeConnectionLocked(r, null, null); if (clist.size() &gt; 0 &amp;&amp; clist.get(0) == r) &#123; // removeConnectionLocked 中会移除这个 ConnectionRecord 对象，这里是异常判断； // 如果 removeConnectionLocked 移除失败，这里会再次移除！ Slog.wtf(TAG, \"Connection \" + r + \" not removed for binder \" + binder); clist.remove(0); &#125; // 如果绑定的服务的进程已经启动，进入该分支！ if (r.binding.service.app != null) &#123; if (r.binding.service.app.whitelistManager) &#123; updateWhitelistManagerLocked(r.binding.service.app); &#125; // This could have made the service less important. if ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; r.binding.service.app.treatLikeActivity = true; mAm.updateLruProcessLocked(r.binding.service.app, r.binding.service.app.hasClientActivities || r.binding.service.app.treatLikeActivity, null); &#125; // 更新服务的 adj 的值！ mAm.updateOomAdjLocked(r.binding.service.app); &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return true;&#125; ActiveServices 的 mServiceConnections 用来封装所有服务的连接对象 IServiceConnection.proxy 和ConnectionRecord 的映射关系，二者是一对多的关系！ 继续来看！ 2.3 ActiveServices.removeConnectionLocked这个方法是 unbindService 整个流程中的关键！ ConnectionRecord c：连接信息对象； ProcessRecord skipApp：传入为 null； ActivityRecord skipAct：传入为 null； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132void removeConnectionLocked(ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct) &#123; // 这里的 c.conn 是 IServiceConnection.Proxy 代理对象，映射着应用进程中的一个连接对象； IBinder binder = c.conn.asBinder(); // 获得 ConnectionRecord 对象所属的进程绑定信息对象 AppBindRecord； AppBindRecord b = c.binding; // 获得所绑定的服务对象 ServiceRecord； ServiceRecord s = b.service; //【1】删除 bindService 时创建的数据结构和引用关系! // 从 ServiceRecord.connections 中获得 IServiceConnection.Proxy 对应的 ArrayList&lt;ConnectionRecord&gt; 集合！ // 并中删除当前的 ConnectionRecord 对象！ ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder); if (clist != null) &#123; clist.remove(c); if (clist.size() == 0) &#123; // 如果 ArrayList&lt;ConnectionRecord&gt; 长度为 0，就移除 // IServiceConnection.Proxy 和 ArrayList&lt;ConnectionRecord&gt; 映射！ s.connections.remove(binder); &#125; &#125; // 从 AppBindRecord.connections 中移除 ConnectionRecord！ b.connections.remove(c); if (c.activity != null &amp;&amp; c.activity != skipAct) &#123; if (c.activity.connections != null) &#123; c.activity.connections.remove(c); &#125; &#125; // AppBindRecord.client 是 ProcessRecord 对象，表示绑定者所在的进程， // 这里是从 ProcessRecord.connections 集合中删除当前的 ConnectionRecord！ if (b.client != skipApp) &#123; b.client.connections.remove(c); if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.updateHasAboveClientLocked(); &#125; if ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) &#123; s.updateWhitelistManager(); if (!s.whitelistManager &amp;&amp; s.app != null) &#123; updateWhitelistManagerLocked(s.app); &#125; &#125; if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true); &#125; &#125; // 从 ActiveServices.mServiceConnections 获得 IServiceConnection.Proxy 对应的 ArrayList&lt;ConnectionRecord&gt;！ // 并从 ArrayList&lt;ConnectionRecord&gt; 中删除 ConnectionRecord！ clist = mServiceConnections.get(binder); if (clist != null) &#123; clist.remove(c); if (clist.size() == 0) &#123; // 如果 ArrayList&lt;ConnectionRecord&gt; 长度为 0，就移除 // IServiceConnection.Proxy 和 ArrayList&lt;ConnectionRecord&gt; 映射！ mServiceConnections.remove(binder); &#125; &#125; mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid, s.name); // 如果 AppBindRecord.connections 的元素个数为 0，表示该进程中已经没有连接对象了！ // 就删除 AppBindRecord.IntentBindRecord.apps 中调用者进程 ProcessRecord 和 AppBindRecord 的映射！ if (b.connections.size() == 0) &#123; b.intent.apps.remove(b.client); &#125; // 此时，服务没有死亡，进入这个分支！！ if (!c.serviceDead) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Disconnecting binding \" + b.intent + \": shouldUnbind=\" + b.intent.hasBound); // 当服务所在进程没有被销毁，且已经没有任何进程通过该 intent 绑定该服务了，就进入这里！ if (s.app != null &amp;&amp; s.app.thread != null &amp;&amp; b.intent.apps.size() == 0 &amp;&amp; b.intent.hasBound) &#123; try &#123; // 【2】设置拉起 onunbind 方法超时处理任务，这里不多说了，逻辑类似！ bumpServiceExecutingLocked(s, false, \"unbind\"); if (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == 0 &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123; mAm.updateLruProcessLocked(s.app, false, null); &#125; mAm.updateOomAdjLocked(s.app); // 设置 IntentBindRecord.hasBound 为 false，表示绑定解除！ b.intent.hasBound = false; // 设置 IntentBindRecord.doRebind 为 false，后面会根据 onUnbind 的返回值来设置 doRebind！ b.intent.doRebind = false; // 【3】通过 binder 通信，进入被绑定服务所在的进程，拉起其 onUnbind 方法 // 采用的是 IBinder.FLAG_ONEWAY 的方式，非阻塞式！！ s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent()); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when unbinding service \" + s.shortName, e); serviceProcessGoneLocked(s); &#125; &#125; // 如果接触绑定的时候，服务正在启动,那就将服务从 mPendingServices 中删除！ mPendingServices.remove(s); //【4】如果服务之前 bind 时，flags 设置了 Context.BIND_AUTO_CREATE，就尝试停止服务！ if ((c.flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; boolean hasAutoCreate = s.hasAutoCreateConnections(); if (!hasAutoCreate) &#123; if (s.tracker != null) &#123; s.tracker.setBound(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); &#125; &#125; // 【4.1】尝试停止服务！ bringDownServiceIfNeededLocked(s, true, hasAutoCreate); &#125; &#125;&#125; 这段代码最开始是解除 bindService 时创建的数据结构和引用关系！然后拉起了被绑定服务的 unbind 方法，最后尝试停止服务！ 注意： 如果之前对应的 bindService 使用了 Context.BIND_AUTO_CREATE 的 flags，这里就会尝试把服务停止，但是如果之前对应的 bindService 没有设置 Context.BIND_AUTO_CREATE 标志位，从前面的 bindService 流程中，可以看出，只会把之前 bind 时的绑定信息删除即可！ 下面我们来一个一个分析！ 2.3.1 ApplicationThreadP.scheduleUnbindService首先，来看看拉起 onUnbind 方法的逻辑！1234567891011121314public final void scheduleUnbindService(IBinder token, Intent intent) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); intent.writeToParcel(data, 0); //【1】binder 通信，采用的是 IBinder.FLAG_ONEWAY 的方式，非阻塞式！ mRemote.transact(SCHEDULE_UNBIND_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 这里通过 binder 通信，进入服务所在的应用进程中！我们在第三部分详细讨论！！ 2.3.2 ActiveServices.bringDownServiceIfNeededLocked拉起了服务的 onUnbind 方法后，对于 bindService 时，如果设置了 Context.BIND_AUTO_CREATE 的 flags，还要尝试停止服务！ 我们来看一下具体的逻辑！ 12345678910111213141516private final void bringDownServiceIfNeededLocked(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; //【1】如果这个服务还被需要，就不能停止！ if (isServiceNeeded(r, knowConn, hasConn)) &#123; return; &#125; //【2】服务正在被启动，就不能停止！ if (mPendingServices.contains(r)) &#123; return; &#125; //【3】继续停止服务！ bringDownServiceLocked(r);&#125; 如果这个服务仍然被需要，或者服务所在的进程正在启动，这两种情况下，不能停止服务！ 2.3.2.1 ActiveServices.isServiceNeeded1234567891011121314151617private final boolean isServiceNeeded(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; //【1】服务已经通过 startService 启动了，返回 true！ if (r.startRequested) &#123; return true; &#125; //【2】仍然有应用通过 auto create 的方式绑定该服务，通过前面的分析，这里的自动创建的服务链接被移除了！！ if (!knowConn) &#123; hasConn = r.hasAutoCreateConnections(); &#125; if (hasConn) &#123; return true; &#125; return false;&#125; hasAutoCreateConnections 方法遍历 ServiceRecord.connections 集合：12345678910111213// in ServiceRecordpublic boolean hasAutoCreateConnections() &#123; for (int conni=connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; cr = connections.valueAt(conni); for (int i=0; i&lt;cr.size(); i++) &#123; if ((cr.get(i).flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; return true; &#125; &#125; &#125; return false;&#125; 判断一个服务是否仍被需要，有两种情况： 服务已经通过 startService 被请求启动了； 服务仍然被一些应用通过自动创建的方式绑定，即 bindService 时，flags 为 Context.BIND_AUTO_CREATE； 如果满足上面的任何一个条件，isServiceNeeded 返回的是 true，那么，就不会停止这个任务了！ 通过我们上面的分析，当我们调用 unbindService后，会将之前 bind 时的创建的连接对象从集合中移除，所以hasConn为false，但是如果服务之前被startService启动了，并没有stopService，那么unbindService不会继续执行！ 下面，我们继续来看： 2.3.2.2 ActiveServices.bringDownServiceLocked如果没有其他的应用通过 BIND_AUTO_CREATE 的方式来绑定这个服务，那么就要调用 bringDownServiceLocked 方法，来停止服务，这里我们假设没有其他的绑定信息！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173private final void bringDownServiceLocked(ServiceRecord r) &#123; // 首先，遍历 r.connections 集合，终止所有的 bind 连接！ for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; c = r.connections.valueAt(conni); for (int i=0; i&lt;c.size(); i++) &#123; ConnectionRecord cr = c.get(i); // 设置每一个 ConnectionRecord.serviceDead 为 true，表示服务要被 stop 掉，连接断开！ // 因为这里设置了每一个 ConnectionRecord，所以前面只有第一次调用才会进入！ cr.serviceDead = true; try &#123; //【1】Binder 调用，进入应用进程触发 ServiceConnection 的 onServiceDisconnected，这是非阻塞的！ // 这里第二个参数，为 null，所以会触发 onServiceDisconnected！ cr.conn.connected(r.name, null); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Failure disconnecting service \" + r.name + \" to connection \" + c.get(i).conn.asBinder() + \" (in \" + c.get(i).binding.client.processName + \")\", e); &#125; &#125; &#125; // 处理所有的 ServiceRecord.bindings 集合中的 IntentBindRecord 对象！ // 因为绑定该服务的不止一个，现在要停止服务了，所以要解除所有的绑定！ if (r.app != null &amp;&amp; r.app.thread != null) &#123; for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123; IntentBindRecord ibr = r.bindings.valueAt(i); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing down binding \" + ibr + \": hasBound=\" + ibr.hasBound); // 显然是 hasBound 是 true 的！ if (ibr.hasBound) &#123; try &#123; // 设置 unbind 超时处理 bumpServiceExecutingLocked(r, false, \"bring down unbind\"); mAm.updateOomAdjLocked(r.app); // 置 IntentBindRecord 对象的 hasBound 为 false，表示 bind 断开； ibr.hasBound = false; //【2】通过 binder 通信，进入绑定了服务的应用进程，调用 AT.scheduleUnbindService 方法 // ，拉起服务的 onUnbind 方法！ r.app.thread.scheduleUnbindService(r, ibr.intent.getIntent()); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when unbinding service \" + r.shortName, e); serviceProcessGoneLocked(r); &#125; &#125; &#125; &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing down \" + r + \" \" + r.intent); // 设置服务的销毁时间 r.destroyTime = SystemClock.uptimeMillis(); if (LOG_SERVICE_START_STOP) &#123; EventLogTags.writeAmDestroyService( r.userId, System.identityHashCode(r), (r.app != null) ? r.app.pid : -1); &#125; final ServiceMap smap = getServiceMap(r.userId); // 从 ActiveServices 的 mServiceMap 中移除服务 ServiceRecord 对象！ smap.mServicesByName.remove(r.name); smap.mServicesByIntent.remove(r.intent); // 重启参数置为 0 r.totalRestartCount = 0; // 取消重启任务 unscheduleServiceRestartLocked(r, 0, true); // 从 mPendingServices 列表中移除！ for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; if (mPendingServices.get(i) == r) &#123; mPendingServices.remove(i); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Removed pending: \" + r); &#125; &#125; // 取消前台的通知！ cancelForegroudNotificationLocked(r); r.isForeground = false; r.foregroundId = 0; r.foregroundNoti = null; // 清理启动项集合！ r.clearDeliveredStartsLocked(); r.pendingStarts.clear(); if (r.app != null) &#123; synchronized (r.stats.getBatteryStats()) &#123; r.stats.stopLaunchedLocked(); &#125; // 将服务从其所在进程的 app.services 集合中删除！ r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; // 如果服务所在的进程没有被杀掉，进入这个分支！ if (r.app.thread != null) &#123; updateServiceForegroundLocked(r.app, false); try &#123; // 设置 destroy 超时处理！ bumpServiceExecutingLocked(r, false, \"destroy\"); // 将其添加到 AS 的 mDestroyingServices 机和中，表示服务正在销毁！ mDestroyingServices.add(r); r.destroying = true; mAm.updateOomAdjLocked(r.app); //【3】通过 binder 通信，回调 AT 的 scheduleStopService 方法！ r.app.thread.scheduleStopService(r); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when destroying service \" + r.shortName, e); serviceProcessGoneLocked(r); &#125; &#125; else &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Removed service that has no process: \" + r); &#125; &#125; else &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Removed service that is not running: \" + r); &#125; // 清空服务的 bindings 集合！ if (r.bindings.size() &gt; 0) &#123; r.bindings.clear(); &#125; // 将服务的重启任务对象置空！ if (r.restarter instanceof ServiceRestarter) &#123; ((ServiceRestarter)r.restarter).setService(null); &#125; int memFactor = mAm.mProcessStats.getMemFactorLocked(); long now = SystemClock.uptimeMillis(); if (r.tracker != null) &#123; r.tracker.setStarted(false, memFactor, now); r.tracker.setBound(false, memFactor, now); if (r.executeNesting == 0) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; smap.ensureNotStartingBackground(r);&#125; 这段代码很简单，主要逻辑如下： 首先进入绑定服务的应用进程，回调 ServiceConnection 的 onServiceDisconnected 方法，取消所有进程对该服务的绑定； 接着，进入服务所在的进程，拉起服务的 onUnbind 方法； 最后，拉起服务的 onDestroy 方法，销毁服务； 整个过程，还会清空和重置一些关键变量！！ 下面我们重点分析一下上面的三个过程！ 3 服务所在进程首先要进入 ApplicationThreadN.onTransact 方法：12345678910case SCHEDULE_UNBIND_SERVICE_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder token = data.readStrongBinder(); Intent intent = Intent.CREATOR.createFromParcel(data); //【1】执行 unbind 方法！ scheduleUnbindService(token, intent); return true;&#125; 继续来看： 进入 ApplicationThread 中！ 3.1 ApplicationThread.scheduleUnbindService12345678public final void scheduleUnbindService(IBinder token, Intent intent) &#123; BindServiceData s = new BindServiceData(); s.token = token; s.intent = intent; //【1】发送 UNBIND_SERVICE 给主线程 Handler！ sendMessage(H.UNBIND_SERVICE, s);&#125; 进入 H！ 3.1.1 ActivityThread.H12345678910111213private class H extends Handler &#123; public void handleMessage(Message msg) &#123; case UNBIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceUnbind\"); //【2】继续调用 handleUnbindService！ handleUnbindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125;&#125; 继续来看！！ 3.1.2 ActivityThread.handleUnbindService接着，这里是关键地方！：123456789101112131415161718192021222324252627282930313233343536private void handleUnbindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); //【3】拉起服务的 onUnbind 方法，并获得返回值！ boolean doRebind = s.onUnbind(data.intent); try &#123; if (doRebind) &#123; // 如果 doRebind 值为 true，进入该分支！ ActivityManagerNative.getDefault().unbindFinished( data.token, data.intent, doRebind); &#125; else &#123; // 如果返回 false（默认），就会执行 serviceDoneExecuting 方法！ ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to unbind to service \" + s + \" with \" + data.intent + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; 如果 doRebind 为 true，调用 AMS 的 unbindFinished 方法；如果 doRebind 为 false，调用 AMS 的 serviceDoneExecuting 方法； 拉起了 onUnbind 方法后，需要根据返回值做相应的处理，接下来进入系统进程，具体逻辑见第四部分！！ 3.2 InnerConnection.connected系统进程会调用 IServiceConnection.Proxy 代理对象的 connected 方法，通过 binder 调用，进入绑定服务的应用进程，这个是异步调用： 1cr.conn.connected(r.name, null); 我们去看看！ 123456789101112131415161718private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; //【1】调用 mDispatcher 对象的 connected，这里的 service 为 null； sd.connected(name, service); &#125; &#125;&#125; 继续来看： 3.2.1 ServiceDispatcher.connected12345678public void connected(ComponentName name, IBinder service) &#123; if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnected(name, service); &#125;&#125; 最后都会调用 doConnected 方法： 3.2.2 ServiceDispatcher.doConnected参数 service 这里为 null！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void doConnected(ComponentName name, IBinder service) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; // mForgotten 在最开始就被设置成了 true，所以这里就会直接返回的！ // ServiceConnection.onServiceDisconnected 方法不会被调用！ if (mForgotten) &#123; // We unbound before receiving the connection; ignore // any connection received. return; &#125; // 获得已有的活跃的 connection 对象！ old = mActiveConnections.get(name); if (old != null &amp;&amp; old.binder == service) &#123; // 因为 service 为 null，所以这里不会进入该分支！ return; &#125; if (service != null) &#123; // A new service is being connected... set it all up. info = new ConnectionInfo(); info.binder = service; info.deathMonitor = new DeathMonitor(name, service); try &#123; service.linkToDeath(info.deathMonitor, 0); mActiveConnections.put(name, info); &#125; catch (RemoteException e) &#123; // This service was dead before we got it... just // don't do anything with it. mActiveConnections.remove(name); return; &#125; &#125; else &#123; // service 为 null，说明是解除绑定，所以要从 mActiveConnections 中移除绑定对象！ mActiveConnections.remove(name); &#125; // 取消死亡通知监控器 if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // 之前是有连接的，所以会进入这分支！！ if (old != null) &#123; // 拉起服务的 onServiceDisconnected 方法！ mConnection.onServiceDisconnected(name); &#125; // 不进入这个分支！ if (service != null) &#123; mConnection.onServiceConnected(name, service); &#125;&#125; 这里，最后会进入应用的 ServiceConnection 对象！123456private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125; 注意：onServiceDisconnected 方法是非阻塞的，即，系统进程不会等 onServiceDisconnected 执行完才继续执行！！ 4 系统进程首先会进入 ActivityManagerNative 的 onTransact 方法中：12345678910111213141516171819202122232425262728case UNBIND_FINISHED_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); Intent intent = Intent.CREATOR.createFromParcel(data); boolean doRebind = data.readInt() != 0; // 继续来看！ unbindFinished(token, intent, doRebind); reply.writeNoException(); return true;&#125;case SERVICE_DONE_EXECUTING_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); int type = data.readInt(); int startId = data.readInt(); int res = data.readInt(); // 继续来看！ serviceDoneExecuting(token, type, startId, res); reply.writeNoException(); return true;&#125; 接下来，进入 AMS！ 4.1 ActivityManagerS.unbindFinished如果 onUnbind 方法返回的是 true，进入该方法：12345678910111213public void unbindFinished(IBinder token, Intent intent, boolean doRebind) &#123; // 不能通过 intent 传递文件描述符！ if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; // 进入 ActiveServices！ mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind); &#125;&#125; 4.1.1 ActiveServices.unbindFinishedLocked继续来看，doRebind 是服务的 onUnbind 方法的返回值！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void unbindFinishedLocked(ServiceRecord r, Intent intent, boolean doRebind) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; if (r != null) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(intent); // 获得绑定 Serivce 的 intent 对应的 IntentBindRecord 对象！ IntentBindRecord b = r.bindings.get(filter); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"unbindFinished in \" + r + \" at \" + b + \": apps=\" + (b != null ? b.apps.size() : 0)); // 这里的 inDestroying 的值为 false，因为还没有添加！ boolean inDestroying = mDestroyingServices.contains(r); // 显然，这里不会为 null！ if (b != null) &#123; if (b.apps.size() &gt; 0 &amp;&amp; !inDestroying) &#123; // Applications have already bound since the last // unbind, so just rebind right here. boolean inFg = false; for (int i=b.apps.size()-1; i&gt;=0; i--) &#123; ProcessRecord client = b.apps.valueAt(i).client; if (client != null &amp;&amp; client.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND) &#123; inFg = true; break; &#125; &#125; try &#123; requestServiceBindingLocked(r, b, inFg, true); &#125; catch (TransactionTooLargeException e) &#123; // Don't pass this back to ActivityThread, it's unrelated. &#125; &#125; else &#123; // 将 doRebind 置为 true！ b.doRebind = true; &#125; &#125; // 最后进入 serviceDoneExecutingLocked 方法！ serviceDoneExecutingLocked(r, inDestroying, false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 接着来看！ 4.1.2 ActiveServices.serviceDoneExecutingLocked参数传递： boolean inDestroying：传入 false； boolean finishing：传入 false； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&lt;&lt;&lt; DONE EXECUTING \" + r + \": nesting=\" + r.executeNesting + \", inDestroying=\" + inDestroying + \", app=\" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&lt;&lt;&lt; DONE EXECUTING \" + r.shortName); r.executeNesting--; if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); // 从所在进程的 executingServices 中删除该服务！ r.app.execServicesFg = false; r.app.executingServices.remove(r); if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); // 如果进程中没有在执行指定代码逻辑的服务了，就取消超市任务！ mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // 如果进程还有在执行指定代码逻辑的服务，并且有服务在前台执行，那就要将进程的 execServicesFg 置为 ture for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; // 不进入！ if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); mDestroyingServices.remove(r); r.bindings.clear(); &#125; // 更新 oomAdj 值！ mAm.updateOomAdjLocked(r.app); &#125; // 置服务的 executeFg 为 false； r.executeFg = false; if (r.tracker != null) &#123; r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); if (finishing) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; if (finishing) &#123; // 不进入这个分支！ if (r.app != null &amp;&amp; !r.app.persistent) &#123; r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; &#125; r.app = null; &#125; &#125;&#125; 这里就不再详细说了！！ 4.2 ActivityManagerS.serviceDoneExecuting对于拉起 onDestroy 方法，最后会调用：123456789101112public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; Slog.e(TAG, \"serviceDoneExecuting: Invalid service token=\" + token); throw new IllegalArgumentException(\"Invalid service token\"); &#125; // 最后，进入 AS！ mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res); &#125;&#125; 接着，进入 ActiveServices！ 4.2.1 ActiveServices.serviceDoneExecutingLocked根据参数传递： int type：传入 ActivityThread.SERVICE_DONE_EXECUTING_STOP； int startId：传入 0； int res：传入0； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123; // 这里的 inDestroying 为 true，因为我们之前已经将该服务添加到 mDestroyingServices！ boolean inDestroying = mDestroyingServices.contains(r); if (r != null) &#123; if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123; ... ... ... // 这里是和 startService 服务有关，我们这里不看！ &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123; // This is the final call from destroying the service... we should // actually be getting rid of the service at this point. Do some // validation of its state, and ensure it will be fully removed. if (!inDestroying) &#123; // Not sure what else to do with this... if it is not actually in the // destroying list, we don't need to make sure to remove it from it. // If the app is null, then it was probably removed because the process died, // otherwise wtf if (r.app != null) &#123; Slog.w(TAG, \"Service done with onDestroy, but not inDestroying: \" + r + \", app=\" + r.app); &#125; &#125; else if (r.executeNesting != 1) &#123; Slog.w(TAG, \"Service done with onDestroy, but executeNesting=\" + r.executeNesting + \": \" + r); // Fake it to keep from ANR due to orphaned entry. r.executeNesting = 1; &#125; &#125; final long origId = Binder.clearCallingIdentity(); // 最后，再次调用 serviceDoneExecutingLocked！ serviceDoneExecutingLocked(r, inDestroying, inDestroying); Binder.restoreCallingIdentity(origId); &#125; else &#123; Slog.w(TAG, \"Done executing unknown service from pid \" + Binder.getCallingPid()); &#125;&#125; 4.2.2 ActiveServices.serviceDoneExecutingLocked参数传递： boolean inDestroying：传入true； boolean finishing：传入 true； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&lt;&lt;&lt; DONE EXECUTING \" + r + \": nesting=\" + r.executeNesting + \", inDestroying=\" + inDestroying + \", app=\" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&lt;&lt;&lt; DONE EXECUTING \" + r.shortName); r.executeNesting--; if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); // 从所在进程的 executingServices 中删除该服务！ r.app.execServicesFg = false; r.app.executingServices.remove(r); if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); // 如果进程中没有在执行指定代码逻辑的服务了，就取消超时任务！ mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // 如果进程还有在执行指定代码逻辑的服务，并且有服务在前台执行，那就要将进程的 execServicesFg 置为 ture for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; // inDestroying 为 true 进入！ if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); // 从 mDestroyingServices 中删除 ServiceRecord！ mDestroyingServices.remove(r); // 清空其 bindings 集合！ r.bindings.clear(); &#125; // 更新 oomAdj 值！ mAm.updateOomAdjLocked(r.app); &#125; // 置服务的 executeFg 为 false； r.executeFg = false; if (r.tracker != null) &#123; r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); // 取消对服务的监控！ if (finishing) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; if (finishing) &#123; // finishing 为 true ，进入这个分支！ if (r.app != null &amp;&amp; !r.app.persistent) &#123; // 如果服务所在的进程不是常驻进程，从进程的 services 中移除这个服务！ r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; &#125; r.app = null; &#125; &#125;&#125; 5 总结这里我们来总结一下，接触绑定的流程！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"Process篇 6 - 从 dumpsys meminfo 看进程的优先级","slug":"Process6-dumpsysMeminfoToShowAdj","date":"2016-06-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/06/13/Process6-dumpsysMeminfoToShowAdj/","link":"","permalink":"https://coolqi.top/2016/06/13/Process6-dumpsysMeminfoToShowAdj/","excerpt":"","text":"0 前言基于 android 7.1.1 源码，分析和总结 Process 相关知识！ 1 dumpsys meminfo –oomdumpsys meminfo 可以来看系统的内存使用情况，这里我们重点关注：Total PSS by OOM adjustment: 默认的 dumpsys meminfo 是出了可以看 Total PSS by OOM adjustment，还可以看 Total PSS by process 等等详细的信息，这里我们只关注第一种，这里有一个很方便的指令： adb shell dumpsys meminfo --oom 下面是该指令的输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Applications Memory Usage (in Kilobytes):Uptime: 37282469 Realtime: 62579406 ... ... ... ...Total PSS by OOM adjustment: 304,190K: Native 38,170K: android.hardware.camera.provider@2.4-service (pid 683) 17,815K: logd (pid 539) 15,833K: vendor.oppo.hardware.biometrics.face@1.0-service (pid 1109) 15,014K: surfaceflinger (pid 721) 7,927K: android.hardware.audio@2.0-service (pid 681) 7,318K: webview_zygote32 (pid 2635) 7,105K: rild (pid 1083) 6,857K: media.codec (pid 1082) ... ... ... ... 119,314K: System 119,314K: system (pid 1703) 168,951K: Persistent 94,755K: com.android.systemui (pid 2598) 23,766K: com.android.phone (pid 2738) 11,445K: .dataservices (pid 2706) 7,254K: com.oppo.multimedia.dirac (pid 3493) ... ... ... ... 95,474K: Foreground 33,792K: com.coloros.safecenter:clear_filter (pid 2514) 26,509K: com.oppo.ota:ui (pid 15668 / activities) 13,879K: com.coloros.securitypermission (pid 3140) 12,447K: com.oppo.ota (pid 15686) 8,847K: com.nearme.romupdate (pid 2491) ... ... ... ... 524,433K: Visible 105,184K: com.tencent.mm:push (pid 7125) 100,550K: com.tencent.mm:exdevice (pid 5237) 62,929K: com.oppo.launcher (pid 3325 / activities) 27,815K: android.process.contacts (pid 4085) 24,425K: com.coloros.safecenter (pid 3708) 23,279K: com.coloros.mcs (pid 4122) 21,670K: android.process.acore (pid 4310) 20,998K: com.coloros.recents (pid 3267 / activities) ... ... ... ... 39,159K: Perceptible 31,468K: com.sohu.inputmethod.sogouoem (pid 2584) 7,691K: com.amap.android.location (pid 4132) 103,667K: A Services 72,943K: com.kuaikan.comic:monitorService (pid 4938) 30,724K: com.kuaikan.comic:QS (pid 5207) 174,752K: Previous 147,972K: com.tencent.mm (pid 7318) 26,780K: com.android.settings (pid 13815 / activities) 489,783K: B Services 370,782K: com.kuaikan.comic (pid 4869 / activities) 28,757K: com.android.mms (pid 5120) 27,198K: com.kuaikan.comic:QALSERVICE (pid 5063) 15,458K: com.coloros.selfcheck (pid 15626 / activities) 15,422K: com.tencent.mobileqq:MSF (pid 10558) 14,523K: com.nearme.statistics.rom (pid 2556) 9,211K: com.coloros.gallery3d (pid 16053) 4,513K: com.coloros.activation (pid 5301) 3,919K: com.coloros.usbselection (pid 16123) 76,443K: Cached 39,483K: com.coloros.aiservice (pid 7038) 17,041K: android.process.media (pid 13010) 10,643K: com.android.providers.downloads (pid 3251) 4,979K: com.coloros.securepay (pid 9412) 4,297K: com.android.defcontainer (pid 15323)Total RAM: 3,831,972K (status normal) Free RAM: 1,734,943K ( 76,527K cached pss + 1,319,364K cached kernel + 24,584K ion cached + 314,468K free) Used RAM: 2,459,876K (2,083,100K used pss + 376,776K kernel) Lost RAM: -979,823K ZRAM: 616,976K physical used for 1,361,056K in swap (2,097,148K total swap) Tuning: 384 (large 512), oom 322,560K, restore limit 107,520K (high-end-gfx) 我们可以看到，这部分，系统是根据进程的 adj 将其分类，然后根据不同的分类，显示出了不同类别进程的内存使用情况！ 这里我们关心的是 adb shell dumpsys meminfo --oom 是如何归类不同类型的进程的！ 2 dumpApplicationMemoryUsageadb shell dumpsys meminfo --oom 最终会调用 dumpApplicationMemoryUsage 函数，这里我们重点关注和 --oom 相关的逻辑： 这里我们先来看几个和该指令相关的常量; 123456789101112131415161718static final int[] DUMP_MEM_OOM_ADJ = new int[] &#123; ProcessList.NATIVE_ADJ, ProcessList.SYSTEM_ADJ, ProcessList.PERSISTENT_PROC_ADJ, ProcessList.PERSISTENT_SERVICE_ADJ, ProcessList.FOREGROUND_APP_ADJ, ProcessList.VISIBLE_APP_ADJ, ProcessList.PERCEPTIBLE_APP_ADJ, ProcessList.BACKUP_APP_ADJ, ProcessList.HEAVY_WEIGHT_APP_ADJ, ProcessList.SERVICE_ADJ, ProcessList.HOME_APP_ADJ, ProcessList.PREVIOUS_APP_ADJ, ProcessList.SERVICE_B_ADJ, ProcessList.CACHED_APP_MIN_ADJ&#125;;static final String[] DUMP_MEM_OOM_LABEL = new String[] &#123; \"Native\", \"System\", \"Persistent\", \"Persistent Service\", \"Foreground\", \"Visible\", \"Perceptible\", \"Heavy Weight\", \"Backup\", \"A Services\", \"Home\", \"Previous\", \"B Services\", \"Cached\"&#125;; DUMP_MEM_OOM_ADJ 中封装的是 oom adj，DUMP_MEM_OOM_LABEL 中封装的是 lebal，这个看命令输出，很容易猜到是什么意思！ 下面我们来重点分析方法！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130final void dumpApplicationMemoryUsage(FileDescriptor fd, PrintWriter pw, String prefix, String[] args, boolean brief, PrintWriter categoryPw) &#123; ... ... ... ... // 解析指令，因为我们有 `--oom`，所以 oomOnly 为 true！ else if (\"--oom\".equals(opt)) &#123; oomOnly = true; &#125; ... ... ... ... &#125; long uptime = SystemClock.uptimeMillis(); long realtime = SystemClock.elapsedRealtime(); final long[] tmpLong = new long[1]; // 收集进程，返回的就是 mLruProcesses 的拷贝！ ArrayList&lt;ProcessRecord&gt; procs = collectProcesses(pw, opti, packages, args); ... ... ... ... // 创建一些数组，用于封装信息，数组长度均是 DUMP_MEM_OOM_LABEL.length: 14！ long oomPss[] = new long[DUMP_MEM_OOM_LABEL.length]; long oomSwapPss[] = new long[DUMP_MEM_OOM_LABEL.length]; ArrayList&lt;MemItem&gt;[] oomProcs = (ArrayList&lt;MemItem&gt;[]) new ArrayList[DUMP_MEM_OOM_LABEL.length]; long totalPss = 0; long totalSwapPss = 0; long cachedPss = 0; long cachedSwapPss = 0; boolean hasSwapPss = false; Debug.MemoryInfo mi = null; // 逆序遍历进程集合！ for (int i = procs.size() - 1 ; i &gt;= 0 ; i--) &#123; // 获得进程对象！ final ProcessRecord r = procs.get(i); final IApplicationThread thread; final int pid; final int oomAdj; final boolean hasActivities; synchronized (this) &#123; thread = r.thread; pid = r.pid; // 收集 pid！ oomAdj = r.getSetAdjWithServices(); // 获得该进程的 oomAdj！ hasActivities = r.activities.size() &gt; 0; // 该进程是否正在运行 activity！ &#125; if (thread != null) &#123; ... ... ... ... if (!isCheckinRequest &amp;&amp; mi != null) &#123; totalPss += myTotalPss; totalSwapPss += myTotalSwapPss; MemItem pssItem = new MemItem(r.processName + \" (pid \" + pid + (hasActivities ? \" / activities)\" : \")\"), r.processName, myTotalPss, myTotalSwapPss, pid, hasActivities); ... ... ... ... //【1】便利 oomPss 数组，匹配 oomAdj！ for (int oomIndex = 0; oomIndex &lt; oomPss.length; oomIndex++) &#123; //【1.1】当此时已经到了 oomPss 的最后一个元素，或者 // 该进程的 oomAdj 处于 [ DUMP_MEM_OOM_ADJ[oomIndex], DUMP_MEM_OOM_ADJ[oomIndex + 1] ) 之间！ // 这是我们匹配到了合适的 oomAdj，进入以下逻辑！ if (oomIndex == (oomPss.length - 1) || (oomAdj &gt;= DUMP_MEM_OOM_ADJ[oomIndex] &amp;&amp; oomAdj &lt; DUMP_MEM_OOM_ADJ[oomIndex + 1])) &#123; // oomPss[oomIndex] 累加上 myTotalPss！ oomPss[oomIndex] += myTotalPss; // oomSwapPss[oomIndex] 累加上 myTotalSwapPss！ oomSwapPss[oomIndex] += myTotalSwapPss; // 创建一个 ArrayList 列表，用于封装进程的内存对象！ if (oomProcs[oomIndex] == null) &#123; oomProcs[oomIndex] = new ArrayList&lt;MemItem&gt;(); &#125; // 将 pssItem 添加爱到该 ArrayList 中去！ oomProcs[oomIndex].add(pssItem); break; &#125; &#125; &#125; &#125; &#125; // 下面这段逻辑很重要，决定了 adb shell dumpsys meminfo --oom 是如何对进程划分的！ if (!isCheckinRequest &amp;&amp; procs.size() &gt; 1 &amp;&amp; !packages) &#123; ... ... ... ... ArrayList&lt;MemItem&gt; oomMems = new ArrayList&lt;MemItem&gt;(); // 遍历 oomPss 数组 for (int j = 0; j &lt; oomPss.length; j++) &#123; if (oomPss[j] != 0) &#123; // 获得 label ，因为 isCompact 为 false，所以为 UMP_MEM_OOM_LABEL[j]！ String label = isCompact ? DUMP_MEM_OOM_COMPACT_LABEL[j] : DUMP_MEM_OOM_LABEL[j]; // 创建总的 MemItem 对象，用于封装每种类型下的进程的信息； // oomPss[j] 表示这个 label 下的总物理内存； // oomSwapPss[j] 表示该 label 下的总交换物理内存； // DUMP_MEM_OOM_ADJ[j] 表示该进程类别的起始 oom adj； MemItem item = new MemItem(label, label, oomPss[j], oomSwapPss[j], DUMP_MEM_OOM_ADJ[j]); // subitems 则用来表示属于该类别的所有进程信息！ item.subitems = oomProcs[j]; oomMems.add(item); &#125; &#125; ... ... ... ... if (!isCompact) &#123; pw.println(\"Total PSS by OOM adjustment:\"); &#125; // 显示出最终的信息！！ dumpMemItems(pw, \" \", \"oom\", oomMems, false, isCompact, dumpSwapPss); ... ... ... ... &#125;&#125; 上面的逻辑是和 Total PSS by OOM adjustment 相关的！ 123456789101112131415161718192021222324252627282930313233343536373839ArrayList&lt;ProcessRecord&gt; collectProcesses(PrintWriter pw, int start, boolean allPkgs, String[] args) &#123; ArrayList&lt;ProcessRecord&gt; procs; synchronized (this) &#123; if (args != null &amp;&amp; args.length &gt; start &amp;&amp; args[start].charAt(0) != '-') &#123; procs = new ArrayList&lt;ProcessRecord&gt;(); int pid = -1; try &#123; pid = Integer.parseInt(args[start]); &#125; catch (NumberFormatException e) &#123; &#125; for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = mLruProcesses.get(i); if (proc.pid == pid) &#123; // 按照 pid 收集； procs.add(proc); &#125; else if (allPkgs &amp;&amp; proc.pkgList != null &amp;&amp; proc.pkgList.containsKey(args[start])) &#123; // 按照 packageName 收集； procs.add(proc); &#125; else if (proc.processName.equals(args[start])) &#123; // 按照 processName 收集！ procs.add(proc); &#125; &#125; if (procs.size() &lt;= 0) &#123; return null; &#125; &#125; else &#123; // 不指定 pid，processName，packageName 的话，就返回 mLruProcesses！ procs = new ArrayList&lt;ProcessRecord&gt;(mLruProcesses); &#125; &#125; return procs;&#125; 其实，我们可以看出 adb shell dumpsys meminfo --oom 没有传入任何参数，所以返回的就是 mLruProcesses 的拷贝！ 3 总结分析了 adb shell dumpsys meminfo –oom 方法的执行流程，我们来总结下，进程的分类： 序号 进程 Label 起始 oom adj 值 1 Native ProcessList.NATIVE_ADJ : -1000 2 System ProcessList.SYSTEM_ADJ : -900 3 Persistent ProcessList.PERSISTENT_PROC_ADJ : -800 4 Persistent Service ProcessList.PERSISTENT_SERVICE_ADJ : -700 5 Foreground ProcessList.FOREGROUND_APP_ADJ : 0 6 Visible ProcessList.VISIBLE_APP_ADJ : 100 7 Perceptible ProcessList.PERCEPTIBLE_APP_ADJ : 200 8 Backup ProcessList.BACKUP_APP_ADJ : 300 9 Heavy Weight ProcessList.HEAVY_WEIGHT_APP_ADJ : 400 10 A Services ProcessList.SERVICE_ADJ : 500 11 Home ProcessList.HOME_APP_ADJ : 600 12 Previous ProcessList.PREVIOUS_APP_ADJ : 700 13 B Services ProcessList.SERVICE_B_ADJ : 800 14 Cached ProcessList.CACHED_APP_MIN_ADJ : 900","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Process进程","slug":"AndroidFramework源码分析/Process进程","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Process进程/"}],"tags":[{"name":"Process进程","slug":"Process进程","permalink":"https://coolqi.top/tags/Process进程/"}]},{"title":"Serivce 篇 4 - bindService 流程分析","slug":"Serivce4-bindService","date":"2016-05-31T12:46:25.000Z","updated":"2018-11-20T16:34:01.000Z","comments":true,"path":"2016/05/31/Serivce4-bindService/","link":"","permalink":"https://coolqi.top/2016/05/31/Serivce4-bindService/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，转载请说明出处！ 0 综述我们在应用中经常会启动 Service： 1context.bindService(intent, mConnection, Service.BIND_AUTO_CREATE); 以前我们只是会调用，但是其底层的调用到底是什么样的呢？知其然知其所以然，今天我们就来学习下 bindService 的过程！ 如果之前并不了解这块逻辑的话，那该如何去学习呢？ follow the funtion path！ 1 绑定者进程1.1 ContextWrapper.bindService123456789101112131415161718192021public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; @Override public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; return mBase.bindService(service, conn, flags); &#125; /** @hide */ @Override public boolean bindServiceAsUser(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; return mBase.bindServiceAsUser(service, conn, flags, user); &#125;&#125; ContextWrapper 提供了两个方法来绑定 Service，其中一个是隐藏方法：bindServiceAsUser！ bindService 的第三个参数 flags 一般都会传 0 或 BIND_AUTO_CREATE，跨进程调用 bindService 会引起组件间的依赖，比如 A 进程的 Activity 中 bindService 调用 B 进程 service，则 B 进程的 service 的 oom_adj 值依赖于 A 进程 Activity 的 oom_adj 值，这个我们后面在说，这些 flags 也可以通过按位或的方式，进行搭配使用！！ 接着来说 flags，这里的 flags 可以取值如下，Android 7.1.1 内置了如下的几个标志位： 标志位 解释 0 无意义 BIND_AUTO_CREATE (0x0001) 绑定服务时候，如果服务尚未创建，服务会自动创建，在 API LEVEL 14 以前的版本不支持这个标志，使用 Context.BIND_WAIVE_PRIORITY 可以达到同样效果 BIND_DEBUG_UNBIND (0x0002) 通常用于 Debug，在 unbindService 时候，会将服务信息保存并打印出来，这个标记很容易造成内存泄漏，应该准备用于 debugging BIND_NOT_FOREGROUND (0x0002) 表示不允许绑定操作将服务所在进程的优先级提升到前台进程优先级 BIND_ABOVE_CLIENT (0x0008) 设置服务的进程优先级高于客户端的优先级，只有当需要服务晚于客户端被销毁这种情况才这样设置。 BIND_ALLOW_OOM_MANAGEMENT (0x0010) 保持服务受默认的服务管理器管理，当内存不足时候，会销毁服务 BIND_WAIVE_PRIORITY (0x0020) 绑定操作不会影响到服务所在进程的优先级 BIND_IMPORTANT (0x0040) 标识服务对客户端是非常重要的，会将服务提升至前台进程优先级，通常情况下，即时客户端是前台优先级，服务最多也只能被提升至可见进程优先级 BIND_ADJUST_WITH_ACTIVITY (0x0080) 如果绑定来自 Activity，服务优先级的提高取决于Activity的进程优先级，使用这个标识后，会无视其他标识 BIND_ALLOW_WHITELIST_MANAGEMENT (0x01000000) BIND_FOREGROUND_SERVICE_WHILE_AWAKE (0x02000000) BIND_FOREGROUND_SERVICE (0x04000000) BIND_TREAT_LIKE_ACTIVITY (0x08000000) BIND_VISIBLE (0x10000000) BIND_SHOWING_UI (0x20000000) 这种绑定方式会让目标服务所在进程显示出 UI 界面，当 UI 界面退出后会触发 UI_HIDDEN 类型的内存回收操作 BIND_NOT_VISIBLE (0x40000000) BIND_EXTERNAL_SERVICE (0x80000000) 1、通过这种方式绑定的服务是属于隔离的外部服务，服务将会被绑定到调用者应用的包内，而不是服务所在的应用包内！2、使用这个标签进行绑定，服务的代码将会在调用者应用的包名和 uid 下执行！因为服务所在的进程是一个隔离进程，隔离进程是不能直接访问应用程序的数据的！ 具体标志位对于 Service 进程有什么影响，请看进程的优先级调度！！！ 这里有一点，对于 BIND_AUTO_CREATE，如果服务没有被创建，会自动创建，而对于其他的 flags，是不会自动创建服务的！所以说我们从 Service 的生命周期的角度来说，可以把这些 flags 分为两大类，自动创建和非自动创建类！！ mBase 是 ContextImpl 对象，继续看！ 1.2 ContextImpl.bindServicemMainThread 是应用进程主线程的 Handler！123456789101112131415161718192021222324252627282930class ContextImpl extends Context &#123; @Override public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle()); &#125; /** @hide */ @Override public boolean bindServiceAsUser(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), user); &#125; /** @hide */ @Override public boolean bindServiceAsUser(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; if (handler == null) &#123; throw new IllegalArgumentException(\"handler must not be null.\"); &#125; return bindServiceCommon(service, conn, flags, handler, user); &#125;&#125; ContextImpl 和 ContextWrapper 的具体关系，请来看另一博文：Android 系统的 Context 分析，这里我们不再详细说明！ mUser：表示的是当前的设备 user！ 最终，调用了 bindServiceCommon 方法； 1.3 ContextImpl.bindServiceCommon12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException(\"connection is null\"); &#125; if (mPackageInfo != null) &#123; // 获得本次连接的 InnerConnection 对象！ sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); &#125; else &#123; throw new RuntimeException(\"Not supported in system context\"); &#125; validateServiceIntent(service); try &#123; // 获得 ActivityClientRecord 对象！ IBinder token = getActivityToken(); // 这里的意思是对于 Android 版本小于 android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH // BIND_AUTO_CREATE 是不使用的，用 BIND_WAIVE_PRIORITY替换！ if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(this); // bind 通信，进入 ActivityManagerService！ int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( \"Not allowed to bind to service \" + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; getActivityToken 方法获得的是 ActivityClientRecord 对象，具体为什么是它，请去看 startActivity 相关的博文！！ 1.3.1 LoadedApk.getServiceDispatchermPackageInfo 是 LoadedApk 类的实例，每一个进程都会有一个，这里调用了 LoadedApk 的 getServiceDispatcher 方法来获得一个 IServiceConnection 类型的对象，这里我们只需要知道，ServiceConnection 是应用进程中的创建的连接对象，ServiceDispatcher 用来托管 ServiceConnection 对象和 ServiceDispatcher.InnerConnection 对象的映射关系，InnerConnection 能够进行 binder 通信！！ 这里会涉及一个集合：12private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices = new ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt;(); 这个是 LoadedApk 的内部实例集合，每一个进程在创建后，都会有一个 LoadedApk 对象， mServices 集合的 key 值为 Context 对象，表示上下文运行环境，大家可以理解为特定的组件，value 是一个 ArrayMap 集合，封装了特定的组件所持有的所有服务连接对象 ServiceConnection 和服务分发对象 ServiceDispatcher！ 1234567891011121314151617181920212223242526272829303132333435public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); // 如果有的话，就直接返回！ if (map != null) &#123; sd = map.get(c); &#125; if (sd == null) &#123; //【1】不然就创建新的 ServiceDispatcher，然后返回，内部会创建 InnerConnection 对象！ sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) &#123; map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mServices.put(context, map); &#125; //【2】添加到对应的 map 集合中！ map.put(c, sd); &#125; else &#123; sd.validate(context, handler); &#125; // 返回 InnerConnection 对象，其继承了 IServiceConnection.Stub！ return sd.getIServiceConnection(); &#125;&#125; 我们来看看 ServiceDispatcher 对象的创建：1234567891011121314ServiceDispatcher(ServiceConnection conn, Context context, Handler activityThread, int flags) &#123; //【1】创建 InnerConnection 对象，用于跨进程调用！ mIServiceConnection = new InnerConnection(this); // 初始化内部 ServiceConnection 对象！ mConnection = conn; mContext = context; mActivityThread = activityThread; mLocation = new ServiceConnectionLeaked(null); mLocation.fillInStackTrace(); mFlags = flags;&#125; 接着再看看 InnerConnection 对象的创建！12345InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; //【1】持有 ServiceDispatcher 的弱引用！ mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);&#125; 这里就看这么多！！ 我们来他通过一张图看看绑定者进程的数据结构之间的关系： 其中，mActiveConnections 表示的是处于活跃中的连接信息，这个我们后面再看！ 接着，调用 ActivityManagerNative.getDefault() 方法，获得 AMS 的代理对象 ActivityManagerProxy，调用代理的 bindService 方法！ 1.5 ActivityManagerP.bindService12345678910111213141516171819202122232425262728293031public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); // 这里的 caller 是 ApplicationThread 对象！ data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeStrongBinder(token); service.writeToParcel(data, 0); data.writeString(resolvedType); // 这里的 connection 是 InnerConnection 对象！ data.writeStrongBinder(connection.asBinder()); data.writeInt(flags); data.writeString(callingPackage); data.writeInt(userId); mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; 通过 binder 进程间通信，进入系统进程，参数分析： IApplicationThread caller：调用者进程的 ApplicationThread 对象，实现了 IApplicationThread 接口； IBinder token：应用端的 mActivityToken； Intent service：启动的 intent String resolvedType：这个 intent 的 MIME 类型； IServiceConnection connection：服务连接对象 InnerConnection； String callingPackage：启动者所属包名； int userId：设备用户 id； 下面会进入系统进程！ 2 系统进程首先要进入 ActivityManagerN.onTransact 方法！1234567891011121314151617181920212223242526272829case BIND_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); //【1】获得 ApplicationThreadProxy 对象！ IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); //【2】Activity 句柄！ IBinder token = data.readStrongBinder(); Intent service = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); b = data.readStrongBinder(); int fl = data.readInt(); String callingPackage = data.readString(); int userId = data.readInt(); //【3】获得 InnerConnection 的代理对象！ IServiceConnection conn = IServiceConnection.Stub.asInterface(b); // 进入 AMS! int res = bindService(app, token, service, resolvedType, conn, fl, callingPackage, userId); reply.writeNoException(); reply.writeInt(res); return true;&#125; 继续看！ 2.1 ActivityManagerS.bindService123456789101112131415161718192021public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"bindService\"); if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; if (callingPackage == null) &#123; throw new IllegalArgumentException(\"callingPackage cannot be null\"); &#125; synchronized(this) &#123; // 进入 ActiveServices 中！！ return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId); &#125;&#125; 2.2 ActiveServices.bindServiceLocked这个方法的逻辑比较长，我们来仔细看看！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String callingPackage, final int userId) throws TransactionTooLargeException &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"bindService: \" + service + \" type=\" + resolvedType + \" conn=\" + connection.asBinder() + \" flags=0x\" + Integer.toHexString(flags)); // 获得调用者进程 ProcessRecord 对象！ final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when binding service \" + service); &#125; // 如果 token 不为 null 的话，就获得其对应的 ActivityRecord 对象！ ActivityRecord activity = null; if (token != null) &#123; activity = ActivityRecord.isInStackLocked(token); if (activity == null) &#123; Slog.w(TAG, \"Binding with unknown activity: \" + token); return 0; &#125; &#125; int clientLabel = 0; PendingIntent clientIntent = null; // 判断是否是系统进程！ final boolean isCallerSystem = callerApp.info.uid == Process.SYSTEM_UID; if (isCallerSystem) &#123; service.setDefusable(true); clientIntent = service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT); if (clientIntent != null) &#123; clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, 0); if (clientLabel != 0) &#123; service = service.cloneFilter(); &#125; &#125; &#125; // 如果设置了 Context.BIND_TREAT_LIKE_ACTIVITY 的标签， // 必须有权限 android.Manifest.permission.MANAGE_ACTIVITY_STACKS； if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, \"BIND_TREAT_LIKE_ACTIVITY\"); &#125; // 非系统进程不能设置 BIND_ALLOW_WHITELIST_MANAGEMENT 的 flags！ if ((flags &amp; Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 &amp;&amp; !isCallerSystem) &#123; throw new SecurityException( \"Non-system caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") set BIND_ALLOW_WHITELIST_MANAGEMENT when binding service \" + service); &#125; // callerFg 表示的是前台调用或者是后台调用！ final boolean callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND; // 表示是否 bind 的是 isolated， external 类型的服务！ final boolean isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != 0; //【1】检索要 bind 的服务信息！ ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg, isBindExternal); if (res == null) &#123; return 0; &#125; if (res.record == null) &#123; return -1; &#125; // 获得服务的信息对象 ServiceRecord！ ServiceRecord s = res.record; boolean permissionsReviewRequired = false; // 如果编译时，指定需要检测权限，那就先要通过权限的检测！ if (Build.PERMISSIONS_REVIEW_REQUIRED) &#123; if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired( s.packageName, s.userId)) &#123; permissionsReviewRequired = true; // 对于前台调用才要校验权限！ if (!callerFg) &#123; Slog.w(TAG, \"u\" + s.userId + \" Binding to a service in package\" + s.packageName + \" requires a permissions review\"); return 0; &#125; final ServiceRecord serviceRecord = s; final Intent serviceIntent = service; // 校验权限后的回调！ RemoteCallback callback = new RemoteCallback( new RemoteCallback.OnResultListener() &#123; @Override public void onResult(Bundle result) &#123; synchronized(mAm) &#123; final long identity = Binder.clearCallingIdentity(); try &#123; if (!mPendingServices.contains(serviceRecord)) &#123; return; &#125; if (!mAm.getPackageManagerInternalLocked() .isPermissionsReviewRequired( serviceRecord.packageName, serviceRecord.userId)) &#123; try &#123; // bringUpServiceLocked(serviceRecord, serviceIntent.getFlags(), callerFg, false, false); &#125; catch (RemoteException e) &#123; /* ignore - local call */ &#125; &#125; else &#123; unbindServiceLocked(connection); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; &#125; &#125; &#125;); // 创建 intent，启动 PackageInstaller，来校验权限！ final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName); intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback); if (DEBUG_PERMISSIONS_REVIEW) &#123; Slog.i(TAG, \"u\" + s.userId + \" Launching permission review for package \" + s.packageName); &#125; mAm.mHandler.post(new Runnable() &#123; @Override public void run() &#123; // 启动权限校验界面！ mAm.mContext.startActivityAsUser(intent, new UserHandle(userId)); &#125; &#125;); &#125; &#125; final long origId = Binder.clearCallingIdentity(); try &#123; //【2】取消服务的重启任务！ if (unscheduleServiceRestartLocked(s, callerApp.info.uid, false)) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"BIND SERVICE WHILE RESTART PENDING: \" + s); &#125; // 如果启动 flags 设置了 Context.BIND_AUTO_CREATE 标签！ if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; // 更新服务的活跃时间！ s.lastActivity = SystemClock.uptimeMillis(); if (!s.hasAutoCreateConnections()) &#123; // 这是第一次 bind，通知服务状态监控器！ ServiceState stracker = s.getTracker(); if (stracker != null) &#123; stracker.setBound(true, mAm.mProcessStats.getMemFactorLocked(), s.lastActivity); &#125; &#125; &#125; mAm.startAssociationLocked(callerApp.uid, callerApp.processName, callerApp.curProcState, s.appInfo.uid, s.name, s.processName); //【3】创建 AppBindRecord 对象，用来记录绑定到这个服务的应用的信息！ // s 是要绑定的 ServiceRecord! AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); // 创建 ConnectionRecord 对象，用来记本次的绑定连接！ ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent); // connection 是一个从应用进程传过来的 InnerConnection 对象！ IBinder binder = connection.asBinder(); // s.connections 记录了这个服务的 IServiceConnection 对象和 ConnectionRecord 对象的对应关系！ ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); s.connections.put(binder, clist); &#125; // 将 ConnectionRecord 保存到 s.connections 中！ clist.add(c); // 将 ConnectionRecord 对象添加到对应的 AppBindRecord 的 connections 中！ b.connections.add(c); // 如果 activity 不为 null，说明是 Activity 执行的 bind，所以要把 ConnectionRecord 添加到其 connections 中; if (activity != null) &#123; if (activity.connections == null) &#123; activity.connections = new HashSet&lt;ConnectionRecord&gt;(); &#125; activity.connections.add(c); &#125; // 将 ConnectionRecord 保存到调用者进程的 connections 列表中！ b.client.connections.add(c); if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.hasAboveClient = true; &#125; if ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) &#123; s.whitelistManager = true; &#125; if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true); &#125; // mServiceConnections 是 AS 的成员变量，记录着 IServiceConnection 和其 ConnectionRecord 的对应关系！ clist = mServiceConnections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); mServiceConnections.put(binder, clist); &#125; clist.add(c); // 如果启动的 flags 设置了 Context.BIND_AUTO_CREATE 标志位，那么就进入这个分支， // 如果服务没有被创建，就会自动创建服务！ if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; // 再次更新服务的活跃时间！ s.lastActivity = SystemClock.uptimeMillis(); //【4】启动该服务，如果服务所在进程未启动，还要启动相应进程，其返回值为 null，说明启动成功！ if (bringUpServiceLocked(s, service.getFlags(), callerFg, false, permissionsReviewRequired) != null) &#123; return 0; &#125; &#125; // 如果服务所在进程的 ProcessRecord 不为 null，就要更新服务的优先级以及 oomAdj 的值！ if (s.app != null) &#123; if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; s.app.treatLikeActivity = true; &#125; if (s.whitelistManager) &#123; s.app.whitelistManager = true; &#125; mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities || s.app.treatLikeActivity, b.client); mAm.updateOomAdjLocked(s.app); &#125; // 【*】接着进入这个分支，这里我们在下面分析： if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bind \" + s + \" with \" + b + \": received=\" + b.intent.received + \" apps=\" + b.intent.apps.size() + \" doRebind=\" + b.intent.doRebind); // 第一次自动创建方式的绑定，两个分支都不进入，多次自动创建方式的绑定，只会进入第二个分支！ if (s.app != null &amp;&amp; b.intent.received) &#123; try &#123; //【5】服务已经在运行中了，那就尝试完成连接，会判断是否已经已有连接 // 如果有，就不会创建连接！ c.conn.connected(s.name, b.intent.binder); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Failure sending service \" + s.shortName + \" to connection \" + c.conn.asBinder() + \" (in \" + c.binding.client.processName + \")\", e); &#125; // If this is the first app connected back to this binding, // and the service had previously asked to be told when // rebound, then do so. // 【6】尝试拉起服务的 onRebind 方法！ if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123; requestServiceBindingLocked(s, b.intent, callerFg, true); &#125; &#125; else if (!b.intent.requested) &#123; // 【7】尝试拉起服务的 onBind 方法！ requestServiceBindingLocked(s, b.intent, callerFg, false); &#125; getServiceMap(s.userId).ensureNotStartingBackground(s); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return 1;&#125; 这个方法的逻辑很长，我们来简单总结一下重点！！ 注意： 对于 Context.BIND_AUTO_CREATE 的方式，bringUpServiceLocked 方法中拉起 onCreate 和 onBind 方法的 Binder 通信是 IBinder.FLAGS_ONEWAY 方式，所以 Binder 服务端系统进程在触发方法后，无需等待，会立即向下执行！ 这里来重点说下最后的分支部分： 这部分内容会涉及到下面的章节！！ 对于 BIND_AUTO_CREATE 的这种 bindService 方式： 第一次绑定时，进入该分支前， received 为 false 而 requested 为 true（requested 是在 bringUpServiceLocked -&gt; requestServiceBindingLocked 被置为 true 的），所以下面 IF 和 ELSE 分支都不会进入！ 多次绑定时，因为第一次绑定连接已经生成，所以 received 和 requested 都会为 true，这里会进入第一个 IF 分支，尝试执行 ServiceConnection.onServiceConnected 方法，因为之前绑定已经存在，就不会执行！！！ 对于非 BIND_AUTO_CREATE 的这种 bindService 方式： 如果服务之前没有启动，那么不管绑定几次，都只是将绑定所数据绑定到相应的集合中，但 received 和 requested 都为 false！，所以会进入第二个 ELSE 分支，尝试拉起 onbind 方法，但是由于服务没有被创建和运行，r.app 和 r.app.thread 都为 null，所以不会继续执行！ 如果服务之前已经被启动了，我们知道对于这种情况，如果之前进行了 bindService 的操作， 因为系统已经保存了绑定信息，所以会立刻拉起服务的 onbind 方法，并执行 ServiceConnection.onServiceConnected 方法！ 如果服务之前已经被启动了，这是我们再执行 bindService 操作： 第一次绑定，进入该分支前， received 和 requested 均为 false（这个第一种情况不同），这样会进入第二个 ELSE 分支，拉起服务的 onBind 方法，并执行 ServiceConnection.onServiceConnected 方法！ 多次绑定，进入该分支前， received 和 requested 均为 true，所以会进入第一个 IF 分支，尝试执行 ServiceConnection.onServiceConnected 方法，因为之前绑定已经存在，就不会执行！！！ 整个流程看起来复杂，但是体现在生命周期上很简单，这里就不说了！！ 然后，我们来看下这个方法中的重点！！ 2.2.1 ActiveServices.retrieveServiceLocked根据 intent 来查询被启动服务的 ServiceRecord 对象，参数传递： boolean createIfNeeded：传入的是 true； boolean callingFromFg：表示是从前台调用，还是后台调用； boolean isBindExternal：表示 bind 的是否是 isolated, external 类型的服务，我们这里默认为 false； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207private ServiceLookupResult retrieveServiceLocked(Intent service, String resolvedType, String callingPackage, int callingPid, int callingUid, int userId, boolean createIfNeeded, boolean callingFromFg, boolean isBindExternal) &#123; // 被绑定的服务！ ServiceRecord r = null; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"retrieveServiceLocked: \" + service + \" type=\" + resolvedType + \" callingUid=\" + callingUid); userId = mAm.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE, \"service\", null); // 从 ActiveServices 的 mServiceMap 中获得设备用户 userId 下的所有服务列表！ ServiceMap smap = getServiceMap(userId); // 如果 intent 有设置组件名，就从 smap.mServicesByName 中获取！ final ComponentName comp = service.getComponent(); if (comp != null) &#123; r = smap.mServicesByName.get(comp); &#125; // 如果 intent 没有设置组件名，就从 smap.mServicesByIntent 通过 filter 获得！ if (r == null &amp;&amp; !isBindExternal) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(service); r = smap.mServicesByIntent.get(filter); &#125; // 对于 external 类型的服务，只能限制其应用程序自己 bind！ if (r != null &amp;&amp; (r.serviceInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 &amp;&amp; !callingPackage.equals(r.packageName)) &#123; r = null; &#125; if (r == null) &#123; try &#123; // 通过 PMS，查询能够匹配 intent 的服务！ ResolveInfo rInfo = AppGlobals.getPackageManager().resolveService(service, resolvedType, ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId); // 获得服务信息！ ServiceInfo sInfo = rInfo != null ? rInfo.serviceInfo : null; if (sInfo == null) &#123; Slog.w(TAG_SERVICE, \"Unable to start service \" + service + \" U=\" + userId + \": not found\"); return null; &#125; ComponentName name = new ComponentName( sInfo.applicationInfo.packageName, sInfo.name); // 如果服务类型是 external 的，那么 bind 时必须加 BIND_EXTERNAL_SERVICE 的标志！ // 不然会抛出安全异常！ if ((sInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) &#123; if (isBindExternal) &#123; if (!sInfo.exported) &#123; // 对于 external 类型的服务，必须要设置 android:exported 的值为 true，不然抛异常！ throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name + \" is not exported\"); &#125; // 对于 external 类型的服务，必须运行在隔离进程中！ if ((sInfo.flags &amp; ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name + \" is not an isolatedProcess\"); &#125; // 获得调用者应用的 ApplicationInfo 信息 ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo( callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId); if (aInfo == null) &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + \"could not resolve client package \" + callingPackage); &#125; sInfo = new ServiceInfo(sInfo); sInfo.applicationInfo = new ApplicationInfo(sInfo.applicationInfo); sInfo.applicationInfo.packageName = aInfo.packageName; sInfo.applicationInfo.uid = aInfo.uid; // 设置 intent 的 ComponentName 对象！ name = new ComponentName(aInfo.packageName, name.getClassName()); service.setComponent(name); &#125; else &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE required for \" + name); &#125; &#125; else if (isBindExternal) &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name + \" is not an externalService\"); &#125; // 处理多用户的情况！ if (userId &gt; 0) &#123; if (mAm.isSingleton(sInfo.processName, sInfo.applicationInfo, sInfo.name, sInfo.flags) &amp;&amp; mAm.isValidSingletonCall(callingUid, sInfo.applicationInfo.uid)) &#123; userId = 0; smap = getServiceMap(0); &#125; sInfo = new ServiceInfo(sInfo); sInfo.applicationInfo = mAm.getAppInfoForUser(sInfo.applicationInfo, userId); &#125; // 根据 ComponentName 获得 ServiceRecord 对象！ r = smap.mServicesByName.get(name); if (r == null &amp;&amp; createIfNeeded) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(service.cloneFilter()); // 创建服务重启对象，这是一个 Runnable 对象！！ ServiceRestarter res = new ServiceRestarter(); BatteryStatsImpl.Uid.Pkg.Serv ss = null; BatteryStatsImpl stats = mAm.mBatteryStatsService.getActiveStatistics(); synchronized (stats) &#123; ss = stats.getServiceStatsLocked( sInfo.applicationInfo.uid, sInfo.packageName, sInfo.name); &#125; // 创建新的 ServiceRecord 对象！ r = new ServiceRecord(mAm, ss, name, filter, sInfo, callingFromFg, res); res.setService(r); // 将新的 ServiceRecord 添加到 smap.mServicesByName 和 smap.mServicesByIntent 中！ smap.mServicesByName.put(name, r); smap.mServicesByIntent.put(filter, r); // 从 mPendingServices 中移除这个 ServiceRecord！ for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord pr = mPendingServices.get(i); if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid &amp;&amp; pr.name.equals(name)) &#123; mPendingServices.remove(i); &#125; &#125; &#125; &#125; catch (RemoteException ex) &#123; // pm is in same process, this will never happen. &#125; &#125; // 下面对查询的数据进行封装！ if (r != null) &#123; if (mAm.checkComponentPermission(r.permission, callingPid, callingUid, r.appInfo.uid, r.exported) != PackageManager.PERMISSION_GRANTED) &#123; // 检查权限如果不授予！ if (!r.exported) &#123; Slog.w(TAG, \"Permission Denial: Accessing service \" + r.name + \" from pid=\" + callingPid + \", uid=\" + callingUid + \" that is not exported from uid \" + r.appInfo.uid); // 异常返回，_record 为 null，无法启动！ return new ServiceLookupResult(null, \"not exported from uid \" + r.appInfo.uid); &#125; Slog.w(TAG, \"Permission Denial: Accessing service \" + r.name + \" from pid=\" + callingPid + \", uid=\" + callingUid + \" requires \" + r.permission); // 异常返回，_record 为 null，无法启动！ return new ServiceLookupResult(null, r.permission); &#125; else if (r.permission != null &amp;&amp; callingPackage != null) &#123; final int opCode = AppOpsManager.permissionToOpCode(r.permission); if (opCode != AppOpsManager.OP_NONE &amp;&amp; mAm.mAppOpsService.noteOperation( opCode, callingUid, callingPackage) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: Accessing service \" + r.name + \" from pid=\" + callingPid + \", uid=\" + callingUid + \" requires appop \" + AppOpsManager.opToName(opCode)); // 异常返回，无法启动！ return null; &#125; &#125; if (!mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid, resolvedType, r.appInfo)) &#123; // 异常返回，无法启动！ return null; &#125; // 返回最终的服务封装类！！ return new ServiceLookupResult(r, null); &#125; return null;&#125; 这个方法的最终目的是返回要启动的服务的信息封装对象 ServiceLookupResult！ 2.2.2 ActiveServices.unscheduleServiceRestartLocked如果服务此时已经在重启列表中了，就要取消这个任务！ 参数传入： boolean force：传入 false12345678910111213141516171819202122232425private final boolean unscheduleServiceRestartLocked(ServiceRecord r, int callingUid, boolean force) &#123; if (!force &amp;&amp; r.restartDelay == 0) &#123; return false; &#125; // Remove from the restarting list; if the service is currently on the // restarting list, or the call is coming from another app, then this // service has become of much more interest so we reset the restart interval. boolean removed = mRestartingServices.remove(r); if (removed || callingUid != r.appInfo.uid) &#123; // 重置重启计数！ r.resetRestartCounter(); &#125; if (removed) &#123; clearRestartingIfNeededLocked(r); &#125; // 从 mAm.mHandler 中移除对一个的 ServiceStarter 对象！ c.removeCallbacks(r.restarter); return true;&#125; 因为当前服务要重新启动，所以之前的重启就要重置！ 2.2.3 ServiceRecord.retrieveAppBindingLocked这里是很关键的一段逻辑，创建了很多的对象，并相互引用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 3、创建 AppBindRecord 对象，用来记录绑定到这个服务的应用的信息！AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);// 创建 ConnectionRecord 对象，用来记录一个连接！ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent);// connection 是一个绑定者进程的 IServiceConnection.proxy 对象，和 InnerConnection 对应！！IBinder binder = connection.asBinder();// s.connections 记录了这个服务的 IServiceConnection 和 ConnectionRecord 的对应关系！ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); s.connections.put(binder, clist);&#125;// 将 ConnectionRecord 保存到 s.connections 中！clist.add(c);// 将 ConnectionRecord 对象添加到对应的 AppBindRecord 的 connections 中！b.connections.add(c);// 如果 activity 不为 null，说明是 Activity 执行的 bind，所以要把// 添加到其 connections 中;if (activity != null) &#123; if (activity.connections == null) &#123; activity.connections = new HashSet&lt;ConnectionRecord&gt;(); &#125; activity.connections.add(c);&#125;// 将 ConnectionRecord 保存到调用者进程的 connections 列表中！b.client.connections.add(c);if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.hasAboveClient = true;&#125;if ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) &#123; s.whitelistManager = true;&#125;if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true);&#125;// mServiceConnections 是 AS 的成员变量，记录着 IServiceConnection 和其 ConnectionRecord 的对应关系！clist = mServiceConnections.get(binder);if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); mServiceConnections.put(binder, clist);&#125;clist.add(c); 这里调用了 ServiceRecord 的 retrieveAppBindingLocked 方法，参数 ProcessRecord app 表示绑定者所在的进程！12345678910111213141516171819202122232425// in ServiceRecordpublic AppBindRecord retrieveAppBindingLocked(Intent intent, ProcessRecord app) &#123; // 首先，创建 FilterComparison 来封装启动 Intent！ // 并获得其对应的 IntentBindRecord 对象，这里可以看到，多次 bindService，只会保存第一次的信息！ Intent.FilterComparison filter = new Intent.FilterComparison(intent); IntentBindRecord i = bindings.get(filter); // 创建对应的 IntentBindRecord 对象，将 FilterComparison 和 IntentBindRecord 的映射保存到 SR.bindings 中！ if (i == null) &#123; i = new IntentBindRecord(this, filter); bindings.put(filter, i); &#125; // 创建 AppBindRecord 对象！ AppBindRecord a = i.apps.get(app); if (a != null) &#123; return a; &#125; a = new AppBindRecord(this, i, app); i.apps.put(app, a); return a;&#125; 这里会创建了一下如下对象 AppBindRecord，用来表示被绑定的 Service 和 bind 它的应用进程 ProcessRecord 的关系！123456final class AppBindRecord &#123; final ServiceRecord service; // 被 bind 的服务！ final IntentBindRecord intent; // IntentBindRecord 对象 final ProcessRecord client; // bind 发起端的进程！ final ArraySet&lt;ConnectionRecord&gt; connections = new ArraySet&lt;&gt;(); // 连接到这个服务的所有 ConnectionRecord！&#125; 以及 IntentBindRecord 对象，用来表示绑定 Service 的 intent 的信息！123456789101112final class IntentBindRecord &#123; final ServiceRecord service; // 被 bind 的服务！ final Intent.FilterComparison intent; // intent 封装类，等价于 intent！ // 用来托管所有使用这个 intent 来绑定服务的进程 ProcessRecord 和其 AppBindRecord 的映射关系！ final ArrayMap&lt;ProcessRecord, AppBindRecord&gt; apps = new ArrayMap&lt;ProcessRecord, AppBindRecord&gt;(); IBinder binder; // 当绑定 Service 成功后，onBind 会返回 Service 的“桩”，而这个 binder 是“桩”的客户端代理！ boolean requested; boolean received; boolean hasBound; boolean doRebind;&#125; 以及 ConnectionRecord 对象，用来表示绑定 Service 的 intent 的信息！！12345678final class ConnectionRecord &#123; final AppBindRecord binding; // AppBindRecord 对象！ final ActivityRecord activity; // bind 服务的 activity final IServiceConnection conn; // 来自 bind 端的 IServiceConnection.proxy 对象！ final int flags; // bindService 的第三个参数！ final PendingIntent clientIntent; // 发送的 intent！ boolean serviceDead; // 表示服务是否死亡！&#125; 除此之外，在 ServiceRecord 中:12345678// 所有活跃的 intent 和其对应的 IntentBindRecord 对象！final ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings = new ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;(); // 所有 IServiceConnection 对象和其对应的 ArrayList&lt;ConnectionRecord&gt;&gt; 列表！ final ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = new ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt;(); // IBinder -&gt; ConnectionRecord of all bound clients 以及在 ActiveServices 中:1final ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; mServiceConnections = new ArrayMap&lt;&gt;(); 这里我们用一张图来看下这几个数据结构间的关系； 可以看到，引用关系很复杂，这也是方便 AMS 在调度时，更快的查询到数据！！ 2.3 AServices.bringUpServiceLocked上面的代码中， 如果 flags 有设置 hasAutoCreateConnections 的话，会进入 bringUpServiceLocked 这个方法，这里和前面的 startService 很类似了，启动服务！ 参数分析： ServiceRecord r：服务的 ServiceRecord 对象； int intentFlags：启动服务的 intent 的 flag，通过 getFlags 获得； boolean execInFg：传入 callFg，表示本次启动是前台调用还是后台调用； boolean whileRestarting：表示是否是正在重启，传入 false； boolean permissionsReviewRequired：是否需要校验权限； 我们这里假设 Service 所在的进程没有启动！ bringUpServiceLocked 的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; // 如果服务所在的进程已经被启动，那就进入 sendServiceArgsLocked 方法， // 但对于 bind，这个方法是不会拉起 onStartCommand 方法的，原因下面说！ // 对于 bindService，如果服务所在进程已经被拉起，条件为 true，这里不会继续往下执行！ if (r.app != null &amp;&amp; r.app.thread != null) &#123; sendServiceArgsLocked(r, execInFg, false); return null; &#125; if (!whileRestarting &amp;&amp; r.restartDelay &gt; 0) &#123; // 如果正在等待重启，就退出！ return null; &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing up \" + r + \" \" + r.intent); // 服务要被启动了，所以要从重启 mRestartingServices 列表中移除它，并清除内部的启动计数！ if (mRestartingServices.remove(r)) &#123; r.resetRestartCounter(); clearRestartingIfNeededLocked(r); &#125; // 如果这个服务是被延迟启动，即 delayed 为 true，那就立刻启动它，从 mDelayedStartList 中移除它，并置 delayed 为 false； if (r.delayed) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"REM FR DELAY LIST (bring up): \" + r); getServiceMap(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; // 如果这个服务所在的设备用户没有被启动，那就不允许启动这个服务！ if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123; String msg = \"Unable to launch app \" + r.appInfo.packageName + \"/\" + r.appInfo.uid + \" for service \" + r.intent.getIntent() + \": user \" + r.userId + \" is stopped\"; Slog.w(TAG, msg); // 执行 bringDown 这个服务！ bringDownServiceLocked(r); return msg; &#125; try &#123; // 服务将要被启动，所以要设置其 package 的停止状态为 false； AppGlobals.getPackageManager().setPackageStoppedState( r.packageName, false, r.userId); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + r.packageName + \": \" + e); &#125; // 判断这个服务是否属于隔离进程； final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; // 获得要启动的服务的所在进程名； final String procName = r.processName; ProcessRecord app; if (!isolated) &#123; // 对于非隔离进程，先获得所在进程的 ProcessRecord 对象； app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (DEBUG_MU) Slog.v(TAG_MU, \"bringUpServiceLocked: appInfo.uid=\" + r.appInfo.uid + \" app=\" + app); if (app != null &amp;&amp; app.thread != null) &#123; // 如果进程已经启动； try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); //【1】启动指定服务！ realStartServiceLocked(r, app, execInFg); return null; &#125; catch (TransactionTooLargeException e) &#123; throw e; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting service \" + r.shortName, e); &#125; &#125; &#125; else &#123; app = r.isolatedProc; &#125; // 如果服务所在的进程没有启动！ if (app == null &amp;&amp; !permissionsReviewRequired) &#123; //【2】首先要启动服务所在的进程，这里请去看进程启动和创建的博文！ if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, \"service\", r.name, false, isolated, false)) == null) &#123; String msg = \"Unable to launch app \" + r.appInfo.packageName + \"/\" + r.appInfo.uid + \" for service \" + r.intent.getIntent() + \": process is bad\"; Slog.w(TAG, msg); bringDownServiceLocked(r); // 进程启动失败； return msg; &#125; // 如果服务要运行在隔离进程中，就把创建的 ProcessRecord 保存到 r.isolatedProc 中！ if (isolated) &#123; r.isolatedProc = app; &#125; &#125; // 将这个服务加入到 mPendingServices 中，表示该服务正在其所在的进程启动； if (!mPendingServices.contains(r)) &#123; mPendingServices.add(r); &#125; if (r.delayedStop) &#123; // 如果服务需要被延迟停止， // Oh and hey we've already been asked to stop! r.delayedStop = false; if (r.startRequested) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Applying delayed stop (in bring up): \" + r); stopServiceLocked(r); &#125; &#125; return null;&#125; 注意 bindService 时候，如果设置了 Context.BIND_AUTO_CREATE 标志，就会调用 bringUpServiceLocked 方法！ 然而对应 bind 来说，是不会执行 sendServiceArgsLocked 方法中的逻辑，不会拉起服务的 onStartCommand 方法的！ 因为只有 start 的方式，才会将启动项目 StartItem 添加到 ServiceRecord 的 pendingStarts 集合中，而对于 bind，pendingStarts 集合的大小始终为 0，所以不会继续执行的！！ 同时，对于 bindService，如果服务所在的进程已经被拉起，那么 bringUpServiceLocked 方法会在 sendServiceArgsLocked 只会返回，不会执行下面的逻辑，而是返回 bindServiceLocked ，继续往下执行！！ 方法流程总结 1、如果已经启动，就会进入 realStartServiceLocked 方法，启动服务！2、如果没有启动，就会 startProcessLocked 先启动服务所在进程，，最后进入 attachApplicationLocked 方法。然后还是会进入 realStartServiceLocked ！ 所以最终调用的是 realStartServiceLocked 方法，它会拉起 Service 的 onCreate、onBind 方法！ 这里我们先假设，服务所在的进程，还没有被启动！！！！ 2.4 ActivityManagerS.attachApplicationLocked当应用进程启动后，会通过 Binder 通信，调用 AMS.attachApplicationLocked，我们去看看：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ... ... ... // 这里会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们不看！ thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); // 更新进程 LRU 队列！ updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); // 每当 bindApplication 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。 startProcessLocked(app, \"bind fail\", processName); return false; &#125; // 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses // 和等待启动的进程集合 mProcessesOnHold 中移除！ mPersistentStartingProcesses.remove(app); mProcessesOnHold.remove(app); boolean badApp = false; boolean didSomething = false; ... ... ... ... if (!badApp) &#123; try &#123; // 检查是否有 service 组件要在这个新进程中运行！ didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown starting services in \" + app, e); badApp = true; &#125; &#125; ... ... ... ... if (badApp) &#123; // badApp 为 true，就杀掉这个进程 app.kill(\"error during init\", true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; // 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！ updateOomAdjLocked(); &#125; return true;&#125; bindApplication 方法会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们不关注！！ 这里会调用 ActiveServices 的 attachApplicationLocked 方法！ 2.5 ActiveServices.attachApplicationLocked当应用进程启动成功，并且 Application 对象已经创建，其 onCreate 方法已经调用后，就要启动指定的服务了！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960boolean attachApplicationLocked(ProcessRecord proc, String processName) throws RemoteException &#123; boolean didSomething = false; // 还记得 mPendingServices 吗？这里面保存着所有正在等待其所在的进程启动的服务！ if (mPendingServices.size() &gt; 0) &#123; ServiceRecord sr = null; try &#123; // 遍历 mPendingServices 集合中的所有服务，启动属于这个进程的所有服务！ for (int i=0; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; continue; &#125; mPendingServices.remove(i); i--; // 将服务的包名，版本号以及 AMS 的进程状态对象保存到进程对象中！ proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode, mAm.mProcessStats); //【1】启动服务，这里又回到了之前的方法中！ realStartServiceLocked(sr, proc, sr.createdFromFg); didSomething = true; if (!isServiceNeeded(sr, false, false)) &#123; bringDownServiceLocked(sr); &#125; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception in new application when starting service \" + sr.shortName, e); throw e; &#125; &#125; // 接着启动那些需要重启的服务，重启的服务都会保存到 mRestartingServices 服务中！ // 因为重启的时间可能还没有到，所以这里并不是立刻启动它们，而是启动了一个任务，交给了 AMS 的 MainHandler 去做！ if (mRestartingServices.size() &gt; 0) &#123; ServiceRecord sr; for (int i=0; i&lt;mRestartingServices.size(); i++) &#123; sr = mRestartingServices.get(i); if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; continue; &#125; mAm.mHandler.removeCallbacks(sr.restarter); mAm.mHandler.post(sr.restarter); &#125; &#125; return didSomething;&#125; 这里最终又回到了 realStartServiceLocked 方法！ 2.6 AS.realStartServiceLocked对于非隔离的进程，最后都会通过调用 realStartServiceLocked 方法来启动进程中的指定服务：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"realStartServiceLocked, ServiceRecord.uid = \" + r.appInfo.uid + \", ProcessRecord.uid = \" + app.uid); // 跟新活跃时间！ r.app = app; r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); // 将被启动服务的 ServiceRecord 对象添加到所属进程的 app.services 中！ // 如果本次启动的是一个新的服务，newService 值为 true！ final boolean newService = app.services.add(r); // 针对 onCreate 方法，设置超时处理！ bumpServiceExecutingLocked(r, execInFg, \"create\"); // 更新 LruProcess 和 OomAdj！ mAm.updateLruProcessLocked(app, false, null); mAm.updateOomAdjLocked(); boolean created = false; try &#123; if (LOG_SERVICE_START_STOP) &#123; // log 相关！ String nameTerm; int lastPeriod = r.shortName.lastIndexOf('.'); nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName; EventLogTags.writeAmCreateService( r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid); &#125; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //【1】通过 binder 通信，拉起服务的 onCreate 方法！ app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); // 启动成功的话，置 created 为 true 方法； created = true; &#125; catch (DeadObjectException e) &#123; Slog.w(TAG, \"Application dead when creating service \" + r); mAm.appDiedLocked(app); // 如果在服务启动时，应用进程死了，调用 appDiedLocked 通知死亡仆告对象！ throw e; &#125; finally &#123; if (!created) &#123; // 如果启动失败，并且不是一个被销毁的服务，那就尝试重启他！ final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); if (newService) &#123; app.services.remove(r); r.app = null; &#125; if (!inDestroying) &#123; scheduleServiceRestartLocked(r, false); &#125; &#125; &#125; if (r.whitelistManager) &#123; app.whitelistManager = true; &#125; //【2】执行 bind 操作，这里会拉起服务的 onBind 方法！！ requestServiceBindingsLocked(r, execInFg); updateServiceClientActivitiesLocked(app, null, true); // 注意 startRequested 只有在 startService 的情况下被置为 true，所以这里是不会添加启动项的！ // 即：r.pendingStarts 的大小为 0！！ if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null)); &#125; // 这里也不会拉起 Service 的 onSrartCommand 方法，原因是 ：r.pendingStarts 的大小为 0，找不到启动项！！ sendServiceArgsLocked(r, execInFg, true); if (r.delayed) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"REM FR DELAY LIST (new proc): \" + r); getServiceMap(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; if (r.delayedStop) &#123; r.delayedStop = false; if (r.startRequested) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Applying delayed stop (from start): \" + r); stopServiceLocked(r); &#125; &#125;&#125; 注意：startRequested 只有在 startService 的情况下被置为 true，所以这里是不会添加启动项的！所以 sendServiceArgsLocked 也不会拉起 Service 的 onSrartCommand 方法，原因是 ：r.pendingStarts 的大小为 0，找不到启动项！！ 这就要进入 requestServiceBindingsLocked 方法了！！！ 2.6.1 ApplicationThreadP.scheduleCreateService这里首先会拉起 Serivce 的 onCreate 方法！1234567891011121314151617181920212223class ApplicationThreadProxy implements IApplicationThread &#123; public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); info.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeInt(processState); try &#123; // 通过 Binder 通信！ mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); &#125; catch (TransactionTooLargeException e) &#123; Log.e(\"CREATE_SERVICE\", \"Binder failure starting service; service=\" + info); throw e; &#125; data.recycle(); &#125;&#125; 进入应用进程，下面再看！！ 2.6.2 ActiveServices.requestServiceBindingsLocked12345678910111213private final void requestServiceBindingsLocked(ServiceRecord r, boolean execInFg) throws TransactionTooLargeException &#123; // 遍历 r.bindings！ for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123; IntentBindRecord ibr = r.bindings.valueAt(i); // 【1】请求 bind 操作，默认 rebind 为 false！ if (!requestServiceBindingLocked(r, ibr, execInFg, false)) &#123; break; &#125; &#125;&#125; 这里会遍历 r.bindings 集合，还记得这个集合吗？这个集合保存这个 bind 的 intent 和 IntentBindRecord 之间的映射关系，只有 bindService 的情况下，该集合才会有元素，startService 的情况下，该集合的 size 为 0，这就解释了 startService 为什么不会执行该方法了！！ 继续来看！！ 2.6.2.1 ActiveServices.requestServiceBindingLocked参数传入： boolean rebind：表示是否重新 bind，这里传入的是 false！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123; if (r.app == null || r.app.thread == null) &#123; // 如果服务没有运行，那就会退出！ return false; &#125; // 这里 i.requested 和 rebind 均为 false， i.apps.size() 也是大于 0 的！ if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; // 为 bind 操作设置超时消息处理！！ bumpServiceExecutingLocked(r, execInFg, \"bind\"); // 将服务所在的进程状态更新为 ActivityManager.PROCESS_STATE_SERVICE！ r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); // 【1】执行 bind 操作，跨进程拉起应用的 onBind 方法！ r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); // 对于 bindService，因为 rebind 为 false，所以这里会把 requested 置为 true！ if (!rebind) &#123; i.requested = true; &#125; // 将 i.hasBound 置为 true，表示已经调用了 i.hasBound = true; i.doRebind = false; &#125; catch (TransactionTooLargeException e) &#123; // Keep the executeNesting count accurate. if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Crashed while binding \" + r, e); final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); throw e; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Crashed while binding \" + r); // Keep the executeNesting count accurate. final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); return false; &#125; &#125; return true;&#125; thread 是 ApplicationThreadProxy 代理对象！！ 2.6.2.2 ApplicationThreadP.scheduleBindService这里的 IBinder token 是 ServiceRecord 对象!!1234567891011121314public final void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); intent.writeToParcel(data, 0); data.writeInt(rebind ? 1 : 0); data.writeInt(processState); // binder 通信！ mRemote.transact(SCHEDULE_BIND_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 可以看到，拉起服务的 onCreate 方法和 onBind 方法的 binder 通信都是 IBinder.FLAG_ONEWAY 的！也就是说 Binder 服务端无需等待 BInder 客户端的操作返回结果，只要 Binder 客户端一收到 Binder服务端传送的命令和数据后，Binder 服务端会立即向下执行！ 下面，进入被绑定者进程！ 3 被绑定者进程3.1 ApplicationThread.scheduleCreateService1234567891011121314public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); // 创建了一个 CreateServiceData 对象！ CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; 这里和 startService 一样，不多说了！ 3.2 ApplicationThread.scheduleBindService12345678910111213141516public final void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) &#123; updateProcessState(processState, false); // 创建了一个 BindServiceData 对象！ BindServiceData s = new BindServiceData(); s.token = token; s.intent = intent; s.rebind = rebind; if (DEBUG_SERVICE) Slog.v(TAG, \"scheduleBindService token=\" + token + \" intent=\" + intent + \" uid=\" + Binder.getCallingUid() + \" pid=\" + Binder.getCallingPid()); sendMessage(H.BIND_SERVICE, s);&#125; 这里创建了一个 BindServiceData 对象！123456789static final class BindServiceData &#123; IBinder token; Intent intent; boolean rebind; public String toString() &#123; return \"BindServiceData&#123;token=\" + token + \" intent=\" + intent + \"&#125;\"; &#125;&#125; 很简单，不多说了！ 接着，发送 H.BIND_SERVICE 方法，进入主线程的 Handler！ 3.3 ActivityThread.H123456789101112131415161718192021222324252627282930313233private class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; // 这里是处理 create service 消息； case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (\"serviceCreate: \" + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; // 这里是处理 bind service 消息； case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceBind\"); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125; Object obj = msg.obj; if (obj instanceof SomeArgs) &#123; ((SomeArgs) obj).recycle(); &#125; if (DEBUG_MESSAGES) Slog.v(TAG, \"&lt;&lt;&lt; done: \" + codeToString(msg.what)); &#125;&#125; 不多说了！！ 3.3.1 ActivityThread.handleCreateService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void handleCreateService(CreateServiceData data) &#123; // 如果此时准备要 GC，那就跳过本次 GC！ unscheduleGcIdler(); // 获得应用程序的加载信息，先会从缓存中获取，找不到才创建； LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; // 通过反射创建要启动的服务的实例； java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( \"Unable to instantiate service \" + data.info.name + \": \" + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); // 创建 Context 对象； ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); // 返回该进程的 Application 对象！ Application app = packageInfo.makeApplication(false, mInstrumentation); // 将服务实例和 context，Application 进行绑定； service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); // 调用了服务的 onCreate 方法； service.onCreate(); // 将创建的服务实例保存到 ActivityThread 的托管集合中！ mServices.put(data.token, service); try &#123; // 通知 AMS，操作完成； ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( \"Unable to create service \" + data.info.name + \": \" + e.toString(), e); &#125; &#125;&#125; 成功地拉起了 Service 的 onCreate 方法！最后有调用了 ActivityManagerNative.getDefault().serviceDoneExecuting，这个和 startService 的流程一样，这里就不多数了！ 3.3.2 ActivityThread.handleBindService123456789101112131415161718192021222324252627282930313233343536373839404142private void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (DEBUG_SERVICE) Slog.v(TAG, \"handleBindService s=\" + s + \" rebind=\" + data.rebind); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; // 如果 rebind 为 false！！ // 调用服务的 onBind 方法，返回值是 Service 的中定义的 “桩”！ IBinder binder = s.onBind(data.intent); // 这里回到了系统进程！ ActivityManagerNative.getDefault().publishService( data.token, data.intent, binder); &#125; else &#123; // 如果 rebind 为 true！！ // 拉起服务的 onRebind 方法！ s.onRebind(data.intent); // 这里回到了系统进程！ ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to bind to service \" + s + \" with \" + data.intent + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; 这里，我们先默认是第一次绑定，rebind 为 false，我们在重写 Service 的 onBind 方法后，会返回一个 Stub 类型的对象，这个是 Service 这边定义的 “桩”，我们继续看！！！！ 3.4 ActivityManagerProxy这里不多说了！ 1234567891011121314151617181920212223242526272829303132333435public void serviceDoneExecuting(IBinder token, int type, int startId, int res) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(token); // 这里的 type 是 SERVICE_DONE_EXECUTING_ANON data.writeInt(type); data.writeInt(startId); data.writeInt(res); mRemote.transact(SERVICE_DONE_EXECUTING_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY); reply.readException(); data.recycle(); reply.recycle();&#125;public void publishService(IBinder token, Intent intent, IBinder service) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(token); intent.writeToParcel(data, 0); data.writeStrongBinder(service); mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 4 系统进程进入 AMS，首先会进入 ActivityManagerN 的 onTransact 方法! 4.1 ActivityManagerN.onTransact123456789101112131415161718192021222324case SERVICE_DONE_EXECUTING_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); int type = data.readInt(); int startId = data.readInt(); int res = data.readInt(); // 进入 AMS! serviceDoneExecuting(token, type, startId, res); reply.writeNoException(); return true;&#125;case PUBLISH_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); Intent intent = Intent.CREATOR.createFromParcel(data); IBinder service = data.readStrongBinder(); // 进入 AMS ! publishService(token, intent, service); reply.writeNoException(); return true;&#125; 4.1.1 ActivityManagerS.serviceDoneExecuting123456789101112131415161718192021222324252627282930313233343536373839404142 public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; Slog.e(TAG, \"serviceDoneExecuting: Invalid service token=\" + token); throw new IllegalArgumentException(\"Invalid service token\"); &#125; mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res); &#125; &#125;``` 最后进入 AS.serviceDoneExecutingLocked 方法！#### 4.1.1.1 ActiveServices.serviceDoneExecutingLocked参数传递：- int type：这里的 type 是 `SERVICE_DONE_EXECUTING_ANON` ```java void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123; boolean inDestroying = mDestroyingServices.contains(r); if (r != null) &#123; if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123; ... ... ... // 不进入，不看 &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123; ... ... ... // 不进入，不看 &#125; final long origId = Binder.clearCallingIdentity(); // 进入 serviceDoneExecutingLocked 方法，看 serviceDoneExecutingLocked(r, inDestroying, inDestroying); Binder.restoreCallingIdentity(origId); &#125; else &#123; Slog.w(TAG, \"Done executing unknown service from pid \" + Binder.getCallingPid()); &#125; &#125; 4.1.2 ActivityManagerS.publishService12345678910111213141516public void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; // 这里不多说了！！ if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException(\"Invalid service token\"); &#125; // 调用 ActiveServices 的 publishServiceLocked 方法！ mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125; 继续看： 4.1.2.1 ActiveServices.publishService12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"PUBLISHING \" + r + \" \" + intent + \": \" + service); if (r != null) &#123; // 尝试找到 intent 对应的 IntentBindRecord 对象! Intent.FilterComparison filter = new Intent.FilterComparison(intent); IntentBindRecord b = r.bindings.get(filter); if (b != null &amp;&amp; !b.received) &#123; // 这里的 received 还是 false! // 将服务的 “桩” 保存到！ b.binder = service; // 将 IntentBindRecord.requested 设为 true！ b.requested = true; // 将 IntentBindRecord.received 设为 true！ b.received = true; for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni); for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); if (!filter.equals(c.binding.intent.intent)) &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Not publishing to: \" + c); if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Bound intent: \" + c.binding.intent.intent); if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Published intent: \" + intent); continue; &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Publishing to: \" + c); try &#123; // 通过 Bind 回调绑定者进程的 ServcieConnection 的 onServiceDisconnected 方法！ // 注意这个方法是非阻塞的，是异步的，因为有 oneway 的标志！！ c.conn.connected(r.name, service); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Failure sending service \" + r.name + \" to connection \" + c.conn.asBinder() + \" (in \" + c.binding.client.processName + \")\", e); &#125; &#125; &#125; &#125; // 接着，调用 serviceDoneExecutingLocked 方法，表示执行完成！ serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 这里会继续通过 Bind 回调绑定者进程的 ServcieConnection 的 onServiceDisconnected 方法！这个方法是非阻塞的，是异步的，因为有 oneway 的标志！！ c.conn 是 IServiceConnection.proxy ，即服务连接代理对象！！！这里，就要回到绑定者进程，我们后面再看！！ 4.1.3 ActivityManagerS.serviceDoneExecutingLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&lt;&lt;&lt; DONE EXECUTING \" + r + \": nesting=\" + r.executeNesting + \", inDestroying=\" + inDestroying + \", app=\" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&lt;&lt;&lt; DONE EXECUTING \" + r.shortName); r.executeNesting--; if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); r.app.execServicesFg = false; r.app.executingServices.remove(r); if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); // 移除 onCreate / onBind 方法的超时处理任务！ mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // Need to re-evaluate whether the app still needs to be in the foreground. for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); mDestroyingServices.remove(r); r.bindings.clear(); &#125; mAm.updateOomAdjLocked(r.app); &#125; r.executeFg = false; if (r.tracker != null) &#123; r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); if (finishing) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; if (finishing) &#123; if (r.app != null &amp;&amp; !r.app.persistent) &#123; r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; &#125; r.app = null; &#125; &#125;&#125; 这里很简单了，就不详细说了！！ 5 绑定者进程下面来看看绑定者进程的 connected 方法的回调问题！！ IServiceConnection.aild 文件中只定义了一个接口： 123456import android.content.ComponentName;/** @hide */oneway interface IServiceConnection &#123; void connected(in ComponentName name, IBinder service);&#125; 可以看到，这个方法是 oneway 类型的，就是说，binder 通信是非阻塞的！ 5.1 InnerConnection.connected进入 LoadedApk 的 InnerConnection 类！123456789101112131415private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; // 接着，调用 ServiceDispatcher 的 connected 方法！ public void connected(ComponentName name, IBinder service) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; sd.connected(name, service); &#125; &#125;&#125; 5.2 ServiceDispatcher.connected12345678910public void connected(ComponentName name, IBinder service) &#123; // 执行一个 RunConnection 的 Runnable！ if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnected(name, service); &#125;&#125; 5.3 ServiceDispatcher.RunConnection参数传递： int command：0；12345678910111213141516171819202122private final class RunConnection implements Runnable &#123; RunConnection(ComponentName name, IBinder service, int command) &#123; mName = name; mService = service; mCommand = command; &#125; public void run() &#123; if (mCommand == 0) &#123; // 执行连接！ doConnected(mName, mService); &#125; else if (mCommand == 1) &#123; doDeath(mName, mService); &#125; &#125; final ComponentName mName; final IBinder mService; final int mCommand;&#125; 继续看： 5.4 ServiceDispatcher.doConnected1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void doConnected(ComponentName name, IBinder service) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; // 当 mForgotten 为 true，表示之前执行了 unBindService 操作！ if (mForgotten) &#123; // We unbound before receiving the connection; ignore // any connection received. return; &#125; // 先尝试获得旧的可用连接，如果已有，就退出！ // 所以说，对于多次 bindService，onServiceConnected 只会执行一次！ old = mActiveConnections.get(name); if (old != null &amp;&amp; old.binder == service) &#123; // Huh, already have this one. Oh well! return; &#125; // service 是被绑定的 Service 的桩对应的代理！ if (service != null) &#123; // 创建一个连接信息对象！ info = new ConnectionInfo(); //将远程 Service 代理保存到 binder 类中！ info.binder = service; // 设置死亡监听器 info.deathMonitor = new DeathMonitor(name, service); try &#123; service.linkToDeath(info.deathMonitor, 0); // 将本次的连接信息保存到 mActiveConnections 中！ mActiveConnections.put(name, info); &#125; catch (RemoteException e) &#123; // This service was dead before we got it... just // don't do anything with it. mActiveConnections.remove(name); return; &#125; &#125; else &#123; // The named service is being disconnected... clean up. mActiveConnections.remove(name); &#125; if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // If there was an old service, it is now disconnected. if (old != null) &#123; mConnection.onServiceDisconnected(name); &#125; // If there is a new service, it is now connected. if (service != null) &#123; // 调用了 Connection 的 onServiceConnected 方法！ mConnection.onServiceConnected(name, service); &#125;&#125; 最后，我们看到，调用了 mConnection.onServiceConnected，这个方法大家很熟悉了，不多说了！ 6 总结6.1 数据结构总结 绑定者进程的数据结构关系图 一个应用进程，只会有一个 InnerConnection 对象！ 系统进程的数据结构关系图 6.2 binder 通信总结6.3 生命周期总结 对于只设置了 BIND_AUTO_CREATE 标志位的情况，只调用 bindService，Service 的周期如下： 服务没有被创建： 1Service.onCreate() -&gt; Service.onBind() -&gt; ServiceConnection.onServiceConnected() 服务已经被创建： 1Service.onBind() -&gt; ServiceConnection.onServiceConnected() 对于没有设置 BIND_AUTO_CREATE 标志，但设置了其他标志的情况，只调用 bindService，Service 的周期如下： 服务没有被创建： 1// 无法实现 bind 操作, 但是会将本次 bind 操作的信息保存到系统进程中！ 服务之前已经被创建（之前通过 startService 启动服务，或者其他组件通过 BIND_AUTO_CREATE 方式绑定拉起）： 1Service.onBind() -&gt; ServiceConnection.onServiceConnected() 服务之后才被创建（之后通过 startService 启动服务，或者其他组件通过 BIND_AUTO_CREATE 方式绑定拉起）： 12345678910 Service.onCreate() -&gt; Service.onBind() (-&gt; Service.onStartCommand) -&gt; ServiceConnection.onServiceConnected() ``` 对于第三中情况，是不是很奇怪？原因很简单，如果服务之前没有被创建，调用 bindService（只设置了其他标志），是不会拉起 Service.onBind 方法的，但是会把本次 bind 的信息保存相应的集合中，当服务被 startService 或者通过 BIND_AUTO_CREATE 方式绑定拉起后，会对之前的 bind 信息处理，返回之前 bind 对应的代理对象！！详情请参考 startService 篇！- 对于多次调用 bindService - 设置了 BIND_AUTO_CREATE 标志！ ```java Service.onCreate()(once) -&gt; Service.onBind()(once) -&gt; ServiceConnection.onServiceConnected()（once） 如果服务已经被创建的话，那 onCreate 方法是不会调用的，直接调用 onBind 方法！ 未设置 BIND_AUTO_CREATE 标志！ 服务没有被启动！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 // 无法实现 bind 操作, 但是会将本次 bind 操作的信息保存到系统进程中，等到服务被 startService 或者其他自动创建类型的 bindService 拉起后才会执行如下周期： Service.onBind(once) -&gt; ServiceConnection.onServiceConnected()(once) ``` - 服务已经被启动！ ```java Service.onBind()(once) -&gt; ServiceConnection.onServiceConnected()(once) ``` 以上就是 bindService 相关的生命周期，有不对的地方，欢迎指正，谢谢！## 6.4 相关 Log 参考```shell07-04 17:24:21.523 1761 4194 V ActiveServices: bindService: Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125; type=null conn=android.os.BinderProxy@abcfcca flags=0x107-04 17:24:21.524 1761 4194 V ActiveServices: retrieveServiceLocked: Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125; type=null callingUid=1010607-04 17:24:21.525 1761 4194 V ActivityManagerService: processName: com.cooqi.servicedemo uid 10106 keepIfLarge false07-04 17:24:21.526 1761 4194 V ActiveServices: Bringing up ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125; android.content.Intent$FilterComparison@7df9497b07-04 17:24:21.526 1761 4194 V ActivityManagerService: processName: com.cooqi.servicedemo uid 10106 keepIfLarge false07-04 17:24:21.527 1761 4194 V ActiveServices_MU: bringUpServiceLocked: appInfo.uid=10106 app=ProcessRecord&#123;39802a4 7994:com.cooqi.servicedemo/u0a106&#125;07-04 17:24:21.527 1761 4194 V ActiveServices_MU: realStartServiceLocked, ServiceRecord.uid = 10106, ProcessRecord.uid = 1010607-04 17:24:21.527 1761 4194 V ActiveServices: &gt;&gt;&gt; EXECUTING create of ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;39802a4 7994:com.cooqi.servicedemo/u0a106&#125;07-04 17:24:21.527 1761 4194 V ActiveServices: bumpServiceExecutingLocked r.executeNesting 007-04 17:24:21.527 1761 4194 V ActiveServices: bumpServiceExecutingLocked r.app.executingServices.size() 107-04 17:24:21.544 1761 4194 D ActivityManagerService: oom: memFactor=0 last=0 allowLow=false numProcs=66 last=6607-04 17:24:21.545 1761 4194 D ActivityManagerService: Did OOM ADJ in 18ms07-04 17:24:21.546 1761 4194 V ActiveServices: &gt;&gt;&gt; EXECUTING bind of ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;39802a4 7994:com.cooqi.servicedemo/u0a106&#125;07-04 17:24:21.547 1761 4194 V ActiveServices: bumpServiceExecutingLocked r.executeNesting 107-04 17:24:21.547 7994 8006 V ActivityThread: SCHEDULE 114 CREATE_SERVICE: 0 / CreateServiceData&#123;token=android.os.BinderProxy@23ffb1d className=com.cooqi.servicedemo.service.AService packageName=com.cooqi.servicedemo intent=null&#125;07-04 17:24:21.547 1761 4194 V ActiveServices: Bind ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125; with AppBindRecord&#123;6e93ab1 com.cooqi.servicedemo/.service.AService:com.cooqi.servicedemo&#125;: received=false apps=1 doRebind=false07-04 17:24:21.548 7994 8006 V ActivityThread: scheduleBindService token=android.os.BinderProxy@23ffb1d intent=Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125; uid=1000 pid=007-04 17:24:21.548 7994 8006 V ActivityThread: SCHEDULE 121 BIND_SERVICE: 0 / BindServiceData&#123;token=android.os.BinderProxy@23ffb1d intent=Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125;&#125;07-04 17:24:21.552 7994 7994 V ActivityThread: &gt;&gt;&gt; handling: CREATE_SERVICE07-04 17:24:21.552 7994 7994 V ActivityThread: Creating service com.cooqi.servicedemo.service.AService07-04 17:24:21.553 7994 7994 D AService: onCreate07-04 17:24:21.553 7994 7994 V ActivityThread: &lt;&lt;&lt; done: CREATE_SERVICE07-04 17:24:21.553 7994 7994 V ActivityThread: &gt;&gt;&gt; handling: BIND_SERVICE07-04 17:24:21.554 7994 7994 V ActivityThread: handleBindService s=com.cooqi.servicedemo.service.AService@92ef192 rebind=false07-04 17:24:21.554 7994 7994 D AService: onBind07-04 17:24:21.554 1761 4106 V ActiveServices: serviceDoneExecutingLocked ServiceRecord= ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125; type= 0 startId= 0 res= 007-04 17:24:21.554 1761 4106 V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=2, inDestroying=false, app=ProcessRecord&#123;39802a4 7994:com.cooqi.servicedemo/u0a106&#125;07-04 17:24:21.555 1761 3764 V ActiveServices: PUBLISHING ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125; Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125;: android.os.BinderProxy@7161b9607-04 17:24:21.556 1761 3764 V ActiveServices: Publishing to: ConnectionRecord&#123;5b95e3b u0 CR com.cooqi.servicedemo/.service.AService:@abcfcca&#125;07-04 17:24:21.556 1761 3764 V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;7454958 u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=1, inDestroying=false, app=ProcessRecord&#123;39802a4 7994:com.cooqi.servicedemo/u0a106&#125;07-04 17:24:21.556 1761 3764 V ActiveServices: Nesting at 0 of com.cooqi.servicedemo/.service.AService07-04 17:24:21.556 1761 3764 V ActiveServices: r.app.executingServices.size(): 007-04 17:24:21.556 1761 3764 V ActiveServices: No more executingServices of com.cooqi.servicedemo/.service.AService07-04 17:24:21.557 7994 7994 V ActivityThread: &lt;&lt;&lt; done: BIND_SERVICE07-04 17:24:21.561 7994 7994 D MainActivity: onServiceConnected http://www.tuicool.com/articles/67zyea","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"Process篇 5 - 进程的 oomAdj 调度算法","slug":"Process5-oomAdjSchedulingAlgorithms","date":"2016-05-15T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/05/15/Process5-oomAdjSchedulingAlgorithms/","link":"","permalink":"https://coolqi.top/2016/05/15/Process5-oomAdjSchedulingAlgorithms/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，总结进程状态调整的调度策略！ 1 进程 oomAdj 的调度方法和进程的 oomAdj 调度相关的主要有`3 个方法： updateOomAdjLocked：用于更新进程的 adj，该方法会依次调用 computeOomAdjLocked 和 applyOomAdjLocked; computeOomAdjLocked：计算进程的 adj，返回计算后 RawAdj 值; applyOomAdjLocked：应用 adj，当需要杀掉目标进程则返回 false；否则返回 true。 当在一些特定的场景下，系统会调用 updateOomAdjLocked 来更新指定进程的 oomAdj，该方法会先调用 computeOomAdjLocked 计算出一个新的 oomAdj，然后在调用 applyOomAdjLocked 来设置指定进程的 oomAdj！ updateOomAdjLocked 有多个重载函数： 123456// 更新指定进程的 oomAdjboolean updateOomAdjLocked(ProcessRecord app) boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now)// 更新所有进程的 oomAdjvoid updateOomAdjLocked() 其中，五个参数的 updateOomAdjLocked 方法是私有方法，只提供给其他的两个方法调用！！ 1boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) 2 调度时机接下里，我们看看 updateOomAdjLocked 的调度时机： 2.1 Activity 调整和 Activity 相关的调整代码主要是位于 ActivityStackSupervisor.java 和 ActivityStack.java 中： 2.1.1 realStartActivityLockedActivityStackSupervisor.realStartActivityLocked：启动 Activity，以下是关键代码段： 1234//【1】将 activity 所在的进程添加到 lru process 列表中！mService.updateLruProcessLocked(app, true, null);//【2】更新所有进程的 oomAdj！mService.updateOomAdjLocked(); 在启动之前会调用 updateOomAdjLocked 更新所有进程的 oomAdj！ 2.1.2 resumeTopActivityInnerLockedActivityStack.resumeTopActivityInnerLocked: 恢复栈顶 Activity，以下是关键代码段： 1234567891011//【1】next 表示的是下一个要被 resume 的 activitynext.state = ActivityState.RESUMED;mResumedActivity = next;next.task.touchActiveTime();mRecentTasks.addLocked(next.task);//【2】更新 lru process 列表！mService.updateLruProcessLocked(next.app, true, null);//【3】更新 lru activity 列表！updateLRUListLocked(next);//【4】更新所有进程的 oomAdj 值mService.updateOomAdjLocked(); 更新所有进程的 oomAdj！ 2.1.3 finishCurrentActivityLockedActivityStack.finishCurrentActivityLocked: 结束 Activity，以下是关键代码段： 123456789101112131415if (mode == FINISH_AFTER_VISIBLE &amp;&amp; (r.visible || r.nowVisible) &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; if (!mStackSupervisor.mStoppingActivities.contains(r)) &#123; addToStopping(r, false /* immediate */); &#125; if (DEBUG_STATES) Slog.v(TAG_STATES, \"Moving to STOPPING: \"+ r + \" (finish requested)\"); // 将 activity 的状态改为 stopping！ r.state = ActivityState.STOPPING; //【1】如果 oomAdj 为 true，那就需要调整所有进程的 `oomAdj` if (oomAdj) &#123; mService.updateOomAdjLocked(); &#125; return r;&#125; 更新所有进程的 oomAdj！ 2.1.4 destroyActivityLockedActivityStack.destroyActivityLocked: 摧毁 Activity，以下是关键代码段： 1234567891011121314151617181920if (hadApp) &#123; if (removeFromApp) &#123; r.app.activities.remove(r); if (mService.mHeavyWeightProcess == r.app &amp;&amp; r.app.activities.size() &lt;= 0) &#123; mService.mHeavyWeightProcess = null; mService.mHandler.sendEmptyMessage( ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG); &#125; //【1】如果被 destroy 的 activity 所在的进程已经没有任何 activity 了，那就需要调整 oomAdj！ if (r.app.activities.isEmpty()) &#123; //【1.1】通知所有的服务，该进程没有任何 activity mService.mServices.updateServiceConnectionActivitiesLocked(r.app); //【1.2】该进程没有了 activity，需要更新 lru list 和 oomAdj 的值！ mService.updateLruProcessLocked(r.app, false, null); //【1.2】更新所有进程的 adj mService.updateOomAdjLocked(); &#125; &#125; ... ... ... ...&#125; 会更新所有进程的 oomAdj！ 2.2 Service 调整和 Service 相关的调整代码主要是位于 ActiveServices.java 中： 2.2.1 realStartServiceLockedActiveServices.realStartServiceLocked: 启动服务，以下是关键代码段： 1234final boolean newService = app.services.add(r);bumpServiceExecutingLocked(r, execInFg, \"create\"); // 设置拉起 onCreate 方法超时处理！mAm.updateLruProcessLocked(app, false, null);mAm.updateOomAdjLocked(); //【1】更新所有进程的 oomAdj 2.2.2 bindServiceLockedActiveServices.bindServiceLocked: 绑定服务，以下是关键代码段： 12345678910111213if (s.app != null) &#123; // 这里的 s.app 表示服务所在的进程！ if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; s.app.treatLikeActivity = true; &#125; if (s.whitelistManager) &#123; s.app.whitelistManager = true; &#125; //【1】当我们 bind 一个服务的时候，该服务的优先级会被提升！ mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities || s.app.treatLikeActivity, b.client); //【2】更新服务所在进程的 oomAdj mAm.updateOomAdjLocked(s.app);&#125; 只更新服务所在进程的 oomAdj! 2.2.3 unbindServiceLockedActiveServices.unbindServiceLocked: 解绑服务，以下是关键代码段： 1234567891011121314if (r.binding.service.app != null) &#123; // r.binding.service.app 在这里表示的是服务所在的进程！ if (r.binding.service.app.whitelistManager) &#123; updateWhitelistManagerLocked(r.binding.service.app); &#125; //【1】当我们 unbind 一个服务的时候，该服务的优先级会被降低！ if ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; r.binding.service.app.treatLikeActivity = true; mAm.updateLruProcessLocked(r.binding.service.app, r.binding.service.app.hasClientActivities || r.binding.service.app.treatLikeActivity, null); &#125; //【2】更新服务所在进程的 oomAdj！ mAm.updateOomAdjLocked(r.binding.service.app);&#125; 只更新服务所在进程的 oomAdj！！ 2.2.4 bringDownServiceLockedActiveServices.bringDownServiceLocked: 结束服务，以下是关键代码段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 当我们要结束一个服务的时候，我们需要接触所有的绑定操作！if (r.app != null &amp;&amp; r.app.thread != null) &#123; for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123; IntentBindRecord ibr = r.bindings.valueAt(i); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing down binding \" + ibr + \": hasBound=\" + ibr.hasBound); // 如果有绑定操作，接触绑定！ if (ibr.hasBound) &#123; try &#123; bumpServiceExecutingLocked(r, false, \"bring down unbind\"); //【1】更新服务所在进程的 oomAdj！ mAm.updateOomAdjLocked(r.app); ibr.hasBound = false; //【2】拉起服务的 onUnBind 方法！ r.app.thread.scheduleUnbindService(r, ibr.intent.getIntent()); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when unbinding service \" + r.shortName, e); serviceProcessGoneLocked(r); &#125; &#125; &#125;&#125;... ... ... ...if (r.app != null) &#123; synchronized (r.stats.getBatteryStats()) &#123; r.stats.stopLaunchedLocked(); &#125; r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; if (r.app.thread != null) &#123; updateServiceForegroundLocked(r.app, false); try &#123; //【1】设置拉起 onDestroy 方法的超时处理！ bumpServiceExecutingLocked(r, false, \"destroy\"); mDestroyingServices.add(r); r.destroying = true; //【2】更新服务所在进程的 oomAdj 值！ mAm.updateOomAdjLocked(r.app); //【3】拉起服务的 onDestroy 服务！ r.app.thread.scheduleStopService(r); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when destroying service \" + r.shortName, e); serviceProcessGoneLocked(r); &#125; &#125; else &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Removed service that has no process: \" + r); &#125;&#125; else &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Removed service that is not running: \" + r);&#125; 只更新服务所在进程的 oomAdj! 2.2.5 sendServiceArgsLockedActiveServices.sendServiceArgsLocked: 发送启动参数，该方法会拉起服务的 onStart 方法，以下是关键代码段： 123456bumpServiceExecutingLocked(r, execInFg, \"start\"); // 设置拉起 onStart 方法超时处理//【1】当 oomAdjusted 为 fasle，才会执行 oomAdj 的更新！if (!oomAdjusted) &#123; oomAdjusted = true; mAm.updateOomAdjLocked(r.app); // 更新服务所在进程的 oomAdj！&#125; sendServiceArgsLocked 在很多地方都有调用： realStartServiceLocked 方法在拉起 onCreate 方法之前，会对所有进程的 oomAdj 做一次调整；接着调用 sendServiceArgsLocked，但是由于其第三个参数 oomAdjusted 传入的是 true，所以不会再次 oomAdj 更新！ cleanUpRemovedTaskLocked 方法是当我们从最近任务中移除一个任务时候，我们会移除该任务所对应的 Service，那么如果 Service 没有设置 ServiceInfo.FLAG_STOP_WITH_TASK 标志位的话，并且如果服务所在进程没有死亡，那么系统会重新拉起服务： 123456789101112131415161718192021for (int i = services.size() - 1; i &gt;= 0; i--) &#123; ServiceRecord sr = services.get(i); if (sr.startRequested) &#123; if ((sr.serviceInfo.flags&amp;ServiceInfo.FLAG_STOP_WITH_TASK) != 0) &#123; Slog.i(TAG, \"Stopping service \" + sr.shortName + \": remove task\"); stopServiceLocked(sr); &#125; else &#123; //【1】创建启动项！ sr.pendingStarts.add(new ServiceRecord.StartItem(sr, true, sr.makeNextStartId(), baseIntent, null)); if (sr.app != null &amp;&amp; sr.app.thread != null) &#123; try &#123; //【2】拉起服务的 onStart 方法！ sendServiceArgsLocked(sr, true, false); &#125; catch (TransactionTooLargeException e) &#123; // Ignore, keep going. &#125; &#125; &#125; &#125;&#125; 这里，第三个参数 oomAdjusted 传入的是 false，所以会发生 oomAdj 更新！ bringUpServiceLocked 方法中如果服务所在进程已经被启动，并且服务的 onCreate 方法已经被拉起，那就会直接 sendServiceArgsLocked 拉起服务的 onStart 方法！ 1234if (r.app != null &amp;&amp; r.app.thread != null) &#123; sendServiceArgsLocked(r, execInFg, false); return null;&#125; 这里，第三个参数 oomAdjusted 也传入的是 false，所以也会发生 oomAdj 更新！ 2.2.6 serviceDoneExecutingLockedActiveServices.serviceDoneExecutingLocked 以下是关键代码段： 12345678910111213141516171819202122232425262728if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); r.app.execServicesFg = false; r.app.executingServices.remove(r); if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // Need to re-evaluate whether the app still needs to be in the foreground. for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); mDestroyingServices.remove(r); r.bindings.clear(); &#125; //【1】更新服务所在进程的 oomAdj！ mAm.updateOomAdjLocked(r.app); &#125; serviceDoneExecutingLocked 方法的调用时机主要是在： 执行启动 Service 等等一些操作时抛出异 服务所在进程死亡时； bind 操作完成后； unbind 操作完成后等等！ 2.2.7 removeConnectionLockedActiveServices.removeConnectionLocked：当我们要移除对一个服务的绑定的时候，会触发该方法，以下是关键代码段： 123456789101112131415161718if (s.app != null &amp;&amp; s.app.thread != null &amp;&amp; b.intent.apps.size() == 0 &amp;&amp; b.intent.hasBound) &#123; try &#123; bumpServiceExecutingLocked(s, false, \"unbind\"); if (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == 0 &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123; mAm.updateLruProcessLocked(s.app, false, null); &#125; //【1】更新进程的 oomAdj 的值！ mAm.updateOomAdjLocked(s.app); b.intent.hasBound = false; b.intent.doRebind = false; s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent()); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when unbinding service \" + s.shortName, e); serviceProcessGoneLocked(s); &#125;&#125; removeConnectionLocked 的调用时机如下： killServicesLocked：当我们要杀掉某个应用进程的时候，我们会解除该进程对其他进程中服务的绑定： 12345// Clean up any connections this application has to other services.for (int i = app.connections.size() - 1; i &gt;= 0; i--) &#123; ConnectionRecord r = app.connections.valueAt(i); removeConnectionLocked(r, app, null);&#125; cleanUpActivityServicesLocked： 123456789if (r.connections != null) &#123; Iterator&lt;ConnectionRecord&gt; it = r.connections.iterator(); while (it.hasNext()) &#123; ConnectionRecord c = it.next(); // 移除该绑定关系！ mService.mServices.removeConnectionLocked(c, null, r); &#125; r.connections = null;&#125; unbindServiceLocked: 当我们要接触绑定某个服务的时候，会调用 removeConnectionLocked，断开连接！ 2.5.8 setServiceForegroundLockedActiveServices.setServiceForegroundLocked：用于将一个服务设置为前台，关键代码段： 123456789101112131415161718192021ServiceRecord r = findServiceLocked(className, token, userId);if (r != null) &#123; if (id != 0) &#123; ... ... ... if (r.app != null) &#123; //【1】设置服务为前台 updateServiceForegroundLocked(r.app, true); &#125; ... ... ... &#125; else &#123; if (r.isForeground) &#123; r.isForeground = false; if (r.app != null) &#123; mAm.updateLruProcessLocked(r.app, false, null); //【2】设置服务为前台 updateServiceForegroundLocked(r.app, true); &#125; &#125; ... ... ... ... &#125;&#125; 在 updateServiceForegroundLocked 方法中，会调用：AMS.updateProcessForegroundLocked 方法： 12345private void updateServiceForegroundLocked(ProcessRecord proc, boolean oomAdj) &#123; ... ... ... ... //【1】更新前台进程的优先级； mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);&#125; AMS.updateProcessForegroundLocked 中会根据第三个参数是否为 true 来设置进程的 oomAdj： 123456789final void updateProcessForegroundLocked(ProcessRecord proc, boolean isForeground, boolean oomAdj) &#123; ... ... ... ... if (oomAdj) &#123; //【1】调整 oomAdj！ updateOomAdjLocked(); &#125; &#125;&#125; 更新所有进程的 oomAdj 的值！ 这里我们来说一下 updateProcessForegroundLocked，我们设置一个服务为前台，实际上是设置其所在的进程为前台进程，updateProcessForegroundLocked 的调用有多处，但只有在 setServiceForegroundLocked 方法的调用链中，boolean oomAdj 为 true！！ 2.3 broadcast 调整和 broadcast 相关的调整代码主要是在 BroadcastQueue.java 中： 2.3.1 processNextBroadcastBroadcastQueue.processNextBroadcast: 发送下一个广播，以下是关键代码段：12345678if (mOrderedBroadcasts.size() == 0) &#123; mService.scheduleAppGcsLocked(); //【1】在处理完最后一个有序广播队列中的广播后，会更新所有进程的 oomAdj！ if (looped) &#123; mService.updateOomAdjLocked(); &#125; return;&#125; 只针对有序发送的广播！ 2.3.2 processCurBroadcastLockedBroadcastQueue.processCurBroadcastLocked: 处理当前广播，以下是关键代码段： 123456789r.receiver = app.thread.asBinder();r.curApp = app;app.curReceiver = r;//【1】更新进程的状态！app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER);//【2】更新 LRU 进程列表！mService.updateLruProcessLocked(app, false, null);//【3】更新所有进程的 oomAdj 值！mService.updateOomAdjLocked(); 只针对有序发送的广播！ 2.3.3 deliverToRegisteredReceiverLockedBroadcastQueue.deliverToRegisteredReceiverLocked: 分发已注册的广播，以下是关键代码段： 12345678910111213if (ordered) &#123; // 只针对有序发送的广播！ r.receiver = filter.receiverList.receiver.asBinder(); r.curFilter = filter; filter.receiverList.curBroadcast = r; r.state = BroadcastRecord.CALL_IN_RECEIVE; if (filter.receiverList.app != null) &#123; //【1】r.curApp 表示要接受该广播的目标进程！ r.curApp = filter.receiverList.app; filter.receiverList.app.curReceiver = r; //【2】更新目标进程的 oomAdj！ mService.updateOomAdjLocked(r.curApp); &#125;&#125; 只针对有序发送的广播，只针对指定的目标进程！ 2.4 ContentProvider 调整和 ContentProvider 相关的调整代码主要是在 ActivityManagerService.java 中： 2.4.1 removeContentProviderXXXActivityManagerService.removeContentProvider: 移除 provider，关键代码段： 12345//【1】如果该 provider 没有其他人在使用，就会返回 true！if (decProviderCountLocked(conn, null, null, stable)) &#123; //【1】更新所有进程的 oomAdj 值！ updateOomAdjLocked();&#125; 更新所有进程的 oomAdj 值！ ActivityManagerService.removeContentProviderExternalUnchecked: 移除 provider，关键代码段： 1234567891011121314//【1】当 contentProvier 有扩展进程的引用，并且引用均被移除，更新所有进程的 oomAdj 值！if (localCpr.hasExternalProcessHandles()) &#123; if (localCpr.removeExternalProcessHandleLocked(token)) &#123; //【1.1】更新所有进程的 oomAdj 值！ updateOomAdjLocked(); &#125; else &#123; Slog.e(TAG, \"Attmpt to remove content provider \" + localCpr + \" with no external reference for token: \" + token + \".\"); &#125;&#125; else &#123; Slog.e(TAG, \"Attmpt to remove content provider: \" + localCpr + \" with no external references.\");&#125; 更新所有进程的 oomAdj 值！ 2.4.2 publishContentProvidersActivityManagerService.publishContentProviders: 发布 provider，关键代码段： 1234567891011121314151617181920212223242526272829final int N = providers.size();for (int i = 0; i &lt; N; i++) &#123; ContentProviderHolder src = providers.get(i); if (src == null || src.info == null || src.provider == null) &#123; continue; &#125; ContentProviderRecord dst = r.pubProviders.get(src.info.name); if (DEBUG_MU) Slog.v(TAG_MU, \"ContentProviderRecord uid = \" + dst.uid); if (dst != null) &#123; ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name); mProviderMap.putProviderByClass(comp, dst); String names[] = dst.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; mProviderMap.putProviderByName(names[j], dst); &#125; ... ... ... ...// 处理 mLaunchingProviders synchronized (dst) &#123; dst.provider = src.provider; dst.proc = r; dst.notifyAll(); &#125; //【1】更新指定进程的 oomAdj！ updateOomAdjLocked(r); maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority); &#125;&#125; 更新指定进程的 oomAdj！ 2.4.3 getContentProviderImplActivityManagerService.getContentProviderImpl: 获取 provider，下面是关键代码段！ 1234... ... ... ...//【1】更新 provider 所在进程的 adj！boolean success = updateOomAdjLocked(cpr.proc);... ... ... ... provider 所在进程的 adj！ 关于 ContentProvider，我会单独开一个系列来分析 2.5 Process 调整和 Process 相关的调整代码主要是在 ActivityManagerService.java 中: 2.5.1 setSystemProcessActivityManagerService.setSystemProcess: 创建并设置系统进程，以下是关键代码段： 12345678910111213141516synchronized (this) &#123; // 创建系统进程对应的 ProcessRecord，并设置其为 persistent 类型的进程！ ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; app.pid = MY_PID; // 设置系统进程的 maxAdj 为 SYSTEM_ADJ！ app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) &#123; mPidsSelfLocked.put(app.pid, app); &#125; // 加入到 lru process 列表中！ updateLruProcessLocked(app, false, null); // 更新所有进程的 adj 值！ updateOomAdjLocked();&#125; 更新所有进程的 adj 值！ 2.5.2 addAppLockedActivityManagerService.addAppLocked: 创建 persistent 进程，以下是关键代码段： 12345678//【1】当该进程第一次或者重新创建时，会更新所有进程的 oomAdj！if (app == null) &#123; app = newProcessRecordLocked(info, null, isolated, 0); //【1.1】更新 lru 进程列表； updateLruProcessLocked(app, false, null); //【1.2】更新进程 oomAdj； updateOomAdjLocked();&#125; 更新所有进程的 oomAdj！ 2.5.3 attachApplicationLockedActivityManagerService.attachApplicationLocked: 进程创建后 attach 到 system_server 的过程，以下是关键代码段： 123456789101112... ... ... ...if (badApp) &#123; app.kill(\"error during init\", true); handleAppDiedLocked(app, false, true); return false;&#125;//【1】didSomething 表示我们在启动进程后是否执行了启动组件的操作// 如果有 didSomething 就为 true，那就不需要在这里更新了，因为组件启动过程会有更新的操作！if (!didSomething) &#123; updateOomAdjLocked();&#125; 更新所有进程的 adj 值！ 2.5.4 trimApplicationsActivityManagerService.trimApplications: 回收应用程序内存，以下是关键代码段： 1234567891011121314151617181920212223// 处理所有要被移除的进程，回收资源！for (i = mRemovedProcesses.size() - 1; i &gt;= 0; i --) &#123; final ProcessRecord app = mRemovedProcesses.get(i); if (app.activities.size() == 0 &amp;&amp; app.curReceiver == null &amp;&amp; app.services.size() == 0) &#123; if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; app.kill(\"empty\", false); &#125; else &#123; try &#123; app.thread.scheduleExit(); &#125; catch (Exception e) &#123; &#125; &#125; cleanUpApplicationRecordLocked(app, false, true, -1, false /*replacingPid*/); mRemovedProcesses.remove(i); //【1】如果该进程是 persistent，那就要 addAppLocked！ if (app.persistent) &#123; addAppLocked(app.info, false, null /* ABI override */); &#125; &#125;&#125;//【2】更新所有进程的 oomAdj！updateOomAdjLocked(); 更新所有进程的 oomAdj！ 2.5.5 appDiedLockedActivityManagerService.appDiedLocked：进程死亡，以下是关键代码段： 1234567891011121314151617181920212223242526272829// 表示进程被重启了！if (app.pid == pid &amp;&amp; app.thread != null &amp;&amp; app.thread.asBinder() == thread.asBinder()) &#123; boolean doLowMem = app.instrumentationClass == null; boolean doOomAdj = doLowMem; if (!app.killedByAm) &#123; Slog.i(TAG, \"Process \" + app.processName + \" (pid \" + pid + \") has died\"); mAllowLowerMemLevel = true; &#125; else &#123; // Note that we always want to do oom adj to update our state with the // new number of procs. mAllowLowerMemLevel = false; doLowMem = false; &#125; EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName); if (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP, \"Dying app: \" + app + \", pid: \" + pid + \", thread: \" + thread.asBinder()); handleAppDiedLocked(app, false, true); if (doOomAdj) &#123; //【1】更新所有进程的 oomAdj！ updateOomAdjLocked(); &#125; if (doLowMem) &#123; doLowMemReportIfNeededLocked(app); &#125; &#125; else if (app.pid != pid) &#123; &#125; 更新所有进程的 oomAdj！ 2.5.6 killAllBackgroundProcessesActivityManagerService.killAllBackgroundProcesses: 杀死所有后台进程，以下是关键代码段： 123456789101112131415161718192021222324252627282930313233synchronized (this) &#123; final ArrayList&lt;ProcessRecord&gt; procs = new ArrayList&lt;&gt;(); final int NP = mProcessNames.getMap().size(); for (int ip = 0; ip &lt; NP; ip++) &#123; final SparseArray&lt;ProcessRecord&gt; apps = mProcessNames.getMap().valueAt(ip); final int NA = apps.size(); for (int ia = 0; ia &lt; NA; ia++) &#123; final ProcessRecord app = apps.valueAt(ia); //【1】跳过 persistent 进程！ if (app.persistent) &#123; continue; &#125; //【2】杀死 removed 为 ture 的进程 if (app.removed) &#123; procs.add(app); //【3】杀死 adj &gt;= CACHED_APP_MIN_ADJ 的进程！ &#125; else if (app.setAdj &gt;= ProcessList.CACHED_APP_MIN_ADJ) &#123; app.removed = true; procs.add(app); &#125; &#125; &#125; //【4】杀死上述两种进程！ final int N = procs.size(); for (int i = 0; i &lt; N; i++) &#123; removeProcessLocked(procs.get(i), false, true, \"kill all background\"); &#125; mAllowLowerMemLevel = true; //【5】更新了所有进程 updateOomAdjLocked(); doLowMemReportIfNeededLocked(null);&#125; 继续分析！ 2.5.7 killPackageProcessesLockedActivityManagerService.killPackageProcessesLocked: 杀掉指定包名相关的进程，以下是关键代码段： 1234567... ... ...// 收集需要被杀掉的进程，这里就列出了！int N = procs.size();for (int i=0; i&lt;N; i++) &#123; removeProcessLocked(procs.get(i), callerWillRestart, allowRestart, reason);&#125;// 调整所有进程的 oomAdj！updateOomAdjLocked(); 调整所有进程的 oomAdj！ 2.5.8 setProcessForegroundActivityManagerService.setProcessForeground：设置进程为前台进程，下面是关键代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142// 这里的 isForeground 是 setProcessForeground 的参数，表示是否为前台进程！synchronized (mPidsSelfLocked) &#123; // 获得 pid 对应的进程！ ProcessRecord pr = mPidsSelfLocked.get(pid); if (pr == null &amp;&amp; isForeground) &#123; Slog.w(TAG, \"setProcessForeground called on unknown pid: \" + pid); return; &#125; // 获得该进程对应的前台 token，如果不为 null，说明该进程已经是前台进程 // 那就要先移除旧的 token！ ForegroundToken oldToken = mForegroundProcesses.get(pid); if (oldToken != null) &#123; oldToken.token.unlinkToDeath(oldToken, 0); // 解除绑定死亡仆告对象！ mForegroundProcesses.remove(pid); if (pr != null) &#123; pr.forcingToForeground = null; &#125; changed = true; &#125; // 如果 isForeground 为 true，且 token 不为 null，这里的 if (isForeground &amp;&amp; token != null) &#123; ForegroundToken newToken = new ForegroundToken() &#123; @Override public void binderDied() &#123; foregroundTokenDied(this); // 当 binder 对象死亡后，该方法会被调用！ &#125; &#125;; newToken.pid = pid; // 设置 newToken 的 pid 和 token！ newToken.token = token; try &#123; token.linkToDeath(newToken, 0); // 给 token 绑定死亡仆告对象！ mForegroundProcesses.put(pid, newToken); // 将该进程加入到 mForegroundProcesses 列表中！ pr.forcingToForeground = token; changed = true; &#125; catch (RemoteException e) &#123; &#125; &#125;&#125;if (changed) &#123; // 当我们设置了一个进程为前台进程，我们需要更新所有进程的 oomAdj！ updateOomAdjLocked();&#125; 调整所有进程的 oomAdj！ 首先我说下 ForegroundToken，表示一个前台句柄，其内部有一个 token 对象，该对象是一个 Binder 对象！当我们设置了一个进程为前台进程后，每个进程都会有一个 token 对象！ 其使用场景是，弹出 Toast，当一个进程中会弹出 Toast 后，该进程会被设置为前台进程，就会触发 setProcessForeground 方法！token 对象定义是在 NotificationManagerService 中： 1final IBinder mForegroundToken = new Binder(); 再说一下：ForegroundToken.binderDied 方法，当 token 死亡后，其会被调用，从而触发 foregroundTokenDied! 123456789101112131415161718192021void foregroundTokenDied(ForegroundToken token) &#123; synchronized (ActivityManagerService.this) &#123; synchronized (mPidsSelfLocked) &#123; ForegroundToken cur = mForegroundProcesses.get(token.pid); if (cur != token) &#123; return; &#125; mForegroundProcesses.remove(token.pid); ProcessRecord pr = mPidsSelfLocked.get(token.pid); if (pr == null) &#123; return; &#125; pr.forcingToForeground = null; // 更新前台进程信息！ updateProcessForegroundLocked(pr, false, false); &#125; // 更新进程的 oomAdj updateOomAdjLocked(); &#125;&#125; 调整所有进程的 oomAdj！ 2.5.9 setHasTopUiActivityManagerService.setHasTopUi：设置进程是否具有 top ui！ 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void setHasTopUi(boolean hasTopUi) throws RemoteException &#123; // 检查 permission.INTERNAL_SYSTEM_WINDOW 权限！ if (checkCallingPermission(permission.INTERNAL_SYSTEM_WINDOW) != PERMISSION_GRANTED) &#123; throw new SecurityException(msg); &#125; final int pid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); try &#123; synchronized (this) &#123; boolean changed = false; // 获得 pid 对应的进程！ ProcessRecord pr; synchronized (mPidsSelfLocked) &#123; pr = mPidsSelfLocked.get(pid); if (pr == null) &#123; Slog.w(TAG, \"setHasTopUi called on unknown pid: \" + pid); return; &#125; // 判断进程的 hasTopUi 是否发生变化！ if (pr.hasTopUi != hasTopUi) &#123; Slog.i(TAG, \"Setting hasTopUi=\" + hasTopUi + \" for pid=\" + pid); pr.hasTopUi = hasTopUi; changed = true; &#125; &#125; // 发生了变化，那就更新该进程的 oomAdj！ if (changed) &#123; updateOomAdjLocked(pr); &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 只更新特定进程的 oomAdj！ 该方法主要是在状态栏使用，具体的代码在 StatusBarWindowManager.apply 方法中，以下是关键代码！ 1234567891011private void apply(State state) &#123; ... ... ... if (mHasTopUi != mHasTopUiChanged) &#123; try &#123; mActivityManager.setHasTopUi(mHasTopUiChanged); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"Failed to call setHasTopUi\", e); &#125; mHasTopUi = mHasTopUiChanged; &#125;&#125; 2.5.10 updateSleepIfNeededLockedActivityManagerService.updateSleepIfNeededLocked：更新睡眠状态！ 123456789101112131415161718192021222324252627void updateSleepIfNeededLocked() &#123; if (mSleeping &amp;&amp; !shouldSleepLocked()) &#123; // 退出休眠时！ mSleeping = false; startTimeTrackingFocusedActivityLocked(); mTopProcessState = ActivityManager.PROCESS_STATE_TOP; mStackSupervisor.comeOutOfSleepIfNeededLocked(); // 更新服务的 oomAdj！ updateOomAdjLocked(); &#125; else if (!mSleeping &amp;&amp; shouldSleepLocked()) &#123; // 进入休眠时！ mSleeping = true; if (mCurAppTimeTracker != null) &#123; mCurAppTimeTracker.stop(); &#125; mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING; mStackSupervisor.goingToSleepLocked(); // 更新服务的 oomAdj！ updateOomAdjLocked(); // Initialize the wake times of all processes. checkExcessivePowerUsageLocked(false); mHandler.removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG); Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG); mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY); &#125;&#125; 更新所有服务的 oomAdj！ 2.6 总结下面我用思维导图总结下，updateOomAdjLocked 的调用时机，当然了，随着版本的更替，代码逻辑和调用机制势必会发生变化，但是，已有的架构和逻辑依然具有很强的参考性，也能帮助我们在新的版本上快速建立代价整体结构的认识！！ 3 oomAdj 算法分析接下来，我们就要分析下 oomAdj 调度的核心算法了，我们从 updateOomAdjLocked 方法入手，我们先从最简单的一参函数看起： 3.1 [1]ActivityManagerS.updateOomAdjLocked - 更新指定进程 oomAdj123456789101112131415161718192021222324252627final boolean updateOomAdjLocked(ProcessRecord app) &#123; // 获得 top activity 以及其所在的进程 top process！ final ActivityRecord TOP_ACT = resumedAppLocked(); final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null; // 该进程是否是缓存进程！ final boolean wasCached = app.cached; mAdjSeq++; // adj 序列计数加 1 //【1】计算 cahce 状态的 adj // 如果我们知道，我们的目标进程是处于缓存状态，那么我们返回 app.curRawAdj，否则 // 我们不能确定其 adj 的值，设置其为 UNKNOWN_ADJ final int cachedAdj = app.curRawAdj &gt;= ProcessList.CACHED_APP_MIN_ADJ ? app.curRawAdj : ProcessList.UNKNOWN_ADJ; //【2】更新指定进程的 oomAdj 的值，调用 5 个参数的 updateOomAdjLocked 方法，具体见[3.2]； boolean success = updateOomAdjLocked(app, cachedAdj, TOP_APP, false, SystemClock.uptimeMillis()); //【3】如果进程的从非缓存状态变为了缓存状态，或者相反，我们也要更新 lru 列表中其他进程的 adj！ if (wasCached != app.cached || app.curRawAdj == ProcessList.UNKNOWN_ADJ) &#123; updateOomAdjLocked(); &#125; return success;&#125; 更新指定进程的 oomAdj，被更新的进程的 app.adjSeq 值会等于 mAdjSeq，这个我们后续再看！ 对于 cachedAdj 的取值范围： 12static final int UNKNOWN_ADJ = 1001;static final int CACHED_APP_MIN_ADJ = 900; 该方法主要功能： 执行五参 updateOomAdjLocked，更新指定进程的 adj； 当 app 经过更新 adj 操作后，其 cached 状态改变，或者 curRawAdj=UNKNOWN_ADJ，则执行空参 updateOomAdjLocked，更新所有进程的adj； 继续来看： 3.1.1 ActivityManagerS.resumedAppLocked12345678910111213141516171819202122232425262728293031323334private final ActivityRecord resumedAppLocked() &#123; // 获得当前的 top activity！ ActivityRecord act = mStackSupervisor.resumedAppLocked(); String pkg; int uid; // 获得 top activity 的 uid 和 package！ if (act != null) &#123; pkg = act.packageName; uid = act.info.applicationInfo.uid; &#125; else &#123; pkg = null; uid = -1; &#125; // Has the UID or resumed package name changed? // 更新一下 mCurResumedUid 和 mCurResumedPackage if (uid != mCurResumedUid || (pkg != mCurResumedPackage &amp;&amp; (pkg == null || !pkg.equals(mCurResumedPackage)))) &#123; if (mCurResumedPackage != null) &#123; mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_FINISH, mCurResumedPackage, mCurResumedUid); &#125; mCurResumedPackage = pkg; mCurResumedUid = uid; // 当前的 current resume pacakge 发生了变化，通知 BatteryStats if (mCurResumedPackage != null) &#123; mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_START, mCurResumedPackage, mCurResumedUid); &#125; &#125; return act;&#125; 3.1.1.1 ActivityStackSupervisor.resumedAppLocked12345678910111213141516ActivityRecord resumedAppLocked() &#123; //【1】获得焦点 stack! ActivityStack stack = mFocusedStack; if (stack == null) &#123; return null; &#125; //【2】获得 resume activity！ ActivityRecord resumedActivity = stack.mResumedActivity; if (resumedActivity == null || resumedActivity.app == null) &#123; resumedActivity = stack.mPausingActivity; if (resumedActivity == null || resumedActivity.app == null) &#123; resumedActivity = stack.topRunningActivityLocked(); &#125; &#125; return resumedActivity;&#125; 这里我们可以看到 resumedActivity 的获取逻辑！ 首先会焦点 stack 获取 mResumedActivity; 如果 resumedActivity 不存在，那就获取 mPausingActivity; 如果 mPausingActivity 不存在，那就获取 top activity！ 3.3 [0]ActivityManagerS.updateOomAdjLocked - 更新 LRU 列表中的所有进程刚才我们看了 updateOomAdjLocked 的一参和多参数方法，用来更新指定的进程的 adj，到那时如果该进程的状态在 cache 和非 cache 之前切换了，那就会更新所有进程的 adj 状态！ 这个是最核心的一个方法，方法体很长，我们耐心点来看！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561final void updateOomAdjLocked() &#123; //【1】获取 top Activity 以及其所在的 top process! final ActivityRecord TOP_ACT = resumedAppLocked(); final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null; final long now = SystemClock.uptimeMillis(); final long nowElapsed = SystemClock.elapsedRealtime(); // MAX_EMPTY_TIME 表示空进程的存活时长，为 30min！ final long oldTime = now - ProcessList.MAX_EMPTY_TIME; //【2】获得 LRU 进程列表的大小！ final int N = mLruProcesses.size(); if (false) &#123; RuntimeException e = new RuntimeException(); e.fillInStackTrace(); Slog.i(TAG, \"updateOomAdj: top=\" + TOP_ACT, e); &#125; //【3】重置当前所有 active uid 内部记录的进程状态：ActivityManager.PROCESS_STATE_CACHED_EMPTY：16 for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123; final UidRecord uidRec = mActiveUids.valueAt(i); if (false &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, \"Starting update of \" + uidRec); uidRec.reset(); &#125; //【4】给所有的 task 排序，更新 task 的 mLayerRank 变量！ mStackSupervisor.rankTaskLayersIfNeeded(); mAdjSeq++; // 更新本次计算序列号 +1 mNewNumServiceProcs = 0; // 表示最新的服务进程数（更新 adj 后）； mNewNumAServiceProcs = 0; // 表示最新的 A service 进程数（更新 adj 后）； //【5】根据系统空进程和缓存进程的总限制量，计算空进程和缓存进程限制数！！ final int emptyProcessLimit; final int cachedProcessLimit; if (mProcessLimit &lt;= 0) &#123; emptyProcessLimit = cachedProcessLimit = 0; &#125; else if (mProcessLimit == 1) &#123; emptyProcessLimit = 1; cachedProcessLimit = 0; &#125; else &#123; // 调用 ProcessList.computeEmptyProcessLimit 计算空进程限制数，计算方法为：totalProcessLimit(参数) / 2 emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit); // 可以得到： // 缓存进程限制数 = 空进程限制数 = 总进程限制数 / 2； cachedProcessLimit = mProcessLimit - emptyProcessLimit; &#125; // CACHED_APP_MAX_ADJ 为 906，而 CACHED_APP_MIN_ADJ 为 900，所以计算出的 numSlots 为 3 // 就是说，我们将 cache adj 划分为 3 个范围，每个范围可以容纳定量的 empty 和 cache 进程！ int numSlots = (ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2; // 计算当前空进程的数量：等于所有进程数 N - 非 cache 进程数 - 被隐藏的 cache 进程数！ int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs; if (numEmptyProcs &gt; cachedProcessLimit) &#123; // 空进程的数量不能超过缓存进程限制数，最大只能和其相等，这是一定的！ numEmptyProcs = cachedProcessLimit; &#125; // 计算空进程分配因子（每个 slot 可以容纳的空进程数量），最高为 1； int emptyFactor = numEmptyProcs / numSlots; if (emptyFactor &lt; 1) emptyFactor = 1; // 计算缓存进程分配因子（计算出每个 slot 中，可容纳后台进程的数量），最高为 1； int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1) / numSlots; if (cachedFactor &lt; 1) cachedFactor = 1; int stepCached = 0; int stepEmpty = 0; int numCached = 0; int numEmpty = 0; int numTrimming = 0; mNumNonCachedProcs = 0; // 用于记录非 cache/empty 进程数，初始化为 0； mNumCachedHiddenProcs = 0; // 用于记录 cache 进程数，初四化为 0； // 用于为 cache 进程和 empty 进程分配 adj！ int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ; // 900； int nextCachedAdj = curCachedAdj + 1; int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ; // 900； int nextEmptyAdj = curEmptyAdj + 2; //【8】逆序遍历 mLruProcesses 进程列表，更新每一个进程的 adj！ for (int i=N-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); if (!app.killedByAm &amp;&amp; app.thread != null) &#123; app.procStateChanged = false; //【8.1】这里调用了 5 个参数的 computeOomAdjLocked 方法，更新指定的进程的 adj // 注意这里的 doingAll 参数传入的是 true，具体分析见 3.3.1 节! computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now); // 如果计算后，仍然没有分配给进程一个合适的 adj，即：app.curAdj &gt;= ProcessList.UNKNOWN_ADJ // 那就在这里分配！ // （computeOomAdjLocked 可能无法计算 cache 进程和 empty 进程的 adj，所以在下面处理！） if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123; // 根据进程的状态进行处理： switch (app.curProcState) &#123; case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY: case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT: // 如果进程是持有 activity 的 cache 进程，或者 // 给其分配一个 cache adj！ // 从 900 到 906，逐个分配，最大不超过 906！ app.curRawAdj = curCachedAdj; app.curAdj = app.modifyRawOomAdj(curCachedAdj); // 此时是单纯的加 1； if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, \"Assigning activity LRU #\" + i + \" adj: \" + app.curAdj + \" (curCachedAdj=\" + curCachedAdj + \")\"); if (curCachedAdj != nextCachedAdj) &#123; stepCached++; if (stepCached &gt;= cachedFactor) &#123; // 判断是否到达分配因子！ stepCached = 0; // stepCached 置为 0，进行下一个 slot 的分配！ curCachedAdj = nextCachedAdj; nextCachedAdj += 2; if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123; // 控制 adj 的不超过最大值！ nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ; &#125; &#125; &#125; break; default: // 否则，将其视为 empty 进程对待，给其分配一个 empty adj！ // 从 900 到 906，逐个分配，最大不超过 906！ app.curRawAdj = curEmptyAdj; app.curAdj = app.modifyRawOomAdj(curEmptyAdj); if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, \"Assigning empty LRU #\" + i + \" adj: \" + app.curAdj + \" (curEmptyAdj=\" + curEmptyAdj + \")\"); if (curEmptyAdj != nextEmptyAdj) &#123; stepEmpty++; if (stepEmpty &gt;= emptyFactor) &#123; stepEmpty = 0; curEmptyAdj = nextEmptyAdj; nextEmptyAdj += 2; if (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123; nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ; &#125; &#125; &#125; break; &#125; &#125; //【8.2】分配好后，调用 applyOomAdjLocked 更新进程的 adj，具体分析见 3.3.2 节! applyOomAdjLocked(app, true, now, nowElapsed); //【8.3】根据进程的类型，统计不同类型的进程数量! switch (app.curProcState) &#123; case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY: case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT: // 如果进程是持有 activity 的 cache 进程或者是客户端进程， // 属于 cache 进程，mNumCachedHiddenProcs 加 1! mNumCachedHiddenProcs++; numCached++; // 注意，如果当前 cache 进程数量超过了限制量，那就杀掉超过限制的所有进程！ // 但是依然统计数量！ if (numCached &gt; cachedProcessLimit) &#123; app.kill(\"cached #\" + numCached, true); &#125; break; case ActivityManager.PROCESS_STATE_CACHED_EMPTY: // 如果进程是 empty cache 进程，下面的处理！ if (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS &amp;&amp; app.lastActivityTime &lt; oldTime) &#123; // 如果空进程的数量超过了空进程上限数，且该空进程的空闲时间超过了 30 min // 那就杀掉该进程！ app.kill(\"empty for \" + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + \"s\", true); &#125; else &#123; // 否则，numEmpty 加 1，如果此时空进程数超过了空进程限制数，杀掉该进程！ // 但是依然统计数量！ numEmpty++; if (numEmpty &gt; emptyProcessLimit) &#123; app.kill(\"empty #\" + numEmpty, true); &#125; &#125; break; default: // 其他类型，默认属于非 cache/empty 进程，mNumNonCachedProcs 加 1； mNumNonCachedProcs++; break; &#125; //【8.4】进一步处理进程的状态！ if (app.isolated &amp;&amp; app.services.size() &lt;= 0) &#123; // 如果这是一个隔离进程，且内部不再运行任何服务，kill 该进程！ app.kill(\"isolated not needed\", true); &#125; else &#123; // 否则，保留该进程，更新其对应的 uid 中记录的进程状态！ final UidRecord uidRec = app.uidRecord; if (uidRec != null &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123; uidRec.curProcState = app.curProcState; &#125; &#125; //【8.5】进一步处理进程的状态！ if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME &amp;&amp; !app.killedByAm) &#123; // 记录需要回收内存的，进程状态优先级不高于 PROCESS_STATE_HOME 的后台进程数量！ // PROCESS_STATE_HOME 表示持有 Home 的后台进程的状态！ numTrimming++; &#125; &#125; &#125; //【9】mNewNumServiceProcs 用于保存更新 adj 后，最新的服务进程数，更新 mNumServiceProcs！ mNumServiceProcs = mNewNumServiceProcs; //【10】计算统计到的 cache 和 empty 进程总数！ final int numCachedAndEmpty = numCached + numEmpty; //【11】根据统计的 cache 和 empty 进程总数，计算内存回收等级，用于内存回收！ int memFactor; // TRIM_CACHED_APPS 表示触发内存回收的 cache 进程上限： 5； // TRIM_EMPTY_APPS 表示触发内存回收的 empty 进程上限：16； if (numCached &lt;= ProcessList.TRIM_CACHED_APPS &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) &#123; if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) &#123; // 个数为 3； // 总数小于 3 时，内存回收等级为 critical，取值为 3！ memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL; &#125; else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) &#123; // 个数为 5； // 总数小于 3 时，内存回收等级为 low，取值为 2； memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW; &#125; else &#123; // 否则，内存回收等级为 moderate，取值为 1； memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE; &#125; &#125; else &#123; // 取值为 0，cachce 和 empty 进程足够时，内存回收等级为 normal memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL; &#125; if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"oom: memFactor=\" + memFactor + \" last=\" + mLastMemoryLevel + \" allowLow=\" + mAllowLowerMemLevel + \" numProcs=\" + mLruProcesses.size() + \" last=\" + mLastNumProcesses); // 如果新的内存回收等级比上一次的大，判读是否使用新的内存回收等级！ // 一般情况下，内存回收等级变高时（即允许尽可能多地回收），是不允许降级的 // 但 mAllowLowerMemLevel 为false，或进程数量变多时，可以降级！ if (memFactor &gt; mLastMemoryLevel) &#123; if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) &#123; // 使用上一次的低内存级别！ memFactor = mLastMemoryLevel; if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, \"Keeping last mem factor!\"); &#125; &#125; if (memFactor != mLastMemoryLevel) &#123; EventLogTags.writeAmMemFactor(memFactor, mLastMemoryLevel); &#125; // 更新内存级别和进程数量！ mLastMemoryLevel = memFactor; mLastNumProcesses = mLruProcesses.size(); // 将最新的内存回收等级保存到 ProcessStats 中，如果和上一次的不同，allChanged 为 true！ boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now); final int trackerMemFactor = mProcessStats.getMemFactorLocked(); // 如果最新的内存回收等级不等于 normal，那么所有进程都要进行内存回收工作！ if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) &#123; if (mLowRamStartTime == 0) &#123; // 记录内存回收时间 mLowRamStartTime = now; &#125; int step = 0; int fgTrimLevel; // 计算前台进程的内存回收等级； switch (memFactor) &#123; case ProcessStats.ADJ_MEM_FACTOR_CRITICAL: fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL; // critical 级别； break; case ProcessStats.ADJ_MEM_FACTOR_LOW: fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW; // low 级别； break; default: fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE; // moderate 级别； break; &#125; // 计算回收因子，numTrimming 表示所有需要回收内存的后台进程！ // 其实就是分阶段的回收！ int factor = numTrimming / 3; int minFactor = 2; // 如果 home 进程不会 null，previous 进程不为 null，最小因子均加 1； if (mHomeProcess != null) minFactor++; if (mPreviousProcess != null) minFactor++; // 回收因子不能低于最小因子！ if (factor &lt; minFactor) factor = minFactor; // 初始默认的回收级别为 complete！ int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE; // 再次逆序遍历 mLruProcesses 列表，根据进程的状态进行不同的回收处理！ for (int i=N-1; i&gt;=0; i--) &#123; // 开始处理进程！ ProcessRecord app = mLruProcesses.get(i); // 如果内存回收等级变化了，或者进程的状态发生变化，更新进程的监控信息！ if (allChanged || app.procStateChanged) &#123; setProcessTrackerStateLocked(app, trackerMemFactor, now); app.procStateChanged = false; &#125; if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME &amp;&amp; !app.killedByAm) &#123; // 如果进程的状态优先级不高于 PROCESS_STATE_HOME：12，并且没有被 AMS 后台杀死，进入该分支！ if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) &#123; // 如果进程的内存回收级别低于 curLevel，并且进程还在运行，执行内存回收！ try &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Trimming memory of \" + app.processName + \" to \" + curLevel); // 回收内存！ app.thread.scheduleTrimMemory(curLevel); &#125; catch (RemoteException e) &#123; &#125; if (false) &#123; // 这里默认是不进入的！ if (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) &#123; mStackSupervisor.scheduleDestroyAllActivities(app, \"trim\"); &#125; &#125; &#125; // 更新进程的内存回收级别！ app.trimMemoryLevel = curLevel; // 记录处理的进度，当到达回收因子的时候，step 归 0，准备进入下一个回收因子阶段！ step++; if (step &gt;= factor) &#123; step = 0; switch (curLevel) &#123; case ComponentCallbacks2.TRIM_MEMORY_COMPLETE: // 如果是 COMPLETE:80，设置 curLevel 为 MODERATE:60 curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE; break; case ComponentCallbacks2.TRIM_MEMORY_MODERATE: // 如果是 COMPLETE:60，设置 curLevel 为 BACKGROUND:40 curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND; break; &#125; &#125; &#125; else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123; // 如果进程的状态属于 height weight 类型（9）的进程，进入该分支！ if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND &amp;&amp; app.thread != null) &#123; // 如果进程的内存回收级别低于 BACKGROUND:40，并且进程还在运行，执行内存回收！ try &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Trimming memory of heavy-weight \" + app.processName + \" to \" + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND); // 回收内存！ app.thread.scheduleTrimMemory( ComponentCallbacks2.TRIM_MEMORY_BACKGROUND); &#125; catch (RemoteException e) &#123; &#125; &#125; // 更新进程的内存回收登记为 BACKGROUND:40 app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND; &#125; else &#123; // 其他情况，进入这里： if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) &amp;&amp; app.pendingUiClean) &#123; // 如果该进程的进程状态优先级低于 important background: 7，或者其是 system 进程但是不显示 ui // 且 pendingUiClean 为 true，这种进程的回收登记很特殊，为 TRIM_MEMORY_UI_HIDDEN: 20 final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN; if (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != null) &#123; // 如果进程的内存回收级别低于 level，并且进程还在运行，执行内存回收！ try &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Trimming memory of bg-ui \" + app.processName + \" to \" + level); // 回收内存！ app.thread.scheduleTrimMemory(level); &#125; catch (RemoteException e) &#123; &#125; &#125; // 设置 pendingUiClean 为 false，表示 ui 资源已经被回收了 app.pendingUiClean = false; &#125; // 如果 TRIM_MEMORY_UI_HIDDEN 等级不够无法回收，则以前台进程的回收级别再次回收！！ if (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != null) &#123; try &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Trimming memory of fg \" + app.processName + \" to \" + fgTrimLevel); // 回收内存！ app.thread.scheduleTrimMemory(fgTrimLevel); &#125; catch (RemoteException e) &#123; &#125; &#125; // 更新进程的内存回收登记！ app.trimMemoryLevel = fgTrimLevel; &#125; &#125; &#125; else &#123; // 如果最新的内存回收等级等于 normal，那么进入该分支！ if (mLowRamStartTime != 0) &#123; mLowRamTimeSinceLastIdle += now - mLowRamStartTime; mLowRamStartTime = 0; &#125; // 逆序遍历 mLruProcesses！ for (int i=N-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); // 同样的，更新进程信息！ if (allChanged || app.procStateChanged) &#123; setProcessTrackerStateLocked(app, trackerMemFactor, now); app.procStateChanged = false; &#125; // 如果该进程的进程状态优先级低于 important background: 6，或者其是 system 进程但是不显示 ui // 且 pendingUiClean 为 true，才会回收内存！！ if ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) &amp;&amp; app.pendingUiClean) &#123; // 回收等级是 TRIM_MEMORY_UI_HIDDEN: 20 if (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN &amp;&amp; app.thread != null) &#123; try &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Trimming memory of ui hidden \" + app.processName + \" to \" + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN); // 回收内存！ app.thread.scheduleTrimMemory( ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN); &#125; catch (RemoteException e) &#123; &#125; &#125; // 设置 pendingUiClean 为 false； app.pendingUiClean = false; &#125; // 这里很特殊，设置 trimMemoryLevel 为 0； app.trimMemoryLevel = 0; &#125; &#125; // 如果允许销毁后台 Activity // 可以通过：开发者选项 ——》不保留活动，开启！ if (mAlwaysFinishActivities) &#123; mStackSupervisor.scheduleDestroyAllActivities(null, \"always-finish\"); &#125; // allChanged 为 true，表示发生了内存回收，这里是请求 PSS 内存！ if (allChanged) &#123; requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered()); &#125; // 更新活跃的 uid 的状态！ for (int i=mActiveUids.size()-1; i&gt;=0; i--) &#123; final UidRecord uidRec = mActiveUids.valueAt(i); int uidChange = UidRecord.CHANGE_PROCSTATE; // 如果 setProcState 和 curProcState 不相等，说明所属进程状态发生了变化！ if (uidRec.setProcState != uidRec.curProcState) &#123; if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, \"Changes in \" + uidRec + \": proc state from \" + uidRec.setProcState + \" to \" + uidRec.curProcState); if (ActivityManager.isProcStateBackground(uidRec.curProcState)) &#123; if (!ActivityManager.isProcStateBackground(uidRec.setProcState)) &#123; // 如果 uid 所属进程当前的状态是后台进程，但是之前的状态不是后台进程！ // 更新 uid 的 lastBackgroundTime 变量！ uidRec.lastBackgroundTime = nowElapsed; if (!mHandler.hasMessages(IDLE_UIDS_MSG)) &#123; // 发送 uid 处于 idle 状态的消息！ mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG, BACKGROUND_SETTLE_TIME); &#125; &#125; &#125; else &#123; // 如果 uid 所属进程当前的状态是前台进程，那么该 uid 处于 active 状态！ if (uidRec.idle) &#123; uidChange = UidRecord.CHANGE_ACTIVE; uidRec.idle = false; &#125; uidRec.lastBackgroundTime = 0; &#125; // 更新 setProcState 为 curProcState！ uidRec.setProcState = uidRec.curProcState; enqueueUidChangeLocked(uidRec, -1, uidChange); noteUidProcessState(uidRec.uid, uidRec.curProcState); &#125; &#125; // 更新进程的状态！ if (mProcessStats.shouldWriteNowLocked(now)) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; synchronized (ActivityManagerService.this) &#123; mProcessStats.writeStateAsyncLocked(); &#125; &#125; &#125;); &#125; if (DEBUG_OOM_ADJ) &#123; // debug 相关，不处理！ final long duration = SystemClock.uptimeMillis() - now; if (false) &#123; Slog.d(TAG_OOM_ADJ, \"Did OOM ADJ in \" + duration + \"ms\", new RuntimeException(\"here\").fillInStackTrace()); &#125; else &#123; Slog.d(TAG_OOM_ADJ, \"Did OOM ADJ in \" + duration + \"ms\"); &#125; &#125;&#125; 3.2.1 变量总结下面我们来总结，空参 updateOomAdjLocked 中遇到的一些变量： 3.2.2 过程总结3.3 [5]ActivityManagerS.updateOomAdjLocked最后，我们来看 5 参的 updateOomAdjLocked 方法更新指定进程的 oomAdj，参数传递： ProcessRecord app：要更新 oomAdj 的进程； int cachedAdj：进程处于 cache 状态的 adj 值； ProcessRecord TOP_APP：top activity 所在进程； boolean doingAll：是否对所有进程都更新 adj 的值！ long now：更新的时间点！ 12345678910111213private final boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) &#123; if (app.thread == null) &#123; // 进程没有启动！ return false; &#125; //【1】计算 oomAdj 的值，doingAll 表示是否是对所有的进程都更新 // 如果是的话，那就会统计进程数量！ computeOomAdjLocked(app, cachedAdj, TOP_APP, doingAll, now); //【2】应用 oomAdj 的值； return applyOomAdjLocked(app, doingAll, now, SystemClock.elapsedRealtime());&#125; 我们看到，更新指定进程的 oomAdj 的会先调用 computeOomAdjLocked 计算 oomAdj，在调用 applyOomAdjLocked 应用计算的 oomAdj！！ 3.3.1 ActivityManagerS.computeOomAdjLocked该方法用于计算除了 cachedProcess 和 emptyProcess 进程以外的进程的 oom_adj 值！ 该方法的判断分支很多，我们按照模块划分下： 3.3.1.1 已经更新/进程未启动的情况123456789101112131415161718private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) &#123; //【1】如果该进程的 app.adjSeq 和 mAdjSeq 相等，说明已经计算过了，直接返回计算的结果！ if (mAdjSeq == app.adjSeq) &#123; return app.curRawAdj; &#125; //【2】如果进程的 thread 为 null，说明进程没有启动， // 设置进程的调度组为 SCHED_GROUP_BACKGROUND，进程状态为 SCHED_GROUP_BACKGROUND // curAdj 和 curRawAdj 均为 CACHED_APP_MAX_ADJ； if (app.thread == null) &#123; app.adjSeq = mAdjSeq; app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ); &#125; ... ... ... ... // 见下面[3.1.2.1.2]！ 对于已经更新过的进程，通过 mAdjSeq == app.adjSeq 进行判断，当系统每次调用 updateOomAdjLocked 方法更新系统中进程的 adj 的时候，mAdjSeq 的值就会加一，同时，本次更新过的进程的 adjSeq 也会等于 mAdjSeq！ 对于进程还没有启动的情况，我们默认设置初始的值给对应的属性！ app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND : app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY : 16 app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ : 906 3.3.1.2 系统进程下面我们来看看系统进程的处理！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657... ... ... ... // 见上面[3.1.2.1.1]！// 初始化一些 debug 的变量，后续会使用！app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;app.adjSource = null;app.adjTarget = null;app.empty = false; // 进程是否会为空；app.cached = false; // 进程是否被缓存；final int activitiesSize = app.activities.size(); // 该进程中的 activity 数！//【3】如果进程的 maxAdj &lt;= FOREGROUND_APP_ADJ(0)，说明该进程是系统进程，那么一定是在前台！if (app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ) &#123; app.adjType = \"fixed\"; app.adjSeq = mAdjSeq; app.curRawAdj = app.maxAdj; app.foregroundActivities = false; // 设置进程的调度组为 SCHED_GROUP_DEFAULT； app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT; // 设置进程的状态为 PROCESS_STATE_PERSISTENT； app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT; // 判断系统进程当前是否正在显示 ui，如果正在显示，那么我们需要等到用户离开 ui 后再回收内存！ app.systemNoUi = true; if (app == TOP_APP) &#123; // 如果该系统进程是 top activity 所在进程，systemNoUi 为 false； app.systemNoUi = false; app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP; app.adjType = \"pers-top-activity\"; &#125; else if (app.hasTopUi) &#123; // 如果该系统进程 hasTopUi 为 true，说明其持有 top-level ui，systemNoUi 为 false； app.systemNoUi = false; app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP; app.adjType = \"pers-top-ui\"; &#125; else if (activitiesSize &gt; 0) &#123; // 如果系统进程中的 activity 数目大于 0 for (int j = 0; j &lt; activitiesSize; j++) &#123; final ActivityRecord r = app.activities.get(j); if (r.visible) &#123; // 如果有可见的 activity，那么 systemNoUi 为 false； app.systemNoUi = false; &#125; &#125; &#125; // 如果系统进程持有 ui 界面，那其进程状态为 PROCESS_STATE_PERSISTENT_UI； if (!app.systemNoUi) &#123; app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI; &#125; // 那么其 curAdj 为 maxAdj 的值，这里直接 return！ return (app.curAdj = app.maxAdj);&#125;... ... ... ... // 见下面[3.1.2.1.3]！ 对于系统进程，其一定是要在前台的，这里首先判断了最大的 maxAdj 的取值！FOREGROUND_APP_ADJ 的取值为 0，表示前台进程的 adj！ maxAdj 在进程对象刚创建的时候，会被初始化为 UNKNOWN_ADJ！ 123maxAdj = ProcessList.UNKNOWN_ADJ;curRawAdj = setRawAdj = ProcessList.INVALID_ADJ;curAdj = setAdj = verifiedAdj = ProcessList.INVALID_ADJ; 1、在设置系统进程 setSystemProcess 的时候，会被设置为如下值：123456// 为系统进程创建 ProcessRecord 对象！ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);app.persistent = true; // 表示为常驻进程！app.pid = MY_PID;app.maxAdj = ProcessList.SYSTEM_ADJ; // 设置 maxAdj！app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); 2、在启动 persistent app 的时候，会调用 addAppLocked 方法，设置为如下值：1234if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;&#125; 这两个值对应的 adj 优先级都高于 FOREGROUND_APP_ADJ，都属于 persistent adj，都会进入该分支！ 这一段的逻辑如下： 如果进程的 maxAdj 比 FOREGROUND_APP_ADJ 小，说明其是常驻进程或者系统进程，那么就做如下判断： app == TOP_APP 当前的 top activity 所在进程就是该进程，那么有： 1234app.systemNoUi = false;app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;app.foregroundActivities = false; app.hasTopUi 当前进程不是 top process，但是显示 top-level 级别的 ui，那么有： 1234app.systemNoUi = false;app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;app.foregroundActivities = false; activitiesSize &gt; 0 如果即不是top process，也没有显示top-level ui，那就要判断下内部的是否持有可见的activity，如果有那么systemNoUi为 false，curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI; 1234app.systemNoUi = false; / trueapp.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI; / ActivityManager.PROCESS_STATE_PERSISTENT;app.foregroundActivities = false; 对于 persistent 进程的情况，最后返回的是 app.curAdj = app.curRawAdj = app.maxAdj! 3.3.1.3 前台进程对于其他的进程来说，maxAdj 只会在初始化的时候被设置为 ProcessList.UNKNOWN_ADJ; 显然，他们是需要进入下面的分支的，判断其是否属于前台进程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374... ... ... ... // 见上面[3.1.2.1.2]！app.systemNoUi = false;final int PROCESS_STATE_CUR_TOP = mTopProcessState; // 用于保存当前 top process 的状态！//【4】接下来就开始决定非系统前台进程的重要性了，从高级别开始一直到低级别，逐级分配 oomAdj！// adj 用来保存计算出的 oomAdj，schedGroup 用来保存计算出的调度组，procState 用来保存计算出的进程状态！int adj;int schedGroup;int procState;boolean foregroundActivities = false;BroadcastQueue queue;if (app == TOP_APP) &#123; // 该进程就是 top activity 所在的进程，此时进程处于前台！ adj = ProcessList.FOREGROUND_APP_ADJ; // 0； schedGroup = ProcessList.SCHED_GROUP_TOP_APP; app.adjType = \"top-activity\"; foregroundActivities = true; procState = PROCESS_STATE_CUR_TOP; &#125; else if (app.instrumentationClass != null) &#123; // 如果进程中有正在运行的 instrumentation，用于测试，此时进程处于前台！ adj = ProcessList.FOREGROUND_APP_ADJ; // 0 schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.adjType = \"instrumentation\"; procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; // 4 &#125; else if ((queue = isReceivingBroadcast(app)) != null) &#123; // 如果进程中有正在运行的 BroadcastReceiver 接收处理广播，此时进程处于前台！ // 然后根据广播所处的队列类型设置调度组！ adj = ProcessList.FOREGROUND_APP_ADJ; // 0 schedGroup = (queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND; app.adjType = \"broadcast\"; procState = ActivityManager.PROCESS_STATE_RECEIVER; // 11 &#125; else if (app.executingServices.size() &gt; 0) &#123; // 如果进程中有服务正在执行，此时进程处于前台，然后根据执行操作的前台后台，设置不同调度组； adj = ProcessList.FOREGROUND_APP_ADJ; // 0 schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND; app.adjType = \"exec-service\"; procState = ActivityManager.PROCESS_STATE_SERVICE; // 10 //Slog.i(TAG, \"EXEC \" + (app.execServicesFg ? \"FG\" : \"BG\") + \": \" + app); &#125; else &#123; // 其他类型的进程进入该分支，进程状态为 PROCESS_STATE_CACHED_EMPTY，调度组为 SCHED_GROUP_BACKGROUND！ // 这种情况下我们无法知道实际的 adj，我们暂时使用 cache adj，后续我们会继续调整！ schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; adj = cachedAdj; procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; // 16 app.cached = true; app.empty = true; app.adjType = \"cch-empty\";&#125;... ... ... ... // 见下面[3.1.2.1.4]！ 首先来说一下：mTopProcessState，其表示 top process 的状态，其默认取值为：1int mTopProcessState = ActivityManager.PROCESS_STATE_TOP; 当我们的系统进入睡眠状态的时候，会更新其状态，具体的方法在 updateSleepIfNeededLocked 方法： 当系统不睡眠时候，设置 mTopProcessState = ActivityManager.PROCESS_STATE_TOP； 当系统睡眠时候，设置 mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING； 我们来看看，那些进程能归类于前台进程： 1、当前进程是 top process，进行如下处理： 12345adj = ProcessList.FOREGROUND_APP_ADJ; // 取值 0schedGroup = ProcessList.SCHED_GROUP_TOP_APP;foregroundActivities = true;procState = PROCESS_STATE_CUR_TOP; // 进程状态 2 或者 5！ 这里的 PROCESS_STATE_CUR_TOP 就是 mTopProcessState，且 foregroundActivities 只有在该条件下才为 true； 4、当前进程不是 top process，但是其内部运行着 instrumentation 用于测试的话： 12345adj = ProcessList.FOREGROUND_APP_ADJ; // 取值 0schedGroup = ProcessList.SCHED_GROUP_DEFAULT;foregroundActivities = false;procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; // 进程状态 4； 继续来看： 3、当前进程不是 top process，内部没有运行着 instrumentation，但是其内部有正在接受处理广播的 BroadcastReceiver 的话： 12345adj = ProcessList.FOREGROUND_APP_ADJ; // 取值 0schedGroup = (queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;foregroundActivities = false;procState = ActivityManager.PROCESS_STATE_RECEIVER; // 进程状态 11； 如果广播所在的队列是后台队列，所属的调度组为：SCHED_GROUP_BACKGROUND，如果是前台，调度组为 SCHED_GROUP_DEFAULT； 4、当前进程不是 top process，内部没有运行着 instrumentation，也没有接受处理广播的 BroadcastReceiver，但是有正在执行的 Service 的话： 12345adj = ProcessList.FOREGROUND_APP_ADJ; // 取值 0schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;foregroundActivities = false;procState = ActivityManager.PROCESS_STATE_SERVICE; // 进程状态 10； 如果后台执行，所属的调度组为：SCHED_GROUP_BACKGROUND，如果是前台，调度组为 SCHED_GROUP_DEFAULT； 5、其他不属于以上的情况，说明其不是前台进程，有如下处理： 1234567schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;adj = cachedAdj; // 我们使用 cachedAdj ，或者为 unknowAdj；procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; // 进程状态为 16；foregroundActivities = false;app.cached = true;app.empty = true; 对于这种情况，我们将其当作 cache 进程处理，后续会进行调整！ 对于前台进程，其 oom_adj 均被赋值为 FOREGROUND_APP_ADJ，即从 LowMemoryKiller 的角度来看，它们的重要性是一致的。但这些进程的 procState 不同，于是从 ActivityManagerService 主动回收内存的角度来看，它们的重要性不同。 这里我们关注一个变量 foregroundActivities，这里只有在 app == TOP_APP 的情况下为 true，表示持有前台 activity! 我们继续来看！ 3.3.1.4 处理非前台 activity 所在进程处理完了前台进程，接下来，处理非前台 activity 的情况，这里可以看作上面部分的延续，以下几种情况，会进入下面的逻辑，进一步的调整其 adj! 如果该进程是前台进程，但不是 top process，并且内部持有 activity，其 adj 为 FOREGROUND_APP_ADJ！ 如果该进程不是前台进程，并且内部持有 activity，其 adj 为 cachedAdj！ 这里的 top process 是 top activity 所在的进程！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114... ... ... ... // 见上面[3.1.2.1.3]！//【5】处理完了前台进程，接下来，处理非前台 activity 的情况！if (!foregroundActivities &amp;&amp; activitiesSize &gt; 0) &#123; // minLayer 默认等于 PERCEPTIBLE_APP_ADJ（200） - VISIBLE_APP_ADJ（100）- 1，等于 99！ int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX; for (int j = 0; j &lt; activitiesSize; j++) &#123; // 遍历！ final ActivityRecord r = app.activities.get(j); if (r.app != app) &#123; Log.e(TAG, \"Found activity \" + r + \" in proc activity list using \" + r.app + \" instead of expected \" + app); if (r.app == null || (r.app.uid == app.uid)) &#123; // 处理数据异常的问题！ r.app = app; &#125; else &#123; continue; &#125; &#125; if (r.visible) &#123; //【5.1】如果 activity 是可见的， // 那提高 adj 最高为 VISIBLE_APP_ADJ，提高 procState 最高为 PROCESS_STATE_CUR_TOP！ if (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123; // 100 adj = ProcessList.VISIBLE_APP_ADJ; app.adjType = \"visible\"; &#125; if (procState &gt; PROCESS_STATE_CUR_TOP) &#123; // top state: 2/5 procState = PROCESS_STATE_CUR_TOP; &#125; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; // 调整调度组为 default！ app.cached = false; app.empty = false; foregroundActivities = true; // 设置 foregroundActivities 为 true； // 如果其所在 task 如果不为 null，需要根据 task.mLayerRank // 调整 minLayer 的值！ if (r.task != null &amp;&amp; minLayer &gt; 0) &#123; final int layer = r.task.mLayerRank; if (layer &gt;= 0 &amp;&amp; minLayer &gt; layer) &#123; // minLayer 为其所在 task.mLayerRank 值！ minLayer = layer; &#125; &#125; break; &#125; else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) &#123; //【5.2】如果 activity 正在暂停，或者已经暂停， // 调整 adj 至少为 PERCEPTIBLE_APP_ADJ，调整 procState 至少为 top 进程的状态； if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; // 200 adj = ProcessList.PERCEPTIBLE_APP_ADJ; app.adjType = \"pausing\"; &#125; if (procState &gt; PROCESS_STATE_CUR_TOP) &#123; // top state: 2/5 procState = PROCESS_STATE_CUR_TOP; &#125; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.empty = false; foregroundActivities = true; // 设置 foregroundActivities 为 true； &#125; else if (r.state == ActivityState.STOPPING) &#123; //【5.3】如果 activity 正在停止， 调整 adj 至少为 PERCEPTIBLE_APP_ADJ if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; // 200 adj = ProcessList.PERCEPTIBLE_APP_ADJ; app.adjType = \"stopping\"; &#125; // 如果此时 activity 没有开始 finish，那就调整 procState 最低为 PROCESS_STATE_LAST_ACTIVITY！ if (!r.finishing) &#123; if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; // 13 procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; &#125; &#125; app.cached = false; app.empty = false; foregroundActivities = true; // 设置 foregroundActivities 为 true； &#125; else &#123; //【5.4】不属于以上情况的话，只是含有 cached activity 的进程！ // 这里只会设置进程状态 procState 最低为 PROCESS_STATE_CACHED_ACTIVITY！ if (procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123; // 14 procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY; app.adjType = \"cch-act\"; &#125; &#125; &#125; // 同时，不同可见进程的 oom_adj 有一定的差异，我们根据其所在的 task 的 mLayerRank 来动态调整其 adj！ // 如果此时 adj 为 VISIBLE_APP_ADJ（100），那就给 adj 加上 minLayer！ // minLayer if (adj == ProcessList.VISIBLE_APP_ADJ) &#123; adj += minLayer; &#125;&#125;... ... ... ... // 见下面[3.1.2.1.5]！ 如果进程中没有 top activity，但是内部运行着 activity，还需要进入如下的判断： 1、如果 r.visible，表示内部有 activity 是可见的： 如果 adj &gt; ProcessList.VISIBLE_APP_ADJ：100，那就调整到 ProcessList.VISIBLE_APP_ADJ； 如果 procState &gt; PROCESS_STATE_CUR_TOP，那就调整到 top process state； 设置 foregroundActivities 为 true； 然后结束处理； 2、如果 r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED，表示内部有 activity 是正在暂停，或者已经暂停： 如果 adj &gt; ProcessList.VISIBLE_APP_ADJ：100，那就调整到 ProcessList.VISIBLE_APP_ADJ； 如果 procState &gt; PROCESS_STATE_CUR_TOP，那就调整到 top process state； 设置 foregroundActivities 为 true； 然后继续处理其他 activity 3、如果 r.state == ActivityState.STOPPING，表示内部有 activity 是正在停止： 如果 adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ：200，那就调整到 ProcessList.PERCEPTIBLE_APP_ADJ； 如果此时 activity 没有开始 finish，并且 procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY：13，那就调整 procState 为 PROCESS_STATE_LAST_ACTIVITY； 设置 foregroundActivities 为 true，然后继续处理其他 activity； 4、其他情况： 如果 procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY: 14，那就设置 procState 为 PROCESS_STATE_CACHED_ACTIVITY，然后继续处理其他 activity! 5、最后，如果 adj 等于 VISIBLE_APP_ADJ：100，在其之上加入 minLayer 调整，这样的话，最后的 adj 介于 100 和 200 之间！ 我们得到： 对于 如果该进程是前台进程，但不是 top process 这种情况，其 adj 为 FOREGROUND_APP_ADJ：0，不会做 adj 调整，但是其 procState 会发生变化，其变化依据是依赖于进程内部的 activity 的状态，根据【3.3.1.3】节我们知道，其 procState 的取值如下：1234procState = PROCESS_STATE_CUR_TOP; // 进程状态 2 或者 5！procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; // 进程状态 4；procState = ActivityManager.PROCESS_STATE_RECEIVER; // 进程状态 11；procState = ActivityManager.PROCESS_STATE_SERVICE; // 进程状态 10； 可以看到，如果其内部持有非 top activity，这里的调整，顶多会将其调整到 PROCESS_STATE_CUR_TOP 级别！ 而对于非前台进程，在【3.3.1.3】节，会被置为如下的状态：123adj = cachedAdj; // 我们使用 cachedAdj ，或者为 unknowAdj；procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; // 进程状态为 16；foregroundActivities = false; 可以看到，如果其内持有非 top activity，会根据其 activity 的状态，其 adj 被调整为：12345// 内部有非 top activity，且其 visible；ProcessList.VISIBLE_APP_ADJ // 100// 内部有非 top activity，其没 visible，但是 pausing 或者 paused，或者 stoping；ProcessList.PERCEPTIBLE_APP_ADJ // 200 其 procState 被调整为： 12345678// 内部有非 top activity，其 visible / pausing / pauesed，且其 procState &gt; PROCESS_STATE_CUR_TOP（满足）ActivityManager.PROCESS_STATE_CUR_TOP // 2 或者 5// 内部有非 top activity，其 stopping，但没 finishing，且其 procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY（满足）ActivityManager.PROCESS_STATE_LAST_ACTIVITY // 13// 内部有非 top activity，其没 visible / pausing / pauesed / stopping，且其 procState &gt; PROCESS_STATE_CACHED_ACTIVITY（满足）ActivityManager.PROCESS_STATE_CACHED_ACTIVITY // 14 我们接着来看！！ 3.3.1.5 调整可感知进程接下来处理可感知的进程，可以看到，能够进入该分支的需要满足下面某一个条件： adj 的值大于 PERCEPTIBLE_APP_ADJ（200）： procState 的值大于 PROCESS_STATE_FOREGROUND_SERVICE（4）： 12345678910111213141516171819202122232425262728293031323334... ... ... ... // 见上面[3.1.2.1.4]！//【5】接下来，处理 adj 大于 PERCEPTIBLE_APP_ADJ（200） // 或者 procState 大于 PROCESS_STATE_FOREGROUND_SERVICE（4）的情况！if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) &#123; if (app.foregroundServices) &#123; //【5.1】如果该进程中有前台服务，那么用户是可以感知到这种进程的，所以是可见的！ // 设置 adj 最低为 PERCEPTIBLE_APP_ADJ（200） // 设置 procState 最低为 PROCESS_STATE_FOREGROUND_SERVICE（4） adj = ProcessList.PERCEPTIBLE_APP_ADJ; procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; app.cached = false; app.adjType = &quot;fg-service&quot;; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; &#125; else if (app.forcingToForeground != null) &#123; //【5.2】如果进程 forcingToForeground 不为 null，说明进程被强制设置到前台，同样可见！ // 设置 adj 最低为 PERCEPTIBLE_APP_ADJ（200） // 设置 procState 最低为 PROCESS_STATE_IMPORTANT_FOREGROUND（6） adj = ProcessList.PERCEPTIBLE_APP_ADJ; procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; app.cached = false; app.adjType = &quot;force-fg&quot;; app.adjSource = app.forcingToForeground; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; &#125;&#125;... ... ... ... // 见下面[3.1.2.1.6]！ 对于系统进程和前台进程 adj 的优先级均是高于 ProcessList.FOREGROUND_APP_ADJ，所以第一个条件是不满足的！ 我们来看看那些进程属于可感知的进程： app.foregroundServices 为 true，表示服务被 start 后，调用了 startForeground 方法此时我们来看看进程的属性： 123adj = ProcessList.PERCEPTIBLE_APP_ADJ; // 200;procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; // 4schedGroup = ProcessList.SCHED_GROUP_DEFAULT; 在 Service 的被启动后，可以调用 startForeground，让服务进程变为可感知的 app.foregroundServices 为 false，但是 app.forcingToForeground != null，表示调用了 setProcessForeground 方法此时我们来看看进程的属性： 123adj = ProcessList.PERCEPTIBLE_APP_ADJ; // 200procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; // 6schedGroup = ProcessList.SCHED_GROUP_DEFAULT; 当我们在进程中调用了 setProcessForeground 方法后，该进程的 app.forcingToForeground 不为 null，这样进程就会变为可感知的！！ 注意 这里要重点看第二个条件：procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE : 4 只要满足该条件的进程，也可以进入该分支，即使对于前台进程，其 adj == FOREGROUND_APP_ADJ，也可能会进入该分支，比如： 不是 top process，其内部没有非top activity，但是其内部有正在接受处理广播的 BroadcastReceiver，其 procState == PROCESS_STATE_RECEIVER：11! 不是 top process，其内部没有非top activity，但是其内部有正在执行的 Service，其 procState == PROCESS_STATE_SERVICE：10! 如果其被显示设置成了前台的话，adj 和 procState 也会发生调整！ 接着来看： 3.3.1.6 heavy weight 进程下面是处理 heavy weight 类型的进程！ 1234567891011121314151617181920... ... ... ... // 见上面[3.1.2.1.5]//【6】接下来，处理 heavy weight 进程！if (app == mHeavyWeightProcess) &#123; //【6.1】设置进程 adj 最低为 HEAVY_WEIGHT_APP_ADJ if (adj &gt; ProcessList.HEAVY_WEIGHT_APP_ADJ) &#123; // 400 adj = ProcessList.HEAVY_WEIGHT_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;heavy&quot;; &#125; //【6.2】设置进程状态 procState 最低为 PROCESS_STATE_HEAVY_WEIGHT if (procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123; // 9 procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT; &#125;&#125;... ... ... ... // 见下面[3.1.2.1.7] ams 通过 mHeavyWeightProcess 来保存系统中的 heavy weight 进程！ 如果 app == mHeavyWeightProcess，说明该进程是 heavy weight 类型的进程，我们来看看其属性设置： adj = ProcessList.HEAVY_WEIGHT_APP_ADJ; procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; 注意，对于 adj 的调整，只有 cacheAdj 或者 unKnowAdj 的情况下，如果满足条件，才会被调整为 HEAVY_WEIGHT_APP_ADJ； 而对于 stateProc，只要 procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT：9，并且该进程是 heavy weight 进程，那就会发生调整，这个可以参见【3.3.1.6】节！ 接着来看： 3.3.1.7 home 进程下面是处理 home 进程！ 1234567891011121314151617181920 ... ... ... ... // 见上面[3.1.2.1.6] //【7】接下来，处理 home 进程！ if (app == mHomeProcess) &#123; //【7.1】设置进程 adj 最低为 HOME_APP_ADJ if (adj &gt; ProcessList.HOME_APP_ADJ) &#123; // 600 adj = ProcessList.HOME_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = \"home\"; &#125; //【7.2】设置进程状态 procState 最低为 PROCESS_STATE_HOME！ if (procState &gt; ActivityManager.PROCESS_STATE_HOME) &#123; // 12 procState = ActivityManager.PROCESS_STATE_HOME; &#125; &#125; ... ... ... ... // 见下面[3.1.2.1.8] 如果 app == mHomeProcess，说明该进程是 home 所在的进程，我们来看看其属性设置： adj = ProcessList.HOME_APP_ADJ; // 600 procState = ActivityManager.PROCESS_STATE_HOME; // 12 schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; 注意： 对于 home process 的情况，只有 cacheAdj 或者 unKnowAdj 的情况下，才会被调整 adj 和 procState！ 而对于 foreground process，visible process，perceptible process和 heavy weight process 来说，他们的 adj 和 procState都远远高于 home process，所以是不会调整的！ 接着来看： 3.3.1.8 持有 activity 的 previous 进程下面是处理持有 activity 的 previous 进程： 123456789101112131415161718192021222324 ... ... ... ... // 见上面[3.1.2.1.7] //【8】接下来，处理用户之前所在的，持有 activity 的 previous 进程！ // 因为这是前一个显示 ui 给用户的进程，我们尽量不杀死它，这样能够给用户一个好的用户体验！ if (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0) &#123; //【8.1】设置进程 adj 最低为 PREVIOUS_APP_ADJ！ if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123; // 700 adj = ProcessList.PREVIOUS_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = \"previous\"; &#125; //【8.2】设置进程状态 procState 最低为 PROCESS_STATE_LAST_ACTIVITY！ if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; // 13 procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; &#125; &#125; if (false) Slog.i(TAG, \"OOM \" + app + \": initial adj=\" + adj + \" reason=\" + app.adjType); ... ... ... ... // 见下面[3.1.2.1.9] 持有 activity 的 previous 进程，就是上一个显示 activity 的进程！ app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0，表示该进程是用户所在的上一个进程，并且该进程内部运行着 activity：下面我们来看看这类进程的属性设置： adj = ProcessList.PREVIOUS_APP_ADJ; procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; 注意： 对于 previous process 的情况，只有 cacheAdj 或者 unKnowAdj 的情况下，才会被调整 adj 和 procState！ 而对于 foreground process，visible process，perceptible process和 heavy weight process， home process 来说，他们的 adj 和 procState都远远高于 previous process，所以是不会调整的！ 接着来看： 3.3.1.9 处于 back-up 的进程下面是处理处于 back-up 的进程： 12345678910111213141516171819202122232425262728293031323334 ... ... ... ... // 见上面[3.1.2.1.8] // 设置进程的 adjSeq 为此时的 mAdjSeq，通过比较 adjSeq 和 mAdjSeq 就可以知道进程是否已经进行了 oomAdj 更新！ app.adjSeq = mAdjSeq; // 如果进程中的 services 或者 providers 被其他进程依赖，那么该进程的 oomAdj 也会发生变化，所以后续还要调整！ app.curRawAdj = adj; app.hasStartedServices = false; // hasStartedServices 表示该进程中是否有被启动的 service //【9】接下来，处理正在执行备份操作的进程，对比这类进程，我们要避免杀死他们； if (mBackupTarget != null &amp;&amp; app == mBackupTarget.app) &#123; //【9.1】设置进程 adj 最低为 BACKUP_APP_ADJ：300 if (adj &gt; ProcessList.BACKUP_APP_ADJ) &#123; // 300 if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, \"oom BACKUP_APP_ADJ for \" + app); adj = ProcessList.BACKUP_APP_ADJ; // 同时，设置进程 procState 最低为 PROCESS_STATE_IMPORTANT_BACKGROUND if (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123; // 7 procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND; &#125; app.adjType = \"backup\"; app.cached = false; &#125; //【9.2】设置进程状态 procState 最低为 PROCESS_STATE_BACKUP：8！ if (procState &gt; ActivityManager.PROCESS_STATE_BACKUP) &#123; procState = ActivityManager.PROCESS_STATE_BACKUP; &#125; &#125;... ... ... ... // 见下面[3.1.2.1.10] 对于正在备份的进程有： mBackupTarget != null &amp;&amp; app == mBackupTarget.app 条件满足，那就做如下调整： 如果 adj &gt; ProcessList.BACKUP_APP_ADJ 的话：12adj = ProcessList.BACKUP_APP_ADJ; // 优先级最低为 BACKUP_APP_ADJprocState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND; // 优先级最低为 PROCESS_STATE_IMPORTANT_BACKGROUND 否则，只调整 procState 优先级最低为 PROCESS_STATE_BACKUP 注意： 正在备份的进程和前面遇到的进程并不冲突，比如，一个前台进程也有可能正在做备份操作，所以这里将其对应的调整放在了其他进程之后！ 我们继续来看： 3.3.1.10 处理持有 services 的进程下面是处理处于持有 services 的进程，当进程中持有 services 并且别其他进程绑定后，该进程的 adj 和 state 会发生变化！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335 ... ... ... ... // 见上面[3.1.2.1.9] boolean mayBeTop = false; //【9】处理该进程中的 serivce，判断是否有其他进程依赖这些 service，如果有，那么该进程的 adj 会发生变化！ // 循环触发的条件是：adj &gt; ProcessList.FOREGROUND_APP_ADJ / schedGroup == ProcessList.SCHED_GROUP_BACKGROUND // / procState &gt; ActivityManager.PROCESS_STATE_TOP for (int is = app.services.size()-1; is &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); is--) &#123;//----------------------------------------------------------------------------------------------------- //【9.1】处理每一个 ServiceRecord 对象！ ServiceRecord s = app.services.valueAt(is); //【9.2】s.startRequested 为 true 表示服务是通过 startService 方式启动了！ if (s.startRequested) &#123; // 设置 hasStartedServices 为 true！ app.hasStartedServices = true; // 同时设置 procState 至少为 PROCESS_STATE_SERVICE！ if (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) &#123; // 10！ procState = ActivityManager.PROCESS_STATE_SERVICE; &#125; if (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123; // 如果进程自启动后，显示过 ui ，并且不是 home 进程，这里并没有做调整，设置了一个标记，用于 debug！ if (adj &gt; ProcessList.SERVICE_ADJ) &#123; app.adjType = \"cch-started-ui-services\"; &#125; &#125; else &#123; // 如果该服务的在 30 mins 内活跃过，那么我们会保持其进程在后台之前！ // 调整 adj 最低为 SERVICE_ADJ，可以看到 adj 大于 500 的进程均会受此判断的影响！ if (now &lt; (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123; if (adj &gt; ProcessList.SERVICE_ADJ) &#123; // 500 adj = ProcessList.SERVICE_ADJ; app.adjType = \"started-services\"; app.cached = false; &#125; &#125; // 如果该服务没有活跃的时间已经超过了 30 mins，那就不会更新其 adj！ if (adj &gt; ProcessList.SERVICE_ADJ) &#123; app.adjType = \"cch-started-services\"; // 增加 debug 的描述信息！ &#125; &#125; &#125;//---------------------------------------------------------------------------------------- //【9.3】如果该服务被 bind 了，处理该服务的所有绑定信息！ for (int conni = s.connections.size()-1; conni &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); conni--) &#123; ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni); for (int i = 0; i &lt; clist.size() &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); i++) &#123; // 获得连接的 client 客户端！ ConnectionRecord cr = clist.get(i); //【9.3.1】如果 client 的宿主进程就是当前进程，跳过！ if (cr.binding.client == app) &#123; continue; &#125; //【9.3.1】接下来，根据 bind 时候设置的 flags 的不同，进行不同的处理！ ///-------------------------------------------------------------------------------------- //【9.3.1.1】如果 bind 的时候没有设置 BIND_WAIVE_PRIORITY，进入下面的分支！ // BIND_WAIVE_PRIORITY 表示 client 会不会影响服务进程的优先级，为 1 表示不会影响，就不会进入 if 分支 // 为 0 表示会影响！ if ((cr.flags &amp; Context.BIND_WAIVE_PRIORITY) == 0) &#123; ProcessRecord client = cr.binding.client; // 计算绑定者进程 client 的 adj，这里依然是调用 computeOomAdjLocked 方法，不多说！ // 计算绑定者进程 client 的状态！ int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now); int clientProcState = client.curProcState; // 当绑定者进程 client 的状态 clientProcState &gt;= PROCESS_STATE_CACHED_ACTIVITY：14 // 设置其为 PROCESS_STATE_CACHED_EMPTY：16 if (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123; clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; &#125; String adjType = null; // 如果 bind 的时候还设置了 BIND_ALLOW_OOM_MANAGEMENT 标志位，表明 // 如果遇到 OOM 需要杀死进程，被绑定的服务进程会被 OOM 杀掉，那就不调整该进程的 adj！！ if ((cr.flags &amp; Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) &#123; if (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123; // 如果当前进程已经显示 ui 且不是 home 进程， // 此时设置 clientAdj 和 clientProcState 均为当前进程的 adj 和 procState！ // 不再考虑 client 的影响！ if (adj &gt; clientAdj) &#123; // 用一个标签标记，用于debug adjType = \"cch-bound-ui-services\"; &#125; app.cached = false; // 设置 client 的 adj 和 procState； clientAdj = adj; clientProcState = procState; &#125; else &#123; // 如果当前进程没有显示 ui，并且在距离上次该服务活跃的时间超过 30mins // 此时只设置 clientAdj 为当前进程的 adj！ // 不再考虑 client 的影响！ if (now &gt;= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123; if (adj &gt; clientAdj) &#123; adjType = \"cch-bound-services\"; &#125; clientAdj = adj; &#125; &#125; &#125; // 如果 client 的 adj 和当前进程的 adj 一样，即不需要考虑客户端进程了 // 如果当前进程的 adj &gt; 绑定者进程的 clientAdj，那就需要调整当前进程的 adj，进入以下分支！ if (adj &gt; clientAdj) &#123; if (app.hasShownUi &amp;&amp; app != mHomeProcess &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; // 如果进程显示 ui，并且不是 home process， // 并且绑定者进程的 adj 优先级低于可感知 ProcessList.PERCEPTIBLE_APP_ADJ: 200 // 这种情况也不需要考虑客户端进程的影响！ adjType = \"cch-bound-ui-services\"; &#125; else &#123; // 不满足上述条件，进入下面的判断，此时该进程的 adj 会收到 client 进程的 adj 的影响！ if ((cr.flags &amp; (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) &#123; // 如果绑定设置了 BIND_IMPORTANT 和 BIND_ABOVE_CLIENT 标记 // BIND_ABOVE_CLIENT 表示客户端处于前台时，绑定的 service 进程也变为前台进程 // 那么该进程的 adj 满足一下关系： // adj 会被调整到和 client 一样但是不超过 PERSISTENT_SERVICE_ADJ！ adj = clientAdj &gt;= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ; &#125; else if ((cr.flags &amp; Context.BIND_NOT_VISIBLE) != 0 &amp;&amp; clientAdj &lt; ProcessList.PERCEPTIBLE_APP_ADJ &amp;&amp; adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; // BIND_NOT_VISIBLE 表示服务进程不能变为 visible 进程 // 如果绑定设置了 BIND_NOT_VISIBLE 标记，且绑定者 adj 优先级 // 高于可感知，而当前进程的 adj 优先级低于可感知 // 那么该进程的 adj 会被提升到可感知 PERCEPTIBLE_APP_ADJ！ adj = ProcessList.PERCEPTIBLE_APP_ADJ; &#125; else if (clientAdj &gt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123; // 其他情况，如果 clientAdj 优先级不高于可感知 // 那么当前进程的 adj 和 client 一样！ adj = clientAdj; &#125; else &#123; // 其他情况，如果当前进程的 adj 大于可感知 VISIBLE_APP_ADJ // 那么 adj 取绑定者进程 clientAdj 和 VISIBLE_APP_ADJ 的最大值，即优先级最低的那个！ if (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123; adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ); &#125; &#125; // 如果绑定者进程没有处于 cache 状态，那么当前进程也不能处于 cache！ if (!client.cached) &#123; app.cached = false; &#125; adjType = \"service\"; &#125; &#125; // 接下来，处理 BIND_NOT_FOREGROUND 标志位的情况！ if ((cr.flags &amp; Context.BIND_NOT_FOREGROUND) == 0) &#123; //【9.3.1.2】如果 bind 的时候没有设置 BIND_NOT_FOREGROUND 标志位， // 那么被绑定的服务进程优先级可以被提升到 FOREGROUND 级别！ // 如果 client 的调度组大于该进程的调度组，调整该进程的调度组 if (client.curSchedGroup &gt; schedGroup) &#123; if ((cr.flags &amp; Context.BIND_IMPORTANT) != 0) &#123; schedGroup = client.curSchedGroup; &#125; else &#123; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; &#125; &#125; // 根据 client 进程的状态，设置 clientProcState 的值，后面会根据 clientProcState 为参考 // 调整该进程的 procState！ // 如果 clientProcState 优先级不低于 PROCESS_STATE_TOP，说明其处于 top 状态，进入 IF 分支 if (clientProcState &lt;= ActivityManager.PROCESS_STATE_TOP) &#123; if (clientProcState == ActivityManager.PROCESS_STATE_TOP) &#123; // 如果 clientProcState 等于 PROCESS_STATE_TOP，说明 client 进程就是 top 进程！ // 设置 mayBeTop 为 true，后续会统一做调整，这里不做调整！ // 设置 clientProcState 为 PROCESS_STATE_CACHED_EMPTY，不做参考！ mayBeTop = true; clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; &#125; else &#123; // 如果 clientProcState 小于 PROCESS_STATE_TOP，说明 client 进程的优先级比 top process // 还要高，比如 persistent 进程，这种情况不会将当前进程调整为 top，而是需要 // 调整 clientProcState 的值，作为参考！ if ((cr.flags &amp; Context.BIND_FOREGROUND_SERVICE) != 0) &#123; clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE; &#125; else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE &amp;&amp; (cr.flags &amp; Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) &#123; clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE; &#125; else &#123; clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; &#125; &#125; &#125; &#125; else &#123; //【9.3.1.2】如果 bind 的时候设置了 BIND_NOT_FOREGROUND 标志位， // 那么被绑定的服务进程优先级不能被提升到 FOREGROUND 级别！ // 设置 clientProcState 最高为 PROCESS_STATE_IMPORTANT_BACKGROUND！ if (clientProcState &lt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123; clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND; &#125; &#125; // 如果当前进程的 state 优先级低于 client 进程的 state，设置二者相等！ if (procState &gt; clientProcState) &#123; procState = clientProcState; &#125; // 如果当前进程的状态高于 PROCESS_STATE_IMPORTANT_BACKGROUND // 并且绑定时候设置了 BIND_SHOWING_UI 标志位，那就设置 pendingUiClean 为 true if (procState &lt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND &amp;&amp; (cr.flags &amp; Context.BIND_SHOWING_UI) != 0) &#123; app.pendingUiClean = true; &#125; // debug 调试相关，暂不处理！ if (adjType != null) &#123; app.adjType = adjType; app.adjTypeCode = ActivityManager.RunningAppProcessInfo .REASON_SERVICE_IN_USE; app.adjSource = cr.binding.client; app.adjSourceProcState = clientProcState; app.adjTarget = s.name; &#125; &#125;///------------------------------------------------------------------------------------------------------------ //【9.2.1.2】如果 bind 的时候设置了 BIND_TREAT_LIKE_ACTIVITY，设置其 treatLikeActivity 为 true！ if ((cr.flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; app.treatLikeActivity = true; &#125;///----------------------------------------------------------------------------------------------------------- final ActivityRecord a = cr.activity; // 获得绑定该 service 的 activity！ //【9.2.1.3】如果 bind 的时候设置了 BIND_ADJUST_WITH_ACTIVITY， // 表示系统根据绑定 service 的 activity 的重要程度来调整这个 service 的优先级！ if ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != 0) &#123; // 如果存在绑定者 activity，并且进程此时的 adj 大于 FOREGROUND_APP_ADJ // 同时 activity 是可见的，或者 activity 处于 resume 或者 pause 状态， // 那就需要调整其 adj 为 FOREGROUND_APP_ADJ！ if (a != null &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp; (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) &#123; adj = ProcessList.FOREGROUND_APP_ADJ; // 那就需要调整其 adj 为 FOREGROUND_APP_ADJ！ // 接着判断 flags 是否设置了 BIND_NOT_FOREGROUND 标志位， // 该 flags 表示被绑定的 service 永远不会有运行于前台的优先级，如果没有设置，进入该分支！ if ((cr.flags &amp; Context.BIND_NOT_FOREGROUND) == 0) &#123; // 接着判断 flags 是否设置了 BIND_IMPORTANT 标志位， // 该标志位表示服务对客户端是非常重要的，会将服务提升至前台进程优先级！ // 调整其所属的调度组； if ((cr.flags &amp; Context.BIND_IMPORTANT) != 0) &#123; schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND; &#125; else &#123; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; &#125; &#125; app.cached = false; app.adjType = \"service\"; app.adjTypeCode = ActivityManager.RunningAppProcessInfo .REASON_SERVICE_IN_USE; app.adjSource = a; app.adjSourceProcState = procState; app.adjTarget = s.name; &#125; &#125; &#125; &#125; &#125; ... ... ... ... // 见下面[3.1.2.1.11] 1、进入条件： `is &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND|| procState &gt; ActivityManager.PROCESS_STATE_TOP` 第一个条件：该进程中运行着服务！第二个条件：该进程的 `adj &gt; ProcessList.FOREGROUND_APP_ADJ`，只要优先级低于前台进程，都可以满足； 或者 `schedGroup == ProcessList.SCHED_GROUP_BACKGROUND`，只要调度组为后台类型，就可以满足； 或者 `procState &gt; ActivityManager.PROCESS_STATE_TOP`，只要进程状态优先级低于 `top state`； 2、处理 Service 的逻辑如下： 处理进程中通过 startService 启动的服务： 处理进程中被其他进程 bind 的服务，针对 bind 时候传入的 flags 进行不同的处理： 如果设置了 Context.BIND_WAIVE_PRIORITY： 如果设置了 Context.BIND_TREAT_LIKE_ACTIVITY： 如果设置了 Context.BIND_ADJUST_WITH_ACTIVITY： 3.3.1.11 处理持有 providers 的进程最后，来看看对持有 ContentProvider 进程的处理， 由于 ContentProvider 也是有 client 的，所以客户端的绑定也会影响其进程！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126... ... ... ... // 见上面[3.1.2.1.10] //【10】处理该进程中的 providers，判断是否有其他进程依赖这些 providers，如果有，那么该进程的 adj 会发生变化！ for (int provi = app.pubProviders.size()-1; provi &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); provi--) &#123; //【10.1】app.pubProviders 内部用于保存该进程中所有的 provider！ ContentProviderRecord cpr = app.pubProviders.valueAt(provi); for (int i = cpr.connections.size()-1; i &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); i--) &#123; ContentProviderConnection conn = cpr.connections.get(i); ProcessRecord client = conn.client; //【10.1.1】跳过那些同一个进程中的绑定！ if (client == app) &#123; continue; &#125; //【10.1.2】计算 client 进程的 adj 和 procState！ int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now); int clientProcState = client.curProcState; //【10.1.3】如果 client 的 procState 优先级比 PROCESS_STATE_CACHED_ACTIVITY 还低，调整其最低为： // PROCESS_STATE_CACHED_EMPTY，即如果 client 进程属于缓存状态，我们一律将其视为空进程； if (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123; clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; &#125; //【10.1.4】处理该进程的 adj 的优先级比 client 进程的 adj 低，那就需要调整该进程的 adj 了！ if (adj &gt; clientAdj) &#123; // 这里和 Service 的处理是一样的！ // 如果该进程已经显示过了 ui，并且不是 home proces，且其 client 进程的 adj 优先级低于可感知 // 那就不考虑 client 进程对当前进程的影响，不调整其 adj！ if (app.hasShownUi &amp;&amp; app != mHomeProcess &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; app.adjType = \"cch-ui-provider\"; &#125; else &#123; // 否则，将当前进程的 adj 调整为 client 进程的 adj，但是不超过 FOREGROUND_APP_ADJ！ adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ; app.adjType = \"provider\"; &#125; app.cached &amp;= client.cached; // debug 相关，不处理！ app.adjTypeCode = ActivityManager.RunningAppProcessInfo .REASON_PROVIDER_IN_USE; app.adjSource = client; app.adjSourceProcState = clientProcState; app.adjTarget = cpr.name; &#125; //【10.1.5】调整该进程的 procState！！ // 如果 client 进程的 procState 优先级不高于 top process 的状态，我们要对 clientProcState 做一下调整！ if (clientProcState &lt;= ActivityManager.PROCESS_STATE_TOP) &#123; // 要先调整下 client 进程的 procState！ if (clientProcState == ActivityManager.PROCESS_STATE_TOP) &#123; // 如果 client 进程是 top 级别的，设置 mayBeTop 为 true，此时我们不会立刻做调整，后续会做调整！ // 设置 clientProcState 为 PROCESS_STATE_CACHED_EMPTY，不做参考！ mayBeTop = true; clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; &#125; else &#123; // 如果 clientProcState 小于 PROCESS_STATE_TOP，说明 client 进程的优先级比 top process // 还要高，比如 persistent 进程，这种情况不会将当前进程调整为 top，而是需要 // 调整 clientProcState 的值，作为参考，这里是设置其为 PROCESS_STATE_BOUND_FOREGROUND_SERVICE clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE; &#125; &#125; // 如果此时该进程的 procState 优先级低于 client 进程的 procState，提高其等于 client 进程的 procState if (procState &gt; clientProcState) &#123; procState = clientProcState; &#125; //【10.1.6】调整该进程的调度组 schedGroup！ if (client.curSchedGroup &gt; schedGroup) &#123; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; &#125; &#125; //【10.2】如何当前的 provider 依赖于一些 external (non-framework) process， // 那么我们要保证当前进程的 adj 至少为 FOREGROUND_APP_ADJ if (cpr.hasExternalProcessHandles()) &#123; if (adj &gt; ProcessList.FOREGROUND_APP_ADJ) &#123; adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.adjType = \"provider\"; app.adjTarget = cpr.name; &#125; if (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123; procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; &#125; &#125; &#125; //【11】如果该进程中之前有 provider 活跃过，并且距离上一次 provider 活时间超过了 20 秒 // 对该进程的 adj，schedGroup 和 procState 做进一步调整； if (app.lastProviderTime &gt; 0 &amp;&amp; (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) &gt; now) &#123; if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123; adj = ProcessList.PREVIOUS_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = \"provider\"; &#125; if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; &#125; &#125; ... ... ...// 见下面[3.1.2.1.12] 这个方法的流程很长，我们总结一下整个的计算过程： 整个的计算过程是从优先级高的 adj 开始，逐级向下遍历，逐渐的调整进程的 oomAdj 和 procState 的状态，知道找到一个合适的 oomAdj 和 procState 值！ 3.3.1.12 最后调整阶段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113 ... ... ...// 见上面[3.1.2.1.11] //【12】处理 top process 绑定了当前进程的 Service 或者 Provider 的情况！ if (mayBeTop &amp;&amp; procState &gt; ActivityManager.PROCESS_STATE_TOP) &#123; // top 进程绑定了该进程 Service 或者 provider，我们应该将该进程也设置为 top 状态 // 但是如果此时该进程因为一些原因正在后台运行，我们会将其设置到特定的状态！ switch (procState) &#123; case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND: // 很重要，可以感知到； case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND: // 很重要，感知不到； case ActivityManager.PROCESS_STATE_SERVICE: // 后台服务； // 上面这三这种状态都是会长时间保持的状态，将其设置为 PROCESS_STATE_BOUND_FOREGROUND_SERVICE！ // 在所有的后台进程之上 procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE; break; default: // 其他情况，该进程的状态为 top procState = ActivityManager.PROCESS_STATE_TOP; break; &#125; &#125; //【13】如果该进程的 procState 优先级低于 PROCESS_STATE_CACHED_EMPTY，表示当前进程是一个 cache 进程！ if (procState &gt;= ActivityManager.PROCESS_STATE_CACHED_EMPTY) &#123; if (app.hasClientActivities) &#123; // hasClientActivities 为 true，表示该进程内部有 activity 作为客户端绑定其他的服务！ // 调整 procState 为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT; app.adjType = \"cch-client-act\"; &#125; else if (app.treatLikeActivity) &#123; // treatLikeActivity 为 true，表示该进程需要被当作有 activity 的进程对待！ // 设置 procState 为 PROCESS_STATE_CACHED_ACTIVITY procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY; app.adjType = \"cch-as-act\"; &#125; &#125; //【14】如果该进程的 adj 等于 SERVICE_ADJ，这边会对进程根据 Service A list 和 Service B list 做一个划分！ if (adj == ProcessList.SERVICE_ADJ) &#123; // doingAll 为 true 表示本次 update 更新的是所有进程的 adj，只有在空参数 update 调用的时候会为 true！ if (doingAll) &#123; // 先判断该进程是否是 Service B list 进程 app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs / 3); mNewNumServiceProcs++; // 计算最新的服务进程数， + 1； //Slog.i(TAG, \"ADJ \" + app + \" serviceb=\" + app.serviceb); if (!app.serviceb) &#123; // This service isn't far enough down on the LRU list to // normally be a B service, but if we are low on RAM and it // is large we want to force it down since we would prefer to // keep launcher over it. // 如果不是 Service B list，但内存回收等级过高，也被视为 Service B list if (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) &#123; app.serviceHighRam = true; app.serviceb = true; //Slog.i(TAG, \"ADJ \" + app + \" high ram!\"); &#125; else &#123; // Service A list 类型的进程数 + 1； mNewNumAServiceProcs++; //Slog.i(TAG, \"ADJ \" + app + \" not high ram!\"); &#125; &#125; else &#123; app.serviceHighRam = false; &#125; &#125; if (app.serviceb) &#123; // 如果 serviceb 为 true，则该进程是 Service B list 中的！ // 设置其 adj 为 SERVICE_B_ADJ！ adj = ProcessList.SERVICE_B_ADJ; &#125; &#125; // 设置进程的 curRawAdj 为最终的计算结果！ app.curRawAdj = adj; //Slog.i(TAG, \"OOM ADJ \" + app + \": pid=\" + app.pid + // \" adj=\" + adj + \" curAdj=\" + app.curAdj + \" maxAdj=\" + app.maxAdj); if (adj &gt; app.maxAdj) &#123; adj = app.maxAdj; if (app.maxAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; &#125; &#125; // Do final modification to adj. Everything we do between here and applying // the final setAdj must be done in this function, because we will also use // it when computing the final cached adj later. Note that we don't need to // worry about this for max adj above, since max adj will always be used to // keep it out of the cached vaues. // 对上面计算出的 adj 做第二次修正计算，其返回值是进程的最终 adj！！ app.curAdj = app.modifyRawOomAdj(adj); // 设置其他的一些变量属性！ app.curSchedGroup = schedGroup; app.curProcState = procState; app.foregroundActivities = foregroundActivities; return app.curRawAdj;&#125; 这里调用了 modifyRawOomAdj 方法，根据 BIND_ABOVE_CLIENT 123456789101112131415161718192021222324int modifyRawOomAdj(int adj) &#123; // hasAboveClient 为 true，表示该进程通过 BIND_ABOVE_CLIENT 方式绑定了 Service！ // BIND_ABOVE_CLIENT 表示该进程的优先级已经超过了 Activity，也就是说当资源不够的时候 Activity 要比 Service 先死； // 所以需要降低该进程的 adj 优先级！ if (hasAboveClient) &#123; if (adj &lt; ProcessList.FOREGROUND_APP_ADJ) &#123; // System process will not get dropped, ever &#125; else if (adj &lt; ProcessList.VISIBLE_APP_ADJ) &#123; adj = ProcessList.VISIBLE_APP_ADJ; &#125; else if (adj &lt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; adj = ProcessList.PERCEPTIBLE_APP_ADJ; &#125; else if (adj &lt; ProcessList.CACHED_APP_MIN_ADJ) &#123; adj = ProcessList.CACHED_APP_MIN_ADJ; &#125; else if (adj &lt; ProcessList.CACHED_APP_MAX_ADJ) &#123; adj++; &#125; &#125; // 一般情况是直接返回第一次计算后的值的！ return adj;&#125; LRU list 中，从后往前数，前 1/3 的 service 进程就是 AService 进程，其余的就是 BService 进程； 3.3.2 ActivityManagerS.applyOomAdjLocked最后，applyOomAdjLocked 方法用来应用计算出的 adj！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) &#123; boolean success = true; //【1】更新 setRawAdj 的值！ if (app.curRawAdj != app.setRawAdj) &#123; app.setRawAdj = app.curRawAdj; // 更新 setRawAdj！ &#125; int changes = 0; // 用于记录进程的状态是否发生了变化！ //【2】更新 setAdj 的值！ if (app.curAdj != app.setAdj) &#123; ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); // 设置进程的最新 adj！ if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Set \" + app.pid + \" \" + app.processName + \" adj \" + app.curAdj + \": \" + app.adjType); app.setAdj = app.curAdj; // 更新 setAdj！ app.verifiedAdj = ProcessList.INVALID_ADJ; &#125; //【3】更新 setSchedGroup 调度组信息！ if (app.setSchedGroup != app.curSchedGroup) &#123; int oldSchedGroup = app.setSchedGroup; app.setSchedGroup = app.curSchedGroup; // 更新 setSchedGroup！ if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Setting sched group of \" + app.processName + \" to \" + app.curSchedGroup); if (app.waitingToKill != null &amp;&amp; app.curReceiver == null &amp;&amp; app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) &#123; //【3.1】杀掉那些之前延迟 kill，现在不持有 receiver 且属于后台的进程！ app.kill(app.waitingToKill, true); success = false; &#125; else &#123; //【3.2】根据调度组 curSchedGroup，设置进程组信息！ int processGroup; switch (app.curSchedGroup) &#123; case ProcessList.SCHED_GROUP_BACKGROUND: // 后台调度组: 6 processGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE; break; case ProcessList.SCHED_GROUP_TOP_APP: case ProcessList.SCHED_GROUP_TOP_APP_BOUND: // 前台调度组：5 processGroup = Process.THREAD_GROUP_TOP_APP; break; default: // 默认调度组：-1 processGroup = Process.THREAD_GROUP_DEFAULT; break; &#125; long oldId = Binder.clearCallingIdentity(); try &#123; //【3.3】设置进程的调度组！ Process.setProcessGroup(app.pid, processGroup); //【3.4】根据调度组，设置 if (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) &#123; // do nothing if we already switched to RT //【3.3.1】如果之前进程的调度组不是 top app 级别，而现在的调度组是 top app 级别，进入这里！ if (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123; // Switch VR thread for app to SCHED_FIFO if (mInVrMode &amp;&amp; app.vrThreadTid != 0) &#123; try &#123; // 如果进程启动了 VR Process.setThreadScheduler(app.vrThreadTid, Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, 1); &#125; catch (IllegalArgumentException e) &#123; // thread died, ignore &#125; &#125; if (mUseFifoUiScheduling) &#123; // Switch UI pipeline for app to SCHED_FIFO app.savedPriority = Process.getThreadPriority(app.pid); try &#123; Process.setThreadScheduler(app.pid, Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, 1); &#125; catch (IllegalArgumentException e) &#123; // thread died, ignore &#125; if (app.renderThreadTid != 0) &#123; try &#123; Process.setThreadScheduler(app.renderThreadTid, Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, 1); &#125; catch (IllegalArgumentException e) &#123; // thread died, ignore &#125; if (DEBUG_OOM_ADJ) &#123; Slog.d(\"UI_FIFO\", \"Set RenderThread (TID \" + app.renderThreadTid + \") to FIFO\"); &#125; &#125; else &#123; if (DEBUG_OOM_ADJ) &#123; Slog.d(\"UI_FIFO\", \"Not setting RenderThread TID\"); &#125; &#125; &#125; else &#123; // Boost priority for top app UI and render threads Process.setThreadPriority(app.pid, -10); if (app.renderThreadTid != 0) &#123; try &#123; Process.setThreadPriority(app.renderThreadTid, -10); &#125; catch (IllegalArgumentException e) &#123; // thread died, ignore &#125; &#125; &#125; &#125; &#125; else if (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &amp;&amp; app.curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123; //【3.3.2】如果之前进程的调度组是 top app 级别，而现在的调度组不是 top app 级别，则进入这里！ // Reset VR thread to SCHED_OTHER // Safe to do even if we're not in VR mode // 进程的 vrThreadTid 不等于 0，说明我们在 VR 模式！ if (app.vrThreadTid != 0) &#123; Process.setThreadScheduler(app.vrThreadTid, Process.SCHED_OTHER, 0); &#125; if (mUseFifoUiScheduling) &#123; // Reset UI pipeline to SCHED_OTHER Process.setThreadScheduler(app.pid, Process.SCHED_OTHER, 0); Process.setThreadPriority(app.pid, app.savedPriority); if (app.renderThreadTid != 0) &#123; Process.setThreadScheduler(app.renderThreadTid, Process.SCHED_OTHER, 0); Process.setThreadPriority(app.renderThreadTid, -4); &#125; &#125; else &#123; // Reset priority for top app UI and render threads Process.setThreadPriority(app.pid, 0); if (app.renderThreadTid != 0) &#123; Process.setThreadPriority(app.renderThreadTid, 0); &#125; &#125; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Failed setting process group of \" + app.pid + \" to \" + app.curSchedGroup); e.printStackTrace(); &#125; finally &#123; Binder.restoreCallingIdentity(oldId); &#125; &#125; &#125; //【4】接下来是记录进程的信息和状态的变化！ // 进程内部的 acitivity 的状态发生了变化！ProcessChangeItem.CHANGE_ACTIVITIES if (app.repForegroundActivities != app.foregroundActivities) &#123; app.repForegroundActivities = app.foregroundActivities; // 更新 repForegroundActivities！ changes |= ProcessChangeItem.CHANGE_ACTIVITIES; &#125; //【5】进程状态发生了变化，通知上层应用进程！！ if (app.repProcState != app.curProcState) &#123; app.repProcState = app.curProcState; // 更新 repProcState！ changes |= ProcessChangeItem.CHANGE_PROCESS_STATE; if (app.thread != null) &#123; try &#123; if (false) &#123; //RuntimeException h = new RuntimeException(\"here\"); Slog.i(TAG, \"Sending new process state \" + app.repProcState + \" to \" + app /*, h*/); &#125; //【5.1】通知上层进程！ app.thread.setProcessState(app.repProcState); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; //【5】如果进程在先后状态下的内存状态不同，那就要更新下下次申请 PSS 的时间！ if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) &#123; if (false &amp;&amp; mTestPssMode &amp;&amp; app.setProcState &gt;= 0 &amp;&amp; app.lastStateTime &lt;= (now - 200)) &#123; // 用于 debug！ long start = SystemClock.uptimeMillis(); // 记录 PPS 物理内存！ long pss = Debug.getPss(app.pid, mTmpLong, null); recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], mTmpLong[1], now); // 从 mPendingPssProcesses 列表中删除当前进程！ mPendingPssProcesses.remove(app); Slog.i(TAG, \"Recorded pss for \" + app + \" state \" + app.setProcState + \" to \" + app.curProcState + \": \" + (SystemClock.uptimeMillis()-start) + \"ms\"); &#125; app.lastStateTime = now; //【5.1】更新下次申请 pss 内存的时间！ app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleepingLocked(), now); if (DEBUG_PSS) Slog.d(TAG_PSS, \"Process state change from \" + ProcessList.makeProcStateString(app.setProcState) + \" to \" + ProcessList.makeProcStateString(app.curProcState) + \" next pss in \" + (app.nextPssTime-now) + \": \" + app); &#125; else &#123; //【5.2】如果当前时间已经超过了 nextPssTime 下一次申请 PSS 的时间 // 那就要请求 PSS 物理内存！ if (now &gt; app.nextPssTime || (now &gt; (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) &amp;&amp; now &gt; (app.lastStateTime + ProcessList.minTimeFromStateChange( mTestPssMode)))) &#123; // 请求物理内存！ requestPssLocked(app, app.setProcState); app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, mTestPssMode, isSleepingLocked(), now); &#125; else if (false &amp;&amp; DEBUG_PSS) Slog.d(TAG_PSS, \"Not requesting PSS of \" + app + \": next=\" + (app.nextPssTime-now)); &#125; //【6】更新 setProcState 属性！ if (app.setProcState != app.curProcState) &#123; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, \"Proc state change of \" + app.processName + \" to \" + app.curProcState); // 计算进程状态变化前后的重要性！ boolean setImportant = app.setProcState &lt; ActivityManager.PROCESS_STATE_SERVICE; boolean curImportant = app.curProcState &lt; ActivityManager.PROCESS_STATE_SERVICE; if (setImportant &amp;&amp; !curImportant) &#123; // 如果进程变的不重要了，需要记录下其 wake time，用于后续的 kill 操作！ BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); synchronized (stats) &#123; app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed); &#125; app.lastCpuTime = app.curCpuTime; &#125; // 更新进程的使用情况！ maybeUpdateUsageStatsLocked(app, nowElapsed); // 更新 setProcState！ app.setProcState = app.curProcState; if (app.setProcState &gt;= ActivityManager.PROCESS_STATE_HOME) &#123; app.notCachedSinceIdle = false; &#125; if (!doingAll) &#123; setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now); &#125; else &#123; app.procStateChanged = true; &#125; &#125; else if (app.reportedInteraction &amp;&amp; (nowElapsed - app.interactionEventTime) &gt; USAGE_STATS_INTERACTION_INTERVAL) &#123; // For apps that sit around for a long time in the interactive state, we need // to report this at least once a day so they don't go idle. maybeUpdateUsageStatsLocked(app, nowElapsed); &#125; //【7】如果 changes 不等于 0，说明进程的状态信息发生了变化！ // 我们需要将这次的改变封装为 mPendingProcessChanges，通知那些监控进程变化的服务！ if (changes != 0) &#123; if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS, \"Changes in \" + app + \": \" + changes); // 判断该进程是否已经有一个 ProcessChangeItem！ int i = mPendingProcessChanges.size()-1; ProcessChangeItem item = null; while (i &gt;= 0) &#123; item = mPendingProcessChanges.get(i); if (item.pid == app.pid) &#123; if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS, \"Re-using existing item: \" + item); break; &#125; i--; &#125; // i &lt; 0 说明该进程没有已存在的等待处理的 ProcessChangeItem 项，那就创建一个新的！ if (i &lt; 0) &#123; final int NA = mAvailProcessChanges.size(); // 尝试从 mAvailProcessChanges 中回收复用一个 ProcessChangeItem 项！ // 不能回收，就创建一个新的！ if (NA &gt; 0) &#123; item = mAvailProcessChanges.remove(NA-1); if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS, \"Retrieving available item: \" + item); &#125; else &#123; item = new ProcessChangeItem(); if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS, \"Allocating new item: \" + item); &#125; // 初始化变量！ item.changes = 0; item.pid = app.pid; item.uid = app.info.uid; if (mPendingProcessChanges.size() == 0) &#123; if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS, \"*** Enqueueing dispatch processes changed!\"); mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget(); &#125; // 添加到 mPendingProcessChanges 列表中！ mPendingProcessChanges.add(item); &#125; // 设置 ProcessChangeItem 的属性！ item.changes |= changes; item.processState = app.repProcState; item.foregroundActivities = app.repForegroundActivities; if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS, \"Item \" + Integer.toHexString(System.identityHashCode(item)) + \" \" + app.toShortString() + \": changes=\" + item.changes + \" procState=\" + item.processState + \" foreground=\" + item.foregroundActivities + \" type=\" + app.adjType + \" source=\" + app.adjSource + \" target=\" + app.adjTarget); &#125; return success;&#125; 4 总结首先，我们知道对于进程的优先级，Android 有 2 套分级机制： ActivityManagerService 中对进程优先级的分级，以 PROCESS_STATE_ 开头，定义在 ActivityManager.java 中; LowMemoryKiller 通过 oomAdj 对进程优先级的分级; //开始逆序处理LRU中的每一个进程 // 对应重要性大于home的进程而言，重要性越高，内存回收等级越低 // 对于重要性小于home的进程，排在LRU表越靠后，即越重要回收等级越高 // 这么安排的理由有两个：1、此时越不重要的进程，其中运行的组件越少，能够回收的内存不多，不需要高回收等级 // 2、越不重要的进程越有可能被LMK kill掉，没必要以高等级回收内存 Android 并不是 kill 掉所有 Empty 进程后，才 kill 后台进程。它是将 CACHED_APP_MIN_ADJ 和 CACHED_APP_MAX_ADJ 之间的范围，分成 3 个 slot。 然后在每个 slot 中，分别分配一定量的后台进程和 Empty 进程。在单独的 slot 中，会先 kill 掉 empty 进程，后 kill 掉后台进程。只有当一个 slot 中的进程 kill 完毕后，才会 kill 掉下一个 slot 中的进程。我们将从后面的代码中，得到对应的分析依据，这里先有个印象即可。 http://blog.csdn.net/Gaugamela/article/details/54176460 http://www.cnblogs.com/tiger-wang-ms/p/6445213.html","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Process进程","slug":"AndroidFramework源码分析/Process进程","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Process进程/"}],"tags":[{"name":"Process进程","slug":"Process进程","permalink":"https://coolqi.top/tags/Process进程/"}]},{"title":"BroadcastReceiver篇 5 - sendBroadcast 流程分析","slug":"BroadcastReceiver5-sendBroadcast","date":"2016-05-10T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/05/10/BroadcastReceiver5-sendBroadcast/","link":"","permalink":"https://coolqi.top/2016/05/10/BroadcastReceiver5-sendBroadcast/","excerpt":"","text":"[toc] 本文基于 Android 7.1.1，分析发送广播的流程，转载请说明出处！ 写本文的目的： 了解广播发送的流程； 了解 AMS 对广播接收者组件的管理； 记录自己的研究和分析； 0 综述在 Android 系统中，有如下种类的广播，他们的发送方式各不一样，我们先来简单的了解一下： 1. 普通广播 发送普通广播的方法如下：123sendBroadcast(...)sendBroadcastMultiplePermissions(...)sendBroadcastAsUser(...) 普通广播的发送参数 serialized 为 false，sticky 也为 false，表示普通广播既不是粘性的，也不是无序的； 对于普通广播，AMS 会针对其接收者的类型做不同的处理： 对于动态注册的广播接收者，AMS 会遍历对应的目标接收者集合，依次发送广播； 对于静态注册的广播接收者，AMS 在发送普通广播时，会按照有序的方式来进行分发； 由此可见，对于普通广播来说，动态注册的广播接收者会先接收到广播！ 2. 有序广播 发送有序广播的方法如下：12sendOrderedBroadcast(...)sendOrderedBroadcastAsUser(...) 有序广播的发送参数 serialized 为 true，sticky 为 false； 对于有序广播，AMS 会收集能够匹配的静态注册和动态注册的广播接收者，按照优先级们，依次有序的发送广播！ AMS 收到上一个 BroadcastReceiver 处理完毕的消息返回后，才会将广播发送给下一个 BroadcastReceiver；其中，任意一个 BroadcastReceiver，都可以中止后续的广播分发流程；同时，上一个 BroadcastReceiver 可以将额外的信息添加到广播中。 对于发送给静态注册的广播接收者的普通广播，AMS 是将其按照发送有序广播的方式来进行发送的，因为静态注册的接收者由于其注册方式的特殊性，其所在进程可能没有被启动，所以如果采用并发的方式发送，那么系统需要在同一时间启动大量的进程，这显然不是合理的设计！ 3. 粘性广播 发送粘性广播的方法如下：12sendStickyBroadcast(...)sendStickyBroadcastAsUser(...) 粘性广播的发送参数 serialized 为 false，sticky 为 true； 粘性广播的特性是系统会保存这个广播，当系统中又新注册了一个广播接收者时，该接收者会立刻接收到这个广播，粘性广播默认属于普通广播！ 4. 粘性有序广播 发送粘性有序广播的方法如下：1sendStickyOrderedBroadcast(...) 粘性广播的发送参数 serialized 为 true，sticky 为 true； 粘性有序广播本质上属于有序广播，只不过其具有 “粘性”！ 本篇文章，会主要分析下广播的发送和处理过程： 1 发送者进程1.1 ContextWapper.sendBroadcast1234567@Overridepublic void sendBroadcast(Intent intent) &#123; //【1.2】继续调用 mBase.sendBroadcast(intent);&#125;... ... ... ... 这里的 mBase 对象是 ContextImpl 实例，其他的方法的调用方式也是一样的！ 1.2 ContextImpl.sendBroadcast进入 ContextImpl，我们看看不同的 send 方法都做了什么操作：123456789101112131415@Overridepublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); //【1.3】开始发送广播！ ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 可以看到，这里最终调用了 AMS 的 broadcastIntent 方法！ 12345/** &#123;@hide&#125; */@Overridepublic int getUserId() &#123; return mUser.getIdentifier();&#125; getUserId 方法用来获得进程所在的设备用户 id，一般我们在应用程序进程中，只能获得当前的设备用户 id，这个 id 是进程启动时获得的！ 1.3 ActivityManagerProxy.broadcastIntent我们来看一下，发送普通广播的参数传递： IApplicationThread caller：发送者进程的 ApplicationThread 对象，用于跨进程通信！ Intent intent：广播 Intent String resolvedType： IIntentReceiver resultTo：广播发送后的结果反馈对象，这里传入 null！ int resultCode：广播发送后的结果反馈码，这里传入 Activity.RESULT_OK！ String resultData： 广播发送后的结果反馈数据，这里传入 null！ Bundle map：传入 null； String[] requiredPermissions：广播接受者需要的权限，传入 null 或者指定的权限数组！ int appOp：发送广播相关的应用操作，传入 AppOpsManager.OP_NONE 或者指定的操作！ Bundle options：广播携带的参数信息，传入 null 或者指定的 Bundle 对象！ boolean serialized：广播是否是序列化的，普通的广播传入 false； boolean sticky： 广播是否是粘性的，传入 false； int userId：当前的设备用户 id； 1234567891011121314151617181920212223242526272829public int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null); data.writeInt(resultCode); data.writeString(resultData); data.writeBundle(map); data.writeStringArray(requiredPermissions); data.writeInt(appOp); data.writeBundle(options); data.writeInt(serialized ? 1 : 0); data.writeInt(sticky ? 1 : 0); data.writeInt(userId); //【1】BROADCAST_INTENT_TRANSACTION binder 消息！ mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); reply.recycle(); data.recycle(); return res;&#125; 下面，就是进入系统进程！ 2 系统进程首先，进入 ActivityManagerNative 中：12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case BROADCAST_INTENT_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); //【1】获得代理对象 ApplicationThreadProxy！ IApplicationThread app = b != null ? ApplicationThreadNative.asInterface(b) : null; Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); //【2】显然这里的 resultTo = null; b = data.readStrongBinder(); IIntentReceiver resultTo = b != null ? IIntentReceiver.Stub.asInterface(b) : null; //【3】得到 Activity.RESULT_OK int resultCode = data.readInt(); //【4】均为 null！ String resultData = data.readString(); Bundle resultExtras = data.readBundle(); String[] perms = data.readStringArray(); int appOp = data.readInt(); Bundle options = data.readBundle(); boolean serialized = data.readInt() != 0; boolean sticky = data.readInt() != 0; int userId = data.readInt(); //【2.1】调用 AMS 的 broadcastIntent 方法继续发送广播！ int res = broadcastIntent(app, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, perms, appOp, options, serialized, sticky, userId); reply.writeNoException(); reply.writeInt(res); return true; &#125;&#125; 我们进入 AMS 的方法中去看看： 2.1 AMService.broadcastIntent这里的参数和之前保持一致，不用多说！ 12345678910111213141516171819202122232425262728public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) &#123; // 首先判断进程是否隔离！ enforceNotIsolatedCaller(\"broadcastIntent\"); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); //【1】获得发送者所在进程！ final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); //【×2.2】调用 broadcastIntentLocked 方法继续处理广播的分发！ int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 2.2 AMService.broadcastIntentLocked这里我们再来看看参数传递： ProcessRecord callerApp：发送者所在的进程对象 String callerPackage：发送者所在的应用包名 Intent intent：广播 Intent String resolvedType： IIntentReceiver resultTo： 广播发送后的结果反馈对象； int resultCode：广播发送后的结果反馈码，这里传入 Activity.RESULT_OK； String resultData：广播发送后的结果反馈数据，这里传入 null； Bundle resultExtras： 传入 null； String[] requiredPermissions： 广播接受者需要的权限，传入 null 或者指定的权限数组； int appOp：发送广播相关的应用操作，传入 AppOpsManager.OP_NONE 或者指定的操作； Bundle bOptions：广播携带的参数信息，传入 null 或者指定的 Bundle 对象； boolean ordered：广播是否是有序广播还是普通广播； boolean sticky：广播是否是粘性的； int callingPid：发送者所在进程的 pid； int callingUid：发送者所在进程的 uid； int userId：目标设备用户 id； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; intent = new Intent(intent); //【1】给 intent 添加 Intent.FLAG_EXCLUDE_STOPPED_PACKAGES 标志位！ // 禁止广播发送给被强制停止的应用！ intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); //【2】如果系统还没有完成启动，并且广播没有设置 FLAG_RECEIVER_BOOT_UPGRADE 标志位！ // 那就给广播 Intent 添加 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位 // 这样，该广播就不会发送给静态注册的广播接收者了，也就不会拉起其所在的进程！ if (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123; intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); &#125; if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, (sticky ? \"Broadcast sticky: \": \"Broadcast: \") + intent + \" ordered=\" + ordered + \" userid=\" + userId); if ((resultTo != null) &amp;&amp; !ordered) &#123; Slog.w(TAG, \"Broadcast \" + intent + \" not ordered but result callback requested!\"); &#125; userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, \"broadcast\", callerPackage); //【3】判断接受该广播的设备用户是否运行，如果没有运行，就停止发送广播！ if (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserRunningLocked(userId, 0)) &#123; if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123; Slog.w(TAG, \"Skipping broadcast of \" + intent + \": user \" + userId + \" is stopped\"); return ActivityManager.BROADCAST_FAILED_USER_STOPPED; &#125; &#125; //【4】如果广播带有附加参数，用于修改 doze 临时白名单，那么就要校验是否有 // CHANGE_DEVICE_IDLE_TEMP_WHITELIST 权限！ BroadcastOptions brOptions = null; if (bOptions != null) &#123; brOptions = new BroadcastOptions(bOptions); if (brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123; if (checkComponentPermission( android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) &#123; String msg = \"Permission Denial: \" + intent.getAction() + \" broadcast from \" + callerPackage + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" requires \" + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; &#125; &#125; //【5】判断该广播是否是被保护的广播，被保护的广播只能由系统发送！ final String action = intent.getAction(); final boolean isProtectedBroadcast; try &#123; //【×2.2.2】判断是否是保护广播！ isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action); &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Remote exception\", e); return ActivityManager.BROADCAST_SUCCESS; &#125; //【6】判断发送者进程是否是系统进程； final boolean isCallerSystem; switch (UserHandle.getAppId(callingUid)) &#123; case Process.ROOT_UID: case Process.SYSTEM_UID: case Process.PHONE_UID: case Process.BLUETOOTH_UID: case Process.NFC_UID: isCallerSystem = true; break; default: isCallerSystem = (callerApp != null) &amp;&amp; callerApp.persistent; break; &#125; //【7】安全校验，禁止非系统的 app 发送受保护的广播！ if (!isCallerSystem) &#123; if (isProtectedBroadcast) &#123; //【7.1】如果应用是非系统应用，但是广播是受保护的，那就抛出异常！ String msg = \"Permission Denial: not allowed to send broadcast \" + action + \" from pid=\" + callingPid + \", uid=\" + callingUid; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123; //【7.2】如果不是受保护的广播，那么会对一些特殊广播做限制，只能发送给应用自身！ if (callerPackage == null) &#123; String msg = \"Permission Denial: not allowed to send broadcast \" + action + \" from unknown caller.\"; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; else if (intent.getComponent() != null) &#123; // 如果指定了组件名，那么会校验下组件所属的包名是否和发送者一样！ if (!intent.getComponent().getPackageName().equals( callerPackage)) &#123; String msg = \"Permission Denial: not allowed to send broadcast \" + action + \" to \" + intent.getComponent().getPackageName() + \" from \" + callerPackage; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; &#125; else &#123; // 设置包名，限制目标包为自身！ intent.setPackage(callerPackage); &#125; &#125; &#125; //【8】针对一些特殊 action 的广播进行处理，比如 uid 被移除，package 相关的广播，外置应用是否可用！ if (action != null) &#123; switch (action) &#123; case Intent.ACTION_UID_REMOVED: case Intent.ACTION_PACKAGE_REMOVED: case Intent.ACTION_PACKAGE_CHANGED: case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE: case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: case Intent.ACTION_PACKAGES_SUSPENDED: case Intent.ACTION_PACKAGES_UNSUSPENDED: //【8.1】首先判断发送者是否有 android.Manifest.permission.BROADCAST_PACKAGE_REMOVED 权限！ // 没有的话，抛出异常！ if (checkComponentPermission( android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) &#123; String msg = \"Permission Denial: \" + intent.getAction() + \" broadcast from \" + callerPackage + \" (pid=\" + callingPid + \", uid=\" + callingUid + \")\" + \" requires \" + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; switch (action) &#123; case Intent.ACTION_UID_REMOVED: //【8.2】如果是 Intent.ACTION_UID_REMOVED，就从 mBatteryStatsService // 和 mAppOpsService 中移除这个 uid 的信息！ final Bundle intentExtras = intent.getExtras(); final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1; if (uid &gt;= 0) &#123; mBatteryStatsService.removeUid(uid); mAppOpsService.uidRemoved(uid); &#125; break; case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE: //【8.3】如果是扩展应用不可用的广播，那就清楚该应用的相关数据！ String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); if (list != null &amp;&amp; list.length &gt; 0) &#123; for (int i = 0; i &lt; list.length; i++) &#123; forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, \"storage unmount\"); &#125; mRecentTasks.cleanupLocked(UserHandle.USER_ALL); sendPackageBroadcastLocked( IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId); &#125; break; case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE: //【8.4】如果是扩展应用可用的广播，那就只清楚最近任务中的数据！ mRecentTasks.cleanupLocked(UserHandle.USER_ALL); break; case Intent.ACTION_PACKAGE_REMOVED: case Intent.ACTION_PACKAGE_CHANGED: //【8.5】如果是 package 移除或改变的广播，进入这里！！ // CHANGED 广播一般是在某个组件 enabled or disabled 的时候！ Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; //【8.5.1】判断是否是覆盖安装，卸载！ boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action); final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false); final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false); // 这里的 fullUninstall 表示是否完全卸载，卸载掉覆盖安装的 apk，replacing 为 true！ final boolean fullUninstall = removed &amp;&amp; !replacing; //【8.5.2】应用包被移除了，进入该分支！ if (removed) &#123; if (killProcess) &#123; //【8.5.2.1】杀掉进程！ forceStopPackageLocked(ssp, UserHandle.getAppId( intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? \"pkg removed\" : \"pkg changed\"); &#125; final int cmd = killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL; sendPackageBroadcastLocked(cmd, new String[] &#123;ssp&#125;, userId); //【8.5.2.2】如果是卸载应用的话，移除该应用的所有信息：包括 uid 信息，uri 权限信息 // 最近任务，以及电池使用信息！ if (fullUninstall) &#123; mAppOpsService.packageRemoved( intent.getIntExtra(Intent.EXTRA_UID, -1), ssp); removeUriPermissionsForPackageLocked(ssp, userId, true); removeTasksByPackageNameLocked(ssp, userId); if (mUnsupportedDisplaySizeDialog != null &amp;&amp; ssp.equals( mUnsupportedDisplaySizeDialog.getPackageName())) &#123; mUnsupportedDisplaySizeDialog.dismiss(); mUnsupportedDisplaySizeDialog = null; &#125; mCompatModePackages.handlePackageUninstalledLocked(ssp); mBatteryStatsService.notePackageUninstalled(ssp); &#125; &#125; else &#123; //【8.5.3】应用包没有被移除，进入该分支，如果需要是杀掉进程，那就执行 kill 操作！ if (killProcess) &#123; killPackageProcessesLocked(ssp, UserHandle.getAppId( intent.getIntExtra(Intent.EXTRA_UID, -1)), userId, ProcessList.INVALID_ADJ, false, true, true, false, \"change \" + ssp); &#125; //【8.5.4】清除掉 disable 的包组件！ cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra( Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST)); &#125; &#125; break; case Intent.ACTION_PACKAGES_SUSPENDED: case Intent.ACTION_PACKAGES_UNSUSPENDED: //【8.6】如果是 SUSPENDED 或 UNSUSPENDED 的广播，进入这里！！ final boolean suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals( intent.getAction()); final String[] packageNames = intent.getStringArrayExtra( Intent.EXTRA_CHANGED_PACKAGE_LIST); final int userHandle = intent.getIntExtra( Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL); synchronized(ActivityManagerService.this) &#123; mRecentTasks.onPackagesSuspendedChanged( packageNames, suspended, userHandle); &#125; break; &#125; break; case Intent.ACTION_PACKAGE_REPLACED: &#123; //【8.7】如果是 REPLACED （覆盖安装的时候）的广播，进入这里！！ final Uri data = intent.getData(); final String ssp; if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123; final ApplicationInfo aInfo = getPackageManagerInternalLocked().getApplicationInfo( ssp, userId); if (aInfo == null) &#123; Slog.w(TAG, \"Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:\" + \" ssp=\" + ssp + \" data=\" + data); return ActivityManager.BROADCAST_SUCCESS; &#125; mStackSupervisor.updateActivityApplicationInfoLocked(aInfo); sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED, new String[] &#123;ssp&#125;, userId); &#125; break; &#125; case Intent.ACTION_PACKAGE_ADDED: &#123; //【8.8】如果是 ADDED （全新安装的时候）的广播，进入这里！！ Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123; final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false); mCompatModePackages.handlePackageAddedLocked(ssp, replacing); try &#123; ApplicationInfo ai = AppGlobals.getPackageManager(). getApplicationInfo(ssp, 0, 0); mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0); &#125; catch (RemoteException e) &#123; &#125; &#125; break; &#125; case Intent.ACTION_PACKAGE_DATA_CLEARED: &#123; //【8.9】如果是 PACKAGE_DATA_CLEARED （清楚数据）的广播，进入这里！！ Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp = data.getSchemeSpecificPart()) != null) &#123; // Hide the \"unsupported display\" dialog if necessary. if (mUnsupportedDisplaySizeDialog != null &amp;&amp; ssp.equals( mUnsupportedDisplaySizeDialog.getPackageName())) &#123; mUnsupportedDisplaySizeDialog.dismiss(); mUnsupportedDisplaySizeDialog = null; &#125; mCompatModePackages.handlePackageDataClearedLocked(ssp); &#125; break; &#125; case Intent.ACTION_TIMEZONE_CHANGED: // If this is the time zone changed action, queue up a message that will reset // the timezone of all currently running processes. This message will get // queued up before the broadcast happens. mHandler.sendEmptyMessage(UPDATE_TIME_ZONE); break; case Intent.ACTION_TIME_CHANGED: // If the user set the time, let all running processes know. final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1 : 0; mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0)); BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); synchronized (stats) &#123; stats.noteCurrentTimeChangedLocked(); &#125; break; case Intent.ACTION_CLEAR_DNS_CACHE: mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG); break; case Proxy.PROXY_CHANGE_ACTION: ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO); mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy)); break; case android.hardware.Camera.ACTION_NEW_PICTURE: case android.hardware.Camera.ACTION_NEW_VIDEO: // These broadcasts are no longer allowed by the system, since they can // cause significant thrashing at a crictical point (using the camera). // Apps should use JobScehduler to monitor for media provider changes. Slog.w(TAG, action + \" no longer allowed; dropping from \" + UserHandle.formatUid(callingUid)); if (resultTo != null) &#123; final BroadcastQueue queue = broadcastQueueForIntent(intent); try &#123; queue.performReceiveLocked(callerApp, resultTo, intent, Activity.RESULT_CANCELED, null, null, false, false, userId); &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure [\" + queue.mQueueName + \"] sending broadcast result of \" + intent, e); &#125; &#125; // Lie; we don't want to crash the app. return ActivityManager.BROADCAST_SUCCESS; &#125; &#125; //【9】如果 sticky 为 true，表示该广播为粘性广播，那就要收集到指定的集合中！ if (sticky) &#123; //【9.1】权限校验，发送粘性广播必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！ // 否则会抛出异常！ if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) &#123; String msg = \"Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=\" + callingPid + \", uid=\" + callingUid + \" requires \" + android.Manifest.permission.BROADCAST_STICKY; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; //【9.2】对于粘性广播，不能强制广播接收者应具有的权限！ if (requiredPermissions != null &amp;&amp; requiredPermissions.length &gt; 0) &#123; Slog.w(TAG, \"Can't broadcast sticky intent \" + intent + \" and enforce permissions \" + Arrays.toString(requiredPermissions)); return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION; &#125; //【9.3】如果粘性广播设置具体的组件，抛出异常！ if (intent.getComponent() != null) &#123; throw new SecurityException( \"Sticky broadcasts can't target a specific component\"); &#125; //【9.4】如果我们的目标设备用户 id 不是 UserHandle.USER_ALL // 那就要判断是否已经有一个相同的全局粘性广播，如果有，产生冲突，抛出异常！ if (userId != UserHandle.USER_ALL) &#123; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get( UserHandle.USER_ALL); if (stickies != null) &#123; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list != null) &#123; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; throw new IllegalArgumentException( \"Sticky broadcast \" + intent + \" for user \" + userId + \" conflicts with existing global broadcast\"); &#125; &#125; &#125; &#125; &#125; //【9.5】将该粘性广播 Intent 添加到设备用户 userId 对应的广播列表中！ // 如果之前已经添加过，就取代之前的相同粘性广播！ ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId); if (stickies == null) &#123; stickies = new ArrayMap&lt;&gt;(); mStickyBroadcasts.put(userId, stickies); &#125; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list == null) &#123; list = new ArrayList&lt;&gt;(); stickies.put(intent.getAction(), list); &#125; final int stickiesCount = list.size(); int i; for (i = 0; i &lt; stickiesCount; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; //【9.5.1】如果有重复，就取代旧的粘性广播！ list.set(i, new Intent(intent)); break; &#125; &#125; //【9.5.2】没有重复，就将这个广播添加到该粘性广播列表中！ if (i &gt;= stickiesCount) &#123; list.add(new Intent(intent)); &#125; &#125; //【10】根据传入的设备用户 id，获得广播的目标设备用户数组！ int[] users; if (userId == UserHandle.USER_ALL) &#123; // 如果 userId 为 UserHandle.USER_ALL，说明这个广播要发送给所有的设备用户， // 就调用 getStartedUserArrayLocked 方法获得当前被启动的所有的设备用户数组！ users = mUserController.getStartedUserArrayLocked(); &#125; else &#123; // 如果 userId 不为 UserHandle.USER_ALL，说明这个广播是发送给指定的设备用户的！ users = new int[] &#123;userId&#125;; &#125; //【11】收集能够接收和处理该广播的广播接收者！ // receivers 保存静态注册的广播接受者，registeredReceivers 保存动态注册的广播接收者！ List receivers = null; List&lt;BroadcastFilter&gt; registeredReceivers = null; // 判断 Intent 是否设置了 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位，如果设置了该标志位 // 那么，静态注册的广播接收者无法接受这个广播！ if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; //【×2.2.1】收集系统中匹配该广播的静态注册的广播接收者！ receivers = collectReceiverComponents(intent, resolvedType, callingUid, users); &#125; //【12】如果广播 Intent 没有设置组件信息，那就从 mReceiverResolver 中进行匹配动态注册的接收者！ // mReceiverResolver 用来保存动态注册的广播接收者信息，这个我们在前面讲过！ if (intent.getComponent() == null) &#123; if (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123; // 遍历每一个设备用户！ for (int i = 0; i &lt; users.length; i++) &#123; if (mUserController.hasUserRestriction( UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123; continue; &#125; List&lt;BroadcastFilter&gt; registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, users[i]); if (registeredReceivers == null) &#123; registeredReceivers = registeredReceiversForUser; &#125; else if (registeredReceiversForUser != null) &#123; registeredReceivers.addAll(registeredReceiversForUser); &#125; &#125; &#125; else &#123; registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, userId); &#125; &#125; //【13】判断 intent 是否设置了 FLAG_RECEIVER_REPLACE_PENDING 标志位，如果设置了。 // 那么新的 intent 会取代前面正在处于等待状态的 intent； final boolean replacePending = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueing broadcast: \" + intent.getAction() + \" replacePending=\" + replacePending); int NR = registeredReceivers != null ? registeredReceivers.size() : 0; // 动态接受者的广播！ //【14】如果该广播是普通广播，并且存在匹配的动态注册的接收器，将广播添加到队列的并行集合中！ if (!ordered &amp;&amp; NR &gt; 0) &#123; if (isCallerSystem) &#123; checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, registeredReceivers); &#125; //【×2.3.1】根据 Intent 是否设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，选择指定的前台队列或者后台队列！ final BroadcastQueue queue = broadcastQueueForIntent(intent); //【×2.3.2】创建广播对应的 BroadcastRecord 对象，发送给动态注册的广播接收者 registeredReceivers！ BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing parallel broadcast \" + r); //【×2.3.3】如果在队列的 mParallelBroadcasts 集合中能够找到相同的无序广播，就取代之前的旧的无序广播！ final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r); if (!replaced) &#123; //【×2.3.4】将该广播添加到队列的并行集合 mParallelBroadcasts 中！ queue.enqueueParallelBroadcastLocked(r); //【×2.3.5】启动队列的广播分发任务！ queue.scheduleBroadcastsLocked(); &#125; //【14.1】将动态注册的广播接收者集合 registeredReceivers 清空！ registeredReceivers = null; NR = 0; &#125; //【15】将查询到的广播接收者合并到一个列表中！ int ir = 0; // 如果收集到静态注册的广播接收者，才会进入该分支！ // 对于普通广播来说，动态注册的广播接收者在前面已经处理完了，这只剩下了静态注册的广播接收者了！ // 对于有序广播来说，静态和动态的广播接收者都还没有处理！ if (receivers != null) &#123; //【15.1】这里对一些特殊的 action 做了一些处理，目的是防止刚安装的应用包通过静态接收这些广播实现自启动！ // 首先收集这些这些广播中携带的 packageName！ String skipPackages[] = null; if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123; Uri data = intent.getData(); if (data != null) &#123; //【15.1.1】上面的广播会携带 Scheme 属性，表示包名，这里会收集到 skipPackages 中！ String pkgName = data.getSchemeSpecificPart(); if (pkgName != null) &#123; skipPackages = new String[] &#123; pkgName &#125;; &#125; &#125; &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123; skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); &#125; //【15.2】从静态注册的广播接收者中删除属于这些 package 的广播接收者，防止应用自启动！ if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123; for (String skipPackage : skipPackages) &#123; if (skipPackage != null) &#123; int NT = receivers.size(); for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; int NT = receivers != null ? receivers.size() : 0; // 静态接收者的数量！ int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; //【15.3】注意，这里的 while 循环的目的是将所有的广播接收者合并到同一个集合中！ // 如果是有序广播，这里会进入 while 循环，将 registeredReceivers 中的动态广播接收者， // 根据优先级合并到静态注册的广播接收者集合 receivers 中！ // 对于普通广播，动态注册的广播接收者在前面已经处理完了，所以只剩下静态注册的接收者，所以不会进入循环！ while (it &lt; NT &amp;&amp; nr &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority() &gt;= curt.priority) &#123; // 按照优先级！ receivers.add(it, curr); ir++; curr = null; it++; NT++; &#125; else &#123; it++; curt = null; &#125; &#125; &#125; while (ir &lt; NR) &#123; if (receivers == null) &#123; receivers = new ArrayList(); &#125; //【15.3】将剩余的动态接收者收集进来。当然如果没有静态接收者 // 这里就只收集动态接收者； receivers.add(registeredReceivers.get(ir)); ir++; &#125; //【16】如果是系统调用，那么这里会做广播检查； if (isCallerSystem) &#123; checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, receivers); &#125; //【17】最后，将广播分发给已经合并到同一个集合中的广播接收者！ // 如果没有收集到任何的广播接收者，且这个广播是一个隐式广播，那就把这个广播的状态记录下来！ if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; // 这里的逻辑和上面的类似，不多说了！ // 注意这里的 ordered，对于目标为静态接收者的普通广播，为 false，对于有序广播，则为 true； //【×2.3.1】选择合适的队列！ BroadcastQueue queue = broadcastQueueForIntent(intent); //【×2.3.2】创建广播对象！ BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing ordered broadcast \" + r + \": prev had \" + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, \"Enqueueing broadcast \" + r.intent.getAction()); //【×2.3.3】判读是否要取代已经存在的广播； boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; //【×2.3.4】将广播添加到有序列表中！ queue.enqueueOrderedBroadcastLocked(r); //【×2.3.5】触发广播分发！ queue.scheduleBroadcastsLocked(); &#125; &#125; else &#123; if (intent.getComponent() == null &amp;&amp; intent.getPackage() == null &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; // 将广播的状态记录下来！ addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0); &#125; &#125; return ActivityManager.BROADCAST_SUCCESS;&#125; 我们来总结一下，这个方法方法流程： 1. 给 intent 添加 Intent.FLAG_EXCLUDE_STOPPED_PACKAGES 标志位，禁止广播发送给被强制停止的应用！ 1.1 如果系统没有启动完成，就给广播添加 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位，禁止启动静态广播接收者！ 2. 针对一些特殊 action 的广播进行处理，比如 uid 被移除，package 相关的广播等等！ 3. 如果是粘性广播，就需要将广播收集到 mStickyBroadcasts 集合中！ 3.1 权限校验：发送粘性广播必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！ 3.2 对于粘性广播，不能强制广播接收者应具有的权限！ 3.3 如果有相同的全局粘性广播，会产生冲突！ 4. 收集能够匹配当前广播的广播接收者： 4.1 尝试收集能够匹配当前广播的静态注册的广播接收者（如果 intent 设置了 Intent.FLAG_RECEIVER_REGISTERED_ONLY，不收集） 4.2 收集能够匹配当前广播动态注册的广播接收者 4.2.1 如果广播没有设置组件信息，那就从 mReceiverResolver 对象中收集动态广播接收者！ 5. 如果广播是普通广播，且存在匹配的动态注册的广播接收者 registeredReceivers！ 5.1 创建对应的 BroadcastRecord(registeredReceivers) 对象，这里的 BroadcastRecord.receivers 都是动态注册的广播接收者！ 5.2 并添加到指定的队列（前台后台由 Intent.FLAG_RECEIVER_FOREGROUND 决定）的无序并行集合 mParallelBroadcasts 中！ 5.3 触发广播发送任务，清空 registeredReceivers！ 6. 将收集到的静态广播接收者 receivers 和动态广播接收者 registeredReceivers 合并到同一个列表 receivers 中，只有在收集到静态注册的广播接收者才会合并！ 6.1 这首先会针对一些特殊 action 做了处理，防止应用自启动！ 6.2 对于普通广播，到这里就只剩下静态广播接收者了，无需合并；对于有序广播，到这里静态广播接收者和动态广播接收者都没有处理，那就按照优先级，将二者合并到静态广播接收者 receivers 中！ 7. 处理 6 中获得的合并广播接收者集合！ 7.1 创建对应的 BroadcastRecord(receivers) 对象，注意这里的 BroadcastRecord.receivers 可能只有静态广播接收者，可能静态动态都有！ 7.2 并添加到指定的队列（前台后台由 Intent.FLAG_RECEIVER_FOREGROUND 决定）的无序并行集合 mParallelBroadcasts / 有序集合 mOrderedBroadcasts 中！ 7.3 触发广播发送任务； 接下来，我们来看看这个方法中的一些细节： 2.2.1 AMService.collectReceiverComponentscollectReceiverComponents 方法用来收集指定设备用户下的静态注册的广播接收者：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293private List&lt;ResolveInfo&gt; collectReceiverComponents(Intent intent, String resolvedType, int callingUid, int[] users) &#123; int pmFlags = STOCK_PM_FLAGS | MATCH_DEBUG_TRIAGED_MISSING; // 用来保存查询结果！ List&lt;ResolveInfo&gt; receivers = null; try &#123; // 用来保存在所有设备用户下都只有一个实例的广播接收者！ HashSet&lt;ComponentName&gt; singleUserReceivers = null; boolean scannedFirstReceivers = false; for (int user : users) &#123; // Skip users that have Shell restrictions, with exception of always permitted // Shell broadcasts if (callingUid == Process.SHELL_UID &amp;&amp; mUserController.hasUserRestriction( UserManager.DISALLOW_DEBUGGING_FEATURES, user) &amp;&amp; !isPermittedShellBroadcast(intent)) &#123; continue; &#125; // 查询指定设备用户下的静态广播接收者！ List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager() .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList(); // 如果不是系统用户，那就要检测该设备用户下的所有静态广播接收者， // 过滤掉设置了 systemUserOnly 属性的接收者！ if (user != UserHandle.USER_SYSTEM &amp;&amp; newReceivers != null) &#123; for (int i=0; i&lt;newReceivers.size(); i++) &#123; ResolveInfo ri = newReceivers.get(i); if ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SYSTEM_USER_ONLY) != 0) &#123; newReceivers.remove(i); i--; &#125; &#125; &#125; if (newReceivers != null &amp;&amp; newReceivers.size() == 0) &#123; newReceivers = null; &#125; // 保存查询结果，查询第一个设备用户下的广播接收者进入该分支！ if (receivers == null) &#123; receivers = newReceivers; &#125; else if (newReceivers != null) &#123; // 后续设备用户下的查询会进入该分支！ if (!scannedFirstReceivers) &#123; // 收集那些在所有的设备用户下都只有一个实例的广播接收者！ scannedFirstReceivers = true; for (int i=0; i&lt;receivers.size(); i++) &#123; ResolveInfo ri = receivers.get(i); if ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123; ComponentName cn = new ComponentName( ri.activityInfo.packageName, ri.activityInfo.name); if (singleUserReceivers == null) &#123; singleUserReceivers = new HashSet&lt;ComponentName&gt;(); &#125; singleUserReceivers.add(cn); &#125; &#125; &#125; for (int i=0; i&lt;newReceivers.size(); i++) &#123; ResolveInfo ri = newReceivers.get(i); if ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123; ComponentName cn = new ComponentName( ri.activityInfo.packageName, ri.activityInfo.name); if (singleUserReceivers == null) &#123; singleUserReceivers = new HashSet&lt;ComponentName&gt;(); &#125; // 这里保证了在所有的设备用户下都只有一个实例的广播接收者只会被添加一次！ if (!singleUserReceivers.contains(cn)) &#123; singleUserReceivers.add(cn); receivers.add(ri); &#125; &#125; else &#123; receivers.add(ri); &#125; &#125; &#125; &#125; &#125; catch (RemoteException ex) &#123; // pm is in same process, this will never happen. &#125; return receivers;&#125; 这里要注意： 如果我们在 AndroidManifest.xml 中给静态广播接收者设置了 android:singleUser=&quot;true&quot; 属性的话，那么他对应的 ActivityInfo.flags 会被设置 ActivityInfo.FLAG_SINGLE_USER 位，这样该接收者在所有的设备用户下都只会有一个实例！ 具体的关于静态广播接收者的查询过程，请去看另一篇文章! 2.2.2 PackageManagerS.isProtectedBroadcast1234567891011121314151617@Overridepublic boolean isProtectedBroadcast(String actionName) &#123; synchronized (mPackages) &#123; if (mProtectedBroadcasts.contains(actionName)) &#123; return true; &#125; else if (actionName != null) &#123; // TODO: remove these terrible hacks if (actionName.startsWith(\"android.net.netmon.lingerExpired\") || actionName.startsWith(\"com.android.server.sip.SipWakeupTimer\") || actionName.startsWith(\"com.android.internal.telephony.data-reconnect\") || actionName.startsWith(\"android.net.netmon.launchCaptivePortalApp\")) &#123; return true; &#125; &#125; &#125; return false;&#125; 我们来看看如何判断一个广播是否是受保护的广播： 该广播在 mProtectedBroadcasts 列表中； 该广播是指定的一些广播； 二者满足任何一个条件就行了！ 其中 mProtectedBroadcasts 是在 PMS 里面对 protected-broadcast 类型的标签进行解析得到的，这里我们不细看！ 2.3 广播的分发处理接下来，我们去看看广播队列是如何处理其内部的广播分发的，我们先回到 ActivityManagerS 中去！1234567891011121314151617181920... ... ... BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing ordered broadcast \" + r + \": prev had \" + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, \"Enqueueing broadcast \" + r.intent.getAction()); boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125;... ... ... 这里是分发广播的核心代码段，我们一个一个来分析！ 2.3.1 ActivityManagerS.broadcastQueueForIntent1234567BroadcastQueue broadcastQueueForIntent(Intent intent) &#123; final boolean isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0; if (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST, \"Broadcast intent \" + intent + \" on \" + (isFg ? \"foreground\" : \"background\") + \" queue\"); return (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;&#125; 用于判断将这个 Intent 插入哪个队列，插入的依据是 Intent 是否设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位！ 这里我们可以看到 ActivityManagerS 通过 2 个队列来管理内部的广播： mFgBroadcastQueue：前台广播队列； mBgBroadcastQueue：后台广播队列； 2.3.2 new BroadcastRecord1234567891011121314151617181920212223242526272829303132333435363738BroadcastRecord(BroadcastQueue _queue, Intent _intent, ProcessRecord _callerApp, String _callerPackage, int _callingPid, int _callingUid, String _resolvedType, String[] _requiredPermissions, int _appOp, BroadcastOptions _options, List _receivers, IIntentReceiver _resultTo, int _resultCode, String _resultData, Bundle _resultExtras, boolean _serialized, boolean _sticky, boolean _initialSticky, int _userId) &#123; if (_intent == null) &#123; throw new NullPointerException(\"Can't construct with a null intent\"); &#125; queue = _queue; // 该广播位于的广播队列 intent = _intent; // 广播的 Intent targetComp = _intent.getComponent(); // 广播的目标组件 callerApp = _callerApp; // 发送者的进程对象 callerPackage = _callerPackage; // 发送者的包名 callingPid = _callingPid; // 发送者的 pid callingUid = _callingUid; // 发送者的 uid resolvedType = _resolvedType; requiredPermissions = _requiredPermissions; // 广播接收者需要具备的权限！ appOp = _appOp; options = _options; receivers = _receivers; // 广播接收者集合，包含静态广播接收者和动态广播接收者 delivery = new int[_receivers != null ? _receivers.size() : 0]; // 广播的分发情况！ resultTo = _resultTo; resultCode = _resultCode; resultData = _resultData; resultExtras = _resultExtras; ordered = _serialized; // 该广播是有序广播吗？ sticky = _sticky; // 该广播是粘性广播吗？ initialSticky = _initialSticky; userId = _userId; // 广播的目标设备用户 nextReceiver = 0; // 下一个要接受该广播的接收者序号！ state = IDLE; // 广播的状态！&#125; 这些属性其实很简单！ 2.3.3 BroadcastQueue.replaceXXXXX替换掉 BroadcastQueue 中 mParallelBroadcasts 已有的正在等待分发的 intent： replace ParallelBroadcast 1234567891011121314public final boolean replaceParallelBroadcastLocked(BroadcastRecord r) &#123; for (int i = mParallelBroadcasts.size() - 1; i &gt;= 0; i--) &#123; final Intent curIntent = mParallelBroadcasts.get(i).intent; //【1】匹配 filter，如果有匹配的 intent，替换掉！ if (r.intent.filterEquals(curIntent)) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"***** DROPPING PARALLEL [\" + mQueueName + \"]: \" + r.intent); mParallelBroadcasts.set(i, r); return true; &#125; &#125; return false;&#125; 同样的，如下操作： replace Ordered Broadcast 12345678910111213public final boolean replaceOrderedBroadcastLocked(BroadcastRecord r) &#123; for (int i = mOrderedBroadcasts.size() - 1; i &gt; 0; i--) &#123; //【1】匹配 filter，如果有匹配的 intent，替换掉！ if (r.intent.filterEquals(mOrderedBroadcasts.get(i).intent)) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"***** DROPPING ORDERED [\" + mQueueName + \"]: \" + r.intent); mOrderedBroadcasts.set(i, r); return true; &#125; &#125; return false;&#125; 不多说了！ 2.3.4 BroadcastQueue.enqueueOrderedBroadcastLocked这里是将广播添加到广播队列的并行集合或者是有序集合中： 123456789public void enqueueParallelBroadcastLocked(BroadcastRecord r) &#123; mParallelBroadcasts.add(r); r.enqueueClockTime = System.currentTimeMillis();&#125;public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123; mOrderedBroadcasts.add(r); r.enqueueClockTime = System.currentTimeMillis();&#125; 通过前面的分析，我们可以看出： 对于普通广播来说 先会被添加到 mParallelBroadcasts 中，BroadcastRecord.receivers 为动态注册的广播接收者集合，采用并发的发送方式； 再被添加到 mOrderedBroadcasts 中，BroadcastRecord.receivers 为静态注册的广播接收者集合，采用有序的发送方式； 对于有序广播来说： 会被直接添加到 mOrderedBroadcasts 中， BroadcastRecord.receivers 为静态注册和动态注册的广播接收者集合，按照优先级排序，采用有序的发送方式； 2.3.5 BroadcastQueue.scheduleBroadcastsLocked接下来，就是触发广播的分发调度！12345678910111213public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\" + mQueueName + \"]: current=\" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; //【×2.4】发送 `BROADCAST_INTENT_MSG` 消息！ mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; 下面就进入了 BroadcastHandler 中！ 2.4 BroadcastHandler.handleMessage1234567891011121314151617181920212223242526272829303132private final class BroadcastHandler extends Handler &#123; public BroadcastHandler(Looper looper) &#123; super(looper, null, true); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //【1】处理 BROADCAST_INTENT_MSG 消息！ case BROADCAST_INTENT_MSG: &#123; if (DEBUG_BROADCAST) Slog.v( TAG_BROADCAST, \"Received BROADCAST_INTENT_MSG\"); //【×2.5】进行广播分发，参数传入 true； processNextBroadcast(true); &#125; break; case BROADCAST_TIMEOUT_MSG: &#123; synchronized (mService) &#123; broadcastTimeoutLocked(true); &#125; &#125; break; case SCHEDULE_TEMP_WHITELIST_MSG: &#123; DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController; if (dic != null) &#123; dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1), msg.arg2, true, (String)msg.obj); &#125; &#125; break; &#125; &#125;&#125; 收到 BROADCAST_INTENT_MSG 消息后，调用 processNextBroadcast 方法，执行广播分发！ 2.5 BroadcastQueue.processNextBroadcastprocessNextBroadcast 方法比较长，需要我们仔细分析，参数传递： boolean fromMsg：传入 true，表示触发是来自消息调用！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; BroadcastRecord r; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"processNextBroadcast [\" + mQueueName + \"]: \" + mParallelBroadcasts.size() + \" broadcasts, \" + mOrderedBroadcasts.size() + \" ordered broadcasts\"); //【1】更新 cpu 的状态信息！ mService.updateCpuStats(); if (fromMsg) &#123; //【2】如果 fromMsg 为 true，会将 mBroadcastsScheduled 置为 false； // 这样之前又可以继续发送消息触发分发了！ mBroadcastsScheduled = false; &#125; //【3】立刻分发 mParallelBroadcasts 集合中的普通广播！ // 根据前面的分析，普通广播会先被加入到 mParallelBroadcasts 中并且目标接收者是动态注册的广播接受者！ while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0); //【3.1】更新普通广播的分发时间！ r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing parallel broadcast [\" + mQueueName + \"] \" + r); for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Delivering non-ordered on [\" + mQueueName + \"] to registered \" + target + \": \" + r); //【×2.5.1.1】将该普通广播分发给动态注册的每个接收者！ deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i); &#125; //【×2.5.1.2】分发成功后，将该普通广播添加到历史集合中！ addBroadcastToHistoryLocked(r); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\" + mQueueName + \"] \" + r); &#125; //【4】处理正在等待目标进程启动的广播，如果 mPendingBroadcast 不为 null，说明该广播仍然未处理！ if (mPendingBroadcast != null) &#123; if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"processNextBroadcast [\" + mQueueName + \"]: waiting for \" + mPendingBroadcast.curApp); boolean isDead; synchronized (mService.mPidsSelfLocked) &#123; //【4.1】获得目标进程的 ProcessRecord 对象！ ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid); isDead = proc == null || proc.crashing; &#125; //【4.2】如果目标进程没有死亡，就继续的等待，return！ if (!isDead) &#123; return; &#125; else &#123; Slog.w(TAG, \"pending app [\" + mQueueName + \"]\" + mPendingBroadcast.curApp + \" died before responding to broadcast\"); //【4.3】目标进程死亡，将 mPendingBroadcast 初始化为 null！ mPendingBroadcast.state = BroadcastRecord.IDLE; mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex; mPendingBroadcast = null; &#125; &#125; boolean looped = false; //【5】 while 循环用于移除 mOrderedBroadcasts 列表中的无需发送的广播，并找到下一个需要发送的广播！ do &#123; //【5.1】如果 mOrderedBroadcasts 的广播已经处理完了，就直接返回！ if (mOrderedBroadcasts.size() == 0) &#123; mService.scheduleAppGcsLocked(); if (looped) &#123; //【5.1.1】更新系统 oomAdj 的值！ mService.updateOomAdjLocked(); &#125; return; &#125; //【5.2】获得有序队列中的第一个要分发的广播！ r = mOrderedBroadcasts.get(0); boolean forceReceive = false; int numReceivers = (r.receivers != null) ? r.receivers.size() : 0; if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123; //【5.3】判断是否广播超时，超时则调用 broadcastTimeoutLocked(false) 强行结束广播； // 并设置 forceReceive 为 true，设置广播状态 r.state 为 BroadcastRecord.IDLE！ long now = SystemClock.uptimeMillis(); if ((numReceivers &gt; 0) &amp;&amp; (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123; Slog.w(TAG, \"Hung broadcast [\" + mQueueName + \"] discarded after timeout failure:\" + \" now=\" + now + \" dispatchTime=\" + r.dispatchTime + \" startTime=\" + r.receiverTime + \" intent=\" + r.intent + \" numReceivers=\" + numReceivers + \" nextReceiver=\" + r.nextReceiver + \" state=\" + r.state); //【5.4】处理广播超时 broadcastTimeoutLocked(false); //【5.5】广播超时了，所以我们视其为接收，forceReceive 为 true； forceReceive = true; //【5.6】更新广播的状态为 idle； r.state = BroadcastRecord.IDLE; &#125; &#125; //【5.7】判断广播的状态是否是 BroadcastRecord.IDLE，对于 mOrderedBroadcasts 集合中的广播来说， // 只有广播的状态为 BroadcastRecord.IDLE 时才能继续下一次的分发，这里就直接返回了！！ if (r.state != BroadcastRecord.IDLE) &#123; if (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST, \"processNextBroadcast(\" + mQueueName + \") called when not idle (state=\" + r.state + \")\"); return; &#125; //【5.8】如果该广播没有接收者，或者该广播的所有接收者都接收到了广播（nextReceiver 大于接收者数） // 或者该广播被终止继续传递（有序广播特性），或者该广播超时了被视为强制接收了，进入该分支； if (r.receivers == null || r.nextReceiver &gt;= numReceivers || r.resultAbort || forceReceive) &#123; if (r.resultTo != null) &#123; try &#123; if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, \"Finishing broadcast [\" + mQueueName + \"] \" + r.intent.getAction() + \" app=\" + r.callerApp); //【×2.5.1.3】如果该广播的 r.resultTo 不为 null，resultTo 也是一个广播接收者， // 那就调用 performReceiveLocked() 将该广播发送给 resultTo！ performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId); //【5.8.1】将广播的 r.resultTo 置为 null； r.resultTo = null; &#125; catch (RemoteException e) &#123; r.resultTo = null; Slog.w(TAG, \"Failure [\" + mQueueName + \"] sending broadcast result of \" + r.intent, e); &#125; &#125; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Cancelling BROADCAST_TIMEOUT_MSG\"); //【5.8.2】取消广播超时的消息！ cancelBroadcastTimeoutLocked(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Finished with ordered broadcast \" + r); //【×2.5.1.2】将广播添加到历史集合中！ addBroadcastToHistoryLocked(r); //【5.8.3】如果该广播是一个隐式广播，将该广播添加到 mCurBroadcastStats 中记录下来！ if (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage, r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime); &#125; //【5.8.4】从 mOrderedBroadcasts 中移除该广播！ mOrderedBroadcasts.remove(0); //【5.8.5】将 r 设为 null，进行下一次循环！ r = null; looped = true; continue; &#125; &#125; while (r == null); //【6】分发 mOrderedBroadcasts 集合中的广播，通过前面的分析 mOrderedBroadcasts 会存储 2 种类型的广播 // 普通广播，接收者为静态注册的；有序广播，接收者为的动态和静态注册的合并； // 首先，计算广播的下一个接收者的序号。同时，增加目标接收者计数！！ int recIdx = r.nextReceiver++; //【7】初始化该广播的接收时间，该时间会不断更新！！ r.receiverTime = SystemClock.uptimeMillis(); //【8】如果是第一个接收者，就记录广播的开始分发时间； if (recIdx == 0) &#123; r.dispatchTime = r.receiverTime; r.dispatchClockTime = System.currentTimeMillis(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing ordered broadcast [\" + mQueueName + \"] \" + r); &#125; //【9】如果没有设置广播超时消息，那就设置超时消息！ if (!mPendingBroadcastTimeoutMessage) &#123; long timeoutTime = r.receiverTime + mTimeoutPeriod; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Submitting BROADCAST_TIMEOUT_MSG [\" + mQueueName + \"] for \" + r + \" at \" + timeoutTime); //【9.1】设置广播处理的超时时间为 10s // 这里会将 mPendingBroadcastTimeoutMessage 设置为 true； setBroadcastTimeoutLocked(timeoutTime); &#125; //【10】获得广播的额外数据； final BroadcastOptions brOptions = r.options; //【11】获得广播的下一个接收者； final Object nextReceiver = r.receivers.get(recIdx); //【12】如果下一个广播接收者是动态注册的广播接收者！（这里只可能是有序广播） if (nextReceiver instanceof BroadcastFilter) &#123; BroadcastFilter filter = (BroadcastFilter)nextReceiver; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Delivering ordered [\" + mQueueName + \"] to registered \" + filter + \": \" + r); //【×2.5.1.1】将该有序广播分发给动态注册的广播接收者，该方法中会进一步过滤！！ deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx); //【12.1】当所有的接收者都接收到了广播时，那么 r.receiver 为 null； // 或者说该广播是普通广播，那么这里会继续下一次分发！ if (r.receiver == null || !r.ordered) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Quick finishing [\" + mQueueName + \"]: ordered=\" + r.ordered + \" receiver=\" + r.receiver); //【12.2】将广播的状态设置为 idle； r.state = BroadcastRecord.IDLE; //【×2.3.5】重新发送BROADCAST_INTENT_MSG，触发下一次发送广播的流程！ scheduleBroadcastsLocked(); &#125; else &#123; // 如果广播没有分发完成，并且是有序广播，并且其携带了额外数据，为了防止其在 doze 模式下 // 能够收到广播，所以如果额外数据中指定了 temp duration，那么会将其加入到 doze 临时白名单中； if (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123; scheduleTempWhitelistLocked(filter.owningUid, brOptions.getTemporaryAppWhitelistDuration(), r); &#125; &#125; //【12.3】这里直接 return 掉，因为对于有序广播而言， // 已经通知了一个 BroadcastReceiver，需要等待其处理结果，因此返回！ return; &#125; //【13】如果下一个广播接收者是静态注册的广播接收者（对于有序/普通广播） ResolveInfo info = (ResolveInfo)nextReceiver; ComponentName component = new ComponentName( info.activityInfo.applicationInfo.packageName, info.activityInfo.name); //【14】判断是否跳过该静态接收者！ boolean skip = false; //【15】如果 sdk 不匹配，跳过该接收者！ if (brOptions != null &amp;&amp; (info.activityInfo.applicationInfo.targetSdkVersion &lt; brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123; skip = true; &#125; //【16】检查广播发送者是否具有接收者要求的权限！ int perm = mService.checkComponentPermission(info.activityInfo.permission, r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid, info.activityInfo.exported); if (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123; //【16.1】如果发送者不被授予该权限，那就跳过该接收者！ if (!info.activityInfo.exported) &#123; Slog.w(TAG, \"Permission Denial: broadcasting \" + r.intent.toString() + \" from \" + r.callerPackage + \" (pid=\" + r.callingPid + \", uid=\" + r.callingUid + \")\" + \" is not exported from uid \" + info.activityInfo.applicationInfo.uid + \" due to receiver \" + component.flattenToShortString()); &#125; else &#123; Slog.w(TAG, \"Permission Denial: broadcasting \" + r.intent.toString() + \" from \" + r.callerPackage + \" (pid=\" + r.callingPid + \", uid=\" + r.callingUid + \")\" + \" requires \" + info.activityInfo.permission + \" due to receiver \" + component.flattenToShortString()); &#125; skip = true; &#125; else if (!skip &amp;&amp; info.activityInfo.permission != null) &#123; //【16.2】权限校验通过，那就要判断发送者是否能执行接收者指定的权限对应的操作！ // 一般情况下，如果有权限有对应的 op，那么权限在授予的情况下，也会授予 op！ final int opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission); if (opCode != AppOpsManager.OP_NONE &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid, r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: broadcasting \" + r.intent.toString() + \" from \" + r.callerPackage + \" (pid=\" + r.callingPid + \", uid=\" + r.callingUid + \")\" + \" requires appop \" + AppOpsManager.permissionToOp( info.activityInfo.permission) + \" due to registered receiver \" + component.flattenToShortString()); skip = true; &#125; &#125; //【17】如果接收者不是 system uid 的，而广播发送者指定了权限，那就要校验接收者是否具有该权限！ if (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp; r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123; for (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123; String requiredPermission = r.requiredPermissions[i]; try &#123; perm = AppGlobals.getPackageManager(). checkPermission(requiredPermission, info.activityInfo.applicationInfo.packageName, UserHandle.getUserId(info.activityInfo.applicationInfo.uid)); &#125; catch (RemoteException e) &#123; perm = PackageManager.PERMISSION_DENIED; &#125; //【17.1】接收者不具有该权限，跳过该接收者！ if (perm != PackageManager.PERMISSION_GRANTED) &#123; Slog.w(TAG, \"Permission Denial: receiving \" + r.intent + \" to \" + component.flattenToShortString() + \" requires \" + requiredPermission + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; break; &#125; //【17.2】判断接收者是否能执行发送者指定的权限所对应的操作！ int appOp = AppOpsManager.permissionToOpCode(requiredPermission); if (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp &amp;&amp; mService.mAppOpsService.noteOperation(appOp, info.activityInfo.applicationInfo.uid, info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: receiving \" + r.intent + \" to \" + component.flattenToShortString() + \" requires appop \" + AppOpsManager.permissionToOp( requiredPermission) + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; break; &#125; &#125; &#125; //【18】如果广播无需权限，只需要执行某个 op 的话，这里会判断是否有 op 权限！ if (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp, info.activityInfo.applicationInfo.uid, info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: receiving \" + r.intent + \" to \" + component.flattenToShortString() + \" requires appop \" + AppOpsManager.opToName(r.appOp) + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; &#125; //【19】判断 Intent 是否满足 AMS 的 IntentFirewall 防火墙要求，不满足，跳过！ if (!skip) &#123; skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid, r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid); &#125; //【20】判断该接收者是否是单例！ boolean isSingleton = false; try &#123; isSingleton = mService.isSingleton(info.activityInfo.processName, info.activityInfo.applicationInfo, info.activityInfo.name, info.activityInfo.flags); &#125; catch (SecurityException e) &#123; Slog.w(TAG, e.getMessage()); skip = true; &#125; //【20.1】如果接收者是单例模式，那就要校验接收者是否有 // android.Manifest.permission.INTERACT_ACROSS_USERS 权限，如果没有，跳过该接收者！ if ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123; if (ActivityManager.checkUidPermission( android.Manifest.permission.INTERACT_ACROSS_USERS, info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) &#123; Slog.w(TAG, \"Permission Denial: Receiver \" + component.flattenToShortString() + \" requests FLAG_SINGLE_USER, but app does not hold \" + android.Manifest.permission.INTERACT_ACROSS_USERS); skip = true; &#125; &#125; //【21】记录处理的静态接收者数量！ if (!skip) &#123; r.manifestCount++; &#125; else &#123; r.manifestSkipCount++; &#125; //【22】如果接收者所在进程 crash 了，跳过该接收者！ if (r.curApp != null &amp;&amp; r.curApp.crashing) &#123; Slog.w(TAG, \"Skipping deliver ordered [\" + mQueueName + \"] \" + r + \" to \" + r.curApp + \": process crashing\"); skip = true; &#125; //【23】判断该静态接收者所在的 package 是否可用，不可用就跳过！ if (!skip) &#123; boolean isAvailable = false; try &#123; isAvailable = AppGlobals.getPackageManager().isPackageAvailable( info.activityInfo.packageName, UserHandle.getUserId(info.activityInfo.applicationInfo.uid)); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception getting recipient info for \" + info.activityInfo.packageName, e); &#125; if (!isAvailable) &#123; // 不可用，跳过！ if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Skipping delivery to \" + info.activityInfo.packageName + \" / \" + info.activityInfo.applicationInfo.uid + \" : package no longer available\"); skip = true; &#125; &#125; //【24】如果在任何组件运行时都要重新校验权限，那就执权限校验，校验失败，跳过！ if (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; !skip) &#123; if (!requestStartTargetPermissionsReviewIfNeededLocked(r, info.activityInfo.packageName, UserHandle.getUserId( info.activityInfo.applicationInfo.uid))) &#123; skip = true; &#125; &#125; final int receiverUid = info.activityInfo.applicationInfo.uid; //【25】如果发送者不是系统进程，且接收者是单例，并且本次调用是有效的 // 那就始终返回默认设备用户下的接收者对象，保持单例有效性！ if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123; info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0); &#125; //【26】获得目标广播接收者的进程名； String targetProcess = info.activityInfo.processName; //【27】获得目标广播接收者所在进程的 ProcessRecord 对象！ ProcessRecord app = mService.getProcessRecordLocked(targetProcess, info.activityInfo.applicationInfo.uid, false); if (!skip) &#123; //【28】判断该静态接收者所在进程是否允许后台启动或者在后台接受广播，不允许就跳过！ final int allowed = mService.checkAllowBackgroundLocked( info.activityInfo.applicationInfo.uid, info.activityInfo.packageName, -1, false); if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123; if (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123; Slog.w(TAG, \"Background execution disabled: receiving \" + r.intent + \" to \" + component.flattenToShortString()); skip = true; &#125; else if (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null &amp;&amp; ((r.intent.getFlags() &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) &#123; //【28.1】这里针对 intent 的属性做了判断： // 如果 intent 设置了 FLAG_RECEIVER_EXCLUDE_BACKGROUND，那就不能发给后台接收者； // 如果是没有设置 FLAG_RECEIVER_INCLUDE_BACKGROUND 的隐式广播，那么也不能发给后台接收者； Slog.w(TAG, \"Background execution not allowed: receiving \" + r.intent + \" to \" + component.flattenToShortString()); skip = true; &#125; &#125; &#125; //【29】如果 skip 的值为 true，说明要跳过当前的静态接收者，继续下次广播分发！！ if (skip) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Skipping delivery of ordered [\" + mQueueName + \"] \" + r + \" for whatever reason\"); //【29.1】设置序号为 recIdx 的接收者的分发状态为 BroadcastRecord.DELIVERY_SKIPPED 跳过！ r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED; r.receiver = null; r.curFilter = null; r.state = BroadcastRecord.IDLE; //【×2.3.5】继续下次广播分发，结束方法！ scheduleBroadcastsLocked(); return; &#125; //【30】如果该静态接收者不会跳过，那就设置其属性，准备发送广播！ r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED; r.state = BroadcastRecord.APP_RECEIVE; // 广播状态； r.curComponent = component; r.curReceiver = info.activityInfo; if (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123; Slog.v(TAG_MU, \"Updated broadcast record activity info for secondary user, \" + info.activityInfo + \", callingUid = \" + r.callingUid + \", uid = \" + info.activityInfo.applicationInfo.uid); &#125; //【31】如果额外参数指定了 doze 白名单参数，那么就设置临时白名单； if (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123; scheduleTempWhitelistLocked(receiverUid, brOptions.getTemporaryAppWhitelistDuration(), r); &#125; try &#123; //【32】设置接收者所在的包 stoped 状态为 false！ AppGlobals.getPackageManager().setPackageStoppedState( r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid)); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + r.curComponent.getPackageName() + \": \" + e); &#125; //【33】如果静态广播接收者所在的进程已经启动，那就要直接发送广播！ if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(info.activityInfo.packageName, info.activityInfo.applicationInfo.versionCode, mService.mProcessStats); //【×2.5.2.1.1】发送广播，并等待结果返回！ processCurBroadcastLocked(r, app); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when sending broadcast to \" + r.curComponent, e); &#125; catch (RuntimeException e) &#123; Slog.wtf(TAG, \"Failed sending broadcast to \" + r.curComponent + \" with \" + r.intent, e); logBroadcastReceiverDiscardLocked(r); //【×4.1.2】发送失败，结束本次发送！ finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); //【×2.3.5】继续发送后续的广播！ scheduleBroadcastsLocked(); r.state = BroadcastRecord.IDLE; // 设置状态！ return; &#125; &#125; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Need to start app [\" + mQueueName + \"] \" + targetProcess + \" for broadcast \" + r); //【34】如果静态广播接收者所在的进程没有启动，那就要先启动其所在进程！ if ((r.curApp=mService.startProcessLocked(targetProcess, info.activityInfo.applicationInfo, true, r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND, \"broadcast\", r.curComponent, (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false)) == null) &#123; Slog.w(TAG, \"Unable to launch app \" + info.activityInfo.applicationInfo.packageName + \"/\" + info.activityInfo.applicationInfo.uid + \" for broadcast \" + r.intent + \": process is bad\"); logBroadcastReceiverDiscardLocked(r); //【×4.1.2】目标进程启动失败，结束本次发送！ finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); //【×2.3.5】继续发送后续的广播！ scheduleBroadcastsLocked(); r.state = BroadcastRecord.IDLE; return; &#125; //【35】将当前的广播保存到 mPendingBroadcast 中，表示正在等待目标进程启动的广播！ mPendingBroadcast = r; // 广播的目标接收者的序号！ mPendingBroadcastRecvIndex = recIdx; &#125;&#125; 这个方法的逻辑很长，我们来总结一下他的业务流程： 1 立刻分发 mParallelBroadcasts 集合中的目标为动态接收者的普通广播，方式方式为并行！ 1.1 调用【deliverToRegisteredReceiverLocked】发送广播！ 2 处理正在等待目标进程启动的广播 mPendingBroadcast，mPendingBroadcast 是有序的发送方式！ 2.1 如果进程没有启动成功，就等待进程启动后处理改广播，return； 3 移除 mOrderedBroadcasts 列表中的无需发送的广播，并找到下一个需要发送的广播，mOrderedBroadcasts 集合中的所有广播都是有序发送！ 3.1 如果某个广播超时了，就强行结束广播，并设置广播的状态为 BroadcastRecord.IDLE; 3.2 如果某个广播的状态不是 BroadcastRecord.IDLE，说明上一个接收者没有结束广播处理，return； 3.3 如果某个广播没有接收者，或者已经分发给了所有的目标接受者，或者被终止传递，或者广播超时了，那就移除该广播！ 如果指定了 r.resultTo，那还需要将该广播发送给 resultTo 接受者！ 4 有序分发 mOrderedBroadcasts 的广播，根据下一个接收者的不同，做不同的处理！ 4.1 如果是动态接收者，调用【deliverToRegisteredReceiverLocked】发送广播，然后等待处理结果，return！ 4.2 如果是静态接收者，先要判断是否 skip 该接收者； 4.2.1 跳过的触发条件： - sdk 不匹配，跳过； - 发送者不具有接收者要求的权限，跳过； - 接收者不具有发送者要求的权限，跳过； - 广播不满足 `AMS` 的 `IntentFirewall` 防火墙要求，跳过； - 接收者是单例，但是没有申明 `android.Manifest.permission.INTERACT_ACROSS_USERS`，跳过； - 接收者所在进程 `crash` 了，跳过； - 接收者所在 `package` 不可用，跳过； - 接收者所在进程不允许后台启动，跳过； &lt;/br&gt; 4.2.2 如果需要跳过该接受者，执行 scheduleBroadcastsLocked，进行下一次广播分发； - `r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED`; - `r.receiver = null`; - `r.curFilter = null`; - `r.state = BroadcastRecord.IDLE`; &lt;/br&gt; 4.2.3 如果不跳过，就执行发送操作，这里需要判断静态接收者的进程是否启动； - 4.2.3.1 静态广播接收者所在的进程已经启动，调用【`processCurBroadcastLocked`】 发送广播，并等待结果，`return`； - 4.2.3.2 静态广播接收者所在的进程没有启动，调用 `startProcessLocked` 启动进程： - 启动成功，将当前广播保存到 `mPendingBroadcast` 中，等待处理！ - 启动失败，那就 执行 `scheduleBroadcastsLocked`，进行下一次广播分发； 梳理后，整个方法的业务逻辑很清楚了，下面我们来关注一些细节： 2.5.1 发送给动态注册的接收者2.5.1.1 BroadcastQueue.deliverToRegisteredReceiverLocked对于目标是动态接收者的普通广播（ordered 为 false），和目标是动态接收者的有序广播（ordered 为 true），都是通过 deliverToRegisteredReceiverLocked 直接发送的！ 下面，我们来看看如何给动态注册的接收者发送广播！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206private void deliverToRegisteredReceiverLocked(BroadcastRecord r, BroadcastFilter filter, boolean ordered, int index) &#123; //【1】判断是否跳过这个接收者，这个和前面的流程很类似！ boolean skip = false; //【2】首先是权限校验，校验发送者是否有接收者定义的权限，没有，跳过该接收者！ // 权限如果是授予的，那还要再校验下 appOps！ if (filter.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(filter.requiredPermission, r.callingPid, r.callingUid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; Slog.w(TAG, \"Permission Denial: broadcasting \" + r.intent.toString() + \" from \" + r.callerPackage + \" (pid=\" + r.callingPid + \", uid=\" + r.callingUid + \")\" + \" requires \" + filter.requiredPermission + \" due to registered receiver \" + filter); skip = true; &#125; else &#123; final int opCode = AppOpsManager.permissionToOpCode(filter.requiredPermission); if (opCode != AppOpsManager.OP_NONE &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid, r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: broadcasting \" + r.intent.toString() + \" from \" + r.callerPackage + \" (pid=\" + r.callingPid + \", uid=\" + r.callingUid + \")\" + \" requires appop \" + AppOpsManager.permissionToOp( filter.requiredPermission) + \" due to registered receiver \" + filter); skip = true; &#125; &#125; &#125; //【3】校验接收者者是否有发送者定义的权限，没有，跳过该接收者！ // 权限如果是授予的，那还要再校验下 appOps！ if (!skip &amp;&amp; r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123; for (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123; String requiredPermission = r.requiredPermissions[i]; int perm = mService.checkComponentPermission(requiredPermission, filter.receiverList.pid, filter.receiverList.uid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; Slog.w(TAG, \"Permission Denial: receiving \" + r.intent.toString() + \" to \" + filter.receiverList.app + \" (pid=\" + filter.receiverList.pid + \", uid=\" + filter.receiverList.uid + \")\" + \" requires \" + requiredPermission + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; break; &#125; int appOp = AppOpsManager.permissionToOpCode(requiredPermission); if (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp &amp;&amp; mService.mAppOpsService.noteOperation(appOp, filter.receiverList.uid, filter.packageName) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: receiving \" + r.intent.toString() + \" to \" + filter.receiverList.app + \" (pid=\" + filter.receiverList.pid + \", uid=\" + filter.receiverList.uid + \")\" + \" requires appop \" + AppOpsManager.permissionToOp( requiredPermission) + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; break; &#125; &#125; &#125; //【4】校验接收者权限，这里跟踪下代码，由于传入的权限为 null，方法里面只针对 uid 做了判断 // 看是不是 root 或者 system，是不是隔离进程 uid； if (!skip &amp;&amp; (r.requiredPermissions == null || r.requiredPermissions.length == 0)) &#123; int perm = mService.checkComponentPermission(null, filter.receiverList.pid, filter.receiverList.uid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; Slog.w(TAG, \"Permission Denial: security check failed when receiving \" + r.intent.toString() + \" to \" + filter.receiverList.app + \" (pid=\" + filter.receiverList.pid + \", uid=\" + filter.receiverList.uid + \")\" + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; &#125; &#125; //【5】校验 ops！ if (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp, filter.receiverList.uid, filter.packageName) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: receiving \" + r.intent.toString() + \" to \" + filter.receiverList.app + \" (pid=\" + filter.receiverList.pid + \", uid=\" + filter.receiverList.uid + \")\" + \" requires appop \" + AppOpsManager.opToName(r.appOp) + \" due to sender \" + r.callerPackage + \" (uid \" + r.callingUid + \")\"); skip = true; &#125; //【6】判断是否允许后台发送广播，不允许就跳过！ if (!skip) &#123; final int allowed = mService.checkAllowBackgroundLocked(filter.receiverList.uid, filter.packageName, -1, true); if (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123; Slog.w(TAG, \"Background execution not allowed: receiving \" + r.intent + \" to \" + filter.receiverList.app + \" (pid=\" + filter.receiverList.pid + \", uid=\" + filter.receiverList.uid + \")\"); skip = true; &#125; &#125; //【7】广播不通过防火墙校验，跳过该接收者！ if (!mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid, r.callingPid, r.resolvedType, filter.receiverList.uid)) &#123; skip = true; &#125; //【8】接收者所在进程 crash 了，就跳过接收者！ if (!skip &amp;&amp; (filter.receiverList.app == null || filter.receiverList.app.crashing)) &#123; Slog.w(TAG, \"Skipping deliver [\" + mQueueName + \"] \" + r + \" to \" + filter.receiverList + \": process crashing\"); skip = true; &#125; //【9】如果跳过该接收者，那就设置该接收者为 DELIVERY_SKIPPED； if (skip) &#123; r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED; return; &#125; //【10】如果需要 review 权限，那就拉起 review！ if (Build.PERMISSIONS_REVIEW_REQUIRED) &#123; if (!requestStartTargetPermissionsReviewIfNeededLocked(r, filter.packageName, filter.owningUserId)) &#123; r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED; return; &#125; &#125; //【11】开始发送广播！ r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED; //【12】如果是有序广播，下面的分支！！ if (ordered) &#123; //【12.1】设置广播的目标接收者 IIntentReceier.Proxy 对象，用于挂进程拉起 onReceive 方法！ r.receiver = filter.receiverList.receiver.asBinder(); //【12.2】设置一系列相互引用； r.curFilter = filter; filter.receiverList.curBroadcast = r; //【12.2】设置广播状态； r.state = BroadcastRecord.CALL_IN_RECEIVE; //【12.3】如果接收者所在进程已经启动！ if (filter.receiverList.app != null) &#123; r.curApp = filter.receiverList.app; filter.receiverList.app.curReceiver = r; mService.updateOomAdjLocked(r.curApp); &#125; &#125; try &#123; if (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST, \"Delivering to \" + filter + \" : \" + r); if (filter.receiverList.app != null &amp;&amp; filter.receiverList.app.inFullBackup) &#123; //【13】如果接收者的进程正在进行数据的备份和还原操作，那就跳过当前接收者！ // 发送给下一个接收者，先 finishReceiverLocked，再 scheduleBroadcastsLocked！！ if (ordered) &#123; skipReceiverLocked(r); &#125; &#125; else &#123; //【×2.5.1.3】发送广播，one way 异步传输，无需等待返回！ performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); &#125; //【14】如果是有序广播，将广播状态置为 CALL_DONE_RECEIVE 已经接受！ if (ordered) &#123; //【14.1】修改广播状态为 CALL_DONE_RECEIVE！ r.state = BroadcastRecord.CALL_DONE_RECEIVE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure sending broadcast \" + r.intent, e); if (ordered) &#123; r.receiver = null; r.curFilter = null; filter.receiverList.curBroadcast = null; if (filter.receiverList.app != null) &#123; filter.receiverList.app.curReceiver = null; &#125; &#125; &#125;&#125; 整个方法的逻辑很简单！ 2.5.1.2 BroadcastQueue.addBroadcastToHistoryLocked将分发的广播加入历史集合中： 12345678910111213141516private final void addBroadcastToHistoryLocked(BroadcastRecord r) &#123; if (r.callingUid &lt; 0) &#123; // This was from a registerReceiver() call; ignore it. return; &#125; r.finishTime = SystemClock.uptimeMillis(); mBroadcastHistory[mHistoryNext] = r; mHistoryNext = ringAdvance(mHistoryNext, 1, MAX_BROADCAST_HISTORY); mBroadcastSummaryHistory[mSummaryHistoryNext] = r.intent; mSummaryHistoryEnqueueTime[mSummaryHistoryNext] = r.enqueueClockTime; mSummaryHistoryDispatchTime[mSummaryHistoryNext] = r.dispatchClockTime; mSummaryHistoryFinishTime[mSummaryHistoryNext] = System.currentTimeMillis(); mSummaryHistoryNext = ringAdvance(mSummaryHistoryNext, 1, MAX_BROADCAST_SUMMARY_HISTORY);&#125; 2.5.1.3 BroadcastQueue.performReceiveLocked123456789101112131415161718192021222324252627void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; if (app != null) &#123; if (app.thread != null) &#123; try &#123; //【×2.5.1.4】one-way 通过 Binder 通信，进入接收者所在的进程！ app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; catch (RemoteException ex) &#123; synchronized (mService) &#123; Slog.w(TAG, \"Can't deliver broadcast to \" + app.processName + \" (pid \" + app.pid + \"). Crashing it.\"); app.scheduleCrash(\"can't deliver broadcast\"); &#125; throw ex; &#125; &#125; else &#123; throw new RemoteException(\"app.thread must not be null\"); &#125; &#125; else &#123; //【1】如果进程 app 为 null，这里会直接通过 binder 拉起相应方法！ receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125; 这里会调用 ApplicationThreadProxy 对象的 scheduleRegisteredReceiver！ 这里就要进入接收者所在的进程了！ 2.5.1.4 ApplicationThreadP.scheduleRegisteredReceiver1234567891011121314151617181920212223public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); // 这里的 receiver 是动态注册的接收者在 AMS 中的 IIntentReceiver.Proxy 对象！ data.writeStrongBinder(receiver.asBinder()); intent.writeToParcel(data, 0); data.writeInt(resultCode); data.writeString(dataStr); data.writeBundle(extras); data.writeInt(ordered ? 1 : 0); data.writeInt(sticky ? 1 : 0); data.writeInt(sendingUser); data.writeInt(processState); // Binder 通信：SCHEDULE_REGISTERED_RECEIVER_TRANSACTION // 这里是 FLAG_ONEWAY，异步传输，无需等待返回！ mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 接下来就会进入接收者所在进程！ 2.5.2 发送给静态注册的接收者对于静态注册的广播接收者（有序广播/普通广播），因为他的进程未必已经被启动，所以要分情况！ 2.5.2.1 进程已启动如果接收者所在的进程被启动了：123456789101112131415// Is this receiver's application already running? if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(info.activityInfo.packageName, info.activityInfo.applicationInfo.versionCode, mService.mProcessStats); //【×2.5.2.1.1】那就调用 processCurBroadcastLocked 处理广播发送！ processCurBroadcastLocked(r, app); return; &#125; catch (RemoteException e) &#123; &#125; catch (RuntimeException e) &#123; &#125; &#125; 我们继续看： 2.5.2.1.1 BroadcastQueue.processCurBroadcastLocked发送当前的广播！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private final void processCurBroadcastLocked(BroadcastRecord r, ProcessRecord app) throws RemoteException &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Process cur broadcast \" + r + \" for app \" + app); if (app.thread == null) &#123; throw new RemoteException(); &#125; //【1】进程如果在进行备份还原操作，跳过该静态接收者！ if (app.inFullBackup) &#123; skipReceiverLocked(r); return; &#125; //【2】将广播的 r.receiver 设置为接收者进程的 ApplicationThreadProxy 对象！ r.receiver = app.thread.asBinder(); r.curApp = app; app.curReceiver = r; app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER); mService.updateLruProcessLocked(app, false, null); mService.updateOomAdjLocked(); //【3】设置组件信息，由于前面 r.receiver 设置的是 ApplicationThreadProxy， // 所以为了拉起接收者，这里必须设置组件名！ r.intent.setComponent(r.curComponent); boolean started = false; try &#123; if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Delivering to component \" + r.curComponent + \": \" + r); mService.notifyPackageUse(r.intent.getComponent().getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_BROADCAST_RECEIVER); //【×3.2.1】通过 Binder 通信，进入应用进程，拉起接收者的 onReceive 方法！ // one ways！ app.thread.scheduleReceiver(new Intent(r.intent), r.curReceiver, mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId, app.repProcState); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Process cur broadcast \" + r + \" DELIVERED for app \" + app); started = true; &#125; finally &#123; if (!started) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Process cur broadcast \" + r + \": NOT STARTED!\"); r.receiver = null; r.curApp = null; app.curReceiver = null; &#125; &#125;&#125; 这里就会进入接收者所在的进程，我们后面再看！ 2.5.2.1.2 ApplicationThreadP.processCurBroadcastLocked发送当前的广播！1234567891011121314151617181920public final void scheduleReceiver(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo, int resultCode, String resultData, Bundle map, boolean sync, int sendingUser, int processState) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); intent.writeToParcel(data, 0); info.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeInt(resultCode); data.writeString(resultData); data.writeBundle(map); data.writeInt(sync ? 1 : 0); data.writeInt(sendingUser); data.writeInt(processState); //【1】发送 SCHEDULE_RECEIVER_TRANSACTION 消息，one way！！ mRemote.transact(SCHEDULE_RECEIVER_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 下面就进入了应用进程： 2.5.2.2 进程未启动对于进程没有启动这种情况，我们需要主动的拉起接收者所在的进程： 1234567891011if ((r.curApp=mService.startProcessLocked(targetProcess, info.activityInfo.applicationInfo, true, r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND, \"broadcast\", r.curComponent, (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false)) == null) &#123; ... ... ... ...&#125;//【1】将广播保存到 mPendingBroadcast 中！mPendingBroadcast = r;mPendingBroadcastRecvIndex = recIdx; 对于进程的启动，我们这里不详细的介绍，请看其他的博文，这里我就直接上结果： 2.5.2.2.1 ActivityManagerService.attachApplicationLocked123456789101112131415161718192021private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ... ... ... //【×2.5.2.2.1.1 】判读是否有等待该进程启动的广播 if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; //【×2.5.2.2.1.2】发送广播！ didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; // If the app died trying to launch the receiver we declare it 'bad' Slog.wtf(TAG, \"Exception thrown dispatching broadcasts in \" + app, e); badApp = true; &#125; &#125; ... ... ... ... &#125; 我们继续来看： 2.5.2.2.1.1 ActivityManagerS.isPendingBroadcastProcessLocked进程启动后，会判断该进程中是否有有需要分发的广播：12345boolean isPendingBroadcastProcessLocked(int pid) &#123; //【×2.5.2.2.1.2】判读是否有等待该进程启动的广播 return mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid) || mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid);&#125; 其实判断的依据很简单：123public boolean isPendingBroadcastProcessLocked(int pid) &#123; return mPendingBroadcast != null &amp;&amp; mPendingBroadcast.curApp.pid == pid;&#125; 如果 BroadcastQueue 内部的 mPendingBroadcast 不为 null，且 mPendingBroadcast.curApp.pid 等于当前进程的 pid，就说明有目标为该进程的广播！ 2.5.2.2.1.2 ActivityManagerS.sendPendingBroadcastsLocked12345678910boolean sendPendingBroadcastsLocked(ProcessRecord app) &#123; boolean didSomething = false; //【1】遍历前台和后台广播队列！ for (BroadcastQueue queue : mBroadcastQueues) &#123; //【×2.5.2.2.1.3】发送 pending broadcast！！ didSomething |= queue.sendPendingBroadcastsLocked(app); &#125; return didSomething;&#125; 下面我们去 BroadcastQueue 中去看看！ 2.5.2.2.1.3 BroadcastQueue.sendPendingBroadcastsLocked1234567891011121314151617181920212223242526272829303132333435363738public boolean sendPendingBroadcastsLocked(ProcessRecord app) &#123; boolean didSomething = false; //【1】将 mPendingBroadcast 赋给 br！ final BroadcastRecord br = mPendingBroadcast; if (br != null &amp;&amp; br.curApp.pid == app.pid) &#123; //【1】校验进程是否匹配！ if (br.curApp != app) &#123; Slog.e(TAG, \"App mismatch when sending pending broadcast to \" + app.processName + \", intended target is \" + br.curApp.processName); return false; &#125; try &#123; //【2】将 mPendingBroadcast 赋值为 null； mPendingBroadcast = null; //【×2.5.2.1.1】发送广播！ processCurBroadcastLocked(br, app); didSomething = true; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception in new application when starting receiver \" + br.curComponent.flattenToShortString(), e); logBroadcastReceiverDiscardLocked(br); finishReceiverLocked(br, br.resultCode, br.resultData, br.resultExtras, br.resultAbort, false); scheduleBroadcastsLocked(); // We need to reset the state if we failed to start the receiver. br.state = BroadcastRecord.IDLE; throw new RuntimeException(e.getMessage()); &#125; &#125; return didSomething;&#125; 这里的 processCurBroadcastLocked 又回到了进程已启动的发送流程了！！ 3 接收者进程这里我们按照广播接收者的不同来分别看看： 3.1 动态接收者进程发送给动态注册的接收者有 2 种广播，首先会进入 ApplicationThreadN 中： 12345678910111213141516171819202122case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IIntentReceiver receiver = IIntentReceiver.Stub.asInterface( data.readStrongBinder()); // 这里是将 IIntentReceiver Binder 对象转为 InnerReceiver 对象！ Intent intent = Intent.CREATOR.createFromParcel(data); int resultCode = data.readInt(); String dataStr = data.readString(); Bundle extras = data.readBundle(); boolean ordered = data.readInt() != 0; boolean sticky = data.readInt() != 0; int sendingUser = data.readInt(); int processState = data.readInt(); //【1】进入 ApplicationThread，调用 scheduleRegisteredReceiver 方法！ scheduleRegisteredReceiver(receiver, intent, resultCode, dataStr, extras, ordered, sticky, sendingUser, processState); return true;&#125; 3.1.1 ApplicationThread.scheduleRegisteredReceiver123456789public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); //【×3.1.2】进入 InnerReceiver！ receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125; 3.1.2 InnerReceiver.performReceive继续看：123456789101112131415161718192021222324252627282930313233343536373839@Overridepublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final LoadedApk.ReceiverDispatcher rd; if (intent == null) &#123; Log.wtf(TAG, \"Null intent received\"); rd = null; &#125; else &#123; //【1】如果广播不为 null，就获得对应的 ReceiverDispatcher 对象，用于分发广播！ rd = mDispatcher.get(); &#125; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(\"seq\", -1); Slog.i(ActivityThread.TAG, \"Receiving broadcast \" + intent.getAction() + \" seq=\" + seq + \" to \" + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; //【×3.1.3】调用 ReceiverDispatcher 的 performReceive 方法，分发广播！ rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; //【3】如果 rd 为 null，那就调用 AMS 的方法，立刻结束广播的发送！ if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing broadcast to unregistered receiver\"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; //【4】调用了 ams 的 finish receiver 方法，这个方法我们在取消注册的时候会看！ mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;&#125; 3.1.3 ReceiverDispatcher.performReceive接着，进入 ReceiverDispatcher，我们都知道 ReceiverDispatcher 保存了 BroadcastReceiver 和 InnerReceiver 的映射关系：1234567891011121314151617181920212223242526272829public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; //【*3.1.3.1】创建了一个 Args 对象，用于封装广播参数信息！Args 继承了 Runnable 对象! final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (intent == null) &#123; Log.wtf(TAG, \"Null intent received\"); &#125; else &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra(\"seq\", -1); Slog.i(ActivityThread.TAG, \"Enqueueing broadcast \" + intent.getAction() + \" seq=\" + seq + \" to \" + mReceiver); &#125; &#125; //【×3.1.4】调用 mActivityThread.post 执行 Args 任务！post 如果返回 false，说明任务执行失败！ if (intent == null || !mActivityThread.post(args)) &#123; //【1】任务执行失败，如果该广播是通过有序的方式发送的，还要通知系统，广播已经分发完成！ // 然后系统就会进行下一个广播的有序分发！ if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing sync broadcast to \" + mReceiver); //【×3.3.2】调用了 args 父类 PendingResult 的 sendFinished 方法！ args.sendFinished(mgr); &#125; &#125;&#125; 这里我们回顾一下，采用有序的分发方式的广播有 2 种类型： 目标是静态注册的接收者的普通广播； 另外一种是目标是静态或者动态注册的接收者的有序广播； 这里的 ordered 如果是普通广播，那么为 false，如果是有序广播，那么为 true！ 3.1.3.1 new Args创建了一个 Args 对象，其继承了 PendingResult： 1234567891011121314151617181920final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; private Intent mCurIntent; private final boolean mOrdered; private boolean mDispatched; public Args(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, int sendingUser) &#123; //【1】这里的 mIIntentReceiver 是 ReceiverDispatcher 的内部变量：InnerReceiver！ // 显然，对于动态注册的接收者，mType 等于 TYPE_REGISTERED 或者 TYPE_UNREGISTERED； super(resultCode, resultData, resultExtras, mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered, sticky, mIIntentReceiver.asBinder(), sendingUser, intent.getFlags()); mCurIntent = intent; mOrdered = ordered; &#125; ... ... ... ...&#125; 这里的 mRegistered 是应用在动态注册接收者时，创建 ReceiverDispatcher 时设置为 true 的，这里显然为 true！ 3.1.4 Args.runmActivityThread.post 方法，会在主线程执行任务 Args，下面我们来看看 Args.run 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public void run() &#123; final BroadcastReceiver receiver = mReceiver; final boolean ordered = mOrdered; // 是否有序！ if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = mCurIntent.getIntExtra(\"seq\", -1); Slog.i(ActivityThread.TAG, \"Dispatching broadcast \" + mCurIntent.getAction() + \" seq=\" + seq + \" to \" + mReceiver); Slog.i(ActivityThread.TAG, \" mRegistered=\" + mRegistered + \" mOrderedHint=\" + ordered); &#125; final IActivityManager mgr = ActivityManagerNative.getDefault(); final Intent intent = mCurIntent; if (intent == null) &#123; Log.wtf(TAG, \"Null intent being dispatched, mDispatched=\" + mDispatched); &#125; mCurIntent = null; mDispatched = true; //【1】如果动态注册的接收者为 null，或者广播为 null，或者已经通过 unregisterReceiver // 方法动态取消注册了接收者，并且如果是有序广播，就要通知系统，继续下一次分发！ if (receiver == null || intent == null || mForgotten) &#123; if (mRegistered &amp;&amp; ordered) &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing null broadcast to \" + mReceiver); //【×3.3.2】调用了 args 父类 PendingResult 的 sendFinished 方法！ sendFinished(mgr); &#125; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"broadcastReceiveReg\"); try &#123; //【2】通过反射的方式，拉起 onReceive 方法！ ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); intent.prepareToEnterProcess(); setExtrasClassLoader(cl); //【3】设置 PendingResult 属性 receiver.setPendingResult(this); //【4】拉起 onReceive 方法！ receiver.onReceive(mContext, intent); &#125; catch (Exception e) &#123; if (mRegistered &amp;&amp; ordered) &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing failed broadcast to \" + mReceiver); //【×3.3.2】这里出现了异常，如果是有序广播，需要通知系统！ // 调用了 args 父类 PendingResult 的 sendFinished 方法！ sendFinished(mgr); &#125; if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); throw new RuntimeException( \"Error receiving broadcast \" + intent + \" in \" + mReceiver, e); &#125; &#125; //【3】显然，这里不为 null，调用 finish 结束广播！ if (receiver.getPendingResult() != null) &#123; //【×3.3.1】调用了父类的 finish 方法！ finish(); &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);&#125; mForgotten 属性是在 unregisterReceiver 的时候被置为 true 的，这里终于进入了 BroadcastReceiver 的 onReceive 方法！ 3.2 静态接收者进程发送给静态注册的接收者也有 2 种广播，首先会进入 ApplicationThreadN 中： 123456789101112131415161718case SCHEDULE_RECEIVER_TRANSACTION:&#123; data.enforceInterface(IApplicationThread.descriptor); Intent intent = Intent.CREATOR.createFromParcel(data); ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(data); CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); int resultCode = data.readInt(); String resultData = data.readString(); Bundle resultExtras = data.readBundle(); boolean sync = data.readInt() != 0; int sendingUser = data.readInt(); int processState = data.readInt(); //【1】进入 ApplicationThread 的 scheduleReceiver 方法！ scheduleReceiver(intent, info, compatInfo, resultCode, resultData, resultExtras, sync, sendingUser, processState); return true;&#125; 3.2.1 ApplicationThread.scheduleReceiver123456789101112131415public final void scheduleReceiver(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras, boolean sync, int sendingUser, int processState) &#123; updateProcessState(processState, false); //【×3.2.1.1】创建了一个 ReceiverData 对象！ // mAppThread 是当前进程的 ApplicationThread 对象，是一个 Binder 对象！ ReceiverData r = new ReceiverData(intent, resultCode, data, extras, sync, false, mAppThread.asBinder(), sendingUser); r.info = info; r.compatInfo = compatInfo; //【×3.2.2】发送 H.RECEIVER 给主线程！ sendMessage(H.RECEIVER, r);&#125; 这里创建了一个 ReceiverData 对象，用来封装接收者的数据信息！ 3.2.1.1 new ReceiverData12345678910111213141516static final class ReceiverData extends BroadcastReceiver.PendingResult &#123; public ReceiverData(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, IBinder token, int sendingUser) &#123; // 这个地方，传入的是 TYPE_COMPONENT，即 mType 是 TYPE_COMPONENT！ super(resultCode, resultData, resultExtras, TYPE_COMPONENT, ordered, sticky, token, sendingUser, intent.getFlags()); this.intent = intent; &#125; // 广播 Intent 对象！ Intent intent; // 接收者的信息 ActivityInfo 对象！ ActivityInfo info; CompatibilityInfo compatInfo;&#125; ReceiverData 继承了 BroadcastReceiver.PendingResult 对象，用来封装静态接收者的数据信息！ 这里就和 Args 类似了！ 3.2.2 H.handleMessage我们去看看主线程 Handler H 是如何处理 H.RECEIVER 消息的： 1234567891011121314151617private class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case RECEIVER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"broadcastReceiveComp\"); //【×3.2.3】调用 handleReceiver 处理广播！ handleReceiver((ReceiverData)msg.obj); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125; &#125;&#125; 3.2.3 ActivityThread.handleReceiver12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void handleReceiver(ReceiverData data) &#123; unscheduleGcIdler(); //【1】获得组件名，用于反射！ String component = data.intent.getComponent().getClassName(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); IActivityManager mgr = ActivityManagerNative.getDefault(); BroadcastReceiver receiver; try &#123; //【2】通过反射获得 BroadcastReceiver 对象的实例！ java.lang.ClassLoader cl = packageInfo.getClassLoader(); data.intent.setExtrasClassLoader(cl); data.intent.prepareToEnterProcess(); data.setExtrasClassLoader(cl); receiver = (BroadcastReceiver)cl.loadClass(component).newInstance(); &#125; catch (Exception e) &#123; if (DEBUG_BROADCAST) Slog.i(TAG, \"Finishing failed broadcast to \" + data.intent.getComponent()); data.sendFinished(mgr); throw new RuntimeException( \"Unable to instantiate receiver \" + component + \": \" + e.toString(), e); &#125; try &#123; //【3】获得 Application 的上下文运行环境！ Application app = packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v( TAG, \"Performing receive of \" + data.intent + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + packageInfo.getPackageName() + \", comp=\" + data.intent.getComponent().toShortString() + \", dir=\" + packageInfo.getAppDir()); ContextImpl context = (ContextImpl)app.getBaseContext(); sCurrentBroadcastIntent.set(data.intent); //【4】设置接收者的 PendingResult 属性！ receiver.setPendingResult(data); //【5】拉起广播接收者的 onReceive 方法！！ receiver.onReceive(context.getReceiverRestrictedContext(), data.intent); &#125; catch (Exception e) &#123; if (DEBUG_BROADCAST) Slog.i(TAG, \"Finishing failed broadcast to \" + data.intent.getComponent()); //【×3.3.2】异常情况直接返回！ data.sendFinished(mgr); if (!mInstrumentation.onException(receiver, e)) &#123; throw new RuntimeException( \"Unable to start receiver \" + component + \": \" + e.toString(), e); &#125; &#125; finally &#123; sCurrentBroadcastIntent.set(null); &#125; //【6】调用 ReceiverData 的 finish 函数，通知 AMS 广播处理完成！ if (receiver.getPendingResult() != null) &#123; //【×3.3.1】实际上调用了 PendingResult 的 finish 方法！ data.finish(); &#125;&#125; 下面，我们进入到 ReceiverData 中去！！ 3.3 PendingResult3.3.1 PendingResult.finish接着，调用 PendingResult .finish 结束广播的分发，通知系统继续广播的分发！123456789101112131415161718192021222324252627282930313233343536public final void finish() &#123; // 如果 mType 为 TYPE_COMPONENT，静态接收者，进入 IF 分支！ if (mType == TYPE_COMPONENT) &#123; final IActivityManager mgr = ActivityManagerNative.getDefault(); // 若主线程的 QueuedWork 中有事情还未处理完，则必须让事情做完后，才通知 AMS 结果！ if (QueuedWork.hasPendingWork()) &#123; // 创建一个任务，通过 singleThreadExecutor 单线程依次执行！ QueuedWork.singleThreadExecutor().execute( new Runnable() &#123; @Override public void run() &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing broadcast after work to component \" + mToken); sendFinished(mgr); &#125; &#125;); &#125; else &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing broadcast to component \" + mToken); //【×3.3.2】如果主线程无等待处理的事件，直接通知 AMS 结果！ sendFinished(mgr); &#125; &#125; else if (mOrderedHint &amp;&amp; mType != TYPE_UNREGISTERED) &#123; //【1】如果 mType 为 TYPE_REGISTERED : TYPE_UNREGISTERED，动态接收者， // 所以会进入 ELSE IF， mOrderedHint 为 true，表示为有序广播，此时我们需要通知系统！！ if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, \"Finishing broadcast to \" + mToken); final IActivityManager mgr = ActivityManagerNative.getDefault(); //【×3.3.2】发送结果！ sendFinished(mgr); &#125;&#125; mOrderedHint 是创建 Args 时赋值初始化的，他是父类 PendingResult 的成员变量，表示该广播是否是有序的！ 3.3.2 PendingResult.sendFinished无论是 Args，还是 ReceiverData 他们都继承了 PendingResult 类，sendFinished 的实现是在 PendingResult 类中！ 通过上面的方法可以看到，静态接收者由于都是有序分发，所以都要回调通知；但是动态接收者，只有广播是有序广播，才会回调通知系统，普通广播是不需要回调系统的！ 12345678910111213141516171819202122232425262728/** @hide */public void sendFinished(IActivityManager am) &#123; synchronized (this) &#123; //【1】判断是否已经 finish 过，会抛出异常！ if (mFinished) &#123; throw new IllegalStateException(\"Broadcast already finished\"); &#125; mFinished = true; try &#123; if (mResultExtras != null) &#123; mResultExtras.setAllowFds(false); &#125; //【1】有序发送的广播，mOrderedHint 为 true，进入该分支！ // mAbortBroadcast 表示是否终止该广播的继续分发！ // mOrderedHint 表示该广播是否是有序发送的！ if (mOrderedHint) &#123; am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras, mAbortBroadcast, mFlags); &#125; else &#123; // 普通广播但是是发送给静态接收者的，也会回调系统！ am.finishReceiver(mToken, 0, null, null, false, mFlags); &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 这里的 mToken 要注意一下： 如果是动态注册的接收者，mToken 是 InnerReceiver 对象； 如果是静态注册的接收者，mToken 是 ApplicationThread 对象； 这里的 mAbortBroadcast 表示是否终止该广播的继续分发，对于有序发送的广播来说，当一个接收者接收到了该广播，可以通过以下方式来设置是否终止该广播的继续传递： 1234public final void abortBroadcast() &#123; checkSynchronousHint(); mPendingResult.mAbortBroadcast = true;&#125; 以及：12345public final void clearAbortBroadcast() &#123; if (mPendingResult != null) &#123; mPendingResult.mAbortBroadcast = false; &#125;&#125; 下面就会进入系统进程！ 4 系统进程通过前面的分析，我们知道以下 2 种广播是通过有序的方式发送的： 目标是静态接收者的普通广播； 有序广播； 下面我们来看看有序发送的广播的后事处理： 4.1 ActivityManagerS.finishReceiver参数 IBinder who 表示的是句柄，代表我们广播的目标客户端！ 12345678910111213141516171819202122232425262728293031323334353637383940public void finishReceiver(IBinder who, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, int flags) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Finish receiver: \" + who); //【1】不能传递文件描述符！ if (resultExtras != null &amp;&amp; resultExtras.hasFileDescriptors()) &#123; throw new IllegalArgumentException(\"File descriptors passed in Bundle\"); &#125; final long origId = Binder.clearCallingIdentity(); try &#123; boolean doNext = false; BroadcastRecord r; synchronized(this) &#123; //【2】根据广播的 Intent 是否设置了 FLAG_RECEIVER_FOREGROUND 标志位，选择前台/后台队列！ BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0 ? mFgBroadcastQueue : mBgBroadcastQueue; //【×4.1.1】接着是在 mOrderedBroadcasts 匹配到 who 对应的广播，也就是我们这次分发的广播！ r = queue.getMatchingOrderedReceiver(who); if (r != null) &#123; //【×4.1.2】判断是否需要继续分发该广播！ doNext = r.queue.finishReceiverLocked(r, resultCode, resultData, resultExtras, resultAbort, true); &#125; &#125; //【3】如果 doNext 为 true，继续下一次分发！ if (doNext) &#123; r.queue.processNextBroadcast(false); &#125; // 回收资源！ trimApplications(); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 流程很简单，不多说了！ 4.1.1 BroadcastQueue.getMatchingOrderedReceiver12345678910public BroadcastRecord getMatchingOrderedReceiver(IBinder receiver) &#123; if (mOrderedBroadcasts.size() &gt; 0) &#123; final BroadcastRecord r = mOrderedBroadcasts.get(0); //【1】匹配接收者处理的广播，并返回！ if (r != null &amp;&amp; r.receiver == receiver) &#123; return r; &#125; &#125; return null;&#125; getMatchingOrderedReceiver 逻辑很简单，这里就不多说了！ 4.1.2 BroadcastQueue.finishReceiverLocked接下来看看 finishReceiverLocked 方法做了什么！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public boolean finishReceiverLocked(BroadcastRecord r, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, boolean waitForServices) &#123; //【1】保存之前的状态！ final int state = r.state; final ActivityInfo receiver = r.curReceiver; //【2】初始化广播的一些变量！ r.state = BroadcastRecord.IDLE; if (state == BroadcastRecord.IDLE) &#123; Slog.w(TAG, \"finishReceiver [\" + mQueueName + \"] called but state is IDLE\"); &#125; //【3】将 r.receiver 置为 null，因为该接收者已经处理完了广播！ r.receiver = null; r.intent.setComponent(null); if (r.curApp != null &amp;&amp; r.curApp.curReceiver == r) &#123; r.curApp.curReceiver = null; &#125; if (r.curFilter != null) &#123; r.curFilter.receiverList.curBroadcast = null; &#125; r.curFilter = null; r.curReceiver = null; r.curApp = null; //【4】将 mPendingBroadcast 置为 null; mPendingBroadcast = null; r.resultCode = resultCode; r.resultData = resultData; r.resultExtras = resultExtras; //【5】判断是否需要终止该广播的继续分发！ // 当 resultAbort 为 true，且广播没有设置 Intent.FLAG_RECEIVER_NO_ABORT 标志位， // 那么该广播就会终止继续传递！ if (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == 0) &#123; r.resultAbort = resultAbort; &#125; else &#123; r.resultAbort = false; &#125; //【6】这里的 waitForServices 传入的是 true，对于后台队列来说 mDelayBehindServices 为 true！ if (waitForServices &amp;&amp; r.curComponent != null &amp;&amp; r.queue.mDelayBehindServices &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; 0 &amp;&amp; r.queue.mOrderedBroadcasts.get(0) == r) &#123; ActivityInfo nextReceiver; if (r.nextReceiver &lt; r.receivers.size()) &#123; //【6.1】计算下一个接收者！ Object obj = r.receivers.get(r.nextReceiver); nextReceiver = (obj instanceof ActivityInfo) ? (ActivityInfo)obj : null; &#125; else &#123; nextReceiver = null; &#125; // 如果本次接受广播的接收者和下一个接收者不在同一个进程，或者下一个接收者为 null if (receiver == null || nextReceiver == null || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid || !receiver.processName.equals(nextReceiver.processName)) &#123; // 对于后台队列中的有序发送的广播，如果广播的目标设别用户下有需要后台延迟启动的服务 // 那就不能继续分发，这里会将广播的状态改为 BroadcastRecord.WAITING_SERVICES，返回 false！ if (mService.mServices.hasBackgroundServices(r.userId)) &#123; Slog.i(TAG, \"Delay finish: \" + r.curComponent.flattenToShortString());。。。。 r.state = BroadcastRecord.WAITING_SERVICES; return false; &#125; &#125; &#125; r.curComponent = null; //【7】前面我们知道，由于发送广播是异步操作，所以正常情况发送前，状态就改为了下面的状态； // 这是返回的是 true，那么 doNext 就是 true；如果需要等待 Service 启动，那么状态就为 WAITING_SERVICES； // 此时 doNext 就为 false； return state == BroadcastRecord.APP_RECEIVE || state == BroadcastRecord.CALL_DONE_RECEIVE;&#125; 对于静态注册的接收者 r.state 被置为 BroadcastRecord.APP_RECEIVE；对于动态注册的接收者 r.state 被置为 BroadcastRecord.CALL_DONE_RECEIVE； 这里的 r.queue.mDelayBehindServices 要解释一下，他是在创建前台和后台队列时初始化的：12mFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", BROADCAST_FG_TIMEOUT, false);mBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", BROADCAST_BG_TIMEOUT, true); 可以看到，对于后台队列，其 mDelayBehindServices 为 true！表示如果有后台延迟启动的服务，就延迟广播的发送！ 那么我们如何判断目标设备用户下是否有后台延迟发送的广播，这就要调用 ActiveServices 的 hasBackgroundServices 方法了：1234boolean hasBackgroundServices(int callingUser) &#123; ServiceMap smap = mServiceMap.get(callingUser); return smap != null ? smap.mStartingBackground.size() &gt;= mMaxStartingBackground : false;&#125; 和 Service 的生命周期相关的内容，请去看其他的博客！ 最后又再次回到了 processNextBroadcast 方法中了！ 5 总结到这里，sendBroadcast 方法的流程就分析完了，下面我们来总结一下： 5.1 广播的处理流程在发送广播之前，都需要收集其目标接收者，包括静态接收者和动态接收者！ 如果广播设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，会被添加到前台队列 mFgBroadcastQueue 中，否则就被添加到后台队列 mBgBroadcastQueue 中！ 如果广播设置了 Intent.FLAG_RECEIVER_NO_ABORT 标志位，有序发送的情况下不能被强制中断分发！ 5.1.1 普通广播的处理流程 1 先发送给动态接收者，并行分发，广播会被加入到 mParallelBroadcasts 集合中，通过一个 while 循环，不断遍历 mParallelBroadcasts，直到为空 。 1.1 设置广播开始分发时间：r.dispatchTime = SystemClock.uptimeMillis(); 和 r.dispatchClockTime = System.currentTimeMillis(); 1.2 设置当前接收者的分发状态：r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED 1.3 对于动态接收者来说，系统进程保存着其 IIntentReceiver.Proxy 对象！ 1.4 通过 app.thread.scheduleRegisteredReceiver，进入应用进程，调用 InnerReceiver.performReceive 拉起广播接收者的 onReceive 方法！如果 app = null，就直接通过 IIntentReceiver.Proxy.performReceive，进入应用进程！- **1.4.1** 这时会创建一个 `Args` 对象（继承了 `BroadcastReceiver.PendingResult` 实现了 `Runnable`），通过主线程执行 `Args.run` 方法！ - **1.4.2** `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于动态接收者：`mType = TYPE_REGISTERED/TYPE_UNREGISTERED`！ - **1.4.3** 最后通过反射，拉起 `onReceive` 方法！ 2 然后发送给静态接收者，广播会被加入到 mOrderedBroadcasts 集合中，有序发送！ 2.1 如果已经有一个正在等待目标进程启动的广播 mPendingBroadcast，那就等待对应进程启动后处理！ 2.2 否则，计算本次该广播要分发的接收者的序号：recIdx，和下一个接收者的序号：r.nextReceiver，二者满足：int recIdx = r.nextReceiver++ 2.3 设置广播开始分发时间（当 recIdx 为第一个接收者的时候）r.dispatchTime = r.receiverTime; r.dispatchClockTime = System.currentTimeMillis(); 设置当前接收者的分发状态：r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED; 设置广播的当前状态：r.state = BroadcastRecord.APP_RECEIVE; 设置广播当前的目标组件：r.curComponent = component; 设置广播当前的目标接收者：r.curReceiver = info.activityInfo; 2.4 对于静态接收者，发送广播时候，其进程未必启动，所以要分情况处理： - **2.4.1** 如果进程未启动，就先启动其进程，并将广播添加到 `mPendingBroadcast` 中，等待进程启动后处理！ 进程启动后，会判断当前进程是否有 `mPendingBroadcast`，有的话，就将 `mPendingBroadcast` 发送目标接收者（2.4.2），并设置 `mPendingBroadcast = null;`！ &lt;/br&gt; - **2.4.2** 如果进程已启动，那就直接发送广播！ - 设置广播的目标接收者通信对象：`r.receiver = app.thread.asBinder();`，即目标进程的 `ApplicationThreadProxy` 对象！ - 设置广播的目标进程：`r.curApp = app;` - 设置目标进程的当前要接收广播的接收者：`app.curReceiver = r;` - 设置广播的组件信息；`r.intent.setComponent(r.curComponent);` - 通过 `app.thread.scheduleReceiver`，跨进程拉起接收者的 `onReceive` 方法！ - 进入应用进程后，会创建一个 `ReceiverData` 对象（其继承了 `BroadcastReceiver.PendingResult`） - `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于静态接收者：`mType = TYPE_COMPONENT`！ - 最后通过反射，拉起 `onReceive` 方法！ 2.5 最后，调用 ActivityManagerService.finishReceiver，通知系统进程，接收者完成了广播处理，继续分发!！ 初始化广播的状态：r.state = BroadcastRecord.IDLE; 清空广播的目标接收者：Binder 对象：r.receiver = null; 清空广播组件信息：r.intent.setComponent(null); 清空广播目标进程的当前接收者：r.curApp.curReceiver = null; 清空广播过滤器的当前广播：r.curFilter.receiverList.curBroadcast = null; 清空广播的过滤器：r.curFilter = null; 清空广播接收者信息：r.curReceiver = null; 清空广播的目标进程：r.curApp = null; 清空广播的组件信息：r.curComponent = null; 5.1.2 有序广播的处理流程对于有序广播来说，会将收集到的静态接收者和动态接收者通过优先级的不同合并到同一个集合中去，然后将该集合添加到指定队列的 mOrderedBroadcasts 集合中！ 1 如果已经有一个正在等待目标进程启动的广播 mPendingBroadcast，那就等待对应进程启动后处理，此时不能继续有序发送！ 2 从 mOrderedBroadcasts 中移除不需要发送的广播，比如：没有接收者，或者所有接收者都已接收了该广播或者被终止继续传递，或者超时了，找到下一个需要分发的广播 r！ 3 准备工作： 计算本次该广播的目标接收者的序号：recIdx，和下一个接收者的序号：r.nextReceiver，二者满足：int recIdx = r.nextReceiver++； 初始化该广播的接收时间： r.receiverTime = SystemClock.uptimeMillis();，根据该事件设置超时任务！ 设置广播开始分发时间： r.dispatchTime = r.receiverTime; r.dispatchClockTime = System.currentTimeMillis();（当 recIdx 为第一个接收者的时候） 4 从广播的接收者列表中找到 recIdx 对应的目标接收者，接下来就是分发广播了： 4.1 如果是动态注册的接收者，deliverToRegisteredReceiverLocked！ 4.1.1 设置目标接收者的分发状态： r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED 4.1.2 设置广播的属性： 设置广播接收者对应的 Binder 通信对象：r.receiver = filter.receiverList.receiver.asBinder();，即 IIntentReceiver.Proxy 对象！ 设置广播的过滤器对象： r.curFilter = filter; 设置过滤器处理的广播： filter.receiverList.curBroadcast = r; 设置广播的状态： r.state = BroadcastRecord.CALL_IN_RECEIVE; 设置广播的目标进程： r.curApp = filter.receiverList.app; 设置目标进程当前处理的广播： filter.receiverList.app.curReceiver = r; 4.1.3 立刻设置广播的状态：r.state = BroadcastRecord.CALL_DONE_RECEIVE; 表示接收完毕！ 4.1.4 发送广播！ 4.1.4.1 通过 app.thread.scheduleRegisteredReceiver，进入应用进程，调用 InnerReceiver.performReceive 拉起广播接收者的 onReceive 方法！如果 app = null，就直接通过 IIntentReceiver.Proxy.performReceive，进入应用进程！ 4.1.4.2 调用 ReceiverDispatcher.performReceive 方法，处理广播！ 这时会创建一个 Args 对象（继承了 BroadcastReceiver.PendingResult 实现了 Runnable），通过主线程执行 Args.run 方法！ PendingResult 有一个内部成员变量 mType，用来保存接收者的类型，对于动态接收者：mType = TYPE_REGISTERED/TYPE_UNREGISTERED！ 最后通过反射，拉起 onReceive 方法！ 调用 ActivityManagerService.finishReceiver，通知系统进程，接收者完成了广播处理，继续分发！ 初始化广播的状态：r.state = BroadcastRecord.IDLE; 清空广播的目标接收者：Binder 对象：r.receiver = null; 清空广播组件信息：r.intent.setComponent(null); 清空广播目标进程的当前接收者：r.curApp.curReceiver = null; 清空广播过滤器的当前广播：r.curFilter.receiverList.curBroadcast = null; 清空广播的过滤器：r.curFilter = null; 清空广播接收者信息：r.curReceiver = null; 清空广播的目标进程：r.curApp = null; 清空广播的组件信息：r.curComponent = null; - **4.2** 如果是**静态注册的接收者**，`deliverToRegisteredReceiverLocked`！ - **4.1.1** 设置目标接收者的分发状态： `r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED` - **4.1.2** 设置广播的属性： - 设置广播的状态：`r.state = BroadcastRecord.APP_RECEIVE;` - 设置广播的目标组件信息：`r.curComponent = component;` - 设置广播的目标接收者信息：`r.curReceiver = info.activityInfo;` - **4.1.3** 根据静态接收者的进程状态来做不同处理： - **4.1.3.1** 如果进程未启动，就先启动其进程，并将广播添加到 `mPendingBroadcast` 中，等待进程启动后处理！进程启动后，会判断当前进程是否有 `mPendingBroadcast`，有的话，就将 `mPendingBroadcast` 发送目标接收者（4.1.3.2），并设置 `mPendingBroadcast = null;`！ - **4.1.3.2** 如果进程已启动，那就直接发送广播！ - 设置广播的目标接收者通信对象：`r.receiver = app.thread.asBinder();`，即目标进程的 `ApplicationThreadProxy` 对象！ - 设置广播的目标进程：`r.curApp = app;` - 设置目标进程的当前要接收广播的接收者：`app.curReceiver = r;` - 设置广播的组件信息；`r.intent.setComponent(r.curComponent);` - 通过 `app.thread.scheduleReceiver`，跨进程拉起接收者的 `onReceive` 方法！ - 进入应用进程后，会创建一个 `ReceiverData` 对象（其继承了 `BroadcastReceiver.PendingResult`） - `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于静态接收者：`mType = TYPE_COMPONENT`！ - 最后通过反射，拉起 `onReceive` 方法！ - 调用 `ActivityManagerService.finishReceiver`，通知系统进程，接收者完成了广播处理，继续广播分发！ - 初始化广播的状态：`r.state = BroadcastRecord.IDLE;` - 清空广播的目标接收者：`Binder` 对象：`r.receiver = null;` - 清空广播组件信息：`r.intent.setComponent(null);` - 清空广播目标进程的当前接收者：`r.curApp.curReceiver = null;` - 清空广播过滤器的当前广播：`r.curFilter.receiverList.curBroadcast = null;` - 清空广播的过滤器：`r.curFilter = null;` - 清空广播接收者信息：`r.curReceiver = null;` - 清空广播的目标进程：`r.curApp = null;` - 清空广播的组件信息：`r.curComponent = null;` 5.1.3 粘性广播的处理流程粘性是一个附加的属性，和有序，普通不冲突，普通广播和有序广播都可以是粘性的，粘性广播的一个特性是，系统会将该粘性广播保存下来，以便分发给以后注册的接收者！ 保存的集合为： 12final SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts = new SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;(); 除去这个特性之外，粘性广播的处理方式和普通广播、有序广播是一样的，这里就不多说了！ 如果要发送粘性广播，应用必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！ 对于粘性广播，不能强制广播接收者应该具有某些权限！ 对于粘性广播，如果有相同的全局粘性广播，会产生冲突，抛出异常！ Android 7.1.1 上已经不推荐使用粘性广播了，因为会产生安全问题！ 5.2 广播的状态周期对于广播来说，会有如下的几种状态：12345static final int IDLE = 0;static final int APP_RECEIVE = 1;static final int CALL_IN_RECEIVE = 2;static final int CALL_DONE_RECEIVE = 3;static final int WAITING_SERVICES = 4; 普通广播： 如果是静态注册的接收者：1BroadcastReocrd.IDLE -&gt; BroadcastReocrd.IDLE.APP_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE 如果是动态注册的接收者：1BroadcastReocrd.IDLE 有序广播： 如果是静态注册的接收者：1BroadcastReocrd.IDLE -&gt; BroadcastReocrd.APP_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE 如果是动态注册的接收者：1BroadcastReocrd.IDLE -&gt; BroadcastReocrd.CALL_IN_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE 这里的 BroadcastReocrd.WAITING_SERVICES 只会对后台队列中有序发送的广播有效，因为这些广播可能在等待一些后台服务的启动！ 当后台服务启动后，ActiveServices 会通过 rescheduleDelayedStarts 方法拉起这些服务！这里不多说了！ 5.3 接收者的分发状态对于接收者来说，下面这些状态用来表示广播的分发状态： 1234static final int DELIVERY_PENDING = 0; // 没有用到！static final int DELIVERY_DELIVERED = 1; // 广播已经分发给该广播接收者static final int DELIVERY_SKIPPED = 2; // 广播跳过了该广播接收者static final int DELIVERY_TIMEOUT = 3; // 广播超时了 关于广播的超时，我们会单独一篇博文中介绍！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"BroadcastReceiver广播接收者","slug":"AndroidFramework源码分析/BroadcastReceiver广播接收者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/"}],"tags":[{"name":"BroadcastReceiver广播接收者","slug":"BroadcastReceiver广播接收者","permalink":"https://coolqi.top/tags/BroadcastReceiver广播接收者/"}]},{"title":"BroadcastReceiver篇 4 - BroadcastReceiver 静态注册","slug":"BroadcastReceiver4-staticRegisterReceiver","date":"2016-05-08T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/05/08/BroadcastReceiver4-staticRegisterReceiver/","link":"","permalink":"https://coolqi.top/2016/05/08/BroadcastReceiver4-staticRegisterReceiver/","excerpt":"","text":"[toc] 本文基于 Android 7.1.1 源码，分析 BroadcastReceiver 的静态注册过程，转载请说明出处，谢谢！ 0 综述广播接收者除了动态注册之外，还有静态注册，就是在 AndroidManifest.xml 文件中进行配置！ 123456789101112&lt;receiver android:enabled=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:name=\"string\" android:permission=\"string\" android:process=\"string\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 我们来简单地看看这些属性的意思： android:enabled：此 broadcastReceiver 是否可用，默认值为 true。 android:exported：此 broadcastReceiver 能否接收其它 App 的发出的广播，如果标签中定义了 intent-filter 字段，则此值默认值为 true，否则为 false。 android:name：此 BroadcastReceiver 的组件名。 android:permission：广播发送方应该具有的权限； android:process：表示 broadcastReceiver 运行的进程，BroadcastReceiver 默认运行在当前 app 的进程中，也可以通过此字段指定其运行于其它独立的进程。 intent-filter：用于指定该broadcastReceiver接收广播的类型。 静态注册的 BroadcastReceiver 不能作为内部类，必须要单独作为一个 BroadcastReceiver.java 文件！ 其实，如果大家对于 PMS 熟悉的话，应该很清楚了，对于静态注册的方式，是会通过 PMS 的解析来获得 BroadcastReceiver 的信息的！！下面我们就到 PMS 中去看看： 1 PackageParser.parseBaseApplication - 解析 application解析的关键的代码段如下，我们简单的回顾下：12345678910111213141516171819202122232425262728293031323334353637private boolean parseBaseApplication(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) throws XmlPullParserException, IOException &#123; ... ... ... ... while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals(\"activity\")) &#123; Activity a = parseActivity(owner, res, parser, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.activities.add(a); //【2.1】解析 \"receiver\"，获得静态注册的广播接收者的信息！ &#125; else if (tagName.equals(\"receiver\")) &#123; Activity a = parseActivity(owner, res, parser, flags, outError, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; //【1】将解析到的 receiver 加入到 Package owner 中！ owner.receivers.add(a); &#125; ... ... ... &#125; ... ... ... ...&#125; 可以看到，这里会解析静态注册的广播接收者，并将其信息封装成 Activity 对象保存到了 Package.receivers 对象中去！ 我们进入到 PackageParser 的 parseActivity 中去看看！ 2.1 PackageParser.parseActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697private Activity parseActivity(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError, boolean receiver, boolean hardwareAccelerated) throws XmlPullParserException, IOException &#123; TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestActivity); if (mParseActivityArgs == null) &#123; mParseActivityArgs = new ParseComponentArgs(owner, outError, R.styleable.AndroidManifestActivity_name, R.styleable.AndroidManifestActivity_label, R.styleable.AndroidManifestActivity_icon, R.styleable.AndroidManifestActivity_roundIcon, R.styleable.AndroidManifestActivity_logo, R.styleable.AndroidManifestActivity_banner, mSeparateProcesses, R.styleable.AndroidManifestActivity_process, R.styleable.AndroidManifestActivity_description, R.styleable.AndroidManifestActivity_enabled); &#125; mParseActivityArgs.tag = receiver ? \"&lt;receiver&gt;\" : \"&lt;activity&gt;\"; mParseActivityArgs.sa = sa; mParseActivityArgs.flags = flags; //【1】创建了一个 Activity 对象！ Activity a = new Activity(mParseActivityArgs, new ActivityInfo()); if (outError[0] != null) &#123; sa.recycle(); return null; &#125; ... ... ... ... int outerDepth = parser.getDepth(); int type; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; // 解析 \"intent-filter\" 标签！ if (parser.getName().equals(\"intent-filter\")) &#123; //【2】创建 ActivityIntentInfo 对象！ ActivityIntentInfo intent = new ActivityIntentInfo(a); //【2.2】解析 \"intent-filter\" 的子标签！ if (!parseIntent(res, parser, true, true, intent, outError)) &#123; return null; &#125; if (intent.countActions() == 0) &#123; Slog.w(TAG, \"No actions in intent filter at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; else &#123; //【4】如果设置了 intent 过滤属性，即 intent.countActions() != 0： a.intents.add(intent); &#125; &#125; else if (!receiver &amp;&amp; parser.getName().equals(\"preferred\")) &#123; // 这个是和 activity 相关的 ActivityIntentInfo intent = new ActivityIntentInfo(a); if (!parseIntent(res, parser, false, false, intent, outError)) &#123; return null; &#125; if (intent.countActions() == 0) &#123; Slog.w(TAG, \"No actions in preferred at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); &#125; else &#123; if (owner.preferredActivityFilters == null) &#123; owner.preferredActivityFilters = new ArrayList&lt;ActivityIntentInfo&gt;(); &#125; owner.preferredActivityFilters.add(intent); &#125; &#125; else if (parser.getName().equals(\"meta-data\")) &#123; if ((a.metaData = parseMetaData(res, parser, a.metaData, outError)) == null) &#123; return null; &#125; &#125; else if (!receiver &amp;&amp; parser.getName().equals(\"layout\")) &#123; parseLayout(res, parser, a); &#125; else &#123; ... ... ... ... &#125; &#125; if (!setExported) &#123; a.info.exported = a.intents.size() &gt; 0; &#125; return a;&#125; 2.2 PackageParser.parseIntent我们来看看 parseIntent 方法中做过了些什么！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private boolean parseIntent(Resources res, XmlResourceParser parser, boolean allowGlobs, boolean allowAutoVerify, IntentInfo outInfo, String[] outError) throws XmlPullParserException, IOException &#123; //【1】这里是解析 \"intent-filter\" 标签的属性，我们这里不重点关注！ TypedArray sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestIntentFilter); ... ... ... ... sa.recycle(); int outerDepth = parser.getDepth(); int type; while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String nodeName = parser.getName(); //【2】解析 \"action\" if (nodeName.equals(\"action\")) &#123; String value = parser.getAttributeValue( ANDROID_RESOURCES, \"name\"); if (value == null || value == \"\") &#123; outError[0] = \"No value supplied for &lt;android:name&gt;\"; return false; &#125; XmlUtils.skipCurrentTag(parser); //【1】设置 action 属性； outInfo.addAction(value); //【3】解析 \"category\" &#125; else if (nodeName.equals(\"category\")) &#123; String value = parser.getAttributeValue( ANDROID_RESOURCES, \"name\"); // android:na if (value == null || value == \"\") &#123; outError[0] = \"No value supplied for &lt;android:name&gt;\"; return false; &#125; XmlUtils.skipCurrentTag(parser); //【2】设置 category 属性； outInfo.addCategory(value); //【4】解析 \"data\" &#125; else if (nodeName.equals(\"data\")) &#123; sa = res.obtainAttributes(parser, com.android.internal.R.styleable.AndroidManifestData); String str = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestData_mimeType, 0); if (str != null) &#123; try &#123; //【4.2】设置 dataType 属性； outInfo.addDataType(str); &#125; catch (IntentFilter.MalformedMimeTypeException e) &#123; outError[0] = e.toString(); sa.recycle(); return false; &#125; &#125; ... ... ... ... sa.recycle(); XmlUtils.skipCurrentTag(parser); &#125; else if (!RIGID_PARSER) &#123; Slog.w(TAG, \"Unknown element under &lt;intent-filter&gt;: \" + parser.getName() + \" at \" + mArchiveSourcePath + \" \" + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); &#125; else &#123; outError[0] = \"Bad element under &lt;intent-filter&gt;: \" + parser.getName(); return false; &#125; &#125; outInfo.hasDefault = outInfo.hasCategory(Intent.CATEGORY_DEFAULT); if (DEBUG_PARSER) &#123; ... ... ... &#125; return true;&#125; 其实看到这里，我们已经能够看出静态注册的 broadcastReceiver 是如何被 PMS 解析了，解析的数据都会被保存到 PackageParser.Package 中！ 2 PMS.scanPackageDirtyLI接下来，PMS 会进一步处理解析的数据！12345678910111213141516171819202122232425262728293031323334353637private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, final int policyFlags, final int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; ... ... ... //【1】将解析到的 BroadcastRecord 数据保存到 PMS 的内部变量 mReceivers 中！ N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; //【2】获得该 package 中静态注册的广播接收者的信息对象 Activity； PackageParser.Activity a = pkg.receivers.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid); //【3】添加到 PMS.mReceivers 中; mReceivers.addActivity(a, \"receiver\"); if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, \" Receivers: \" + r); &#125; ... ...&#125; 将之前是扫描解析到的信息对象 Activity，保存到 PMS.mReceivers 对象中，mReceivers 是一个 ActivityIntentResolver 类的对象，用于保存系统中定义的所有的静态接收者： 123// All available receivers, for your resolving pleasure.final ActivityIntentResolver mReceivers = new ActivityIntentResolver(); 我们继续分析！ 2.1 PMS.ActivityIntentResolver我们来看下 ActivityIntentResolver 是如何处理静态接收者的注册的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final class ActivityIntentResolver extends IntentResolver&lt;PackageParser.ActivityIntentInfo, ResolveInfo&gt; &#123; ... ... ... ... public final void addActivity(PackageParser.Activity a, String type) &#123; //【1】key 为广播接收者组件名，value 为 PackageParser.Activity 对象，保存到内部的 mActivities 哈希表中！ mActivities.put(a.getComponentName(), a); if (DEBUG_SHOW_INFO) Log.v( TAG, \" \" + type + \" \" + (a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name) + \":\"); if (DEBUG_SHOW_INFO) Log.v(TAG, \" Class=\" + a.info.name); //【2】处理对应的 ActivityIntentInfo 对象！ final int NI = a.intents.size(); for (int j=0; j&lt;NI; j++) &#123; PackageParser.ActivityIntentInfo intent = a.intents.get(j); if (\"activity\".equals(type)) &#123; // 因为我们的 type 是 \"receiver\" ，所以不进入该分支！ final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName); final List&lt;PackageParser.Activity&gt; systemActivities = ps != null &amp;&amp; ps.pkg != null ? ps.pkg.activities : null; adjustPriority(systemActivities, intent); &#125; if (DEBUG_SHOW_INFO) &#123; Log.v(TAG, \" IntentFilter:\"); intent.dump(new LogPrinter(Log.VERBOSE, TAG), \" \"); &#125; if (!intent.debugCheck()) &#123; Log.w(TAG, \"==&gt; For Activity \" + a.info.name); &#125; //【2.2】调用了父类的 addFilter 方法； addFilter(intent); &#125; &#125; ... ... ... ... // 内部集合，存储解析到的组件！ private final ArrayMap&lt;ComponentName, PackageParser.Activity&gt; mActivities = new ArrayMap&lt;ComponentName, PackageParser.Activity&gt;(); private int mFlags; &#125; ActivityIntentResolver 继承了 IntentResolver，IntentResolver 是一个模板类： 2.2 IntentResolver.addFilter这里 F 是 PackageParser.ActivityIntentInfo， R 是 ResolveInfo：1234567891011121314151617181920212223242526272829303132public abstract class IntentResolver&lt;F extends IntentFilter, R extends Object&gt; &#123; //【1】调用了 addFilter 方法！ public void addFilter(F f) &#123; if (localLOGV) &#123; Slog.v(TAG, \"Adding filter: \" + f); f.dump(new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), \" \"); Slog.v(TAG, \" Building Lookup Maps:\"); &#125; //【2】添加到内部总集合 mFilters 中！ mFilters.add(f); //【3】根据 filter 属性配置，添加到不同的子集合中！ //【3.1】处理 Scheme； int numS = register_intent_filter(f, f.schemesIterator(), mSchemeToFilter, \" Scheme: \"); //【3.2】处理 Type； int numT = register_mime_types(f, \" Type: \"); //【3.3】处理 Action； if (numS == 0 &amp;&amp; numT == 0) &#123; register_intent_filter(f, f.actionsIterator(), mActionToFilter, \" Action: \"); &#125; //【3.4】处理 TypedAction； if (numT != 0) &#123; register_intent_filter(f, f.actionsIterator(), mTypedActionToFilter, \" TypedAction: \"); &#125; &#125; private final ArraySet&lt;F&gt; mFilters = new ArraySet&lt;F&gt;(); // 所有注册的 filter&#125; 这里我们就是实现了对静态注册的广播接收者的处理！！ 2.2.1 IntentResolver.register_intent_filterregister_intent_filter 用于注册 filter ，并返回注册的数量，对于参数，我们以 mSchemeToFilter 为例： F filter：这里是我们解析的 intentFilter 的 ActivityIntentInfo 对象！ Iterator i：f.schemesIterator()，是一个 Scheme 迭代器，用于遍历该 filter 设置的所有的 Scheme； ArrayMap&lt;String, F[]&gt; dest：是我们要加入集合，这里是 mSchemeToFilter； String prefix：用于 log，不过多关注！ 1234567891011121314151617private final int register_intent_filter(F filter, Iterator&lt;String&gt; i, ArrayMap&lt;String, F[]&gt; dest, String prefix) &#123; if (i == null) &#123; return 0; &#125; int num = 0; while (i.hasNext()) &#123; //【1】这里返回的就是 android:name 属性对应的值！ String name = i.next(); num++; if (localLOGV) Slog.v(TAG, prefix + name); //【2.2.2】继续处理！ addFilter(dest, name, filter); &#125; return num;&#125; 2.2.2 IntentResolver.addFilter123456789101112131415161718192021222324private final void addFilter(ArrayMap&lt;String, F[]&gt; map, String name, F filter) &#123; F[] array = map.get(name); if (array == null) &#123; array = newArray(2); map.put(name, array); array[0] = filter; //【1】保存到 array[0] 中！ &#125; else &#123; final int N = array.length; int i = N; while (i &gt; 0 &amp;&amp; array[i-1] == null) &#123; i--; &#125; if (i &lt; N) &#123; //【2】插入到末尾！ array[i] = filter; &#125; else &#123; //【3】扩充数组为之前的 3/2 倍，插入到末尾！ F[] newa = newArray((N*3)/2); System.arraycopy(array, 0, newa, 0, N); newa[N] = filter; map.put(name, newa); &#125; &#125;&#125; 当我们要发送广播时，是要查找当前系统中所有已经静态注册的广播接收者的，那么我们去看看查询相关的方法： 3 PMS.queryIntentReceivers - 查询静态接收者查询静态注册的广播接收者方法如下：1234567@Overridepublic @NonNull ParceledListSlice&lt;ResolveInfo&gt; queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) &#123; return new ParceledListSlice&lt;&gt;( queryIntentReceiversInternal(intent, resolvedType, flags, userId));&#125; 最终会调用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private @NonNull List&lt;ResolveInfo&gt; queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId) &#123; //【1】如果不存在这个设备用户 id，就返回一个数据为 null 的 list； if (!sUserManager.exists(userId)) return Collections.emptyList(); flags = updateFlagsForResolve(flags, userId, intent); ComponentName comp = intent.getComponent(); if (comp == null) &#123; if (intent.getSelector() != null) &#123; intent = intent.getSelector(); comp = intent.getComponent(); &#125; &#125; //【2】如果 Intent 设置了组件名，就通过组件名直接获取！ if (comp != null) &#123; List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); //【3.1】创建 ResolveInfo 的 list 列表，用于保存匹配结果！ ActivityInfo ai = getReceiverInfo(comp, flags, userId); if (ai != null) &#123; ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; list.add(ri); &#125; return list; &#125; synchronized (mPackages) &#123; //【2】如果 Intent 没有设置组件名和包名，就调用 queryIntent 进行查询！ String pkgName = intent.getPackage(); if (pkgName == null) &#123; //【3.2】使用 queryIntent 方法！ return mReceivers.queryIntent(intent, resolvedType, flags, userId); &#125; //【3】如果 Intent 没有设置组件名，但是设置了包名，就通过之前的扫描解析信息，查询！ final PackageParser.Package pkg = mPackages.get(pkgName); if (pkg != null) &#123; //【3.3】使用 queryIntentForPackage 根据包名查询，mReceivers 中保存了解析到的所有的； return mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers, userId); &#125; return Collections.emptyList(); &#125;&#125; 下面我们一个一个去看看： 3.1 PackageManagerS.getReceiverInfo - 组件名查询12345678910111213141516171819202122232425@Overridepublic ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; flags = updateFlagsForComponent(flags, userId, component); enforceCrossUserPermission(Binder.getCallingUid(), userId, false /* requireFullPermission */, false /* checkShell */, \"get receiver info\"); synchronized (mPackages) &#123; //【1】直接通过组件名获得对应的 PackageParser.Activity 对象，封装了 receiver 的信息！ PackageParser.Activity a = mReceivers.mActivities.get(component); if (DEBUG_PACKAGE_INFO) Log.v( TAG, \"getReceiverInfo \" + component + \": \" + a); if (a != null &amp;&amp; mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) &#123; //【2】如果对应的 PackageSetting 对象为 null，说明应用没有安装，返回 null PackageSetting ps = mSettings.mPackages.get(component.getPackageName()); if (ps == null) return null; //【3.1.1】调用 PackageParser 的 generateActivityInfo 方法继续查询！ return PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId), userId); &#125; &#125; return null;&#125; 继续看： 3.1.1 PackageParser.generateActivityInfo12345678910111213141516171819public static final ActivityInfo generateActivityInfo(Activity a, int flags, PackageUserState state, int userId) &#123; if (a == null) return null; //【1】判断应用是否安装或者隐藏； if (!checkUseInstalledOrHidden(flags, state)) &#123; return null; &#125; //【2】判断是否需要 copy 一份数据，如果不需要就直接返回 mReceivers 中解析到的！ if (!copyNeeded(flags, a.owner, state, a.metaData, userId)) &#123; return a.info; &#125; //【3】获得 Activity 内部的 ActivityInfo 对象的拷贝！ ActivityInfo ai = new ActivityInfo(a.info); ai.metaData = a.metaData; //【4】拷贝封装需要的信息 ai.applicationInfo = generateApplicationInfo(a.owner, flags, state, userId); return ai;&#125; 这里很简单，返回了之前解析获得的广播接收者的 ActivityInfo 对象 ai！ 然后，创建 ResolveInfo ri = new ResolveInfo() 对象，然后初始化 ri.activityInfo = ai，将 ResolveInfo 对象 ri 添加到 List 返回！ 3.2 ActivityIntentResolver.queryIntent - 意图匹配查询这里先会调用子类 ActivityIntentResolver 的 queryIntent 方法！ 12345678910public List&lt;ResolveInfo&gt; queryIntent(Intent intent, String resolvedType, int flags, int userId) &#123; //【1】userId 不存在，返回 null if (!sUserManager.exists(userId)) return null; mFlags = flags; //【3.2.1】调用父类的 queryIntent 方法继续查询！ return super.queryIntent(intent, resolvedType, (flags &amp; PackageManager.MATCH_DEFAULT_ONLY) != 0, userId);&#125; 进入父类 IntentResolver： 3.2.1 IntentResolver.queryIntent这里的模板参数 R 为 ResolveInfo 类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public List&lt;R&gt; queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) &#123; String scheme = intent.getScheme(); //【1】最终要返回的 ArrayList&lt;R&gt; list 集合！ ArrayList&lt;R&gt; finalList = new ArrayList&lt;R&gt;(); final boolean debug = localLOGV || ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); if (debug) Slog.v( TAG, \"Resolving type=\" + resolvedType + \" scheme=\" + scheme + \" defaultOnly=\" + defaultOnly + \" userId=\" + userId + \" of \" + intent); F[] firstTypeCut = null; F[] secondTypeCut = null; F[] thirdTypeCut = null; F[] schemeCut = null; //【2】如果 intent 包含一个 MIME type，我们会手机所有能匹配该 MIME 的 filters！ // MIME 是描述消息内容类型的因特网标准，格式如下：application/pdf if (resolvedType != null) &#123; int slashpos = resolvedType.indexOf('/'); //【2.1】校验指定的 MIME 的格式是否正确，必须要有 / 隔开！ if (slashpos &gt; 0) &#123; //【2.1.1】获得 MIME 的前半部分：application，针对其取值做不同的处理！ final String baseType = resolvedType.substring(0, slashpos); if (!baseType.equals(\"*\")) &#123; //【2.1.1.1】如果 baseType 不为 *，说明 intent 可能指定了一个 MIME，接下来，我们继续处理！ if (resolvedType.length() != slashpos+2 || resolvedType.charAt(slashpos+1) != '*') &#123; // Not a wild card, so we can just look for all filters that // completely match or wildcards whose base type matches. //【2.1.1.1.1】如果 resolvedType firstTypeCut = mTypeToFilter.get(resolvedType); if (debug) Slog.v(TAG, \"First type cut: \" + Arrays.toString(firstTypeCut)); secondTypeCut = mWildTypeToFilter.get(baseType); if (debug) Slog.v(TAG, \"Second type cut: \" + Arrays.toString(secondTypeCut)); &#125; else &#123; //【2.1.1.1.2】如果 resolvedType 的长度等于 slashpos + 2，且 slashpos + 1 为 \"*\" // 那么其能够匹配所有的 \"baseType/*\" firstTypeCut = mBaseTypeToFilter.get(baseType); if (debug) Slog.v(TAG, \"First type cut: \" + Arrays.toString(firstTypeCut)); secondTypeCut = mWildTypeToFilter.get(baseType); if (debug) Slog.v(TAG, \"Second type cut: \" + Arrays.toString(secondTypeCut)); &#125; // Any */* types always apply, but we only need to do this // if the intent type was not already */*. thirdTypeCut = mWildTypeToFilter.get(\"*\"); if (debug) Slog.v(TAG, \"Third type cut: \" + Arrays.toString(thirdTypeCut)); &#125; else if (intent.getAction() != null) &#123; //【2.1.1.2】如果 baseType 为 *，说明是通过正则表达式匹配任何类型的 filters // 这种情况会有风险，那就使用 action 来匹配！ firstTypeCut = mTypedActionToFilter.get(intent.getAction()); if (debug) Slog.v(TAG, \"Typed Action list: \" + Arrays.toString(firstTypeCut)); &#125; &#125; &#125; //【3】如果 intent 设置了 scheme（data URI），收集所有能匹配该 scheme 的 filter！ if (scheme != null) &#123; schemeCut = mSchemeToFilter.get(scheme); if (debug) Slog.v(TAG, \"Scheme list: \" + Arrays.toString(schemeCut)); &#125; //【4】intent 没有设置 Scheme 和 MIME，那就匹配 action！ if (resolvedType == null &amp;&amp; scheme == null &amp;&amp; intent.getAction() != null) &#123; firstTypeCut = mActionToFilter.get(intent.getAction()); if (debug) Slog.v(TAG, \"Action list: \" + Arrays.toString(firstTypeCut)); &#125; //【3.4】开始进一步的匹配，将结果保存到 finalList 中！ FastImmutableArraySet&lt;String&gt; categories = getFastIntentCategories(intent); if (firstTypeCut != null) &#123; buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, firstTypeCut, finalList, userId); &#125; if (secondTypeCut != null) &#123; buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, secondTypeCut, finalList, userId); &#125; if (thirdTypeCut != null) &#123; buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, thirdTypeCut, finalList, userId); &#125; if (schemeCut != null) &#123; buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, schemeCut, finalList, userId); &#125; //【3.5】对结果进行过滤； filterResults(finalList); //【3.6】对结果进行排序； sortResults(finalList); if (debug) &#123; Slog.v(TAG, \"Final result list:\"); for (int i=0; i&lt;finalList.size(); i++) &#123; Slog.v(TAG, \" \" + finalList.get(i)); &#125; &#125; return finalList;&#125; 最后返回匹配的 intent filter！ 3.3 ActivityIntentResolver.queryIntentForPackage - 包名查询参数： ArrayList&lt;PackageParser.Activity&gt; packageActivities：传入 PackageParser.Package.receivers list 集合！12345678910111213141516171819202122232425262728293031323334public List&lt;ResolveInfo&gt; queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList&lt;PackageParser.Activity&gt; packageActivities, int userId) &#123; //【1】userId 不存在，返回 null； if (!sUserManager.exists(userId)) return null; //【2】如果 packageActivities 为 null，返回 null； if (packageActivities == null) &#123; return null; &#125; mFlags = flags; final boolean defaultOnly = (flags&amp;PackageManager.MATCH_DEFAULT_ONLY) != 0; final int N = packageActivities.size(); ArrayList&lt;PackageParser.ActivityIntentInfo[]&gt; listCut = new ArrayList&lt;PackageParser.ActivityIntentInfo[]&gt;(N); //【3】这里是找到 packageActivities 列表中所有 Activity 对象的 ActivityIntentInfo 数组！ // 将其收集起来，保存到 listCut 列表中！ ArrayList&lt;PackageParser.ActivityIntentInfo&gt; intentFilters; for (int i = 0; i &lt; N; ++i) &#123; intentFilters = packageActivities.get(i).intents; if (intentFilters != null &amp;&amp; intentFilters.size() &gt; 0) &#123; PackageParser.ActivityIntentInfo[] array = new PackageParser.ActivityIntentInfo[intentFilters.size()]; intentFilters.toArray(array); listCut.add(array); &#125; &#125; //【3.3.1】调用父类的 queryIntentFromList 方法继续查询！ return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);&#125; 进入父类 IntentResolver 中： 3.3.1 ActivityIntentResolver.queryIntentFromList这里的模板参数 R 为 ResolveInfo 类：1234567891011121314151617181920212223public List&lt;R&gt; queryIntentFromList(Intent intent, String resolvedType, boolean defaultOnly, ArrayList&lt;F[]&gt; listCut, int userId) &#123; //【1】用于保存查询的结果！ ArrayList&lt;R&gt; resultList = new ArrayList&lt;R&gt;(); final boolean debug = localLOGV || ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); FastImmutableArraySet&lt;String&gt; categories = getFastIntentCategories(intent); final String scheme = intent.getScheme(); int N = listCut.size(); for (int i = 0; i &lt; N; ++i) &#123; //【3.4】遍历 ArrayList&lt;PackageParser.ActivityIntentInfo[]&gt; 列表 listCut // 处理每一个 ActivityIntentInfo 数组，也就是 IntentFliter 数组！ buildResolveList(intent, categories, debug, defaultOnly, resolvedType, scheme, listCut.get(i), resultList, userId); &#125; filterResults(resultList); //【3】对结果进行排序！ sortResults(resultList); return resultList;&#125; 3.4 IntentResolver.buildResolveList下面我们来看一下，查询静态注册的广播接收者信息的最重要的一个方法，如何通过 ActivityIntentInfo[] 数组 src，生成 List&lt;ResolveList&gt; 列表 dest： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115private void buildResolveList(Intent intent, FastImmutableArraySet&lt;String&gt; categories, boolean debug, boolean defaultOnly, String resolvedType, String scheme, F[] src, List&lt;R&gt; dest, int userId) &#123; //【1】获得广播 Intent 的 action！ final String action = intent.getAction(); //【2】获得广播 Intent 的 uri 数据！ final Uri data = intent.getData(); //【3】获得广播 Intent 的 package 数据！ final String packageName = intent.getPackage(); //【4】广播是否设置了 FLAG_EXCLUDE_STOPPED_PACKAGES 标志！ final boolean excludingStopped = intent.isExcludingStopped(); final Printer logPrinter; final PrintWriter logPrintWriter; if (debug) &#123; logPrinter = new LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM); logPrintWriter = new FastPrintWriter(logPrinter); &#125; else &#123; logPrinter = null; logPrintWriter = null; &#125; final int N = src != null ? src.length : 0; boolean hasNonDefaults = false; int i; F filter; //【1】遍历传入的 ActivityIntentInfo[] 数组 src，选择能接受当前广播 Intent 的 ActivityIntentInfo！ for (i=0; i&lt;N &amp;&amp; (filter=src[i]) != null; i++) &#123; int match; if (debug) Slog.v(TAG, \"Matching against filter \" + filter); //【3.4.1】如果广播设置了 FLAG_EXCLUDE_STOPPED_PACKAGES 标签，那就要判断 filter 所属的应用是否被 stop 了！ // isFilterStopped 方法是 IntentResolver 的子类中实现！ // 如果满足，那么这个应用是不能接收到当前的广播的！ if (excludingStopped &amp;&amp; isFilterStopped(filter, userId)) &#123; if (debug) &#123; Slog.v(TAG, \" Filter's target is stopped; skipping\"); &#125; continue; &#125; //【3.4.2】如果广播 Intent 设置了包名，那就要判断当前 ActivityIntentInfo 所属的目标应用包名是否一致 // 不一致，说明这个不是目标应用，isPackageForFilter 也是在 IntentResolver 的子类中实现！ if (packageName != null &amp;&amp; !isPackageForFilter(packageName, filter)) &#123; if (debug) &#123; Slog.v(TAG, \" Filter is not from package \" + packageName + \"; skipping\"); &#125; continue; &#125; if (filter.getAutoVerify()) &#123; if (localVerificationLOGV || debug) &#123; Slog.v(TAG, \" Filter verified: \" + isFilterVerified(filter)); int authorities = filter.countDataAuthorities(); for (int z = 0; z &lt; authorities; z++) &#123; Slog.v(TAG, \" \" + filter.getDataAuthority(z).getHost()); &#125; &#125; &#125; //【3.4.3】allowFilterResult 方法也是在 IntentResolver 的子类中实现！ // 判断我们是否已经添加过这个 filter！ if (!allowFilterResult(filter, dest)) &#123; if (debug) &#123; Slog.v(TAG, \" Filter's target already added\"); &#125; continue; &#125; //【2】进行匹配操作，结果返回值 match &gt;= 0，说明匹配成功！ match = filter.match(action, resolvedType, scheme, data, categories, TAG); if (match &gt;= 0) &#123; if (debug) Slog.v(TAG, \" Filter matched! match=0x\" + Integer.toHexString(match) + \" hasDefault=\" + filter.hasCategory(Intent.CATEGORY_DEFAULT)); if (!defaultOnly || filter.hasCategory(Intent.CATEGORY_DEFAULT)) &#123; //【3.4.4】创建 ResolveList 对象！ // newResult 方法也是在 IntentResolver 的子类中实现中实现 final R oneResult = newResult(filter, match, userId); if (oneResult != null) &#123; //【2.2】添加到目标集合 dest 中！ dest.add(oneResult); if (debug) &#123; dumpFilter(logPrintWriter, \" \", filter); logPrintWriter.flush(); filter.dump(logPrinter, \" \"); &#125; &#125; &#125; else &#123; hasNonDefaults = true; &#125; &#125; else &#123; if (debug) &#123; String reason; switch (match) &#123; case IntentFilter.NO_MATCH_ACTION: reason = \"action\"; break; case IntentFilter.NO_MATCH_CATEGORY: reason = \"category\"; break; case IntentFilter.NO_MATCH_DATA: reason = \"data\"; break; case IntentFilter.NO_MATCH_TYPE: reason = \"type\"; break; default: reason = \"unknown reason\"; break; &#125; Slog.v(TAG, \" Filter did not match: \" + reason); &#125; &#125; &#125; if (debug &amp;&amp; hasNonDefaults) &#123; if (dest.size() == 0) &#123; Slog.v(TAG, \"resolveIntent failed: found match, but none with CATEGORY_DEFAULT\"); &#125; else if (dest.size() &gt; 1) &#123; Slog.v(TAG, \"resolveIntent: multiple matches, only some with CATEGORY_DEFAULT\"); &#125; &#125;&#125; 这个方法流程很简单，我们来看一些细节！ 3.4.1 ActivityIntentResolver ActivityIntentResolver.isFilterStopped12345678910111213@Overrideprotected boolean isFilterStopped(PackageParser.ActivityIntentInfo filter, int userId) &#123; if (!sUserManager.exists(userId)) return true; PackageParser.Package p = filter.activity.owner; if (p != null) &#123; PackageSetting ps = (PackageSetting)p.mExtras; if (ps != null) &#123; return (ps.pkgFlags&amp;ApplicationInfo.FLAG_SYSTEM) == 0 &amp;&amp; ps.getStopped(userId); &#125; &#125; return false;&#125; isFilterStopped 方法用来判断 filter 所属的应用是否被强行停止了，返回 true 的情况如下： 设备用户 id 不存在； filter 所属的应用是非系统应用，且应用的 stoped 属性被置为 true； 该方法返回 true，表示该应用在该设备用户下，被强制停止了！ 3.4.2 ActivityIntentResolver.isPackageForFilter123456@Overrideprotected boolean isPackageForFilter(String packageName, PackageParser.ActivityIntentInfo info) &#123; //【1】就是匹配下 package name！ return packageName.equals(info.activity.owner.packageName);&#125; 这个方法很简单，不用多说了，就是判断 Intent 设置的包名和 filter 所属的应用的包名是不是一样的！一样的话，说明该应用是广播的目标应用！ 3.4.3 ActivityIntentResolver.allowFilterResult123456789101112131415@Overrideprotected boolean allowFilterResult( PackageParser.ActivityIntentInfo filter, List&lt;ResolveInfo&gt; dest) &#123; //【1】获得 filter 所属的组件的 ActivityInfo 对象！ ActivityInfo filterAi = filter.activity.info; for (int i=dest.size()-1; i&gt;=0; i--) &#123; ActivityInfo destAi = dest.get(i).activityInfo; if (destAi.name == filterAi.name &amp;&amp; destAi.packageName == filterAi.packageName) &#123; return false; &#125; &#125; return true;&#125; 该方法的作用是是否重复添加过同一个 filter，判断依据是：要被添加的 filter 的组件名和包名是否和 dest 集合中的某个 filter 一样！！ ActivityInfo 是对应组件的信息对象，ActivityInfo.name 这个值来自于 android:name 属性！！ 3.4.4 ActivityIntentResolver.newResult最后，就是将 ActivityIntentInfo 对象封装为 ResolveInfo 对象了！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Overrideprotected ResolveInfo newResult(PackageParser.ActivityIntentInfo info, int match, int userId) &#123; //【1】如果设备用户不存在，返回 null； if (!sUserManager.exists(userId)) return null; if (!mSettings.isEnabledAndMatchLPr(info.activity.info, mFlags, userId)) &#123; return null; &#125; final PackageParser.Activity activity = info.activity; PackageSetting ps = (PackageSetting) activity.owner.mExtras; if (ps == null) &#123; return null; &#125; //【2】获得组件新的 ActivityInfo 拷贝对象 ai！ ActivityInfo ai = PackageParser.generateActivityInfo(activity, mFlags, ps.readUserState(userId), userId); if (ai == null) &#123; return null; &#125; //【3】创建一个 ResolveInfo 对象 res，并设置 res.activityInfo 为 ai； final ResolveInfo res = new ResolveInfo(); res.activityInfo = ai; if ((mFlags&amp;PackageManager.GET_RESOLVED_FILTER) != 0) &#123; res.filter = info; &#125; if (info != null) &#123; res.handleAllWebDataURI = info.handleAllWebDataURI(); &#125; res.priority = info.getPriority(); res.preferredOrder = activity.owner.mPreferredOrder; //System.out.println(\"Result: \" + res.activityInfo.className + // \" = \" + res.priority); res.match = match; res.isDefault = info.hasDefault; res.labelRes = info.labelRes; res.nonLocalizedLabel = info.nonLocalizedLabel; if (userNeedsBadging(userId)) &#123; res.noResourceId = true; &#125; else &#123; res.icon = info.icon; &#125; res.iconResourceId = info.icon; //【4】是否是系统应用！ res.system = res.activityInfo.applicationInfo.isSystemApp(); //【5】返回我们创建的新的 ResolveInfo 对象！ return res;&#125; 到这里，我们就知道了如何查询系统中所有注册过的广播接收者了！ 4 总结！我们来看看广播的静态注册的类关系图： 4.1 静态注册类关系图PMS 解析了静态注册的广播接收者后，数据结婚间的关系图如下： 4.2 查询注册结果关系图","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"BroadcastReceiver广播接收者","slug":"AndroidFramework源码分析/BroadcastReceiver广播接收者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/"}],"tags":[{"name":"BroadcastReceiver广播接收者","slug":"BroadcastReceiver广播接收者","permalink":"https://coolqi.top/tags/BroadcastReceiver广播接收者/"}]},{"title":"BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析","slug":"BroadcastReceiver3-unregisterReceiverAndTimeOut","date":"2016-05-04T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/05/04/BroadcastReceiver3-unregisterReceiverAndTimeOut/","link":"","permalink":"https://coolqi.top/2016/05/04/BroadcastReceiver3-unregisterReceiverAndTimeOut/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，分析 BroadcastReceiver 动态注册 的过程，转载请说明出处！ 0 综述BroadcastReceiver 动态注册后，需要动态取消注册： 1public void unregisterReceiver(BroadcastReceiver receiver); 下面，我们来进入源码，分析 unregisterReceiver 的流程！ 1 应用进程我们先去应用进程来看下： 1.1 ContextWrapper.unregisterReceiver1234@Overridepublic void unregisterReceiver(BroadcastReceiver receiver) &#123; mBase.unregisterReceiver(receiver);&#125; 这里的 mBase 为 ContextImpl 实例！ 1.2 ContextImpl.unregisterReceiver123456789101112131415161718@Overridepublic void unregisterReceiver(BroadcastReceiver receiver) &#123; if (mPackageInfo != null) &#123; //【*1.2.1】获得接收者对应的 InnerReceiver 对象！ IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher( getOuterContext(), receiver); try &#123; //【*1.2.2】进入系统进程，取消动态接收者的注册！ // 这是同步调用！ ActivityManagerNative.getDefault().unregisterReceiver(rd); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; else &#123; throw new RuntimeException(\"Not supported in system context\"); &#125;&#125; mPackageInfo 是 LoadedApk 实例，用来保存应用程序的加载信息，每一个进程都会有一个！ 这里我们来分析下： 1.2.1 LoadedApk.forgetReceiverDispatcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public IIntentReceiver forgetReceiverDispatcher(Context context, BroadcastReceiver r) &#123; synchronized (mReceivers) &#123; //【1】首先，获得当前设备用户下，动态注册的所有接收者的 map 表！ ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = mReceivers.get(context); LoadedApk.ReceiverDispatcher rd = null; if (map != null) &#123; //【1.2】获得该接收者对应的 ReceiverDispatcher 对象！ rd = map.get(r); if (rd != null) &#123; //【1.3】从 map 表中移除该 rd 对象！ map.remove(r); if (map.size() == 0) &#123; mReceivers.remove(context); &#125; //【1.4】只有设置了 debug 模式，才会进入！ if (r.getDebugUnregister()) &#123; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder = mUnregisteredReceivers.get(context); //【1.5】会将该接触注册的接收者添加到 mUnregisteredReceivers 集合中！ if (holder == null) &#123; holder = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mUnregisteredReceivers.put(context, holder); &#125; RuntimeException ex = new IllegalArgumentException( \"Originally unregistered here:\"); ex.fillInStackTrace(); rd.setUnregisterLocation(ex); holder.put(r, rd); &#125; //【1.6】设置 ReceiverDispatcher 对象的 mForgotten 值为 true！ rd.mForgotten = true; //【1.7】返回内部的 InnerReceiver 对象！ return rd.getIIntentReceiver(); &#125; &#125; //【2】每个动态注册的接收者都只能被 unregisteredReceivers 一次，不然会抛出异常！ ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder = mUnregisteredReceivers.get(context); if (holder != null) &#123; rd = holder.get(r); if (rd != null) &#123; RuntimeException ex = rd.getUnregisterLocation(); throw new IllegalArgumentException( \"Unregistering Receiver \" + r + \" that was already unregistered\", ex); &#125; &#125; if (context == null) &#123; throw new IllegalStateException(\"Unbinding Receiver \" + r + \" from Context that is no longer in use: \" + context); &#125; else &#123; throw new IllegalArgumentException(\"Receiver not registered: \" + r); &#125; &#125;&#125; 这个方法的主要作用是： 删除 ReceiverDispatcher 对象； 返回接收者对应的 InnerReceiver 对象； 继续来看： 1.2.2 ActivityManagerProxy.unregisterReceiver123456789101112public void unregisterReceiver(IIntentReceiver receiver) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(receiver.asBinder()); //【1】Binder 通信：UNREGISTER_RECEIVER_TRANSACTION mRemote.transact(UNREGISTER_RECEIVER_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 下面会进入系统进程，我们直接去看！ 2 系统进程首先会进入 ActivityManagerN 中去：1234567891011121314case UNREGISTER_RECEIVER_TRANSACTION:&#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); if (b == null) &#123; return true; &#125; //【1】这里将客户端的 InnerReceiver 转为了服务端的 IIntentReceiver.Proxy 对象！ IIntentReceiver rec = IIntentReceiver.Stub.asInterface(b); //【2】继续调用 unregisterReceiver，解除注册！ unregisterReceiver(rec); reply.writeNoException(); return true;&#125; 进入 ActivityManagerS 中去！ 2.1 ActivityManagerS.unregisterReceiver这里的 receiver 是接收者在系统进程中的 Binder 对象！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void unregisterReceiver(IIntentReceiver receiver) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Unregister receiver: \" + receiver); final long origId = Binder.clearCallingIdentity(); try &#123; boolean doTrim = false; synchronized(this) &#123; //【1】获得对应的 ReceiverList 过滤器对象！ ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); if (rl != null) &#123; //【2.1.1】判断接收者是否在处理有序发送的广播，如果在处理广播，就要立刻结束处理！ final BroadcastRecord r = rl.curBroadcast; if (r != null &amp;&amp; r == r.queue.getMatchingOrderedReceiver(r)) &#123; //【×2.1.2】立刻结束广播处理！ final boolean doNext = r.queue.finishReceiverLocked( r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); //【2】继续分发广播！ if (doNext) &#123; doTrim = true; r.queue.processNextBroadcast(false); &#125; &#125; if (rl.app != null) &#123; rl.app.receivers.remove(rl); &#125; //【×2.1.3】移除该广播接收者！ removeReceiverLocked(rl); //【5】如果绑定了死亡监听，就取消绑定！ if (rl.linkedToDeath) &#123; rl.linkedToDeath = false; rl.receiver.asBinder().unlinkToDeath(rl, 0); &#125; &#125; &#125; //【6】回收资源！ if (doTrim) &#123; trimApplications(); return; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 这段代码主要作用： 如果当前接收者正在处理有序发送的广播，那就立刻结束处理； 对于有序发送的广播，继续分发广播； 移除当前接收者，同时解除绑定； 我们继续分析细节！ 2.1.1 BroadcastQueue.getMatchingOrderedReceiver该方法用来判断当前是否有有序分发的广播发送给当前的广播！123456789public BroadcastRecord getMatchingOrderedReceiver(IBinder receiver) &#123; if (mOrderedBroadcasts.size() &gt; 0) &#123; final BroadcastRecord r = mOrderedBroadcasts.get(0); if (r != null &amp;&amp; r.receiver == receiver) &#123; return r; &#125; &#125; return null;&#125; 判断依据很简单：当有序发送的广播指定了某个动态接收者时，其 r.receiver 会保存接收者对应的 IIntentReceiver.Proxy 对象！ 2.1.2 BroadcastQueue.finishReceiverLocked立刻结束广播的处理，注意：这里的 waitForServices 传入的是 false，结果表示是否 finish 完成！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public boolean finishReceiverLocked(BroadcastRecord r, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, boolean waitForServices) &#123; final int state = r.state; final ActivityInfo receiver = r.curReceiver; //【1】初始化广播的状态为 BroadcastRecord.IDLE！ r.state = BroadcastRecord.IDLE; if (state == BroadcastRecord.IDLE) &#123; Slog.w(TAG, \"finishReceiver [\" + mQueueName + \"] called but state is IDLE\"); &#125; //【2】清空广播的当前目标接收者 Binder 实体！ r.receiver = null; //【3】清空广播的 Intent 组件信息！ r.intent.setComponent(null); //【4】清空广播目标进程的 curReceiver！ if (r.curApp != null &amp;&amp; r.curApp.curReceiver == r) &#123; r.curApp.curReceiver = null; &#125; //【5】清空广播目标 filter 所在的接收者处理的当前广播； if (r.curFilter != null) &#123; r.curFilter.receiverList.curBroadcast = null; &#125; r.curFilter = null; r.curReceiver = null; r.curApp = null; mPendingBroadcast = null; //【6】保存了和返回的结果码等信息； r.resultCode = resultCode; r.resultData = resultData; r.resultExtras = resultExtras; //【7】是否忽视结果； if (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == 0) &#123; r.resultAbort = resultAbort; &#125; else &#123; r.resultAbort = false; &#125; //【8】因为 waitForServices 不进入该分支！ if (waitForServices &amp;&amp; r.curComponent != null &amp;&amp; r.queue.mDelayBehindServices &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; 0 &amp;&amp; r.queue.mOrderedBroadcasts.get(0) == r) &#123; ActivityInfo nextReceiver; if (r.nextReceiver &lt; r.receivers.size()) &#123; Object obj = r.receivers.get(r.nextReceiver); nextReceiver = (obj instanceof ActivityInfo) ? (ActivityInfo)obj : null; &#125; else &#123; nextReceiver = null; &#125; if (receiver == null || nextReceiver == null || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid || !receiver.processName.equals(nextReceiver.processName)) &#123; //【8.1】延迟结束该广播的本次分发！ if (mService.mServices.hasBackgroundServices(r.userId)) &#123; Slog.i(TAG, \"Delay finish: \" + r.curComponent.flattenToShortString()); r.state = BroadcastRecord.WAITING_SERVICES; return false; &#125; &#125; &#125; r.curComponent = null; //【9】判断广播的状态！ return state == BroadcastRecord.APP_RECEIVE || state == BroadcastRecord.CALL_DONE_RECEIVE;&#125; 这个过程主要有以下的目的： 初始化广播的属性，为下次分发做准备； 然后根据广播的状态，判断是否需要继续分发； 对于有序发送广播，如果其目标接收者为动态注册，那么广播的状态为 BroadcastRecord.CALL_DONE_RECEIVE, 这里就会返回 true! 这里在 sendBroadcast 流程中有讲，这里就不再细说了！ 2.1.3 ActivityManagerS.removeReceiverLocked12345678void removeReceiverLocked(ReceiverList rl) &#123; //【1】从动态注册的接收者列表中移除该接收者！ mRegisteredReceivers.remove(rl.receiver.asBinder()); for (int i = rl.size() - 1; i &gt;= 0; i--) &#123; //【2】移除该接收者的 filter！ mReceiverResolver.removeFilter(rl.get(i)); &#125;&#125; 这个方法逻辑很简单； 从 mRegisteredReceivers 中删除该动态注册的接收者； 从 mReceiverResolver 中删除该动态注册的接收者对应的过滤器对象； 3 TimeOut 流程分析下面我们来看看广播的超时处理！ 3.1 设置超时对于有序发送的广播（注意：不是有序广播），是会设置超时处理，防止一个接收者的处理超时，导致其他接收者无法接收到广播。设置超时的地方是在 processNextBroadcast 方法中： 3.1.1 BroadcastQueue.processNextBroadcast1234567891011121314151617r.receiverTime = SystemClock.uptimeMillis();if (recIdx == 0) &#123; r.dispatchTime = r.receiverTime; r.dispatchClockTime = System.currentTimeMillis(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Processing ordered broadcast [\" + mQueueName + \"] \" + r);&#125;if (!mPendingBroadcastTimeoutMessage) &#123; //【1】计算超时时间点，时间为 r.receiverTime 加上 mTimeoutPeriod！ long timeoutTime = r.receiverTime + mTimeoutPeriod; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Submitting BROADCAST_TIMEOUT_MSG [\" + mQueueName + \"] for \" + r + \" at \" + timeoutTime); //【×3.1.2】设置超时任务！ setBroadcastTimeoutLocked(timeoutTime);&#125; 每次在有序发送广播给接收者的时候，会设置 r.receiverTime 的值，超时是基于这个值来计算的！ mPendingBroadcastTimeoutMessage 表示当前是否有超时的消息被处理，默认是为 false！ timeoutTime 是超时任务的触发时间点，系统会该时间点发送 BROADCAST_TIMEOUT_MSG消息，系统进程主线程会处理该消息！ mTimeoutPeriod 表示超时周期，是一段时间间隔！前台队列和后台队列的 mTimeoutPeriod 是不一样的： 1234mFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", BROADCAST_FG_TIMEOUT, false);mBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", BROADCAST_BG_TIMEOUT, true); 对于前台队列，超时周期为 10 s：static final int BROADCAST_FG_TIMEOUT = 10*1000; 对于后台队列，超时周期为 60 s：static final int BROADCAST_BG_TIMEOUT = 60*1000; 3.1.2 BroadcastQueue.setBroadcastTimeoutLocked设置超时消息！ 12345678910final void setBroadcastTimeoutLocked(long timeoutTime) &#123; if (!mPendingBroadcastTimeoutMessage) &#123; Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this); //【1】发送消息！ mHandler.sendMessageAtTime(msg, timeoutTime); //【2】将 mPendingBroadcastTimeoutMessage 置为 true！ mPendingBroadcastTimeoutMessage = true; &#125;&#125; 超时时间点到了后，会发送 BROADCAST_TIMEOUT_MSG 消息给系统进程主线程的 Handler 处理！ 3.1.3 BroadcastHandler.handleMessage[BROADCAST_TIMEOUT_MSG]这里只列举重点的代码：12345678switch (msg.what) &#123; case BROADCAST_TIMEOUT_MSG: &#123; synchronized (mService) &#123; //【×3.1.4】处理广播超时！ broadcastTimeoutLocked(true); &#125; &#125; break; &#125; 3.1.4 BroadcastQueue.broadcastTimeoutLocked执行超时任务的处理，此时 fromMsg 为 true，因为是通过 BroadcastHandler 触发的超时处理！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122final void broadcastTimeoutLocked(boolean fromMsg) &#123; if (fromMsg) &#123; mPendingBroadcastTimeoutMessage = false; &#125; //【1】有序发送的广播队列为空，不处理，返回！ if (mOrderedBroadcasts.size() == 0) &#123; return; &#125; long now = SystemClock.uptimeMillis(); //【2】获得超时的广播，因为每次发送的时候，都是从 mOrderedBroadcasts 的 0 index 处获取广播！ BroadcastRecord r = mOrderedBroadcasts.get(0); if (fromMsg) &#123; //【2.1】如果系统正在进行 odex 优化，就延迟超时任务的处理，并返回！ if (mService.mDidDexOpt) &#123; mService.mDidDexOpt = false; //【×3.1.2】这里延长了 time out 的时间！ long timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod; setBroadcastTimeoutLocked(timeoutTime); return; &#125; //【2.2】系统进程没有准备好，返回！ if (!mService.mProcessesReady) &#123; return; &#125; //【2.3】如果当前时间没到超时时间点，说明没有超时，再次重置任务，返回！ long timeoutTime = r.receiverTime + mTimeoutPeriod; if (timeoutTime &gt; now) &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Premature timeout [\" + mQueueName + \"] @ \" + now + \": resetting BROADCAST_TIMEOUT_MSG for \" + timeoutTime); //【×3.1.2】重新设置超时时间点！ setBroadcastTimeoutLocked(timeoutTime); return; &#125; &#125; BroadcastRecord br = mOrderedBroadcasts.get(0); //【3】判断广播的状态，如果此时是 WAITING_SERVICES，说明当前的接收者已经处理完毕， // 但是需要等待目标进程后台服务启动后，才能发送给下一个接收者！ if (br.state == BroadcastRecord.WAITING_SERVICES) &#123; Slog.i(TAG, \"Waited long enough for: \" + (br.curComponent != null ? br.curComponent.flattenToShortString() : \"(null)\")); //【3.1】如果此时触发了该广播的超时任务，就直接初始化广播属性，发送给下一个接收者，然后返回！ br.curComponent = null; br.state = BroadcastRecord.IDLE; //【3.2】继续分发！ processNextBroadcast(false); return; &#125; Slog.w(TAG, \"Timeout of broadcast \" + r + \" - receiver=\" + r. receiver + \", started \" + (now - r.receiverTime) + \"ms ago\"); //【4】广播的接收时间设置为当前！ r.receiverTime = now; //【5】广播的 ANR 次数加 1； r.anrCount++; // Current receiver has passed its expiration date. if (r.nextReceiver &lt;= 0) &#123; Slog.w(TAG, \"Timeout on receiver with nextReceiver &lt;= 0\"); return; &#125; ProcessRecord app = null; String anrMessage = null; //【7】设置广播的当前接收者的分发状态为 BroadcastRecord.DELIVERY_TIMEOUT，表示分发超时！ Object curReceiver = r.receivers.get(r.nextReceiver-1); r.delivery[r.nextReceiver-1] = BroadcastRecord.DELIVERY_TIMEOUT; Slog.w(TAG, \"Receiver during timeout: \" + curReceiver); logBroadcastReceiverDiscardLocked(r); //【8】获得广播接收者所在的进程！ if (curReceiver instanceof BroadcastFilter) &#123; BroadcastFilter bf = (BroadcastFilter)curReceiver; if (bf.receiverList.pid != 0 &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123; synchronized (mService.mPidsSelfLocked) &#123; app = mService.mPidsSelfLocked.get( bf.receiverList.pid); &#125; &#125; &#125; else &#123; app = r.curApp; &#125; //【9】广播处理超时后，会导致 ANR 的问题，这里是设置 ANR 的信息！ if (app != null) &#123; anrMessage = \"Broadcast of \" + r.intent.toString(); &#125; //【10】如果正在进程启动的广播！ if (mPendingBroadcast == r) &#123; mPendingBroadcast = null; &#125; //【11】结束当前的接收者； finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); //【12】将广播发送给下一个接收者； scheduleBroadcastsLocked(); if (anrMessage != null) &#123; //【×3.1.5】发送 ANR 消息！ mHandler.post(new AppNotResponding(app, anrMessage)); &#125;&#125; 这个函数的逻辑梳理如下： 1 如果有序列表集合 mOrderedBroadcasts 为空，不做任何处理，直接返回； 2 如果系统正在进行 odex 优化，就延迟超时任务的处理，并返回； 3 系统进程没有准备好，不做任何处理，直接返回； 4 如果超时处理提前触发了，就重置超时处理，并返回； 5 如果当前广播的状态是 BroadcastRecord.WAITING_SERVICES，说明当前接受者已经处理完毕了，但是该广播在等待后台服务的启动，那就初始化广播属性，直接发送给下一个接受者，返回！ 如果以上条件不满足，那么该广播处理超时会导致 ANR 的问题： 设置当前接收者的分发状态为：BroadcastRecord.DELIVERY_TIMEOUT 获得下一个广播接收者进程 ProcessRecord 结束当前的接收者 finishReceiverLocked； 将广播发送给下一个接收者 scheduleBroadcastsLocked; 最后，就是很关键的一步了： 创建一个 Runable，主线程会执行该任务，抛出 ANR 异常！ 3.1.5 new AppNotRespondingAppNotResponding 继承了 Runnable，我们来看看它的 run 方法：1234567891011121314private final class AppNotResponding implements Runnable &#123; private final ProcessRecord mApp; private final String mAnnotation; public AppNotResponding(ProcessRecord app, String annotation) &#123; mApp = app; mAnnotation = annotation; &#125; @Override public void run() &#123; mService.mAppErrors.appNotResponding(mApp, null, null, false, mAnnotation); &#125;&#125; 系统进程的主线程会执行该 Runable，AppNotResponding 会调用 mAppErrors.appNotResponding 方法处理接收者进程的 ANR! 这里我简单的提一下，AppErrors 是 ActivityManagerService 专门用来处理系统和应用的 ANR 和 Crash 的类！ 后面会写一篇文章来详细分析其处理的过程，这里就不先不细说了！！ 3.2 取消超时当有序发送的广播及时处理后，我们会取消超时消息，我们回到 processNextBroadcast 方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; ... ... ... do &#123; if (mOrderedBroadcasts.size() == 0) &#123; mService.scheduleAppGcsLocked(); if (looped) &#123; mService.updateOomAdjLocked(); &#125; return; &#125; r = mOrderedBroadcasts.get(0); boolean forceReceive = false; ... ... ... ... //【1】当有序发送的广播发送完成或者被终止的时候，会 remove 掉该超时消息！ if (r.receivers == null || r.nextReceiver &gt;= numReceivers || r.resultAbort || forceReceive) &#123; if (r.resultTo != null) &#123; try &#123; if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, \"Finishing broadcast [\" + mQueueName + \"] \" + r.intent.getAction() + \" app=\" + r.callerApp); performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId); r.resultTo = null; &#125; catch (RemoteException e) &#123; r.resultTo = null; Slog.w(TAG, \"Failure [\" + mQueueName + \"] sending broadcast result of \" + r.intent, e); &#125; &#125; //【3.2.1】移除超时消息！ cancelBroadcastTimeoutLocked(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Finished with ordered broadcast \" + r); addBroadcastToHistoryLocked(r); if (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; // This was an implicit broadcast... let's record it for posterity. mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage, r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime); &#125; mOrderedBroadcasts.remove(0); r = null; looped = true; continue; &#125; &#125; while (r == null); 这里可以看到，只有在广播发送完成或者被终止的时候，才会移除消息！ 因为每次有序发送广播的时候，都会重新设置超时消息，具体的逻辑见：processNextBroadcast 方法！ 3.2.1 BroadcastQueue.cancelBroadcastTimeoutLocked取消广播超时消息： 1234567final void cancelBroadcastTimeoutLocked() &#123; if (mPendingBroadcastTimeoutMessage) &#123; mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, this); mPendingBroadcastTimeoutMessage = false; &#125;&#125; 4 总结关于 unregisterReceiver 和 TimeOut 超时处理的逻辑就分析到这里！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"BroadcastReceiver广播接收者","slug":"AndroidFramework源码分析/BroadcastReceiver广播接收者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/"}],"tags":[{"name":"BroadcastReceiver广播接收者","slug":"BroadcastReceiver广播接收者","permalink":"https://coolqi.top/tags/BroadcastReceiver广播接收者/"}]},{"title":"BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析","slug":"BroadcastReceiver2-dynamicRegisterReceiver","date":"2016-05-01T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/05/01/BroadcastReceiver2-dynamicRegisterReceiver/","link":"","permalink":"https://coolqi.top/2016/05/01/BroadcastReceiver2-dynamicRegisterReceiver/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，分析 BroadcastReceiver 动态注册 的过程，转载请说明出处！ 0 综述BroadcastReceiver 动态注册，就是应用程序在运行过程中，调用 registerReceiver 方法注册：12345678910111213@Overridepublic Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter)；@Overridepublic Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)；@Overridepublic Intent registerReceiverAsUser( BroadcastReceiver receiver, UserHandle user, IntentFilter filter, String broadcastPermission, Handler scheduler)； 可以看到，动态注册广播接收者者时，我们需要创建一个 IntentFilter 过滤器对象，我们还可以指定广播发送者的权限，除此之外，我们还可以通过传入 Handler 来指定 onReceive 方法执行的线程（默认是主线程）。 当应用不再需要这个广播接收者后，需要动态取消注册： 1public void unregisterReceiver(BroadcastReceiver receiver); 下面，我们来进入源码，分析动态注册的流程！ 1 应用进程1.1 ContextWapper.registerReceiver123456789101112131415161718192021222324252627@Overridepublic Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter);&#125;// broadcastPermission 用来指定发送者需要的权限！// scheduler 用来指定 onReceive 方法执行的线程！@Overridepublic Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return mBase.registerReceiver(receiver, filter, broadcastPermission, scheduler);&#125;/** @hide */@Overridepublic Intent registerReceiverAsUser( BroadcastReceiver receiver, UserHandle user, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return mBase.registerReceiverAsUser(receiver, user, filter, broadcastPermission, scheduler);&#125; 这里的 mBase 是 ContextImpl 对象！ 1.2 ContextImpl.registerReceiver进入 ContextImpl 继续看：1234567891011121314151617181920@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; return registerReceiver(receiver, filter, null, null);&#125;@Overridepublic Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext());&#125;@Overridepublic Intent registerReceiverAsUser(BroadcastReceiver receiver, UserHandle user, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return registerReceiverInternal(receiver, user.getIdentifier(), filter, broadcastPermission, scheduler, getOuterContext());&#125; 我们可以看到，虽然是不同的注册方法，最后都调用了 registerReceiverInternal 方法！getOuterContext() 方法用于获得注册时的上下文运行环境！也就是代表注册时所属的组件！！ 1.3 ContextImpl.registerReceiverInternal - 核心入口12345678910111213141516171819202122232425262728293031323334353637383940414243private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; //【1】mPackageInfo 是 LoadedApk 对象，每个进程都有一个！ if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; // 如果传入的 Handler 为 null，就设置 scheduler 为所在进程的主线程 Handler! scheduler = mMainThread.getHandler(); &#125; //【*1.3.1】获得 BroadcastReceiver 对应的 IIntentReceiver 对象！ rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; //【*1.3.2】创建一个 ReceiverDispatcher 对象！ rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; //【*1.4】进入系统进程，继续注册！ final Intent intent = ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; IIntentReceiver 类实例 rd 用来在应用进程和系统进程中进行 Binder 通信！ Handler 类对象 scheduler 用来设置接受到广播后 onReceive 执行的线程，如果传入 null，默认就在主线程！ 这里涉及到一个 mPackageInfo，他是 LoadedApk 类的实例。每一个进程在创建时，都会有一个 LoadedApk 对象。用来分装一个应用程序的信息！ 我们去 LoadedApk 目录去看看： 1.3.1 LoadedApk.getReceiverDispatcher这里的 boolean registered 为 true：123456789101112131415161718192021222324252627282930313233343536373839public getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; //【1】尝试获得对应的 ReceiverDispatcher，如果没有就重新创建！ LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; //【*1.3.2】第一次注册，创建全新的 ReceiverDispatcher 对象！ if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; //【2】校验一下 context 和 handler 是否和之前注册的一样，不一样会抛出异常！ rd.validate(context, handler); &#125; rd.mForgotten = false; //【3】返回内部的 InnerReceiver 对象！ return rd.getIIntentReceiver(); &#125;&#125; LoadedApk 有一个 ArrayMap 集合 mReceivers：12private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt;&gt; mReceivers = new ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt;(); 用来保存当前进程下，每个上下文运行环境 Context 中，对应的 BroadcastReceiver 和 ReceiverDispatcher 的映射关系！ 1.3.2 new LoadedApk.ReceiverDispatcher我们再去看看 ReceiverDispatcher 对象： 12345678910111213141516171819ReceiverDispatcher(BroadcastReceiver receiver, Context context, Handler activityThread, Instrumentation instrumentation, boolean registered) &#123; if (activityThread == null) &#123; throw new NullPointerException(\"Handler must not be null\"); &#125; //【*1.3.2.1】创建了一个 InnerReceiver 对象，用于 Binder 通信！ mIIntentReceiver = new InnerReceiver(this, !registered); mReceiver = receiver; mContext = context; mActivityThread = activityThread; mInstrumentation = instrumentation; mRegistered = registered; mLocation = new IntentReceiverLeaked(null); mLocation.fillInStackTrace();&#125; 这里的 IntentReceiverLeaked，我们不过多分析，很简单！12345final class IntentReceiverLeaked extends AndroidRuntimeException &#123; public IntentReceiverLeaked(String msg) &#123; super(msg); &#125;&#125; ReceiverDispatcher 用于保存 BroadcastReceiver 和 InnerReceiver 映射关系，我们继续看： 1.3.2.1 new ReceiverDispatcher.InnerReceiver1234567891011121314151617final static class InnerReceiver extends IIntentReceiver.Stub &#123; final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher; final LoadedApk.ReceiverDispatcher mStrongRef; InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123; //【1】创建了一个 ReceiverDispatcher 的弱引用！ mDispatcher = new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd); //【2】这里 strong 为 false，所以 mStrongRef 为 null； mStrongRef = strong ? rd : null; &#125; @Override public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; ... ... ... ... // 用于处理广播的接收！ &#125;&#125; 我们可以看到 InnerReceiver 继承了 IIntentReceiver.Stub，他是作为 Binder 通信的服务端，其实，这种架构，我们在 Service 的创建和启动中，也同样看到过！！ 1.4 ActivityManagerP.registerReceiver接着调用 AMP 代理对象的 registerReceiver 方法，进入系统进程，注册 BroadcastReceiver！1234567891011121314151617181920212223242526272829public Intent registerReceiver(IApplicationThread caller, String packageName, IIntentReceiver receiver, IntentFilter filter, String perm, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); //【1】处理 ApplicationThread 对象！ data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(packageName); //【2】处理 IIntentReceiver 对象！ data.writeStrongBinder(receiver != null ? receiver.asBinder() : null); filter.writeToParcel(data, 0); data.writeString(perm); data.writeInt(userId); mRemote.transact(REGISTER_RECEIVER_TRANSACTION, data, reply, 0); reply.readException(); Intent intent = null; int haveIntent = reply.readInt(); if (haveIntent != 0) &#123; intent = Intent.CREATOR.createFromParcel(reply); &#125; reply.recycle(); data.recycle(); return intent;&#125; 下面，进入系统进程！ 2 系统进程首先，进入 ActivityManagerN.onTransact 方法：123456789101112131415161718192021222324252627282930313233343536373839@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; ... ... ... case REGISTER_RECEIVER_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); //【1】获得 ApplicationThreadProxy 对象！ IBinder b = data.readStrongBinder(); IApplicationThread app = b != null ? ApplicationThreadNative.asInterface(b) : null; String packageName = data.readString(); b = data.readStrongBinder(); //【2】获得 IIntentReceiver.proxy 对象！ IIntentReceiver rec = b != null ? IIntentReceiver.Stub.asInterface(b) : null; //【3】获得 IntentFilter 对象！ IntentFilter filter = IntentFilter.CREATOR.createFromParcel(data); String perm = data.readString(); int userId = data.readInt(); //【*2.1】继续调用 AMS.registerReceiver 方法，注册广播接收者！ Intent intent = registerReceiver(app, packageName, rec, filter, perm, userId); reply.writeNoException(); if (intent != null) &#123; reply.writeInt(1); intent.writeToParcel(reply, 0); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; ... ... ... &#125; 2.1 ActivityManagerS.registerReceiver参数分析： IApplicationThread caller：注册操作所属的应用进程的 ApplicationThreadProxy 对象 String callerPackage：注册者所属的应用程序包名； IIntentReceiver receiver：IIntentReceiver.Proxy 对象，映射注册者进程中的 InnerReceiver 对象； IntentFilter filter：Intent 过滤器； String permission：需要的权限！ int userId：当前设备用户 id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; enforceNotIsolatedCaller(\"registerReceiver\"); //【1】用来保存能够处理的粘性广播列表！ ArrayList&lt;Intent&gt; stickyIntents = null; ProcessRecord callerApp = null; int callingUid; int callingPid; synchronized(this) &#123; if (caller != null) &#123; //【*2.1.1】获得注册者进程对应的 ProcessRecord 对象！ // 如果注册者进程为 null，抛出异常！ callerApp = getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when registering receiver \" + receiver); &#125; //【2】如果注册者进程的 uid 不是系统 uid，并且注册者包名不在注册者进程的列表中 // 且注册者包名不是 “android” 抛出异常！ if (callerApp.info.uid != Process.SYSTEM_UID &amp;&amp; !callerApp.pkgList.containsKey(callerPackage) &amp;&amp; !\"android\".equals(callerPackage)) &#123; throw new SecurityException(\"Given caller package \" + callerPackage + \" is not running in process \" + callerApp); &#125; callingUid = callerApp.info.uid; callingPid = callerApp.pid; &#125; else &#123; callerPackage = null; callingUid = Binder.getCallingUid(); callingPid = Binder.getCallingPid(); &#125; userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_FULL_ONLY, \"registerReceiver\", callerPackage); //【2】通过解析 IntentFilter 获得 BroadcastReceiver 设置的 action 列表！ Iterator&lt;String&gt; actions = filter.actionsIterator(); if (actions == null) &#123; ArrayList&lt;String&gt; noAction = new ArrayList&lt;String&gt;(1); noAction.add(null); actions = noAction.iterator(); &#125; // 收集所有设备用户； int[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;; //【3】遍历广播接收者的 actions 列表，找到能够和 action 匹配的粘性广播，添加到 stickyIntents 集合中！ while (actions.hasNext()) &#123; String action = actions.next(); for (int id : userIds) &#123; //【3.1】获得每个设备用户下的“粘性”广播！ ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id); if (stickies != null) &#123; ArrayList&lt;Intent&gt; intents = stickies.get(action); if (intents != null) &#123; if (stickyIntents == null) &#123; stickyIntents = new ArrayList&lt;Intent&gt;(); &#125; stickyIntents.addAll(intents); &#125; &#125; &#125; &#125; &#125; //【4】因为 Intent 出了设置 action 这个属性之外，还会设置其他的一些属性！ // 这里是查找完全匹配的“粘性”广播，添加到 allSticky 集合中！ ArrayList&lt;Intent&gt; allSticky = null; if (stickyIntents != null) &#123; final ContentResolver resolver = mContext.getContentResolver(); for (int i = 0, N = stickyIntents.size(); i &lt; N; i++) &#123; Intent intent = stickyIntents.get(i); if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123; if (allSticky == null) &#123; allSticky = new ArrayList&lt;Intent&gt;(); &#125; allSticky.add(intent); &#125; &#125; &#125; //【5】我们会将第一个完全匹配的粘性广播发给接收者，如果动态注册的接收者为 null 的话，立刻返回！ Intent sticky = allSticky != null ? allSticky.get(0) : null; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Register receiver \" + filter + \": \" + sticky); if (receiver == null) &#123; return sticky; &#125; synchronized (this) &#123; if (callerApp != null &amp;&amp; (callerApp.thread == null || callerApp.thread.asBinder() != caller.asBinder())) &#123; //【6】如果注册者进程死亡了，就退出！ return null; &#125; //【7】尝试获得广播接收者在系统进程中的 ReceiverList 对象，如果为 null，说明没有注册！ ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); if (rl == null) &#123; //【*3.1.4】创建一个全新的 ReceiverList 对象，封装该动态注册的广播接收者！ rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver); //【*5.2】如果 rl.app 不为 null，说明注册者进程已经启动，就将 ReceiverList 对象添加 // 到注册者的进程的 receivers 集合中，对于动态注册，显然进入这个分支！ if (rl.app != null) &#123; rl.app.receivers.add(rl); &#125; else &#123; try &#123; // 如果 rl.app 为 bull，这可能是一种异常状态！！直接 linkToDeath 进行 Binder 监听！ receiver.asBinder().linkToDeath(rl, 0); &#125; catch (RemoteException e) &#123; return sticky; &#125; rl.linkedToDeath = true; &#125; //【6】将 InnerReceiver.proxy 和 ReceiverList 的映射关系保存到 mRegisteredReceivers 中！ // 表示该广播接收者已经被注册！ mRegisteredReceivers.put(receiver.asBinder(), rl); &#125; else if (rl.uid != callingUid) &#123; throw new IllegalArgumentException( \"Receiver requested to register for uid \" + callingUid + \" was previously registered for uid \" + rl.uid); &#125; else if (rl.pid != callingPid) &#123; throw new IllegalArgumentException( \"Receiver requested to register for pid \" + callingPid + \" was previously registered for pid \" + rl.pid); &#125; else if (rl.userId != userId) &#123; throw new IllegalArgumentException( \"Receiver requested to register for user \" + userId + \" was previously registered for user \" + rl.userId); &#125; //【7】创建 BroadcastFilter 对象 bf，用来封装广播接收者的 IntentFilter 对象！ BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId); // 将 BroadcastFilter 对象添加到 ReceiverList 列表中！ rl.add(bf); if (!bf.debugCheck()) &#123; Slog.w(TAG, \"==&gt; For Dynamic broadcast\"); &#125; //【8】将创建的广播过滤器 BroadcastFilter 保存到 mReceiverResolver 中，用于查询使用！ mReceiverResolver.addFilter(bf); //【9】如果 allSticky 不为 null，说明有能匹配该广播过滤器的 “粘性广播”！ // 接着就是要处理粘性广播的分发了！ if (allSticky != null) &#123; //【9.1】将该动态注册的广播接收者添加到 ArrayList 中！ // 准备将该粘性广播发送给接收者！ ArrayList receivers = new ArrayList(); receivers.add(bf); final int stickyCount = allSticky.size(); for (int i = 0; i &lt; stickyCount; i++) &#123; Intent intent = allSticky.get(i); //【9.2】根据 Intent 是否设置 Intent.FLAG_RECEIVER_FOREGROUND 标志位， // 选择前台或者后台广播队列！ BroadcastQueue queue = broadcastQueueForIntent(intent); //【9.3】创建 BroadcastRecord 对象！！ BroadcastRecord r = new BroadcastRecord(queue, intent, null, null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers, null, 0, null, null, false, true, true, -1); //【9.4】将粘性广播加入到广播队列的并发广播集合中！！ queue.enqueueParallelBroadcastLocked(r); //【2.3】处理广播队列中的已有的广播！！ queue.scheduleBroadcastsLocked(); &#125; &#125; return sticky; &#125;&#125; 下面我们来分析下这个方法中的一些重要步骤： 2.1.1 ActivityManagerS.getRecordForAppLocked获得注册者进程的 ProcessRecord 对象，传入参数： IApplicationThread thread：注册者进程在系统进程中的 ApplicationThreadProxy 对象！ 12345678910final ProcessRecord getRecordForAppLocked( IApplicationThread thread) &#123; if (thread == null) &#123; return null; &#125; // 获得进程 ProcessRecord 在 mLruProcesses 中的下标！ int appIndex = getLRURecordIndexForAppLocked(thread); return appIndex &gt;= 0 ? mLruProcesses.get(appIndex) : null;&#125; 这里调用了 getLRURecordIndexForAppLocked 方法：1234567891011121314private final int getLRURecordIndexForAppLocked(IApplicationThread thread) &#123; IBinder threadBinder = thread.asBinder(); // Find the application record. for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord rec = mLruProcesses.get(i); // 找到正在运行，并且 IApplicationThread 对象可以匹配的进程！ if (rec.thread != null &amp;&amp; rec.thread.asBinder() == threadBinder) &#123; return i; &#125; &#125; return -1;&#125; mLruProcesses 是一个 ArrayList 集合，用来保存正在运行中的应用程序进程，这里我们先不看！ 2.1.2 IntentFilter.match主要代码段：123456if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123; if (allSticky == null) &#123; allSticky = new ArrayList&lt;Intent&gt;(); &#125; allSticky.add(intent);&#125; 当前要注册的广播接收者只能接收到能够和 IntentFilter 匹配的广播，所以对于“粘性广播”，我们还需要再进行一次匹配操作，找到能够匹配 IntentFilter 的粘性广播，保存到 allSticky 列表中，我们来看看匹配过程： 12345678public final int match(ContentResolver resolver, Intent intent, boolean resolve, String logTag) &#123; String type = resolve ? intent.resolveType(resolver) : intent.getType(); return match(intent.getAction(), type, intent.getScheme(), intent.getData(), intent.getCategories(), logTag);&#125; 2.1.3 ActivityManagerS.broadcastQueueForIntent该方法的作用是为广播选择合适的队列：123456789BroadcastQueue broadcastQueueForIntent(Intent intent) &#123; final boolean isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0; if (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST, \"Broadcast intent \" + intent + \" on \" + (isFg ? \"foreground\" : \"background\") + \" queue\"); return (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;&#125; 如果 Intent 设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，那该广播就是一个前台广播，应该被加入 mFgBroadcastQueue 队列；否则，这是一个后台广播，就应该被添加到 mBgBroadcastQueue 队列中； 2.1.4 new BroadcastRecord创建广播管理对象 BroadcastRecord，参数传递： BroadcastQueue _queue：表示广播所在的队列，传入 queue Intent _intent：传入 intent ProcessRecord _callerApp：传入 null String _callerPackage：传入 null int _callingPid：传入 -1 int _callingUid：传入 -1 String _resolvedType：传入 null String[] _requiredPermissions：传入 null int _appOp：传入 AppOpsManager.OP_NONE BroadcastOptions _options：传入 null List _receivers：传入 receivers，这里是 IIntentReceiver _resultTo：传入 null int _resultCode：传入 0 String _resultData：传入 null Bundle _resultExtras：传入 null boolean _serialized：传入 false boolean _sticky：传入 true boolean _initialSticky：传入 true int _userId：传入 -1 1234567891011121314151617181920212223242526272829303132333435363738394041BroadcastRecord(BroadcastQueue _queue, Intent _intent, ProcessRecord _callerApp, String _callerPackage, int _callingPid, int _callingUid, String _resolvedType, String[] _requiredPermissions, int _appOp, BroadcastOptions _options, List _receivers, IIntentReceiver _resultTo, int _resultCode, String _resultData, Bundle _resultExtras, boolean _serialized, boolean _sticky, boolean _initialSticky, int _userId) &#123; // 如果广播对应的 Intent 为 null，抛出异常 if (_intent == null) &#123; throw new NullPointerException(\"Can't construct with a null intent\"); &#125; queue = _queue; // 广播所属的广播队列，有前台和后台之分； intent = _intent; // 广播 Intent targetComp = _intent.getComponent(); // 广播的目标组件，也就是目标 BroadcastReceiver callerApp = _callerApp; // 发送者所在的进程 callerPackage = _callerPackage; // 发送者所属的包名 callingPid = _callingPid; // 发送者的进程 pid callingUid = _callingUid; // 发送者进程的 uid resolvedType = _resolvedType; requiredPermissions = _requiredPermissions; // 发送该广播需要的权限 appOp = _appOp; options = _options; receivers = _receivers; // delivery = new int[_receivers != null ? _receivers.size() : 0]; // 该广播分发给每个接收者的次数 resultTo = _resultTo; resultCode = _resultCode; resultData = _resultData; resultExtras = _resultExtras; ordered = _serialized; sticky = _sticky; initialSticky = _initialSticky; userId = _userId; nextReceiver = 0; state = IDLE;&#125; 这里是对“粘性”广播创建对应的 BroadcastRecord 管理对象！ 2.1.5 BroadcastQueue.enqueueParallelBroadcastLocked将“粘性”广播 BroadcastRecord 添加到 BroadcastQueue 对象内部的 mParallelBroadcasts 列表中，并初始化 r.enqueueClockTime 为当前系统时间，表示广播进入队列的时间；1234public void enqueueParallelBroadcastLocked(BroadcastRecord r) &#123; mParallelBroadcasts.add(r); r.enqueueClockTime = System.currentTimeMillis();&#125; 可以看出，粘性广播属于并发的广播！ 2.1.6 BroadcastQueue.scheduleBroadcastsLocked开始处理广播，mBroadcastsScheduled 表示是否开始广播处理任务！12345678910111213public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\" + mQueueName + \"]: current=\" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; //【1】发送 BROADCAST_INTENT_MSG 消息！ mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; 收集了粘性广播，把粘性广播添加到了指定的广播队列中，然后就是要处理广播了！mHandler 是 BroadcastHandler 对象，这里是向 BroadcastHandler 发送 BROADCAST_INTENT_MSG 消息，开始分发广播！！ 2.2 BroadcastQueue.scheduleBroadcastsLocked123456789101112public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\" + mQueueName + \"]: current=\" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; //【1】触发广播的分发！ mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; 2.3 BroadcastQueue.BroadcastHandler1234567891011121314151617181920212223242526272829303132333435private final class BroadcastHandler extends Handler &#123; public BroadcastHandler(Looper looper) &#123; super(looper, null, true); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BROADCAST_INTENT_MSG: &#123; if (DEBUG_BROADCAST) Slog.v( TAG_BROADCAST, \"Received BROADCAST_INTENT_MSG\"); //【1】接收到 BROADCAST_INTENT_MSG 消息，开始分发广播！ processNextBroadcast(true); &#125; break; case BROADCAST_TIMEOUT_MSG: &#123; //【2】广播处理超时 synchronized (mService) &#123; broadcastTimeoutLocked(true); &#125; &#125; break; case SCHEDULE_TEMP_WHITELIST_MSG: &#123; //【3】添加 doze 模式白名单，这个在 doze 模式篇中会讲解！！ DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController; if (dic != null) &#123; dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1), msg.arg2, true, (String)msg.obj); &#125; &#125; break; &#125; &#125;&#125; 接着，调用 processNextBroadcast 方法，分发队列中的广播，分发的具体流程，我们会在 sendBroadcast 流程分析那篇博文中详细解析，这里先不看！ 3 总结3.1 数据结构分析以上过程涉及到了一些重要的数据结构！ 3.1.1 BroadcastRecevier12345public abstract class BroadcastReceiver &#123; private PendingResult mPendingResult; public abstract void onReceive(Context context, Intent intent);&#125; BroadcastReceiver 是一个抽象类，我们在开发时，需要继承 BroadcastReceiver 来实现自己的广播接收者！ 3.1.2 mStickyBroadcasts12final SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts = new SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;(); mStickyBroadcasts 用来保存每个设备用户下活跃的粘性广播！ 这里来解释下粘性广播，粘性广播是可以发送给以后注册的接受者的广播，意思是系统会将前面的粘性广播保存在 AMS 中，一旦注册了能够接受对应粘性广播的 BroadcastReceiver，在注册结束后，BroadcastReceiver 会立即收到粘性广播！ mStickyBroadcasts 是一个稀疏数组，数组下标为设备用户ID：userId，对应的数组元素是设备用户 ID 下所有活跃的粘性广播：ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;； ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; 的 key 是粘性广播 Intent 的 action，value 是一个 ArrayList：是所有设置了同一个 action 的粘性广播 Intent； 3.1.3 mRegisteredReceivers1final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = new HashMap&lt;&gt;(); 用来保存动态注册的广播接收者，是一个 HashMap，key 是广播接收者的 IInnerReceiver 对象，value 是 ReceiverList 对象，是一个 ArrayList 集合，用来封装该广播接收者的信息！ 3.1.4 ReceiverListReceiverList 用于封装每一个动态创建 123456789101112131415161718192021222324252627final class ReceiverList extends ArrayList&lt;BroadcastFilter&gt; implements IBinder.DeathRecipient &#123; final ActivityManagerService owner; // AMS 对象 public final IIntentReceiver receiver; // 广播接收者的 InnerReceiver.Proxy 对象 public final ProcessRecord app; // 注册者所在的进程 public final int pid; // 注册者的进程 pid public final int uid; // 注册者的进程 uid public final int userId; // 注册者所在的设备用户 id BroadcastRecord curBroadcast = null; // 接收者当前正在处理的广播 boolean linkedToDeath = false; String stringName; ReceiverList(ActivityManagerService _owner, ProcessRecord _app, int _pid, int _uid, int _userId, IIntentReceiver _receiver) &#123; owner = _owner; receiver = _receiver; app = _app; pid = _pid; uid = _uid; userId = _userId; &#125;&#125; ReceiverList 继承了 ArrayList，所以它本质上就是一个 ArrayList 集合！ 3.1.5 BroadcastFilterBroadcastFilter 表示的动态设定的 12345678910111213141516171819final class BroadcastFilter extends IntentFilter &#123; // Back-pointer to the list this filter is in. final ReceiverList receiverList; // BroadcastFilter 所属的 receiverList 列表； final String packageName; // 注册者的包名； final String requiredPermission; // 广播需要的权限 final int owningUid; // 注册者的 uid final int owningUserId; // 注册者所属的 UserId BroadcastFilter(IntentFilter _filter, ReceiverList _receiverList, String _packageName, String _requiredPermission, int _owningUid, int _userId) &#123; super(_filter); receiverList = _receiverList; packageName = _packageName; requiredPermission = _requiredPermission; owningUid = _owningUid; owningUserId = _userId; &#125; &#125; BroadcastFilter 继承了 IntentFilter，其本身是一个 IntentFilter 扩展类，出了有 IntentFilter 的属性和方法之外，他还封装了一些其他的属性，我们可以把 BroadcastFilter 理解为注册广播是传入的 IntentFilter！ 3.1.6 mReceiverResolvermReceiverResolver 是模板类 IntentResolver 的子类，用于解析 Intent 对象！ 12345678910111213141516171819202122232425262728293031323334final IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver = new IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt;() &#123; @Override protected boolean allowFilterResult( BroadcastFilter filter, List&lt;BroadcastFilter&gt; dest) &#123; IBinder target = filter.receiverList.receiver.asBinder(); for (int i = dest.size() - 1; i &gt;= 0; i--) &#123; if (dest.get(i).receiverList.receiver.asBinder() == target) &#123; return false; &#125; &#125; return true; &#125; @Override protected BroadcastFilter newResult(BroadcastFilter filter, int match, int userId) &#123; if (userId == UserHandle.USER_ALL || filter.owningUserId == UserHandle.USER_ALL || userId == filter.owningUserId) &#123; return super.newResult(filter, match, userId); &#125; return null; &#125; @Override protected BroadcastFilter[] newArray(int size) &#123; return new BroadcastFilter[size]; &#125; @Override protected boolean isPackageForFilter(String packageName, BroadcastFilter filter) &#123; return packageName.equals(filter.packageName); &#125;&#125;; mReceiverResolver 持有所有动态注册的广播接受者的 BroadcastFilter 对象，也就是 IntentFilter，当广播没有设置组件信息时，会通过 mReceiverResolver 查询接收者的信息！ 3.1.7 BroadcastQueueBroadcastQueue 表示的是广播队列，任何一个广播都需要被添加到这个队列才能被分发！Android 系统提供了两个队列：12345678BroadcastQueue mFgBroadcastQueue;BroadcastQueue mBgBroadcastQueue;final BroadcastQueue[] mBroadcastQueues = new BroadcastQueue[2];// 广播接收者运行超时时间static final int BROADCAST_FG_TIMEOUT = 10*1000;static final int BROADCAST_BG_TIMEOUT = 60*1000; 他们是在 AMS 的启动时候初始化的：1234567mFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", BROADCAST_FG_TIMEOUT, false);mBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", BROADCAST_BG_TIMEOUT, true);mBroadcastQueues[0] = mFgBroadcastQueue;mBroadcastQueues[1] = mBgBroadcastQueue; 一个是前台队列，一个是后台队列！一个广播会根据是否设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，会被放到 mFgBroadcastQueue 或者 mBgBroadcastQueue 队列中进行分发，我们去看看 BroadcastQueue 类的一些重要的成员变量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public final class BroadcastQueue &#123; static final int MAX_BROADCAST_HISTORY = ActivityManager.isLowRamDeviceStatic() ? 10 : 50; static final int MAX_BROADCAST_SUMMARY_HISTORY = ActivityManager.isLowRamDeviceStatic() ? 25 : 300; final ActivityManagerService mService; final String mQueueName; // 队列的名称 final long mTimeoutPeriod; // 广播接收者运行超时时间 final boolean mDelayBehindServices; // 是否延迟发送广播，后台队列才会为 true！ final ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = new ArrayList&lt;&gt;(); // 并行广播列表 final ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;(); // 有序广播列表 // 队列中广播的历史记录，用于 debugging！ final BroadcastRecord[] mBroadcastHistory = new BroadcastRecord[MAX_BROADCAST_HISTORY]; int mHistoryNext = 0; final Intent[] mBroadcastSummaryHistory = new Intent[MAX_BROADCAST_SUMMARY_HISTORY]; int mSummaryHistoryNext = 0; // 用于记录所有广播的操作时间！ final long[] mSummaryHistoryEnqueueTime = new long[MAX_BROADCAST_SUMMARY_HISTORY]; final long[] mSummaryHistoryDispatchTime = new long[MAX_BROADCAST_SUMMARY_HISTORY]; final long[] mSummaryHistoryFinishTime = new long[MAX_BROADCAST_SUMMARY_HISTORY]; boolean mBroadcastsScheduled = false; // 分发广播时（BROADCAST_INTENT_MSG），该变量会被置为 true！ boolean mPendingBroadcastTimeoutMessage; // 广播处理超时（BROADCAST_TIMEOUT_MSG），该变量会被置为 true！ BroadcastRecord mPendingBroadcast = null; // 等待目标进程启动的挂起广播 int mPendingBroadcastRecvIndex; // 等待目标进程启动的挂起广播的目标接收者的下标 final BroadcastHandler mHandler; // 用于在系统进程中处理发送广播和广播超时的操作！ BroadcastQueue(ActivityManagerService service, Handler handler, String name, long timeoutPeriod, boolean allowDelayBehindServices) &#123; mService = service; mHandler = new BroadcastHandler(handler.getLooper()); mQueueName = name; mTimeoutPeriod = timeoutPeriod; mDelayBehindServices = allowDelayBehindServices; &#125; ... ... ... ...&#125; BroadcastQueue 里面还有很多的方法，用于处理广播的分发，超时等等，这个我们后面再看！！ 3.1.8 BroadcastRecord在应用端，广播的表现形式是一个个 Intent 对象，但是在系统进程中，AMS 会将 Intent 封装成 BroadcastRecord 对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final class BroadcastRecord extends Binder &#123; final Intent intent; // 广播对应的 Intent final ComponentName targetComp; // Intent 设置的组件 final ProcessRecord callerApp; // 发送该广播的进程 final String callerPackage; // 发送该广播的 package final int callingPid; // 发送该广播的进程 pid final int callingUid; // 发送该广播的进程 uid final boolean ordered; // 该广播是否是有序广播 final boolean sticky; // 该广播是否是粘性广播 final boolean initialSticky; // initial broadcast from register to sticky? final int userId; // 广播所属的设备用户 id final String resolvedType; // the resolved data type final String[] requiredPermissions; // 发送改变广播需要的权限 final int appOp; // 和该广播相关联的应用操作 final BroadcastOptions options; // 发送者提供广播参数 final List receivers; // 该广播的目标接收者列表，动态接收者为 BroadcastFilter，静态接收者为 ResolveInfo； final int[] delivery; // 该广播对于每个广播接收者的分发状态 IIntentReceiver resultTo; // 用来接收发送广播的结果 long enqueueClockTime; // 该广播加入队列的时间！ long dispatchTime; // 该广播开始分发的时间（uptimeMillis） long dispatchClockTime; // 该广播开始分发的时间（currentTimeMillis） long receiverTime; // 接收者接收该广播的时间，用于计算超时 long finishTime; // 该广播完成分发的时间（uptimeMillis） int resultCode; // current result code value. String resultData; // current result data value. Bundle resultExtras; // current result extra data values. boolean resultAbort; // current result abortBroadcast value. int nextReceiver; // 下一个广播的序号 IBinder receiver; // 当前接收者的 Binder 实体，用于跨进程通信 int state; // 广播的状态！ int anrCount; // ANR 的次数； int manifestCount; // 目标静态接收者的个数； int manifestSkipCount; // 跳过的静态接收者个数； BroadcastQueue queue; // 该广播所属的队列； BroadcastFilter curFilter; // 目标动态接收者！ ProcessRecord curApp; // 接受该广播的广播接收者所在进程！ ComponentName curComponent; // 接受该广播的广播接收者的组件名！ ActivityInfo curReceiver; // 接受该广播的静态广播接收者的信息对象！ ... ... ... ... &#125; 3.2 结构关系图结构关系图我们从 2 个方面来说明！ 3.2.1 注册者进程关系图处理广播的类是 BroadcastReceiver，InnerReceiver 用于实现注册者进程和系统进程的跨进程通信，ReceiverDispatcher 实现了二者的低耦合，用于管理二者的映射关系！ 系统进程通过 InnerReceiver.Proxy 代理对象，通过 Binder 通信将广播传递给注册者进程的 BroadcastReceiver！performReceive 方法最终会创建一个 Args 对象，用于拉起 BroadcastReceiver 的 onReceive 方法！ 3.2.2 系统进程关系图","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"BroadcastReceiver广播接收者","slug":"AndroidFramework源码分析/BroadcastReceiver广播接收者","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/"}],"tags":[{"name":"BroadcastReceiver广播接收者","slug":"BroadcastReceiver广播接收者","permalink":"https://coolqi.top/tags/BroadcastReceiver广播接收者/"}]},{"title":"JobScheduler第 8 篇 - JobInfo JobStatus 和 JobParameters","slug":"JobScheduler8-JobInfoAndJobStatusAndJobParameters","date":"2016-04-29T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/04/29/JobScheduler8-JobInfoAndJobStatusAndJobParameters/","link":"","permalink":"https://coolqi.top/2016/04/29/JobScheduler8-JobInfoAndJobStatusAndJobParameters/","excerpt":"","text":"基于 Android 7.1.1 源码分析，本文为原创，转载请说明出处，谢谢！ 前言这一篇我们来分析一下 JSS 中的一些对象，看看我们能对 job 做哪些属性的设置： JobInfo JobStatus JobParameters 1 JobInfo我们先来看看 JobInfo 的简化结构： 123456789public class JobInfo implements Parcelable &#123; public static final class Builder &#123; public JobInfo build() &#123; return job; &#125; &#125;&#125; 这里使用了设计模式中的建造者模式，通过 build 方法，返回最终的 JobInfo！ 1.1 builder我们先来看看 buidler 中的方法和参数，我们用一张表格来说明一下： 属性 属性默认值 属性解释 int mJobId Job 的 Id ComponentName mJobService - Job 对应的 JobService 组件 PersistableBundle mExtras PersistableBundle.EMPTY job 重启保留需要恢复的数据 int mPriority PRIORITY_DEFAULT job 优先级 int mFlags - - boolean mRequiresCharging - 约束条件：充电 boolean mRequiresDeviceIdle - 约束条件：doze 模式 int mNetworkType - 约束条件：网络类型 ArrayList mTriggerContentUris - 约束条件：数据库 Uri long mTriggerContentUpdateDelay -1 数据库改变后，job 的延迟执行时间 long mTriggerContentMaxDelay -1 数据库改变后，job 的最大延迟执行时间 boolean mIsPersisted job 是否重启保留，需要RECEIVE_BOOT_COMPLETED 权限 long mMinLatencyMillis - job 延迟执行时间 long mMaxExecutionDelayMillis - job 最大延迟执行时间，一旦达到该时间，无论条件是否满足，任务都会执行 boolean mIsPeriodic - job 是否是周期性的 boolean mHasEarlyConstraint - job 是否设置了延迟执行时间（周期和非周期都有） boolean mHasLateConstraint - job 是否设置了最大延迟执行时间（周期和非周期都有） long mIntervalMillis - job 执行的周期时间间隔 long mFlexMillis - job 执行周期末的一个时间窗，任何任务在这个时间窗中都可能被执行 long mInitialBackoffMillis DEFAULT_INITIAL_BACKOFF_MILLIS job 第一次尝试重试的等待间隔，单位为毫秒 int mBackoffPolicy DEFAULT_BACKOFF_POLICY job 对应的退避策略 boolean mBackoffPolicySet False job 是否设置了设置退避 / 重试策略，类似网络原理中的冲突退避，当一个任务的调度失败时需要重试，所采取的策略。 接着来看属性和其对应的方法： 属性 设置方法 int mJobId Builder 构造器 ComponentName mJobService Builder 构造器 PersistableBundle mExtras setExtras int mPriority setPriority int mFlags setFlags boolean mRequiresCharging setRequiresCharging boolean mRequiresDeviceIdle setRequiresDeviceIdle int mNetworkType setRequiredNetworkType ArrayList mTriggerContentUris addTriggerContentUri long mTriggerContentUpdateDelay setTriggerContentUpdateDelay long mTriggerContentMaxDelay setTriggerContentMaxDelay boolean mIsPersisted setPersisted long mMinLatencyMillis setMinimumLatency long mMaxExecutionDelayMillis setOverrideDeadline boolean mIsPeriodic setPeriodic boolean mHasEarlyConstraint setMinimumLatency、setPeriodic boolean mHasLateConstraint setOverrideDeadline、setPeriodic long mIntervalMillis setPeriodic long mFlexMillis setPeriodic long mInitialBackoffMillis setBackoffCriteria int mBackoffPolicy setBackoffCriteria boolean mBackoffPolicySet setBackoffCriteria 接下来我们分析一下细节： 网络类型的取值： NETWORK_TYPE_NONE：默认值。表示与网络状态无关 NETWORK_TYPE_ANY：必须连接网络 NETWORK_TYPE_NOT_ROAMING：必须连接非漫游的网络 NETWORK_TYPE_UNMETERED：必须连接非计费的网络 退避 | 重试策略： long mInitialBackoffMillis：第一次尝试重试的等待间隔，单位为毫秒，预设的取值有下面 2 种： DEFAULT_INITIAL_BACKOFF_MILLIS：30 秒 MAX_BACKOFF_DELAY_MILLIS：5 小时 int mBackoffPolicy：退避策略 BACKOFF_POLICY_LINEAR：0 对应的重试时间计算公式是: current_time + initial_backoff_millis * num_failures, num_failures &gt;= 1 BACKOFF_POLICY_EXPONENTIAL：1 对应的重试时间计算公式是： current_time + initial_backoff_millis * 2 ^ (num_failures - 1), num_failures &gt;= 1 优先级的取值： PRIORITY_DEFAULT：0 PRIORITY_SYNC_EXPEDITED：10 PRIORITY_SYNC_INITIALIZATION：20 PRIORITY_FOREGROUND_APP：30 PRIORITY_TOP_APP：40 PRIORITY_ADJ_OFTEN_RUNNING：-40 PRIORITY_ADJ_ALWAYS_RUNNING：-80 周期时间的取值： MIN_PERIOD_MILLIS：15 60 1000L，最小的执行周期时间，15 分钟 MIN_FLEX_MILLIS：5 60 1000L，最小的时间窗，5分钟 接下来，我们来分析下 build 方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public JobInfo build() &#123; // 至少要设置一个约束条件！ if (!mHasEarlyConstraint &amp;&amp; !mHasLateConstraint &amp;&amp; !mRequiresCharging &amp;&amp; !mRequiresDeviceIdle &amp;&amp; mNetworkType == NETWORK_TYPE_NONE &amp;&amp; mTriggerContentUris == null) &#123; throw new IllegalArgumentException(\"You're trying to build a job with no \" + \"constraints, this is not allowed.\"); &#125; mExtras = new PersistableBundle(mExtras); // Make our own copy. // 周期性的 job 不能设置延迟执行时间和最大延迟执行时间，也不能设置数据库变化的约束条件！ // 重启保留的 job 不能设置数据库变化的约束条件！ // 设置了退避 | 重试策略的 job 不能设置 DOZE 约束条件！ if (mIsPeriodic &amp;&amp; (mMaxExecutionDelayMillis != 0L)) &#123; throw new IllegalArgumentException(\"Can't call setOverrideDeadline() on a \" + \"periodic job.\"); &#125; if (mIsPeriodic &amp;&amp; (mMinLatencyMillis != 0L)) &#123; throw new IllegalArgumentException(\"Can't call setMinimumLatency() on a \" + \"periodic job\"); &#125; if (mIsPeriodic &amp;&amp; (mTriggerContentUris != null)) &#123; throw new IllegalArgumentException(\"Can't call addTriggerContentUri() on a \" + \"periodic job\"); &#125; if (mIsPersisted &amp;&amp; (mTriggerContentUris != null)) &#123; throw new IllegalArgumentException(\"Can't call addTriggerContentUri() on a \" + \"persisted job\"); &#125; if (mBackoffPolicySet &amp;&amp; mRequiresDeviceIdle) &#123; throw new IllegalArgumentException(\"An idle mode job will not respect any\" + \" back-off policy, so calling setBackoffCriteria with\" + \" setRequiresDeviceIdle is an error.\"); &#125; // 创建 JobInfo 对象！ JobInfo job = new JobInfo(this); if (job.isPeriodic()) &#123; if (job.intervalMillis != job.getIntervalMillis()) &#123; StringBuilder builder = new StringBuilder(); builder.append(\"Specified interval for \") .append(String.valueOf(mJobId)) .append(\" is \"); formatDuration(mIntervalMillis, builder); builder.append(\". Clamped to \"); formatDuration(job.getIntervalMillis(), builder); Log.w(TAG, builder.toString()); &#125; if (job.flexMillis != job.getFlexMillis()) &#123; StringBuilder builder = new StringBuilder(); builder.append(\"Specified flex for \") .append(String.valueOf(mJobId)) .append(\" is \"); formatDuration(mFlexMillis, builder); builder.append(\". Clamped to \"); formatDuration(job.getFlexMillis(), builder); Log.w(TAG, builder.toString()); &#125; &#125; return job;&#125; 这里我们来总结一下： 至少要设置一个约束条件！ 周期性的 job 不能设置延迟执行时间和最大延迟执行时间，也不能设置数据库变化的约束条件！ 重启保留的 job 不能设置数据库变化的约束条件！ 设置了退避 | 重试策略的 job 不能设置 DOZE 约束条件！ 1.2 JobInfo我们来看看构造器：12345678910111213141516171819202122232425private JobInfo(JobInfo.Builder b) &#123; jobId = b.mJobId; extras = b.mExtras; service = b.mJobService; requireCharging = b.mRequiresCharging; requireDeviceIdle = b.mRequiresDeviceIdle; triggerContentUris = b.mTriggerContentUris != null ? b.mTriggerContentUris.toArray(new TriggerContentUri[b.mTriggerContentUris.size()]) : null; triggerContentUpdateDelay = b.mTriggerContentUpdateDelay; triggerContentMaxDelay = b.mTriggerContentMaxDelay; networkType = b.mNetworkType; minLatencyMillis = b.mMinLatencyMillis; maxExecutionDelayMillis = b.mMaxExecutionDelayMillis; isPeriodic = b.mIsPeriodic; isPersisted = b.mIsPersisted; intervalMillis = b.mIntervalMillis; flexMillis = b.mFlexMillis; initialBackoffMillis = b.mInitialBackoffMillis; backoffPolicy = b.mBackoffPolicy; hasEarlyConstraint = b.mHasEarlyConstraint; hasLateConstraint = b.mHasLateConstraint; priority = b.mPriority; flags = b.mFlags;&#125; 可以看出，参数的意义和 builder 是一样的，我们来看看： 属性 获取方法 int jobId getId ComponentName service getService PersistableBundle extras getExtras int priority getPriority int flags getFlags boolean requiresCharging isRequireCharging boolean requiresDeviceIdle isRequireDeviceIdle int networkType getNetworkType ArrayList triggerContentUris getTriggerContentUris long triggerContentUpdateDelay getTriggerContentUpdateDelay long triggerContentMaxDelay getTriggerContentMaxDelay boolean isPersisted isPersisted long minLatencyMillis getMinLatencyMillis long maxExecutionDelayMillis getMaxExecutionDelayMillis boolean isPeriodic isPeriodic boolean hasEarlyConstraint hasEarlyConstraint boolean hasLateConstraint hasLateConstraint long intervalMillis getIntervalMillis long flexMillis getFlexMillis long initialBackoffMillis getInitialBackoffMillis int backoffPolicy getBackoffPolicy 我们接着看： 2 JobStatus我们 schedule 一个 jobInfo 后，JSS 会创建对应的 JobStatus，我们先来看看他的构造器：1234567891011121314151617181920212223242526// 通过一个 JobStatus 创建！public JobStatus(JobStatus jobStatus) &#123; this(jobStatus.getJob(), jobStatus.getUid(), jobStatus.getSourcePackageName(), jobStatus.getSourceUserId(), jobStatus.getSourceTag(), jobStatus.getNumFailures(), jobStatus.getEarliestRunTime(), jobStatus.getLatestRunTimeElapsed());&#125;// 从本地文件 Jobs.xml 中读取数据，创建 JobStatuspublic JobStatus(JobInfo job, int callingUid, String sourcePackageName, int sourceUserId, String sourceTag, long earliestRunTimeElapsedMillis, long latestRunTimeElapsedMillis) &#123; this(job, callingUid, sourcePackageName, sourceUserId, sourceTag, 0, earliestRunTimeElapsedMillis, latestRunTimeElapsedMillis);&#125;// 根据参数创建一个 JobStatuspublic JobStatus(JobStatus rescheduling, long newEarliestRuntimeElapsedMillis, long newLatestRuntimeElapsedMillis, int backoffAttempt) &#123; this(rescheduling.job, rescheduling.getUid(), rescheduling.getSourcePackageName(), rescheduling.getSourceUserId(), rescheduling.getSourceTag(), backoffAttempt, newEarliestRuntimeElapsedMillis, newLatestRuntimeElapsedMillis);&#125; 最终都会调用这个构造器方法，参数传递： JobInfo job：jobInfo 对象 int callingUid：job 所属进程的 uid String sourcePackageName：job 所属应用的包名 int sourceUserId：job所属的设备用户 String tag： int numFailures：失败次数 long earliestRunTimeElapsedMillis： 最早执行时间 long latestRunTimeElapsedMillis：最晚执行时间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private JobStatus(JobInfo job, int callingUid, String sourcePackageName, int sourceUserId, String tag, int numFailures, long earliestRunTimeElapsedMillis, long latestRunTimeElapsedMillis) &#123; this.job = job; this.callingUid = callingUid; int tempSourceUid = -1; if (sourceUserId != -1 &amp;&amp; sourcePackageName != null) &#123; try &#123; tempSourceUid = AppGlobals.getPackageManager().getPackageUid(sourcePackageName, 0, sourceUserId); &#125; catch (RemoteException ex) &#123; // Can't happen, PackageManager runs in the same process. &#125; &#125; if (tempSourceUid == -1) &#123; this.sourceUid = callingUid; this.sourceUserId = UserHandle.getUserId(callingUid); this.sourcePackageName = job.getService().getPackageName(); this.sourceTag = null; &#125; else &#123; this.sourceUid = tempSourceUid; this.sourceUserId = sourceUserId; this.sourcePackageName = sourcePackageName; this.sourceTag = tag; &#125; this.batteryName = this.sourceTag != null ? this.sourceTag + \":\" + job.getService().getPackageName() : job.getService().flattenToShortString(); this.tag = \"*job*/\" + this.batteryName; this.earliestRunTimeElapsedMillis = earliestRunTimeElapsedMillis; this.latestRunTimeElapsedMillis = latestRunTimeElapsedMillis; this.numFailures = numFailures; // requiredConstraints 使用二进制位记录 job 所依赖的约束条件，依赖某个条件，对应的二进制位置为 1！ int requiredConstraints = 0; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_ANY) &#123; requiredConstraints |= CONSTRAINT_CONNECTIVITY; &#125; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_UNMETERED) &#123; requiredConstraints |= CONSTRAINT_UNMETERED; &#125; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_NOT_ROAMING) &#123; requiredConstraints |= CONSTRAINT_NOT_ROAMING; &#125; if (job.isRequireCharging()) &#123; requiredConstraints |= CONSTRAINT_CHARGING; &#125; if (earliestRunTimeElapsedMillis != NO_EARLIEST_RUNTIME) &#123; requiredConstraints |= CONSTRAINT_TIMING_DELAY; &#125; if (latestRunTimeElapsedMillis != NO_LATEST_RUNTIME) &#123; requiredConstraints |= CONSTRAINT_DEADLINE; &#125; if (job.isRequireDeviceIdle()) &#123; requiredConstraints |= CONSTRAINT_IDLE; &#125; if (job.getTriggerContentUris() != null) &#123; requiredConstraints |= CONSTRAINT_CONTENT_TRIGGER; &#125; this.requiredConstraints = requiredConstraints;&#125; 我们可以看到，构造函数很简单，没有多么复杂的，我们来总结一下，JobStatus 中的参数： 参数 参数解释 JobInfo job JobInfo 对象 int callingUid 调用者进程 uid String batteryName String sourcePackageName job 所属应用的包名 int sourceUserId job 所属设备用户 int sourceUid job 所属应用的 uid String sourceTag String tag long earliestRunTimeElapsedMillis job 最早执行的时间 long latestRunTimeElapsedMillis job 最晚执行的时间 int numFailures job 执行失败的次数 int requiredConstraints 每个二进制位表示 job 所依赖的约束条件 int satisfiedConstraints = 0 每个二进制位表示 job 对应的约束条件是否满足 boolean dozeWhitelisted job 是否在 doze 白名单中 ArraySet changedUris job 依赖的数据库的 Uri ArraySet changedAuthorities job 依赖的数据库的 Uri int lastEvaluatedPriority job 的优先级 int overrideState = 0 shell 命令用到 我们继续来看： 约束条件的表示 用户可以设置的约束条件： CONSTRAINT_CHARGING：1&lt;&lt;0，充电 CONSTRAINT_TIMING_DELAY：1&lt;&lt;1，延迟处理 CONSTRAINT_DEADLINE：1&lt;&lt;2，超时处理 CONSTRAINT_IDLE：1&lt;&lt;3，doze 模式 CONSTRAINT_UNMETERED：1&lt;&lt;4，必须连接非漫游的网络 CONSTRAINT_CONNECTIVITY：1&lt;&lt;5，必须连接网络 CONSTRAINT_APP_NOT_IDLE：1&lt;&lt;6，app 处于非空闲状态 CONSTRAINT_CONTENT_TRIGGER：1&lt;&lt;7，数据库变化 CONSTRAINT_NOT_ROAMING：1&lt;&lt;9，必须连接非计费的网络 用户无法设置的约束条件： CONSTRAINT_DEVICE_NOT_DOZING：1&lt;&lt;8，不受 doze 模式限制，这个是由 DeviceIdleJobsController 获得 doze 模式白名单的更新，动态的对 uid 在白名单中的 job 进行设置的！ 最早执行时间和最晚执行时间（） 对于周期性 job 最早执行时间： earliestRunTimeElapsedMillis = latestRunTimeElapsedMillis - job.getFlexMillis() 最晚执行时间： latestRunTimeElapsedMillis = elapsedNow + job.getIntervalMillis() 对于非周期性 job 最早执行时间： 设置了延迟执行时间： earliestRunTimeElapsedMillis = elapsedNow + job.getMinLatencyMillis() 未设置延迟执行时间： earliestRunTimeElapsedMillis = NO_EARLIEST_RUNTIME = 0L 最晚执行时间： 设置了最大延迟执行时间： latestRunTimeElapsedMillis = elapsedNow + job.getMaxExecutionDelayMillis() 未设置最大延迟执行时间： latestRunTimeElapsedMillis = NO_LATEST_RUNTIME = Long.MAX_VALUE 3 JobParametersJobParameters 是 job 执行时的参数，我们来看看他的参数： int jobId：job 的 id！ PersistableBundle extras：重启恢复的数据！ IBinder callback：JobSchedulerContext 的 binder 代理对象！ boolean overrideDeadlineExpired：job 是否已经超时！ Uri[] mTriggeredContentUris：监控的数据库的 Uri！ String[] mTriggeredContentAuthorities：监控的数据库的 Authorities！ int stopReason：job 停止的原因！ int REASON_CANCELED = 0，默认为 cancel int REASON_CONSTRAINTS_NOT_SATISFIED = 1 int REASON_PREEMPT = 2 int REASON_TIMEOUT = 3 int REASON_DEVICE_IDLE = 4","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"JobScheduler第 7 篇 - JobSchedulerService - package and uid change","slug":"JobScheduler7-JobSchedulerService-packageAndUidChange","date":"2016-04-27T12:46:25.000Z","updated":"2018-11-20T17:38:50.000Z","comments":true,"path":"2016/04/27/JobScheduler7-JobSchedulerService-packageAndUidChange/","link":"","permalink":"https://coolqi.top/2016/04/27/JobScheduler7-JobSchedulerService-packageAndUidChange/","excerpt":"","text":"基于 Android 7.1.1 源码分析： 前言我们想象这样的场景，如果有一个应用，它 schedule 了一些 job， 这些 job 可能正在运行，可能在 pending！这个时候，用户卸载了这个应用，那这个应用对应的 job 该何去何从？这里就要涉及到 package change 对 job 的影响了！ 同时，进程优先级的变化，其实也会影响进程内的 job 的优先级！ 我们回到 JSS 的启动和初始化：12345678910111213141516171819202122232425262728293031323334@Overridepublic void onBootPhase(int phase) &#123; if (PHASE_SYSTEM_SERVICES_READY == phase) &#123; mConstants.start(getContext().getContentResolver()); // 注册广播，监听应用程序包的操作！ final IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_PACKAGE_REMOVED); filter.addAction(Intent.ACTION_PACKAGE_CHANGED); filter.addAction(Intent.ACTION_PACKAGE_RESTARTED); filter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); filter.addDataScheme(\"package\"); getContext().registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, filter, null, null); // 注册广播，监听设备用户的操作！ final IntentFilter userFilter = new IntentFilter(Intent.ACTION_USER_REMOVED); getContext().registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, userFilter, null, null); mPowerManager = (PowerManager)getContext().getSystemService(Context.POWER_SERVICE); try &#123; // 注册 uid 监控者 ActivityManagerNative.getDefault().registerUidObserver(mUidObserver, ActivityManager.UID_OBSERVER_PROCSTATE | ActivityManager.UID_OBSERVER_GONE | ActivityManager.UID_OBSERVER_IDLE); &#125; catch (RemoteException e) &#123; // ignored; both services live in system_server &#125; &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123; ... ... ... ... &#125;&#125; 可以看到，这段代码，注册了两个广播监听者，下面我们一一来看！ 这里有个小细节，如果想监听程序的安装和删除的广播，需要静态或者动态配置以下属性：12&lt;data android:scheme=\"package\"&gt;&lt;/data&gt; 或者：1filter.addDataScheme(\"package\"); 1 Package Change我们回到 JobSchedulerService 服务中去，在 JSS 中，有一个广播接收者，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * Cleans up outstanding jobs when a package is removed. Even if it's being replaced later we * still clean up. On reinstall the package will have a new uid. */private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (DEBUG) &#123; Slog.d(TAG, \"Receieved: \" + action); &#125; if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) &#123; // 应用程序包改变的广播！ // Purge the app's jobs if the whole package was just disabled. When this is // the case the component name will be a bare package name. final String pkgName = getPackageName(intent); final int pkgUid = intent.getIntExtra(Intent.EXTRA_UID, -1); if (pkgName != null &amp;&amp; pkgUid != -1) &#123; // 获得改变的应用程序组件。 final String[] changedComponents = intent.getStringArrayExtra( Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST); if (changedComponents != null) &#123; for (String component : changedComponents) &#123; if (component.equals(pkgName)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Package state change: \" + pkgName); &#125; try &#123; final int userId = UserHandle.getUserId(pkgUid); IPackageManager pm = AppGlobals.getPackageManager(); // 获得这个 package 的状态！ final int state = pm.getApplicationEnabledSetting(pkgName, userId); if (state == COMPONENT_ENABLED_STATE_DISABLED || state == COMPONENT_ENABLED_STATE_DISABLED_USER) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Removing jobs for package \" + pkgName + \" in user \" + userId); &#125; // 第二个参数表示，强制取消！ cancelJobsForUid(pkgUid, true); &#125; &#125; catch (RemoteException|IllegalArgumentException e) &#123; ... ... ... ... ... &#125; break; &#125; &#125; &#125; &#125; else &#123; Slog.w(TAG, \"PACKAGE_CHANGED for \" + pkgName + \" / uid \" + pkgUid); &#125; &#125; else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) &#123; // 应用程序被移除的广播！ // If this is an outright uninstall rather than the first half of an // app update sequence, cancel the jobs associated with the app. if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123; int uidRemoved = intent.getIntExtra(Intent.EXTRA_UID, -1); if (DEBUG) &#123; Slog.d(TAG, \"Removing jobs for uid: \" + uidRemoved); &#125; cancelJobsForUid(uidRemoved, true); &#125; &#125; else if (Intent.ACTION_USER_REMOVED.equals(action)) &#123; // 设备用户被移除的广播！ final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0); if (DEBUG) &#123; Slog.d(TAG, \"Removing jobs for user: \" + userId); &#125; cancelJobsForUser(userId); &#125; else if (Intent.ACTION_QUERY_PACKAGE_RESTART.equals(action)) &#123; // package 被启用的广播！ // Has this package scheduled any jobs, such that we will take action // if it were to be force-stopped? final int pkgUid = intent.getIntExtra(Intent.EXTRA_UID, -1); final String pkgName = intent.getData().getSchemeSpecificPart(); if (pkgUid != -1) &#123; List&lt;JobStatus&gt; jobsForUid; synchronized (mLock) &#123; jobsForUid = mJobs.getJobsByUid(pkgUid); &#125; for (int i = jobsForUid.size() - 1; i &gt;= 0; i--) &#123; if (jobsForUid.get(i).getSourcePackageName().equals(pkgName)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Restart query: package \" + pkgName + \" at uid \" + pkgUid + \" has jobs\"); &#125; setResultCode(Activity.RESULT_OK); break; &#125; &#125; &#125; &#125; else if (Intent.ACTION_PACKAGE_RESTARTED.equals(action)) &#123; // package 被重启 的广播！ // possible force-stop final int pkgUid = intent.getIntExtra(Intent.EXTRA_UID, -1); final String pkgName = intent.getData().getSchemeSpecificPart(); if (pkgUid != -1) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Removing jobs for pkg \" + pkgName + \" at uid \" + pkgUid); &#125; cancelJobsForPackageAndUid(pkgName, pkgUid); &#125; &#125; &#125;&#125;; 我们来总结一下： 监听的广播有下面的这些： package 相关 Intent.ACTION_PACKAGE_CHANGED：应用程序包发生改变的广播！ Intent.ACTION_PACKAGE_REMOVED：删除应用程序包的广播！ Intent.ACTION_QUERY_PACKAGE_RESTART： Intent.ACTION_PACKAGE_RESTARTED： user 相关 Intent.ACTION_USER_REMOVED：设备用户被移除的广播！ 但不管怎样，最后都会到了 cancel 相关的代码了！ 2 Uid Change接着来，是监听进程 uid 的变化，依赖于 JSS 内部的一个观察者：mUidObserver：123456789101112131415161718final private IUidObserver mUidObserver = new IUidObserver.Stub() &#123; // 传入的参数是 uid 和 uid 所属进程的状态 ! @Override public void onUidStateChanged(int uid, int procState) throws RemoteException &#123; // 进程状态变化！ updateUidState(uid, procState); &#125; @Override public void onUidGone(int uid) throws RemoteException &#123; // 进程被杀了！ updateUidState(uid, ActivityManager.PROCESS_STATE_CACHED_EMPTY); &#125; @Override public void onUidActive(int uid) throws RemoteException &#123; // 进程活跃！ &#125; @Override public void onUidIdle(int uid) throws RemoteException &#123; // 进程空闲！ cancelJobsForUid(uid, false); &#125;&#125;; 这里面调用了一个 方法：123456789101112131415161718void updateUidState(int uid, int procState) &#123; synchronized (mLock) &#123; if (procState == ActivityManager.PROCESS_STATE_TOP) &#123; // Only use this if we are exactly the top app. All others can live // with just the foreground priority. This means that persistent processes // can never be the top app priority... that is fine. mUidPriorityOverride.put(uid, JobInfo.PRIORITY_TOP_APP); &#125; else if (procState &lt;= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) &#123; mUidPriorityOverride.put(uid, JobInfo.PRIORITY_FOREGROUND_APP); &#125; else &#123; mUidPriorityOverride.delete(uid); &#125; &#125;&#125; 可以看到，这里当应用的进程的状态发生变化时，需要对其进程的状态和uid进行记录：1234/** * Which uids are currently in the foreground. */final SparseIntArray mUidPriorityOverride = new SparseIntArray(); 这个稀疏数组用来保存进程的 uid 和进程的状态的，当某个应用的进程变为前台进程，每次变化就会被保存到这个集合中！ 还记得在 schedule 篇中，我们讲到，对于同一个 uid 和 jobId 的 job，如果优先级不同，会发生优先级高的替换优先级低的 job 的情况，这里会用到如下的方法： 123456789101112131415161718192021222324252627282930private int adjustJobPriority(int curPriority, JobStatus job) &#123; if (curPriority &lt; JobInfo.PRIORITY_TOP_APP) &#123; float factor = mJobPackageTracker.getLoadFactor(job); if (factor &gt;= mConstants.HEAVY_USE_FACTOR) &#123; curPriority += JobInfo.PRIORITY_ADJ_ALWAYS_RUNNING; &#125; else if (factor &gt;= mConstants.MODERATE_USE_FACTOR) &#123; curPriority += JobInfo.PRIORITY_ADJ_OFTEN_RUNNING; &#125; &#125; return curPriority;&#125;private int evaluateJobPriorityLocked(JobStatus job) &#123; // 获得 job 的优先级，默认为：PRIORITY_DEFAULT(0) int priority = job.getPriority(); if (priority &gt;= JobInfo.PRIORITY_FOREGROUND_APP) &#123; return adjustJobPriority(priority, job); &#125; // 这里是判断当前 job 的 uid 所属进程是否是前台进程。 int override = mUidPriorityOverride.get(job.getSourceUid(), 0); if (override != 0) &#123; return adjustJobPriority(override, job); &#125; return adjustJobPriority(priority, job);&#125; 这个方式是为了给 job 计算合适的优先级！ 这里就不细说哦，可以去看 schedule 篇！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"JobScheduler第 6 篇 - JobSchedulerService - job controll","slug":"JobScheduler6-JobSchedulerService-jobControll","date":"2016-04-25T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/04/25/JobScheduler6-JobSchedulerService-jobControll/","link":"","permalink":"https://coolqi.top/2016/04/25/JobScheduler6-JobSchedulerService-jobControll/","excerpt":"","text":"基于 Android 7.1.1 源码分析，分析 job controller 的实现机制！ 前言我们知道，当我们把 job schedule 进入 JobSchedulerService 中后，JobSchdulerService 会拉起它，之前我们分析了用户主动 cancel 和 jobFinished job 时，具体的函数调用，而对于 job 除了受的到用户的主动操作之外，还有 controller 的控制，接下来，我们来看看那这部分代码！ Job 的 controll 都是在 controller 中，controller 的初始化是在 JobSchedulerService 中：1234567891011121314151617public JobSchedulerService(Context context) &#123; super(context); mHandler = new JobHandler(context.getMainLooper()); mConstants = new Constants(mHandler); mJobSchedulerStub = new JobSchedulerStub(); mJobs = JobStore.initAndGet(this); // Create the controllers. mControllers = new ArrayList&lt;StateController&gt;(); mControllers.add(ConnectivityController.get(this)); mControllers.add(TimeController.get(this)); mControllers.add(IdleController.get(this)); mControllers.add(BatteryController.get(this)); mControllers.add(AppIdleController.get(this)); mControllers.add(ContentObserverController.get(this)); mControllers.add(DeviceIdleJobsController.get(this));&#125; 每一个 Controller 都采用了单例模式，保证了有且仅有一个 Controller，每个 Controller 内部都有一个集合用来管理其所控制的左右 job！ 接下来，我们一个一个看： 1 ConnectivityControllerConnectivityController 主要是用来根据网络条件来控制 job！我们先来看构造器：123456789101112131415private ConnectivityController(StateChangedListener stateChangedListener, Context context, Object lock) &#123; super(stateChangedListener, context, lock); mConnManager = mContext.getSystemService(ConnectivityManager.class); mNetPolicyManager = mContext.getSystemService(NetworkPolicyManager.class); // 这里很简单，注册了一个广播接收者，监听 ConnectivityManager.CONNECTIVITY_ACTION 广播! final IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); mContext.registerReceiverAsUser( mConnectivityReceiver, UserHandle.SYSTEM, intentFilter, null, null); // 向网络策略管理服务注册监听器！ mNetPolicyManager.registerListener(mNetPolicyListener);&#125; ConnectivityController 对 job 的控制主要依靠这两个监听器： 1.1 CC.ConnectivityReceiver我们先来看看第一个：123456private BroadcastReceiver mConnectivityReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; updateTrackedJobs(-1); &#125;&#125;; 这个很简单，当网络断开或连接，会调用 updateTrackedJobs 方法！ 1.2 CC.NetPolicyListener接着看看网络策略监听器，当网络策略发生变化后，会回调接口：1234567891011121314151617181920212223242526private INetworkPolicyListener mNetPolicyListener = new INetworkPolicyListener.Stub() &#123; @Override public void onUidRulesChanged(int uid, int uidRules) &#123; updateTrackedJobs(uid); &#125; @Override public void onMeteredIfacesChanged(String[] meteredIfaces) &#123; updateTrackedJobs(-1); &#125; @Override public void onRestrictBackgroundChanged(boolean restrictBackground) &#123; updateTrackedJobs(-1); &#125; @Override public void onRestrictBackgroundWhitelistChanged(int uid, boolean whitelisted) &#123; updateTrackedJobs(uid); &#125; @Override public void onRestrictBackgroundBlacklistChanged(int uid, boolean blacklisted) &#123; updateTrackedJobs(uid); &#125;&#125;; 可以发现，最终都调用了 updateTrackedJobs 方法： 1.3 CC.updateTrackedJobs通过传入的 uid 的值，来更新具体的 job 状态！12345678910111213141516171819private void updateTrackedJobs(int uid) &#123; synchronized (mLock) &#123; boolean changed = false; for (int i = 0; i &lt; mTrackedJobs.size(); i++) &#123; // 遍历 job 监控列表 final JobStatus js = mTrackedJobs.get(i); // 关键点！ if (uid == -1 || uid == js.getSourceUid()) &#123; changed |= updateConstraintsSatisfied(js); &#125; &#125; if (changed) &#123; // changed 为 ture 表示约束条件改变！ mStateChangedListener.onControllerStateChanged(); &#125; &#125;&#125; 更新策略分析： 如果 uid 的值为 -1，那就更新这个控制器监视的所有 job； 如果 uid 的值为指定的 uid，那就更新属于这个 uid 的所有 job； 这里调用了 updateConstraintsSatisfied 方法判断是否有 job 需要更新： 12345678910111213141516171819private boolean updateConstraintsSatisfied(JobStatus jobStatus) &#123; final boolean ignoreBlocked = (jobStatus.getFlags() &amp; JobInfo.FLAG_WILL_BE_FOREGROUND) != 0; // 获得这个 job 所属 uid （应用程序）的网络信息对象：NetworkInfo！ final NetworkInfo info = mConnManager.getActiveNetworkInfoForUid(jobStatus.getSourceUid(), ignoreBlocked); final boolean connected = (info != null) &amp;&amp; info.isConnected(); final boolean unmetered = connected &amp;&amp; !info.isMetered(); final boolean notRoaming = connected &amp;&amp; !info.isRoaming(); boolean changed = false; // 根据网络信息来更新 job 的状态，动态更新 satisfiedConstraints 的对应二进制位！ changed |= jobStatus.setConnectivityConstraintSatisfied(connected); changed |= jobStatus.setUnmeteredConstraintSatisfied(unmetered); changed |= jobStatus.setNotRoamingConstraintSatisfied(notRoaming); return changed;&#125; 这个方法获得这个 job 所属 uid （应用程序）的网络信息对象， 根据网络信息来更新 job！利用 |= 方法，只要有一个约束条件发生了变化，即发生了变化！最后，调用 mStateChangedListener 的 onControllerStateChanged 方法来通知有 job 变化了！ ConnectivityController 的 startTrack 和 stopTrack 也很简单：12345678910111213141516171819202122@Overridepublic void maybeStartTrackingJobLocked(JobStatus jobStatus, JobStatus lastJob) &#123; if (jobStatus.hasConnectivityConstraint() || jobStatus.hasUnmeteredConstraint() || jobStatus.hasNotRoamingConstraint()) &#123; // 在监控 job 之前，检查一下约束条件，并更新 job 的状态！ updateConstraintsSatisfied(jobStatus); // 添加到监控列表！ mTrackedJobs.add(jobStatus); &#125;&#125;@Overridepublic void maybeStopTrackingJobLocked(JobStatus jobStatus, JobStatus incomingJob, boolean forUpdate) &#123; if (jobStatus.hasConnectivityConstraint() || jobStatus.hasUnmeteredConstraint() || jobStatus.hasNotRoamingConstraint()) &#123; // 从监控列表中移除！ mTrackedJobs.remove(jobStatus); &#125;&#125; 先到这里，不多说了！ 2 TimeController接下来，看看时间控制器，一个 job 的超时和延迟处理，都是由这个控制器处理的：123456private TimeController(StateChangedListener stateChangedListener, Context context, Object lock) &#123; super(stateChangedListener, context, lock); // 初始化为无限大！ mNextJobExpiredElapsedMillis = Long.MAX_VALUE; mNextDelayExpiredElapsedMillis = Long.MAX_VALUE;&#125; 可以看到，构造器中的代码很简单，重点不在这里啦！ 2.1 maybeStartTrackingJobLocked在 maybeStartTrackingJobLocked，参数传递： JobStatus job：这次要执行的 job JobStatus lastJob：被取代的 job，可以为 null！1234567891011121314151617181920212223242526272829303132@Overridepublic void maybeStartTrackingJobLocked(JobStatus job, JobStatus lastJob) &#123; // 判断 job 是否设置了延迟时间和超时时间！ if (job.hasTimingDelayConstraint() || job.hasDeadlineConstraint()) &#123; maybeStopTrackingJobLocked(job, null, false); boolean isInsert = false; ListIterator&lt;JobStatus&gt; it = mTrackedJobs.listIterator(mTrackedJobs.size()); // 遍历 track 集合，根据超时处理的时间升序排列，插入新的 job！ while (it.hasPrevious()) &#123; JobStatus ts = it.previous(); if (ts.getLatestRunTimeElapsed() &lt; job.getLatestRunTimeElapsed()) &#123; // Insert isInsert = true; break; &#125; &#125; if (isInsert) &#123; it.next(); &#125; it.add(job); // 设置延时处理和超时处理的 alarm！ maybeUpdateAlarmsLocked( job.hasTimingDelayConstraint() ? job.getEarliestRunTime() : Long.MAX_VALUE, job.hasDeadlineConstraint() ? job.getLatestRunTimeElapsed() : Long.MAX_VALUE, job.getSourceUid()); &#125;&#125; 可以看到： 如果 job 设置了延时触发条件，那么需要传入一个延迟时间值，这个时间值在这里通过 job.getEarliestRunTime() 获取！ 如果 job 设置了超时处理触发条件，那么需要传入一个超时时间值，这个时间值在这里通过 job.getLatestRunTimeElapsed() 获取！ 如果没有设置，默认为 Long.MAX_VALUE！ 注意：TimeController 的监控集合是以每个 job 的超时时间点排序的！ 2.2 maybeUpdateAlarmsLocked接着进入 maybeUpdateAlarmsLocked 方法中，参数传递： long delayExpiredElapsed：延迟触发时间！ long deadlineExpiredElapsed：超时处理时间！ 12345678910111213private void maybeUpdateAlarmsLocked(long delayExpiredElapsed, long deadlineExpiredElapsed, int uid) &#123; // mNextDelayExpiredElapsedMillis 的值为 Long.MAX_VALUE if (delayExpiredElapsed &lt; mNextDelayExpiredElapsedMillis) &#123; setDelayExpiredAlarmLocked(delayExpiredElapsed, uid); &#125; // mNextJobExpiredElapsedMillis 的值为 Long.MAX_VALUE if (deadlineExpiredElapsed &lt; mNextJobExpiredElapsedMillis) &#123; setDeadlineExpiredAlarmLocked(deadlineExpiredElapsed, uid); &#125;&#125; 这里调用了两个方法，来设定 alarm： 2.3 setXXXXExpiredAlarmLocked123456789101112131415161718192021// 延时处理闹钟设置！private void setDelayExpiredAlarmLocked(long alarmTimeElapsedMillis, int uid) &#123; // 校验时间，最小等于从开机到现在的时间！ alarmTimeElapsedMillis = maybeAdjustAlarmTime(alarmTimeElapsedMillis); mNextDelayExpiredElapsedMillis = alarmTimeElapsedMillis; updateAlarmWithListenerLocked(DELAY_TAG, mNextDelayExpiredListener, mNextDelayExpiredElapsedMillis, uid);&#125;// 超时处理闹钟设置！private void setDeadlineExpiredAlarmLocked(long alarmTimeElapsedMillis, int uid) &#123; // 校验时间，最小等于从开机到现在的时间！ alarmTimeElapsedMillis = maybeAdjustAlarmTime(alarmTimeElapsedMillis); mNextJobExpiredElapsedMillis = alarmTimeElapsedMillis; updateAlarmWithListenerLocked(DEADLINE_TAG, mDeadlineExpiredListener, mNextJobExpiredElapsedMillis, uid);&#125; 这里的代码很有意思：首先返回一个正确的延迟或者超时处理时间点，然后根据这个时间点设置一个 alarm，时间点到了，会触发这个 alarm，linster 的回调会被执行！我们继续看： 2.3.1 maybeAdjustAlarmTime1234567891011private long maybeAdjustAlarmTime(long proposedAlarmTimeElapsedMillis) &#123; // 获得从开机到现在的时间！ final long earliestWakeupTimeElapsed = SystemClock.elapsedRealtime(); // 取 job 的时间和开机时间的最大值！ if (proposedAlarmTimeElapsedMillis &lt; earliestWakeupTimeElapsed) &#123; return earliestWakeupTimeElapsed; &#125; return proposedAlarmTimeElapsedMillis; &#125; 这个方法是用来和开机时间比较的，返回一个最大值，确保时间正确性！ 2.3.2 updateAlarmWithListenerLocked这里是设置一个 alarm，在指定时间触发 alarm，执行 job，参数传递： String tag：表示 alarm 的 tag，可取值为 DELAY_TAG 或者 DEADLINE_TAG； OnAlarmListener listener：OnAlarmListener 对象！ long alarmTimeElapsed：触发时间！ int uid： job 的 uid 123456789101112131415161718private void updateAlarmWithListenerLocked(String tag, OnAlarmListener listener, long alarmTimeElapsed, int uid) &#123; // 获得 alarmService 代理对象！ ensureAlarmServiceLocked(); if (alarmTimeElapsed == Long.MAX_VALUE) &#123; mAlarmService.cancel(listener); &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"Setting \" + tag + \" for: \" + alarmTimeElapsed); &#125; // important point！ mAlarmService.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, alarmTimeElapsed, AlarmManager.WINDOW_HEURISTIC, 0, tag, listener, null, new WorkSource(uid)); &#125;&#125; 这里会在时间点 alarmTimeElapsed 到达时，触发 alarm，执行监听器 OnAlarmListener listener 的 onAlarm 方法： 2.3.2.1 mNextDelayExpiredListener我们先来看看延迟处理的 Listener：1234567891011private final OnAlarmListener mNextDelayExpiredListener = new OnAlarmListener() &#123; @Override public void onAlarm() &#123; if (DEBUG) &#123; Slog.d(TAG, \"Delay-expired alarm fired\"); &#125; // 时间点到后会触发 checkExpiredDelaysAndResetAlarm 方法！ checkExpiredDelaysAndResetAlarm(); &#125;&#125;; 2.3.2.1.1 checkExpiredDelaysAndResetAlarm这里调用了 checkExpiredDelaysAndResetAlarm 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void checkExpiredDelaysAndResetAlarm() &#123; synchronized (mLock) &#123; // 获得从开机到现在的时间 final long nowElapsedMillis = SystemClock.elapsedRealtime(); long nextDelayTime = Long.MAX_VALUE; int nextDelayUid = 0; boolean ready = false; // 默认为 false，表示是否有 job 准备执行！ Iterator&lt;JobStatus&gt; it = mTrackedJobs.iterator(); // 遍历 track 集合！ while (it.hasNext()) &#123; final JobStatus job = it.next(); if (!job.hasTimingDelayConstraint()) &#123; continue; &#125; // 获得每个 job 的延迟处理时间； final long jobDelayTime = job.getEarliestRunTime(); if (jobDelayTime &lt;= nowElapsedMillis) &#123; // 说明延时触发时间点到了！ // 设置该 job 的对应 TimingDelay 二进制位为 1，表示满足条件！ job.setTimingDelayConstraintSatisfied(true); if (canStopTrackingJobLocked(job)) &#123; it.remove(); &#125; if (job.isReady()) &#123; // 如果 job 准备好了，就准备执行 job！ ready = true; &#125; &#125; else if (!job.isConstraintSatisfied(JobStatus.CONSTRAINT_TIMING_DELAY)) &#123; // 这里是为了在剩余的，本次未触发的 job 里，找到延时触发时间最短的 job，并以它的延迟触发时间， // 作为下次 alarm 的触发时间点！ if (nextDelayTime &gt; jobDelayTime) &#123; nextDelayTime = jobDelayTime; nextDelayUid = job.getSourceUid(); &#125; &#125; &#125; if (ready) &#123; // 如果是 true，通知 jobScheduler！ mStateChangedListener.onControllerStateChanged(); &#125; // 设置下一轮的 alarm! setDelayExpiredAlarmLocked(nextDelayTime, nextDelayUid); &#125;&#125; 当 lisener 的回调被执行时，这个时候，job 的延时处理时间会小于等于系统从开机到现在的时间，所以会进入第一个 if 分支！ 对于本次没有触发，且没有被取消的 job，找到延时处理时间最短的 job，并以它的延迟触发时间，作为下次 alarm 的触发时间点！ 这里调用了 job.isReady()，判断一个 job 是否准备好：12345678910111213141516public boolean isReady() &#123; // 判断 job 的 deadline 条件是否满足，只对非周期 job 才会有； final boolean deadlineSatisfied = (!job.isPeriodic() &amp;&amp; hasDeadlineConstraint() &amp;&amp; (satisfiedConstraints &amp; CONSTRAINT_DEADLINE) != 0); // 判断应用处于非空闲状态的条件是否满足！ final boolean notIdle = (satisfiedConstraints &amp; CONSTRAINT_APP_NOT_IDLE) != 0; // 判断处于非 dozing 模式的是否满足！ final boolean notDozing = (satisfiedConstraints &amp; CONSTRAINT_DEVICE_NOT_DOZING) != 0 || (job.getFlags() &amp; JobInfo.FLAG_WILL_BE_FOREGROUND) != 0; // 最后判断这个 job 是否 ready！ return (isConstraintsSatisfied() || deadlineSatisfied) &amp;&amp; notIdle &amp;&amp; notDozing;&#125; 可以看到，一个 job 处于 ready 状态，需要同时满足如下的几个条件： job 的所有约束条件都满足，或者对于非周期 job，deadline 已经满足了！ job 设置的应用处于非空闲状态的条件满足； job 设置的设备处于非doze的条件满足； 2.3.2.2 mDeadlineExpiredListener我们先来看看超时处理的 Listener：1234567891011private final OnAlarmListener mDeadlineExpiredListener = new OnAlarmListener() &#123; @Override public void onAlarm() &#123; if (DEBUG) &#123; Slog.d(TAG, \"Deadline-expired alarm fired\"); &#125; // 时间点到后会触发 checkExpiredDeadlinesAndResetAlarm 方法！ checkExpiredDeadlinesAndResetAlarm(); &#125;&#125;; 这里调用了 checkExpiredDeadlinesAndResetAlarm： 2.3.2.2.1 checkExpiredDeadlinesAndResetAlarm1234567891011121314151617181920212223242526272829303132333435363738private void checkExpiredDeadlinesAndResetAlarm() &#123; synchronized (mLock) &#123; long nextExpiryTime = Long.MAX_VALUE; int nextExpiryUid = 0; final long nowElapsedMillis = SystemClock.elapsedRealtime(); Iterator&lt;JobStatus&gt; it = mTrackedJobs.iterator(); while (it.hasNext()) &#123; // 遍历集合 JobStatus job = it.next(); if (!job.hasDeadlineConstraint()) &#123; continue; &#125; final long jobDeadline = job.getLatestRunTimeElapsed(); // 获得每个 job 的超时触发时间点！ if (jobDeadline &lt;= nowElapsedMillis) &#123; // 超时时间触发点到了！ if (job.hasTimingDelayConstraint()) &#123; // 如果 job 还有设置了延迟时间触发条件，将相应的 TimingDelay 二进制位为 1！ job.setTimingDelayConstraintSatisfied(true); &#125; job.setDeadlineConstraintSatisfied(true); // 设置相应的 Deadline 二进制位为 1！ mStateChangedListener.onRunJobNow(job); // 立刻执行 Job！ it.remove(); // 移除，不再监控！ &#125; else &#123; // 找到下一个没有满足的 job ，以它的超时处理时间点作为下次 alarm 的触发点，退出循环！ nextExpiryTime = jobDeadline; nextExpiryUid = job.getSourceUid(); break; &#125; &#125; // 设置下一次的 alarm！ setDeadlineExpiredAlarmLocked(nextExpiryTime, nextExpiryUid); &#125;&#125; 最后，调用了 JSS 的 onRunJobNow 方法，这里我们后面再看！ 3 IdleController我们来看看 IdleController 这个空闲状态控制器的构造器：12345private IdleController(StateChangedListener stateChangedListener, Context context, Object lock) &#123; super(stateChangedListener, context, lock); initIdleStateTracking();&#125; 调用了这个方法，initIdleStateTracking：123456789101112131415/** * Idle state tracking, and messaging with the task manager when * significant state changes occur */private void initIdleStateTracking() &#123; // 设备真正进入空闲的时间间隔：4260000 毫秒 mInactivityIdleThreshold = mContext.getResources().getInteger( com.android.internal.R.integer.config_jobSchedulerInactivityIdleThreshold); mIdleWindowSlop = mContext.getResources().getInteger( com.android.internal.R.integer.config_jobSchedulerIdleWindowSlop); // 创建了一个设备空闲监控器，并启动监控！ mIdleTracker = new IdlenessTracker(); mIdleTracker.startTracking();&#125; 这里创建了一个 IdlenessTracker。 3.1 IdlenessTracker这个 Tracker 是一个广播接收者！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990class IdlenessTracker extends BroadcastReceiver &#123; private AlarmManager mAlarm; private PendingIntent mIdleTriggerIntent; boolean mIdle; boolean mScreenOn; public IdlenessTracker() &#123; // 设置一个 alarm，用来发送 ActivityManagerService.ACTION_TRIGGER_IDLE 广播！ mAlarm = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE); Intent intent = new Intent(ActivityManagerService.ACTION_TRIGGER_IDLE) .setPackage(\"android\") .setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); mIdleTriggerIntent = PendingIntent.getBroadcast(mContext, 0, intent, 0); // At boot we presume that the user has just \"interacted\" with the // device in some meaningful way. mIdle = false; mScreenOn = true; &#125; // 设备是否处于空闲的标志！ public boolean isIdle() &#123; return mIdle; &#125; public void startTracking() &#123; IntentFilter filter = new IntentFilter(); // 监听屏幕的亮暗状态！ filter.addAction(Intent.ACTION_SCREEN_ON); filter.addAction(Intent.ACTION_SCREEN_OFF); // 监听设备的睡眠状态 filter.addAction(Intent.ACTION_DREAMING_STARTED); filter.addAction(Intent.ACTION_DREAMING_STOPPED); // 监听设备进入空闲状态 filter.addAction(ActivityManagerService.ACTION_TRIGGER_IDLE); mContext.registerReceiver(this, filter); &#125; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); // 监听亮屏广播 或者 退出休眠的广播。 if (action.equals(Intent.ACTION_SCREEN_ON) || action.equals(Intent.ACTION_DREAMING_STOPPED)) &#123; if (DEBUG) &#123; Slog.v(TAG,\"exiting idle : \" + action); &#125; mScreenOn = true; // 表示亮屏 //cancel the alarm mAlarm.cancel(mIdleTriggerIntent); // 取消闹钟！ if (mIdle) &#123; mIdle = false; // 表示设备进入了非空闲！ reportNewIdleState(mIdle); &#125; &#125; else if (action.equals(Intent.ACTION_SCREEN_OFF) // 熄屏广播 和 进入休眠的广播。 || action.equals(Intent.ACTION_DREAMING_STARTED)) &#123; // 因为接到广播和设备真正处于空闲是有一定时间间隔的，所以这里设置了一个闹钟， // 用于在指定时间后发送广播：ActivityManagerService.ACTION_TRIGGER_IDLE final long nowElapsed = SystemClock.elapsedRealtime(); final long when = nowElapsed + mInactivityIdleThreshold; if (DEBUG) &#123; Slog.v(TAG, \"Scheduling idle : \" + action + \" now:\" + nowElapsed + \" when=\" + when); &#125; mScreenOn = false; // 表示灭屏！ mAlarm.setWindow(AlarmManager.ELAPSED_REALTIME_WAKEUP, when, mIdleWindowSlop, mIdleTriggerIntent); &#125; else if (action.equals(ActivityManagerService.ACTION_TRIGGER_IDLE)) &#123; // 表示设备真正进入了空闲！ // idle time starts now. Do not set mIdle if screen is on. if (!mIdle &amp;&amp; !mScreenOn) &#123; if (DEBUG) &#123; Slog.v(TAG, \"Idle trigger fired @ \" + SystemClock.elapsedRealtime()); &#125; mIdle = true; // 表示设备进入了空闲状态 reportNewIdleState(mIdle); &#125; &#125; &#125;&#125; 总结下：收到亮屏广播或者退出休眠的广播，设备处于非空闲，取消 alarm，如果设备之前是空闲的，那就通知 jobScheduler！收到熄屏广播或者进入出休眠的广播，设备可能进入空闲状态，设置 alarm，在一定时间后发送广播；接受这个广播，如果设备之前是非空闲的，那就通知 jobScheduler！ 接下来，进入 reportNewIdleState 方法中来看看：1234567891011void reportNewIdleState(boolean isIdle) &#123; synchronized (mLock) &#123; for (JobStatus task : mTrackedTasks) &#123; // 设置 job 的设备空闲状态条件！ task.setIdleConstraintSatisfied(isIdle); &#125; &#125; // 通知 JSS，设备的空闲状态发生了变化！ mStateChangedListener.onControllerStateChanged();&#125; 这个方法很简单，修改自己所监控的 Job 的 JobStatus 的 Idle 二进制位，并通知 JobSchedulerService ，JobSchdulerService 会根据这个状态来动态控制 jobServcie！ IdleController 的 StartTrackingJob 和 StopTrackingJob 都很简单，请看下面：1234567891011121314151617/** * StateController interface */@Overridepublic void maybeStartTrackingJobLocked(JobStatus taskStatus, JobStatus lastJob) &#123; if (taskStatus.hasIdleConstraint()) &#123; // 判断 job 是否设置空闲约束！ mTrackedTasks.add(taskStatus); // 监控之前，进行 job 的设备状态初始化！ taskStatus.setIdleConstraintSatisfied(mIdleTracker.isIdle()); &#125;&#125;@Overridepublic void maybeStopTrackingJobLocked(JobStatus taskStatus, JobStatus incomingJob, boolean forUpdate) &#123; mTrackedTasks.remove(taskStatus);&#125; 不多说了！ 4 BatteryController我们来看看电量控制器：12345678private BatteryController(StateChangedListener stateChangedListener, Context context, Object lock) &#123; super(stateChangedListener, context, lock); // 这里创建了一个充电监视器 mChargeTracker = new ChargingTracker(); mChargeTracker.startTracking();&#125; 4.1 ChargingTracker我们去看看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class ChargingTracker extends BroadcastReceiver &#123; /** * Track whether we're \"charging\", where charging means that we're ready to commit to * doing work. */ private boolean mCharging; /** Keep track of whether the battery is charged enough that we want to do work. */ private boolean mBatteryHealthy; public ChargingTracker() &#123; &#125; public void startTracking() &#123; IntentFilter filter = new IntentFilter(); // Battery health. // 监听电量 filter.addAction(Intent.ACTION_BATTERY_LOW); filter.addAction(Intent.ACTION_BATTERY_OKAY); // Charging/not charging. // 监听充电的广播 filter.addAction(BatteryManager.ACTION_CHARGING); filter.addAction(BatteryManager.ACTION_DISCHARGING); mContext.registerReceiver(this, filter); // Initialise tracker state. BatteryManagerInternal batteryManagerInternal = LocalServices.getService(BatteryManagerInternal.class); // 初始化电量的状态 mBatteryHealthy = !batteryManagerInternal.getBatteryLevelLow(); mCharging = batteryManagerInternal.isPowered(BatteryManager.BATTERY_PLUGGED_ANY); &#125; // 判断当前的电池环境是否稳定 boolean isOnStablePower() &#123; return mCharging &amp;&amp; mBatteryHealthy; &#125; @Override public void onReceive(Context context, Intent intent) &#123; // 处理广播！ onReceiveInternal(intent); &#125; @VisibleForTesting public void onReceiveInternal(Intent intent) &#123; final String action = intent.getAction(); if (Intent.ACTION_BATTERY_LOW.equals(action)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Battery life too low to do work. @ \" + SystemClock.elapsedRealtime()); &#125; // If we get this action, the battery is discharging =&gt; it isn't plugged in so // there's no work to cancel. We track this variable for the case where it is // charging, but hasn't been for long enough to be healthy. // 电量太低，mBatteryHealthy 置为 false！ mBatteryHealthy = false; &#125; else if (Intent.ACTION_BATTERY_OKAY.equals(action)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Battery life healthy enough to do work. @ \" + SystemClock.elapsedRealtime()); &#125; // 电量充足，mBatteryHealthy 置为 true，通知 job 状态需要改变！ mBatteryHealthy = true; maybeReportNewChargingState(); &#125; else if (BatteryManager.ACTION_CHARGING.equals(action)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Received charging intent, fired @ \" + SystemClock.elapsedRealtime()); &#125; // 正在充电，mCharging 置为 true，通知 job 状态需要改变！ mCharging = true; maybeReportNewChargingState(); &#125; else if (BatteryManager.ACTION_DISCHARGING.equals(action)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Disconnected from power.\"); &#125; // 充电断开，mCharging 置为 false，通知 job 状态需要改变！ mCharging = false; maybeReportNewChargingState(); &#125; &#125;&#125; 4.1.1 maybeReportNewChargingState最后调用了 maybeReportNewChargingState 方法：123456789101112131415161718192021222324252627282930private void maybeReportNewChargingState() &#123; // 获得本次电池的状态 final boolean stablePower = mChargeTracker.isOnStablePower(); if (DEBUG) &#123; Slog.d(TAG, \"maybeReportNewChargingState: \" + stablePower); &#125; boolean reportChange = false; synchronized (mLock) &#123; for (JobStatus ts : mTrackedTasks) &#123; // 对于这个 controller 监视的所有 JobStatus，判断这次是否满足约束条件！ boolean previous = ts.setChargingConstraintSatisfied(stablePower); if (previous != stablePower) &#123; // 这里一次和上一次不一样，需要通知 JobSchedulerService，发生变化 reportChange = true; &#125; &#125; &#125; // Let the scheduler know that state has changed. This may or may not result in an // execution. if (reportChange) &#123; // 通知 jobScheduler，发生变化 mStateChangedListener.onControllerStateChanged(); &#125; // Also tell the scheduler that any ready jobs should be flushed. if (stablePower) &#123; // 通知 jobScheduler，如果电池状态满足，执行任务 mStateChangedListener.onRunJobNow(null); &#125;&#125; 这里很简单，就不说了！ 5 AppIdleController这个控制器的主要作用是，判断 app 是否是闲置的，如果是闲置的，那么他的 job 将会被执行，如何判断闲置呢？没有被启动，或者数小时或者数天之前在启动过！我们先来看看 AppIdleController 的构造器：12345678private AppIdleController(JobSchedulerService service, Context context, Object lock) &#123; super(service, context, lock); mJobSchedulerService = service; mUsageStatsInternal = LocalServices.getService(UsageStatsManagerInternal.class); mAppIdleParoleOn = true; // 将 AppIdleStateChangeListener 注册进入 UsageStatsManagerInternal 服务中 mUsageStatsInternal.addAppIdleStateChangeListener(new AppIdleStateChangeListener());&#125; 我们继续看： 5.1 AppIdleStateChangeListener这里有一个监听器： AppIdleStateChangeListener：123456789101112131415161718192021222324252627282930private class AppIdleStateChangeListener extends UsageStatsManagerInternal.AppIdleStateChangeListener &#123; @Override public void onAppIdleStateChanged(String packageName, int userId, boolean idle) &#123; boolean changed = false; synchronized (mLock) &#123; if (mAppIdleParoleOn) &#123; return; &#125; // 创建 PackageUpdateFunc，对 userId 下的包名为 pacakgeName 的应用的所有 job，进行状态检查和更新 PackageUpdateFunc update = new PackageUpdateFunc(userId, packageName, idle); mJobSchedulerService.getJobStore().forEachJob(update); if (update.mChanged) &#123; changed = true; &#125; &#125; if (changed) &#123; // 通知 jobScheduler，发生变化 mStateChangedListener.onControllerStateChanged(); &#125; &#125; @Override public void onParoleStateChanged(boolean isParoleOn) &#123; if (DEBUG) &#123; Slog.d(LOG_TAG, \"Parole on: \" + isParoleOn); &#125; setAppIdleParoleOn(isParoleOn); &#125;&#125; 这里的监听器本质上只是一个回调接口，具体的 controll 策略是在 UsageStatsManagerInternal 服务中，这里不多讲（因为特么我还没看） 5.1.1 PackageUpdateFunc首先来看看这个函数类：123456789101112131415161718192021222324final static class PackageUpdateFunc implements JobStore.JobStatusFunctor &#123; final int mUserId; final String mPackage; final boolean mIdle; boolean mChanged; // 用来保存 app 状态是否发生变化 PackageUpdateFunc(int userId, String pkg, boolean idle) &#123; mUserId = userId; mPackage = pkg; mIdle = idle; &#125; @Override public void process(JobStatus jobStatus) &#123; if (jobStatus.getSourcePackageName().equals(mPackage) // 判断当前的 job 是否属于这个应用程序 &amp;&amp; jobStatus.getSourceUserId() == mUserId) &#123; if (jobStatus.setAppNotIdleConstraintSatisfied(!mIdle)) &#123; if (DEBUG) &#123; Slog.d(LOG_TAG, \"App Idle state changed, setting idle state of \" + mPackage + \" to \" + mIdle); &#125; mChanged = true; &#125; &#125; &#125;&#125;; PackageUpdateFunc 会遍历 JobStore，查找指定 app 的 Job，改变 job 的属性值！ 5.1.2 setAppIdleParoleOn这个方法的作用是（特么我没看懂，这里的解释空下）12345678910111213141516171819void setAppIdleParoleOn(boolean isAppIdleParoleOn) &#123; // Flag if any app's idle state has changed boolean changed = false; synchronized (mLock) &#123; if (mAppIdleParoleOn == isAppIdleParoleOn) &#123; // 如果状态没有变化，不处理！ return; &#125; mAppIdleParoleOn = isAppIdleParoleOn; // 创建 GlobalUpdateFunc 来更新 Job 状态！ GlobalUpdateFunc update = new GlobalUpdateFunc(); mJobSchedulerService.getJobStore().forEachJob(update); if (update.mChanged) &#123; changed = true; &#125; &#125; if (changed) &#123; mStateChangedListener.onControllerStateChanged(); &#125;&#125; 我们再去看看 GlobalUpdateFunc：123456789101112131415final class GlobalUpdateFunc implements JobStore.JobStatusFunctor &#123; boolean mChanged; @Override public void process(JobStatus jobStatus) &#123; String packageName = jobStatus.getSourcePackageName(); final boolean appIdle = !mAppIdleParoleOn &amp;&amp; mUsageStatsInternal.isAppIdle(packageName, jobStatus.getSourceUid(), jobStatus.getSourceUserId()); if (DEBUG) &#123; Slog.d(LOG_TAG, \"Setting idle state of \" + packageName + \" to \" + appIdle); &#125; // 改变 job 状态！如果改变成功了，该方法返回的是 true！ if (jobStatus.setAppNotIdleConstraintSatisfied(!appIdle)) &#123; mChanged = true; &#125; &#125;&#125;; 如果，有 job 的状态发生了变化，那么 GlobalUpdateFunc 的 mChanged 的值为 true，然后通知 JobScheduler 即可！ 6 ContentObserverController通过监听数据库的变化来 controll job：12345private ContentObserverController(StateChangedListener stateChangedListener, Context context, Object lock) &#123; super(stateChangedListener, context, lock); mHandler = new Handler(context.getMainLooper());&#125; 可以看到 ，构造器很简单，那真正的 controll 在哪里呢，首先我们来一个内部变量：12345final private List&lt;JobStatus&gt; mTrackedTasks = new ArrayList&lt;JobStatus&gt;();/** * Per-userid &#123;@link JobInfo.TriggerContentUri&#125; keyed ContentObserver cache. */SparseArray&lt;ArrayMap&lt;JobInfo.TriggerContentUri, ObserverInstance&gt;&gt; mObservers = new SparseArray&lt;&gt;(); mTrackedTasks：表示这个 controller 监视的所有的 job：mObservers：key 值为 userId，表示的是设备用户，value 值为 ArrayMap&lt;JobInfo.TriggerContentUri, ObserverInstance&gt;，数据库uri和它的观察者！ 还记得，在 JobScheduler 中我们开始 track 每一个 job 吗？我们去这个方法里面去看看： 6.1 maybeStartTrackingJobLocked参数传递： JobStatus taskStatus：即将要执行的 job JobStatus lastJob：被取代的旧的 job123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overridepublic void maybeStartTrackingJobLocked(JobStatus taskStatus, JobStatus lastJob) &#123; // 判断新的 job hasContentTriggerConstraint 是否为 true！ if (taskStatus.hasContentTriggerConstraint()) &#123; if (taskStatus.contentObserverJobInstance == null) &#123; // 给 jobStatus 创建一个 JobInstance 对象！ taskStatus.contentObserverJobInstance = new JobInstance(taskStatus); &#125; if (DEBUG) &#123; Slog.i(TAG, \"Tracking content-trigger job \" + taskStatus); &#125; // 添加到追踪列表中！ mTrackedTasks.add(taskStatus); boolean havePendingUris = false; // If there is a previous job associated with the new job, propagate over // any pending content URI trigger reports. if (taskStatus.contentObserverJobInstance.mChangedAuthorities != null) &#123; havePendingUris = true; &#125; // If we have previously reported changed authorities/uris, then we failed // to complete the job with them so will re-record them to report again. // 对于有些 job ，我们之前有监视过其依赖的数据库的变化；但是，我们并没有完成这个 job， // 如果这个 job 被 reschedule，那么之前的 uris/authorities 仍然要被监控！ if (taskStatus.changedAuthorities != null) &#123; havePendingUris = true; // 用户标记是否有正在处理的 uris if (taskStatus.contentObserverJobInstance.mChangedAuthorities == null) &#123; taskStatus.contentObserverJobInstance.mChangedAuthorities = new ArraySet&lt;&gt;(); &#125; for (String auth : taskStatus.changedAuthorities) &#123; taskStatus.contentObserverJobInstance.mChangedAuthorities.add(auth); &#125; if (taskStatus.changedUris != null) &#123; if (taskStatus.contentObserverJobInstance.mChangedUris == null) &#123; taskStatus.contentObserverJobInstance.mChangedUris = new ArraySet&lt;&gt;(); &#125; for (Uri uri : taskStatus.changedUris) &#123; taskStatus.contentObserverJobInstance.mChangedUris.add(uri); &#125; &#125; taskStatus.changedAuthorities = null; taskStatus.changedUris = null; &#125; taskStatus.changedAuthorities = null; taskStatus.changedUris = null; taskStatus.setContentTriggerConstraintSatisfied(havePendingUris); &#125; // 如果当前的这个 job 有相同 jobId 的被取消的上一次 job ! if (lastJob != null &amp;&amp; lastJob.contentObserverJobInstance != null) &#123; // And now we can detach the instance state from the last job. lastJob.contentObserverJobInstance.detachLocked(); lastJob.contentObserverJobInstance = null; &#125;&#125; 对于有被替代的相同uid和jobId的旧的 job，会调用 jobInstance 的 detachLocked 方法来做一些释放资源的操作，这个我们在后面来看！ 可以看到，每一个 JobStatus 都会有一个 ContentObserverController.JobInstance 类型的对象： 6.1.1 JobInstance参数传递： JobStatus jobStatus12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final class JobInstance &#123; final ArrayList&lt;ObserverInstance&gt; mMyObservers = new ArrayList&lt;&gt;(); // 这个 job 所拥有的观察者实例集合 final JobStatus mJobStatus; // 所属的 jobStatus final Runnable mExecuteRunner; final Runnable mTimeoutRunner; // 表示哪些数据库发生了变化，最大等于 build 时传入的 uris 个数！ ArraySet&lt;Uri&gt; mChangedUris; ArraySet&lt;String&gt; mChangedAuthorities; boolean mTriggerPending; // This constructor must be called with the master job scheduler lock held. JobInstance(JobStatus jobStatus) &#123; mJobStatus = jobStatus; mExecuteRunner = new TriggerRunnable(this); mTimeoutRunner = new TriggerRunnable(this); // 获得这个 job 所依赖的所有的数据库 uri，在 JobInfo.mTriggerContentUris 中！ // 以及这个 job 所属的 userId！ final JobInfo.TriggerContentUri[] uris = jobStatus.getJob().getTriggerContentUris(); final int sourceUserId = jobStatus.getSourceUserId(); // 创建 useId 下的观察者缓存，用来提高查询效率！ ArrayMap&lt;JobInfo.TriggerContentUri, ObserverInstance&gt; observersOfUser = mObservers.get(sourceUserId); if (observersOfUser == null) &#123; observersOfUser = new ArrayMap&lt;&gt;(); mObservers.put(sourceUserId, observersOfUser); &#125; if (uris != null) &#123; for (JobInfo.TriggerContentUri uri : uris) &#123; ObserverInstance obs = observersOfUser.get(uri); if (obs == null) &#123; // 为每一个 uri 都创建一个观察者实例！ obs = new ObserverInstance(mHandler, uri, jobStatus.getSourceUserId()); // 添加到 ContentObserverController 的缓存集合里 observersOfUser.put(uri, obs); final boolean andDescendants = (uri.getFlags() &amp; JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0; if (DEBUG) &#123; Slog.v(TAG, \"New observer \" + obs + \" for \" + uri.getUri() + \" andDescendants=\" + andDescendants + \" sourceUserId=\" + sourceUserId); &#125; // 注册这个内容观察者，当内容发生变化后，会触发回调！ mContext.getContentResolver().registerContentObserver( uri.getUri(), andDescendants, obs, sourceUserId ); &#125; else &#123; if (DEBUG) &#123; final boolean andDescendants = (uri.getFlags() &amp; JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS) != 0; Slog.v(TAG, \"Reusing existing observer \" + obs + \" for \" + uri.getUri() + \" andDescendants=\" + andDescendants); &#125; &#125; // 将这个 JobInstance 添加到这个 ContextObsercer 中！ obs.mJobs.add(this); // 添加到 jobInstance 的 mMyObservers 中！ mMyObservers.add(obs); &#125; &#125; &#125; ... ... ... ...&#125; 这里创建了一个 ObserverInstance 对象，用来监听数据库的变动，当 uri 所指向的数据库发生变化后，他会通知所有的和他关联的 job Instance： 6.1.2 ObserverInstance123456789101112131415161718192021222324252627282930313233343536373839final class ObserverInstance extends ContentObserver &#123; final JobInfo.TriggerContentUri mUri; final @UserIdInt int mUserId; // 表示的是这个数据库关联的所有的 job 实例！ final ArraySet&lt;JobInstance&gt; mJobs = new ArraySet&lt;&gt;(); public ObserverInstance(Handler handler, JobInfo.TriggerContentUri uri, @UserIdInt int userId) &#123; super(handler); mUri = uri; mUserId = userId; &#125; @Override public void onChange(boolean selfChange, Uri uri) &#123; if (DEBUG) &#123; Slog.i(TAG,\"onChange(self=\" + selfChange + \") for \" + uri + \" when mUri=\" + mUri + \" mUserId=\" + mUserId); &#125; synchronized (mLock) &#123; final int N = mJobs.size(); // 当 uri 所指向的数据库发生变化后，他会通知所有的和他关联的 job Instance！ // 将改变的数据库的 uri 和 authority 保存到对应的 JobInstance 中！ for (int i=0; i&lt;N; i++) &#123; JobInstance inst = mJobs.valueAt(i); if (inst.mChangedUris == null) &#123; inst.mChangedUris = new ArraySet&lt;&gt;(); &#125; if (inst.mChangedUris.size() &lt; MAX_URIS_REPORTED) &#123; inst.mChangedUris.add(uri); &#125; if (inst.mChangedAuthorities == null) &#123; inst.mChangedAuthorities = new ArraySet&lt;&gt;(); &#125; inst.mChangedAuthorities.add(uri.getAuthority()); // 调用 JobStance 的 scheduleLocked 方法！ inst.scheduleLocked(); &#125; &#125; &#125;&#125; 接下来，进入到 JobInstance 中，当观察者发现数据库改变了，他最终会调用相关联的所有的 JobInstance 的 scheduleLocked 方法： 6.1.2.1 JI.scheduleLocked开始执行触发任务：1234567891011121314void scheduleLocked() &#123; if (!mTriggerPending) &#123; mTriggerPending = true; mHandler.postDelayed(mTimeoutRunner, mJobStatus.getTriggerContentMaxDelay()); &#125; mHandler.removeCallbacks(mExecuteRunner); // URIS_URGENT_THRESHOLD 表示一个 job 最大可以依赖的数据库个数！ if (mChangedUris.size() &gt;= URIS_URGENT_THRESHOLD) &#123; // If we start getting near the limit, GO NOW! mHandler.post(mExecuteRunner); &#125; else &#123; mHandler.postDelayed(mExecuteRunner, mJobStatus.getTriggerContentUpdateDelay()); &#125;&#125; mTriggerPending 默认为 fasle。用来标记：Job 触发是否正在进行！可以看出：第一次数据库改变，执行触发时，会延迟处理，延迟时间是：JobStatus.getTriggerContentMaxDelay()；如果在第一次触发还未结束，又进行了多次触发，延时处理，延时时间是：JobStatus.getTriggerContentUpdateDelay()；如果这个 job 依赖的数据库 uri 的个数到达的最大限制，就立刻触发，优先处理资源紧缺的 job 触发！ 这里会在主线程执行 mTimeoutRunner 和 mExecuteRunner，mExecuteRunner 是 TriggerRunnable 对象：12345678910static final class TriggerRunnable implements Runnable &#123; final JobInstance mInstance; TriggerRunnable(JobInstance instance) &#123; mInstance = instance; &#125; @Override public void run() &#123; // 执行 JobInstance 的 trigger 方法！ mInstance.trigger(); &#125;&#125; 我们进入到 trigger 方法中，去看看： 6.1.2.2 JI.trigger这个方法就是最终的通知改变的方法：1234567891011121314151617void trigger() &#123; boolean reportChange = false; synchronized (mLock) &#123; if (mTriggerPending) &#123; // 判断是否需要改变 job 状态 if (mJobStatus.setContentTriggerConstraintSatisfied(true)) &#123; reportChange = true; &#125; unscheduleLocked(); // 结束本次执行操作！ &#125; &#125; // Let the scheduler know that state has changed. This may or may not result in an // execution. if (reportChange) &#123; // 当 reportChange 为 true 后，就通知 JobScheduler！ mStateChangedListener.onControllerStateChanged(); &#125;&#125; 再来看看 unscheduleLocked 方法，本次执行结束，取消任务，标记位置 mTriggerPending 置为 false！1234567void unscheduleLocked() &#123; if (mTriggerPending) &#123; mHandler.removeCallbacks(mExecuteRunner); mHandler.removeCallbacks(mTimeoutRunner); mTriggerPending = false; &#125;&#125; 这里逻辑已经很清楚了，就不多说了！ 6.2 maybeStopTrackingJobLocked接下来，我们来看看停止监视相关的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic void maybeStopTrackingJobLocked(JobStatus taskStatus, JobStatus incomingJob, boolean forUpdate) &#123; if (taskStatus.hasContentTriggerConstraint()) &#123; if (taskStatus.contentObserverJobInstance != null) &#123; // 停止相应的 jobInstance 的执行 taskStatus.contentObserverJobInstance.unscheduleLocked(); if (incomingJob != null) &#123; // 如果是有相同 userId 和 jobId 的新 job。即 incomingJob 不为 null！ if (taskStatus.contentObserverJobInstance != null &amp;&amp; taskStatus.contentObserverJobInstance.mChangedAuthorities != null) &#123; // We are stopping this job, but it is going to be replaced by this given // incoming job. We want to propagate our state over to it, so we don't // lose any content changes that had happend since the last one started. // If there is a previous job associated with the new job, propagate over // any pending content URI trigger reports. if (incomingJob.contentObserverJobInstance == null) &#123; // 给新 job 创建对应的 jobInstance incomingJob.contentObserverJobInstance = new JobInstance(incomingJob); &#125; // 用旧的 jobInstance 来初始化新的 JobInstance 的 uris/authorities incomingJob.contentObserverJobInstance.mChangedAuthorities = taskStatus.contentObserverJobInstance.mChangedAuthorities; incomingJob.contentObserverJobInstance.mChangedUris = taskStatus.contentObserverJobInstance.mChangedUris; // 清空旧得 jobInstance 的 uris/authorities taskStatus.contentObserverJobInstance.mChangedAuthorities = null; taskStatus.contentObserverJobInstance.mChangedUris = null; &#125; // We won't detach the content observers here, because we want to // allow them to continue monitoring so we don't miss anything... and // since we are giving an incomingJob here, we know this will be // immediately followed by a start tracking of that job. &#125; else &#123; // But here there is no incomingJob, so nothing coming up, so time to detach. taskStatus.contentObserverJobInstance.detachLocked(); taskStatus.contentObserverJobInstance = null; &#125; &#125; if (DEBUG) &#123; Slog.i(TAG, \"No longer tracking job \" + taskStatus); &#125; // 从监视队列中删除这个 job！ mTrackedTasks.remove(taskStatus); &#125; 这段代码的逻辑很简单： 如果 incomingJob 不为 null，说明有新任务会取代旧任务！ 如果 incomingJob 为 null，说明是取消当前的这个任务！ 这里调用了 JobInstance 的 detachLocked 方法： 6.2.1 JI.detachLocked遍历 JobInstance 所依赖的所有观察者，解除依赖；取消依赖为 0 的观察者的注册；从 ContentObserverController 的缓存中删除这个观察者！123456789101112131415161718192021222324void detachLocked() &#123; final int N = mMyObservers.size(); for (int i=0; i&lt;N; i++) &#123; // 从这个 jobInstance 相关联的所有 ObserverInstance 移除对自身的关联！ final ObserverInstance obs = mMyObservers.get(i); obs.mJobs.remove(this); // 如果这个观察者依赖的 JobInstance 为 0！ if (obs.mJobs.size() == 0) &#123; if (DEBUG) &#123; Slog.i(TAG, \"Unregistering observer \" + obs + \" for \" + obs.mUri.getUri()); &#125; // 取消这个观察者的注册 mContext.getContentResolver().unregisterContentObserver(obs); ArrayMap&lt;JobInfo.TriggerContentUri, ObserverInstance&gt; observerOfUser = mObservers.get(obs.mUserId); if (observerOfUser != null) &#123; // 并将这个观测者从 ContentObserverController 的缓存中删除！ observerOfUser.remove(obs.mUri); &#125; &#125; &#125;&#125; 不多说了！ 6.3 prepareForExecutionLocked这个是执行 job 前的准备操作！123456789101112@Overridepublic void prepareForExecutionLocked(JobStatus taskStatus) &#123; if (taskStatus.hasContentTriggerConstraint()) &#123; if (taskStatus.contentObserverJobInstance != null) &#123; taskStatus.changedUris = taskStatus.contentObserverJobInstance.mChangedUris; taskStatus.changedAuthorities = taskStatus.contentObserverJobInstance.mChangedAuthorities; taskStatus.contentObserverJobInstance.mChangedUris = null; taskStatus.contentObserverJobInstance.mChangedAuthorities = null; &#125; &#125;&#125; 这个很简单吧，不说了！ 7 DeviceIdleJobsController这个是 Doze 模式的控制器，我们先来看看构造器：1234567891011121314151617181920private DeviceIdleJobsController(JobSchedulerService jobSchedulerService, Context context, Object lock) &#123; super(jobSchedulerService, context, lock); mJobSchedulerService = jobSchedulerService; // 获得 PowerManagerService 对象！ mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE); // 获得 DOZE 模式的 DeviceIdleController 服务对象！ mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class); // 这里注册了一个广播接收者！ final IntentFilter filter = new IntentFilter(); filter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED); filter.addAction(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED); filter.addAction(PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED); mContext.registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, filter, null, null);&#125; 注册了一个广播接收者，来接受这三个广播： PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED； PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED； PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED； 7.1 BroadcastReceiver我们来看看这里注册的这个广播接收者：1234567891011121314151617181920private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); // 设备 idle 状态改变的广播 if (PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED.equals(action) || PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(action)) &#123; updateIdleMode(mPowerManager != null ? (mPowerManager.isDeviceIdleMode() || mPowerManager.isLightDeviceIdleMode()) : false); // doze 模式白名单改变的广播 &#125; else if (PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED.equals(action)) &#123; updateWhitelist(); &#125; &#125;&#125;; 这里在接收到指定的广播后，会调用指定的方法，我们一个一个看：1234567891011121314// 更新 doze 模式的白名单！void updateWhitelist() &#123; synchronized (mLock) &#123; if (mLocalDeviceIdleController != null) &#123; // 将最新的白名单保存到 mDeviceIdleWhitelistAppIds 数组中！ mDeviceIdleWhitelistAppIds = mLocalDeviceIdleController.getPowerSaveWhitelistUserAppIds(); if (LOG_DEBUG) &#123; Slog.d(LOG_TAG, \"Got whitelist \" + Arrays.toString(mDeviceIdleWhitelistAppIds)); &#125; &#125; &#125;&#125; 这个方法很简单，更新 mDeviceIdleWhitelistAppIds 白名单数组！ 接着来看 updateIdleMode 方法，当受到设备状态改变的广播后，需要通知 JSS：1234567891011121314151617181920212223void updateIdleMode(boolean enabled) &#123; boolean changed = false; // Need the whitelist to be ready when going into idle if (mDeviceIdleWhitelistAppIds == null) &#123; // 如果白名单为 null，就先去更新 doze 白名单！ updateWhitelist(); &#125; synchronized (mLock) &#123; if (mDeviceIdleMode != enabled) &#123; // 如果这次的状态和上一次不一样，那就要触发 job！ changed = true; // changed 置为 true &#125; mDeviceIdleMode = enabled; if (LOG_DEBUG) Slog.d(LOG_TAG, \"mDeviceIdleMode=\" + mDeviceIdleMode); mJobSchedulerService.getJobStore().forEachJob(mUpdateFunctor); // 更新 job 的状态！ &#125; // Inform the job scheduler service about idle mode changes if (changed) &#123; mStateChangedListener.onDeviceIdleStateChanged(enabled); // 回调通知 jobScheduler，设备状态改变了！ &#125;&#125; 这里会执行一个 JobStatusFunctor 的操作：1234567final JobStore.JobStatusFunctor mUpdateFunctor = new JobStore.JobStatusFunctor() &#123; // 对 JobStore 中的每个 job 执行 process 操作！ @Override public void process(JobStatus jobStatus) &#123; updateTaskStateLocked(jobStatus); &#125;&#125;; 接着来看：1234567891011private void updateTaskStateLocked(JobStatus task) &#123; // 判断这个 job 的 uid 是否在 doze 模式的白名单中！ final boolean whitelisted = isWhitelistedLocked(task); // 是否满足 doze 模式的约束条件 final boolean enableTask = !mDeviceIdleMode || whitelisted; // 更新 job 的状态！ task.setDeviceNotDozingConstraintSatisfied(enableTask, whitelisted);&#125; 这里最后会调用：setDeviceNotDozingConstraintSatisfied 方法！ 8 附录8.1 JobStatus.setConstraintSatisfied在 JobStatus 中，有着两个变量： 123// Constraints.final int requiredConstraints;int satisfiedConstraints = 0; 这里解释一下： requiredConstraints：这是一个 final 类型的变量，是在 JobInfo 创建的时候，设置的所有的约束条件，一旦设置，就不可变了！ satisfiedConstraints：它的每个二进制位是可变的，用来动态记录 job 的约束条件是否发生了变化！ 在上面，我们看到，每个控制器都有调用这样的方法，这个方法，很有意思，我们看一下，参数传递： int constraint：某一个约束条件！ boolean state：这一次是否满足条件！ 123456789101112boolean setConstraintSatisfied(int constraint, boolean state) &#123; // 判断上一次是否满足约束条件！ boolean old = (satisfiedConstraints&amp;constraint) != 0; // 如果相等，说明约束条件没有变化，无需改变 job 的状态，返回 false！ if (old == state) &#123; return false; &#125; // 如果不相等，说明约束条件变化了，那就要返回 true！ // 并根据 state 的值来修改 satisfiedConstraints 的 constraint 位！ satisfiedConstraints = (satisfiedConstraints&amp;~constraint) | (state ? constraint : 0); return true;&#125; 返回值说明： 返回 false：说明约束条件保持不变，无需修改 satisfiedConstraints 的指定二进制位！ 返回 true：说明约束条件发生了变化，可能是从满足变为不满足，也可能是从不满足变为满足，最终的状态动态记录在 satisfiedConstraints 中！ 注意：satisfiedConstraints&amp;~constraint 的作用是：将 constraint 位置为 0！(satisfiedConstraints&amp;~constraint) | (state ? constraint : 0) 的作用是：根据 state 的值，将 satisfiedConstraints 的二进制位 constraint 置为 1/0； 8.1 JobStatus.isConstraintSatisfied这个方法的作用很简单，判断此时 jobStatus 是否满足指定条件：123boolean isConstraintSatisfied(int constraint) &#123; return (satisfiedConstraints&amp;constraint) != 0;&#125; 8.3 JobSchedulerService前面可以看到，每个控制器，最后都调用了 JSS 的如下方法： ConnectivityController： onControllerStateChanged、onRunJobNow TimeController： onControllerStateChanged、onRunJobNow IdleController： onControllerStateChanged BatteryController： onControllerStateChanged、onRunJobNow AppIdleController： onControllerStateChanged ContentObserverController： onControllerStateChanged DeviceIdleJobsController： onDeviceIdleStateChanged 接下来，我们看下这几个方法：123456789@Overridepublic void onControllerStateChanged() &#123;// 控制器状态变化， mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget();&#125;@Overridepublic void onRunJobNow(JobStatus jobStatus) &#123; mHandler.obtainMessage(MSG_JOB_EXPIRED, jobStatus).sendToTarget();&#125; 这两个方法很简单，区别在于： MSG_CHECK_JOB：让 JobSchedulerService 去，遍历 JobStore 执行相应的 job！ MSG_JOB_EXPIRED：立刻执行这个 job！ 接着： 123456789101112131415161718192021222324252627282930@Overridepublic void onDeviceIdleStateChanged(boolean deviceIdle) &#123; synchronized (mLock) &#123; if (deviceIdle) &#123; // When becoming idle, make sure no jobs are actively running, // except those using the idle exemption flag. for (int i=0; i&lt;mActiveServices.size(); i++) &#123; JobServiceContext jsc = mActiveServices.get(i); final JobStatus executing = jsc.getRunningJob(); if (executing != null &amp;&amp; (executing.getFlags() &amp; JobInfo.FLAG_WILL_BE_FOREGROUND) == 0) &#123; jsc.cancelExecutingJob(JobParameters.REASON_DEVICE_IDLE); // 取消执行 job &#125; &#125; &#125; else &#123; // When coming out of idle, allow thing to start back up. if (mReadyToRock) &#123; if (mLocalDeviceIdleController != null) &#123; if (!mReportedActive) &#123; mReportedActive = true; mLocalDeviceIdleController.setJobsActive(true); &#125; &#125; &#125; mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget(); &#125; &#125;&#125; 先到这里吧！ 8.3 Controller 和对应的条件我们来总结一下，Controller 和其对应的约束条件：","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"JobScheduler第 5 篇 - JobSchedulerService - jobFinished","slug":"JobScheduler5-JobSchedulerService-jobFinished","date":"2016-04-23T12:46:25.000Z","updated":"2018-11-20T15:58:45.000Z","comments":true,"path":"2016/04/23/JobScheduler5-JobSchedulerService-jobFinished/","link":"","permalink":"https://coolqi.top/2016/04/23/JobScheduler5-JobSchedulerService-jobFinished/","excerpt":"","text":"基于 Android 7.1.1 源码分析 前言当任务完成时，应用需要手动调用 jobFinished 方法，这个方法是属于 JobService 的：123456public final void jobFinished(JobParameters params, boolean needsReschedule) &#123; ensureHandler(); Message m = Message.obtain(mHandler, MSG_JOB_FINISHED, params); m.arg2 = needsReschedule ? 1 : 0; m.sendToTarget();&#125; 其实，参数很简单，这个消息 MSG_JOB_FINISHED 会发送到 JobHandler 中！ 1 JS.JobHandler进入 JobHandler 中来看看：1234567891011121314151617181920212223242526272829303132class JobHandler extends Handler &#123; JobHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; final JobParameters params = (JobParameters) msg.obj; switch (msg.what) &#123; ... ... ... ... case MSG_JOB_FINISHED: final boolean needsReschedule = (msg.arg2 == 1); // callback 是 JobServiceContext IJobCallback callback = params.getCallback(); if (callback != null) &#123; try &#123; callback.jobFinished(params.getJobId(), needsReschedule); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"Error reporting job finish to system: binder has gone\" + \" away.\"); &#125; &#125; else &#123; Log.e(TAG, \"finishJob() called for a nonexistent job id.\"); &#125; break; default: Log.e(TAG, \"Unrecognised message received.\"); break; &#125; &#125;&#125; 这里调用了 JObServiceContext 的 jobFinished 方法！ 2 JSC.jobFinished我们来看看 JobServiceContext 的 jobFinished 方法：123456789@Overridepublic void jobFinished(int jobId, boolean reschedule) &#123; if (!verifyCallingUid()) &#123; return; &#125; mCallbackHandler.obtainMessage(MSG_CALLBACK, jobId, reschedule ? 1 : 0) .sendToTarget();&#125; 这里先调用了 JobServiceContext 的 verifyCallingUid，校验 uid！1234567891011private boolean verifyCallingUid() &#123; synchronized (mLock) &#123; if (mRunningJob == null || Binder.getCallingUid() != mRunningJob.getUid()) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Stale callback received, ignoring.\"); &#125; return false; &#125; return true; &#125;&#125; 接着发送了一个 MSG_CALLBACK 的消息给了 JobServiceHandler！ 3 JSC.JobServiceHandler接着进入了 JobServiceHandler，来看主要代码：12345678910111213141516171819case MSG_CALLBACK: if (DEBUG) &#123; Slog.d(TAG, \"MSG_CALLBACK of : \" + mRunningJob + \" v:\" + VERB_STRINGS[mVerb]); &#125; removeOpTimeOut(); if (mVerb == VERB_STARTING) &#123; final boolean workOngoing = message.arg2 == 1; handleStartedH(workOngoing); &#125; else if (mVerb == VERB_EXECUTING || // 此时 mVerb 的状态为 VERB_EXECUTING mVerb == VERB_STOPPING) &#123; final boolean reschedule = message.arg2 == 1; handleFinishedH(reschedule); &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"Unrecognised callback: \" + mRunningJob); &#125; &#125; break; 调用了 handleFinishedH：1234567891011private void handleFinishedH(boolean reschedule) &#123; switch (mVerb) &#123; case VERB_EXECUTING: case VERB_STOPPING: closeAndCleanupJobH(reschedule); break; default: Slog.e(TAG, \"Got an execution complete message for a job that wasn't being\" + \"executed. Was \" + VERB_STRINGS[mVerb] + \".\"); &#125;&#125; 这里就很简单了，调用了 closeAndCleanupJobH 来解除 bind 和将 JObServiceContext 恢复初始化，为下一次 bind 做准备！12345678910111213141516171819202122232425262728293031323334353637 private void closeAndCleanupJobH(boolean reschedule) &#123; final JobStatus completedJob; synchronized (mLock) &#123; if (mVerb == VERB_FINISHED) &#123; return; &#125; completedJob = mRunningJob; mJobPackageTracker.noteInactive(completedJob); try &#123; mBatteryStats.noteJobFinish(mRunningJob.getBatteryName(), mRunningJob.getSourceUid()); &#125; catch (RemoteException e) &#123; // Whatever. &#125; if (mWakeLock != null) &#123; mWakeLock.release(); &#125; mContext.unbindService(JobServiceContext.this); mWakeLock = null; mRunningJob = null; mParams = null; mVerb = VERB_FINISHED; // 状态变为 VERB_FINISHED mCancelled.set(false); service = null; mAvailable = true; &#125; removeOpTimeOut(); removeMessages(MSG_CALLBACK); removeMessages(MSG_SERVICE_BOUND); removeMessages(MSG_CANCEL); removeMessages(MSG_SHUTDOWN_EXECUTION); // 通知 JobSchedulerService，这个 job 已经 finished 了 mCompletedListener.onJobCompleted(completedJob, reschedule); &#125;&#125; 接着，进入了 JobSchedulerService 方法中： 4 JSS.onJobCompleted调用了 onJobCompleted 方法；12345678910111213141516171819202122232425262728293031323334@Overridepublic void onJobCompleted(JobStatus jobStatus, boolean needsReschedule) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Completed \" + jobStatus + \", reschedule=\" + needsReschedule); &#125; // 停止 track job，会将 job 从 JobStore 中删除，如果不是周期性的 job，还要更新本地的 jobs.xml 文件！ if (!stopTrackingJob(jobStatus, null, !jobStatus.getJob().isPeriodic())) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Could not find job to remove. Was job removed while executing?\"); &#125; // 停止失败，说明 job 之前已经被移除，继续发起下一轮的执行！ mHandler.obtainMessage(MSG_CHECK_JOB_GREEDY).sendToTarget(); return; &#125; // 停止成功 if (needsReschedule) &#123;// 需要 reschedule 这个 job，如果需要，就 startTrackingJob JobStatus rescheduled = getRescheduleJobForFailure(jobStatus); startTrackingJob(rescheduled, jobStatus); &#125; else if (jobStatus.getJob().isPeriodic()) &#123; // 如果不需要 reschedule，但是这个 job 是周期性的，也要 startTrackingJob JobStatus rescheduledPeriodic = getRescheduleJobForPeriodic(jobStatus); startTrackingJob(rescheduledPeriodic, jobStatus); &#125; // 汇报 JSS 运行状态给 DeviceIdleController！ reportActive(); // 继续开始新一轮的 job 执行！ mHandler.obtainMessage(MSG_CHECK_JOB_GREEDY).sendToTarget();&#125; 4.1 JSS.getRescheduleJobForFailure这里调用了 getRescheduleJobForPeriodic 的方法：1234567891011121314151617181920212223242526272829303132333435363738private JobStatus getRescheduleJobForFailure(JobStatus failureToReschedule) &#123; // 获得自开机后，经过的时间，包括深度睡眠的时间; final long elapsedNowMillis = SystemClock.elapsedRealtime(); // 获得这个 jobFinished 的 jobStatus 对应的 JobInfo; final JobInfo job = failureToReschedule.getJob(); final long initialBackoffMillis = job.getInitialBackoffMillis(); final int backoffAttempts = failureToReschedule.getNumFailures() + 1; long delayMillis; switch (job.getBackoffPolicy()) &#123; case JobInfo.BACKOFF_POLICY_LINEAR: delayMillis = initialBackoffMillis * backoffAttempts; break; case JobInfo.BACKOFF_POLICY_EXPONENTIAL: delayMillis = (long) Math.scalb(initialBackoffMillis, backoffAttempts - 1); break; default: if (DEBUG) &#123; Slog.v(TAG, \"Unrecognised back-off policy, defaulting to exponential.\"); &#125; &#125; delayMillis = Math.min(delayMillis, JobInfo.MAX_BACKOFF_DELAY_MILLIS); JobStatus newJob = new JobStatus(failureToReschedule, elapsedNowMillis + delayMillis, JobStatus.NO_LATEST_RUNTIME, backoffAttempts); for (int ic=0; ic&lt;mControllers.size(); ic++) &#123; StateController controller = mControllers.get(ic); controller.rescheduleForFailure(newJob, failureToReschedule); &#125; return newJob;&#125; 4.2 JSS.getRescheduleJobForPeriodic123456789101112131415161718192021private JobStatus getRescheduleJobForPeriodic(JobStatus periodicToReschedule) &#123; final long elapsedNow = SystemClock.elapsedRealtime(); // Compute how much of the period is remaining. long runEarly = 0L; // If this periodic was rescheduled it won't have a deadline. if (periodicToReschedule.hasDeadlineConstraint()) &#123; runEarly = Math.max(periodicToReschedule.getLatestRunTimeElapsed() - elapsedNow, 0L); &#125; long flex = periodicToReschedule.getJob().getFlexMillis(); long period = periodicToReschedule.getJob().getIntervalMillis(); long newLatestRuntimeElapsed = elapsedNow + runEarly + period; long newEarliestRunTimeElapsed = newLatestRuntimeElapsed - flex; if (DEBUG) &#123; Slog.v(TAG, \"Rescheduling executed periodic. New execution window [\" + newEarliestRunTimeElapsed/1000 + \", \" + newLatestRuntimeElapsed/1000 + \"]s\"); &#125; return new JobStatus(periodicToReschedule, newEarliestRunTimeElapsed, newLatestRuntimeElapsed, 0 /* backoffAttempt */);&#125;","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"JobScheduler第 4 篇 - JobSchedulerService - cancel","slug":"JobScheduler4-JobSchedulerService-cancel","date":"2016-04-21T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/04/21/JobScheduler4-JobSchedulerService-cancel/","link":"","permalink":"https://coolqi.top/2016/04/21/JobScheduler4-JobSchedulerService-cancel/","excerpt":"","text":"基于 Android 7.1.1 源码分析 前提接下来，我们来看看 JobServiceService 服务中和 cancel 相关的服务：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 取消指定设备用户的所有的 job！void cancelJobsForUser(int userHandle) &#123; List&lt;JobStatus&gt; jobsForUser; synchronized (mLock) &#123; jobsForUser = mJobs.getJobsByUser(userHandle); &#125; for (int i=0; i&lt;jobsForUser.size(); i++) &#123; JobStatus toRemove = jobsForUser.get(i); cancelJobImpl(toRemove, null); &#125;&#125;// 取消指定 package 和指定 uid 的所有的 job！void cancelJobsForPackageAndUid(String pkgName, int uid) &#123; List&lt;JobStatus&gt; jobsForUid; synchronized (mLock) &#123; jobsForUid = mJobs.getJobsByUid(uid); &#125; for (int i = jobsForUid.size() - 1; i &gt;= 0; i--) &#123; final JobStatus job = jobsForUid.get(i); if (job.getSourcePackageName().equals(pkgName)) &#123; cancelJobImpl(job, null); &#125; &#125;&#125;// 取消指定 uid 的应用程序的所有的 job！public void cancelJobsForUid(int uid, boolean forceAll) &#123; List&lt;JobStatus&gt; jobsForUid; synchronized (mLock) &#123; jobsForUid = mJobs.getJobsByUid(uid); &#125; for (int i=0; i&lt;jobsForUid.size(); i++) &#123; JobStatus toRemove = jobsForUid.get(i); if (!forceAll) &#123; String packageName = toRemove.getServiceComponent().getPackageName(); try &#123; if (ActivityManagerNative.getDefault().getAppStartMode(uid, packageName) != ActivityManager.APP_START_MODE_DISABLED) &#123; continue; &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; cancelJobImpl(toRemove, null); &#125;&#125;// 取消指定 uid 的应用程序的 id 为 jobId 的 job！public void cancelJob(int uid, int jobId) &#123; JobStatus toCancel; synchronized (mLock) &#123; toCancel = mJobs.getJobByUidAndJobId(uid, jobId); &#125; if (toCancel != null) &#123; cancelJobImpl(toCancel, null); &#125;&#125; JobSchedulerService 提供了很多个接口来取消 job，但是他们都疯了似的调用了同一个方法，我们来继续看！ 1 JSS.cancelJobImpl同一个取消接口：12345678910111213141516private void cancelJobImpl(JobStatus cancelled, JobStatus incomingJob) &#123; if (DEBUG) Slog.d(TAG, \"CANCEL: \" + cancelled.toShortString()); // 停止监视这个 job，writeBack 为 true! stopTrackingJob(cancelled, incomingJob, true /* writeBack */); synchronized (mLock) &#123; // Remove from pending queue. // 从 mPendingJobs 中移除！ if (mPendingJobs.remove(cancelled)) &#123; mJobPackageTracker.noteNonpending(cancelled); &#125; // Cancel if running. // 如果正在运行，就要停止这个 job stopJobOnServiceContextLocked(cancelled, JobParameters.REASON_CANCELED); reportActive(); &#125;&#125; 这里我们一个一个来看： 1.1 JSS.stopTrackingJob停止 stopTrackingJob 如下：12345678910111213141516private boolean stopTrackingJob(JobStatus jobStatus, JobStatus incomingJob, boolean writeBack) &#123; synchronized (mLock) &#123; // Remove from store as well as controllers. // 先从 JobStore 中移除这个 job，因为 writeBack 为 true，则需要更新 jobxs.xml 文件！ final boolean removed = mJobs.remove(jobStatus, writeBack); if (removed &amp;&amp; mReadyToRock) &#123; for (int i=0; i&lt;mControllers.size(); i++) &#123; // 通知控制器，取消 track！ StateController controller = mControllers.get(i); controller.maybeStopTrackingJobLocked(jobStatus, incomingJob, false); &#125; &#125; return removed; &#125;&#125; 先从 JobStore 中移除这个 job，因为 writeBack 为 true，则需要更新 jobxs.xml 文件，通知控制器，取消 track！ 1.2 JSS.stopJobOnServiceContextLocked如果这个 job 是在运行中，就要取消它！1234567891011private boolean stopJobOnServiceContextLocked(JobStatus job, int reason) &#123; for (int i=0; i&lt;mActiveServices.size(); i++) &#123; JobServiceContext jsc = mActiveServices.get(i); final JobStatus executing = jsc.getRunningJob(); if (executing != null &amp;&amp; executing.matches(job.getUid(), job.getJobId())) &#123; jsc.cancelExecutingJob(reason); return true; &#125; &#125; return false;&#125; 每一个运行着的 job，都是和一个 JobServiceContext 绑定着的，这里是遍历所有的 JobServiceContext，找到要 cancel 的 job，调用 jobServiceContext 的 cancelExecutingJob 方法： 1.2.1 JSC.cancelExecutingJob这个方法很简单，发送了 MSG_CANCEL 消息给 JobServiceHandler，reason 为 JobParameters.REASON_CANCELED123void cancelExecutingJob(int reason) &#123; mCallbackHandler.obtainMessage(MSG_CANCEL, reason, 0 /* unused */).sendToTarget();&#125; 我们继续看，进入 JobServiceHandler： 1.2.2 JSH.MSG_CANCELJobServiceHander 会处理 MSG_CANCEL 消息！1234567891011121314151617181920212223242526272829303132333435363738private class JobServiceHandler extends Handler &#123; JobServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message message) &#123; ... ... ... ... case MSG_CANCEL: // 接受到了 MSG_CANCEL. if (mVerb == VERB_FINISHED) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Trying to process cancel for torn-down context, ignoring.\"); &#125; return; &#125; mParams.setStopReason(message.arg1); // reason 为 JobParameters.REASON_CANCELED if (message.arg1 == JobParameters.REASON_PREEMPT) &#123; // 不进入，因为这不是优先级取代！ mPreferredUid = mRunningJob != null ? mRunningJob.getUid() : NO_PREFERRED_UID; &#125; handleCancelH(); break; case MSG_TIMEOUT: handleOpTimeoutH(); break; case MSG_SHUTDOWN_EXECUTION: closeAndCleanupJobH(true /* needsReschedule */); break; default: Slog.e(TAG, \"Unrecognised message: \" + message); &#125; &#125; ... ... ... ... ...&#125; 调用 handleCancelH 方法来取消 Job： 1.2.3 JSH.handleCancelH1234567891011121314151617181920212223242526272829303132333435/** * A job can be in various states when a cancel request comes in: * VERB_BINDING -&gt; Cancelled before bind completed. Mark as cancelled and wait for * &#123;@link #onServiceConnected(android.content.ComponentName, android.os.IBinder)&#125; * _STARTING -&gt; Mark as cancelled and wait for * &#123;@link JobServiceContext#acknowledgeStartMessage(int, boolean)&#125; * _EXECUTING -&gt; call &#123;@link #sendStopMessageH&#125;&#125;, but only if there are no callbacks * in the message queue. * _ENDING -&gt; No point in doing anything here, so we ignore. */ private void handleCancelH() &#123; if (JobSchedulerService.DEBUG) &#123; Slog.d(TAG, \"Handling cancel for: \" + mRunningJob.getJobId() + \" \" + VERB_STRINGS[mVerb]); &#125; switch (mVerb) &#123; case VERB_BINDING: // 如果 job 的状态是 VERB_BINDING 或者 VERB_STARTING，直接将 mCancelled 置为 true ! case VERB_STARTING: mCancelled.set(true); break; case VERB_EXECUTING: // 如果 job 的状态是 VERB_EXECUTING， if (hasMessages(MSG_CALLBACK)) &#123; // 判断客户端是否已经调用过 jobFinished 方法，有直接 return! // If the client has called jobFinished, ignore this cancel. return; &#125; sendStopMessageH(); // break; case VERB_STOPPING: // Nada. break; default: Slog.e(TAG, \"Cancelling a job without a valid verb: \" + mVerb); break; &#125; &#125; 我们来看看 sendStopMessageH 方法： 1.2.4 JSH.sendStopMessageH1234567891011121314151617181920/** * Already running, need to stop. Will switch &#123;@link #mVerb&#125; from VERB_EXECUTING -&gt; * VERB_STOPPING. */private void sendStopMessageH() &#123; removeOpTimeOut(); if (mVerb != VERB_EXECUTING) &#123; // 如果 job 的状态已经不是 VERB_EXECUTING，那就清除资源，恢复初始化! Slog.e(TAG, \"Sending onStopJob for a job that isn't started. \" + mRunningJob); closeAndCleanupJobH(false /* reschedule */); return; &#125; try &#123; mVerb = VERB_STOPPING; // 否则，job 状态设置为 VERB_STOPPING， scheduleOpTimeOut(); service.stopJob(mParams); // 调用 jobService 的 stopJob，停止服务! &#125; catch (RemoteException e) &#123; Slog.e(TAG, \"Error sending onStopJob to client.\", e); closeAndCleanupJobH(false /* reschedule */); &#125;&#125; 这里会根据 mVerb 中存储的 job 的动作状态，来做相应的处理：如果 job 的状态已经不是 VERB_EXECUTING，那就清除资源，恢复初始化；否则，job 状态设置为 VERB_STOPPING，调用 jobService 的 stopJob，停止服务! 1.2.4.1 JobService.stopJob通过 Binder 机制，停止 job：1234567891011121314151617181920212223242526272829303132public abstract class JobService extends Service &#123; ... ... ... ... private static final String TAG = \"JobService\"; static final class JobInterface extends IJobService.Stub &#123; final WeakReference&lt;JobService&gt; mService; JobInterface(JobService service) &#123; mService = new WeakReference&lt;&gt;(service); &#125; @Override public void startJob(JobParameters jobParams) throws RemoteException &#123; JobService service = mService.get(); if (service != null) &#123; service.ensureHandler(); Message m = Message.obtain(service.mHandler, MSG_EXECUTE_JOB, jobParams); m.sendToTarget(); &#125; &#125; @Override public void stopJob(JobParameters jobParams) throws RemoteException &#123; JobService service = mService.get(); if (service != null) &#123; service.ensureHandler(); // 确保 Handler 已经创建 Message m = Message.obtain(service.mHandler, MSG_STOP_JOB, jobParams); // 发送 MSG_STOP_JOB 到 JobHandler！ m.sendToTarget(); &#125; &#125; &#125; ... ... ... ...&#125; 进入 JobHandler 方法： 1.2.4.2 JobService.JobHandler处理前面通过 Binder 发送过来的 MSG_STOP_JOB：123456789101112131415161718192021222324252627282930313233343536373839404142434445class JobHandler extends Handler &#123; JobHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; final JobParameters params = (JobParameters) msg.obj; switch (msg.what) &#123; ... ... ... ... case MSG_STOP_JOB: try &#123; // 这里是获得 JobService 的 onStopJob 的返回值! boolean ret = JobService.this.onStopJob(params); ackStopMessage(params, ret); &#125; catch (Exception e) &#123; Log.e(TAG, \"Application unable to handle onStopJob.\", e); throw new RuntimeException(e); &#125; break; ... ... ... ... default: Log.e(TAG, \"Unrecognised message received.\"); break; &#125; &#125; ... ... ... ... private void ackStopMessage(JobParameters params, boolean reschedule) &#123; final IJobCallback callback = params.getCallback(); final int jobId = params.getJobId(); if (callback != null) &#123; try &#123; // 将被停止的 job 的 id 和 onStopJob 的返回值发给 JobServiceContext！ callback.acknowledgeStopMessage(jobId, reschedule); &#125; catch(RemoteException e) &#123; Log.e(TAG, \"System unreachable for stopping job.\"); &#125; &#125; else &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"Attempting to ack a job that has already been processed.\"); &#125; &#125; &#125;&#125; JobService 的 onStopJob 的返回值如果为 true，那么，就表示 JobService 需要重新拉起他！前面我们分析的时候，知道，callback 就是 JobServiceContext 1.2.4.3 JSC.acknowledgeStopMessage接着发送 MSG_CALLBACK 给 JobServiceHandler：12345678@Overridepublic void acknowledgeStopMessage(int jobId, boolean reschedule) &#123; if (!verifyCallingUid()) &#123; return; &#125; mCallbackHandler.obtainMessage(MSG_CALLBACK, jobId, reschedule ? 1 : 0) .sendToTarget();&#125; 我们进入 JobServiceHandler 方法里面看看： 1.2.4.4 JSC.JobServiceHandler12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private class JobServiceHandler extends Handler &#123; @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; ... ... ... ... case MSG_CALLBACK: if (DEBUG) &#123; Slog.d(TAG, \"MSG_CALLBACK of : \" + mRunningJob + \" v:\" + VERB_STRINGS[mVerb]); &#125; removeOpTimeOut(); if (mVerb == VERB_STARTING) &#123; final boolean workOngoing = message.arg2 == 1; handleStartedH(workOngoing); &#125; else if (mVerb == VERB_EXECUTING || mVerb == VERB_STOPPING) &#123; // 进入这里！ final boolean reschedule = message.arg2 == 1; handleFinishedH(reschedule); &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"Unrecognised callback: \" + mRunningJob); &#125; &#125; break; ... ... ... ... default: Slog.e(TAG, \"Unrecognised message: \" + message); &#125; &#125; ... ... ... ... /** * VERB_EXECUTING -&gt; Client called jobFinished(), clean up and notify done. * _STOPPING -&gt; Successful finish, clean up and notify done. * _STARTING -&gt; Error * _PENDING -&gt; Error */ private void handleFinishedH(boolean reschedule) &#123; switch (mVerb) &#123; case VERB_EXECUTING: case VERB_STOPPING: closeAndCleanupJobH(reschedule); break; default: Slog.e(TAG, \"Got an execution complete message for a job that wasn't being\" + \"executed. Was \" + VERB_STRINGS[mVerb] + \".\"); &#125; &#125; ... ... ... ...&#125; 可以看到，最后会调用 JSH 的 closeAndCleanupJobH 方法： 1.2.4.5 JSH.closeAndCleanupJobH如果 job 的状态已经不是 VERB_EXECUTING，那就清除资源，恢复初始化；这个方法很简单，就是将 JobServiceContext 中的属性值恢复初始化，表示没有任何 job 在运行！12345678910111213141516171819202122232425262728293031323334private void closeAndCleanupJobH(boolean reschedule) &#123; final JobStatus completedJob; synchronized (mLock) &#123; if (mVerb == VERB_FINISHED) &#123; return; &#125; completedJob = mRunningJob; mJobPackageTracker.noteInactive(completedJob); try &#123; mBatteryStats.noteJobFinish(mRunningJob.getBatteryName(), mRunningJob.getSourceUid()); &#125; catch (RemoteException e) &#123; // Whatever. &#125; if (mWakeLock != null) &#123; mWakeLock.release(); &#125; mContext.unbindService(JobServiceContext.this); // 取消绑定 jobSerivce mWakeLock = null; mRunningJob = null; // mRunningJob 的值置为 null! mParams = null; // JobParamters 置为 null mVerb = VERB_FINISHED; // mVerb 的状态值为 VERB_FINISHED mCancelled.set(false); // mCancelled 置为 false service = null; // 应用的 JobService 代理对象置为 null mAvailable = true; // mAvailable 置为 true，表示这个 JobService 可以分配给其他 job &#125; removeOpTimeOut(); removeMessages(MSG_CALLBACK); // 清除处理过的 MSG removeMessages(MSG_SERVICE_BOUND); removeMessages(MSG_CANCEL); removeMessages(MSG_SHUTDOWN_EXECUTION); // 回调 JobSchedulerService 的 onJobCompleted 方法! mCompletedListener.onJobCompleted(completedJob, reschedule);&#125; 恢复初始化，为下次做准备! 1.2.4.5.1 JSC.onServiceDisconnected取消绑定 JobService 会调用 onServiceDisconnected12345/** If the client service crashes we reschedule this job and clean up. */@Overridepublic void onServiceDisconnected(ComponentName name) &#123; mCallbackHandler.obtainMessage(MSG_SHUTDOWN_EXECUTION).sendToTarget();&#125; 这里的会再回到 JobServiceHandler 中：123case MSG_SHUTDOWN_EXECUTION: closeAndCleanupJobH(true /* needsReschedule */); break; 做第二次 clean，防止第一次不成功，其实第一次 clean 成功的话，mVerb 的值为 VERB_FINISHED，第二次 clean 会自动退出的！ 1.2.4.5.2 JSS.onJobCompleted我们进入 JSS 的 onJobCompleted 的方法中：1234567891011121314151617181920212223242526272829303132@Overridepublic void onJobCompleted(JobStatus jobStatus, boolean needsReschedule) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Completed \" + jobStatus + \", reschedule=\" + needsReschedule); &#125; // Do not write back immediately if this is a periodic job. The job may get lost if system // shuts down before it is added back. // 再次停止 track 这个 job，这里 stopTrackingJob 的返回值为 false！ if (!stopTrackingJob(jobStatus, null, !jobStatus.getJob().isPeriodic())) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Could not find job to remove. Was job removed while executing?\"); &#125; // We still want to check for jobs to execute, because this job may have // scheduled a new job under the same job id, and now we can run it. // 发送 MSG_CHECK_JOB_GREEDY，继续执行其他的 job，然后直接 return mHandler.obtainMessage(MSG_CHECK_JOB_GREEDY).sendToTarget(); return; &#125; // Note: there is a small window of time in here where, when rescheduling a job, // we will stop monitoring its content providers. This should be fixed by stopping // the old job after scheduling the new one, but since we have no lock held here // that may cause ordering problems if the app removes jobStatus while in here. if (needsReschedule) &#123; JobStatus rescheduled = getRescheduleJobForFailure(jobStatus); startTrackingJob(rescheduled, jobStatus); &#125; else if (jobStatus.getJob().isPeriodic()) &#123; JobStatus rescheduledPeriodic = getRescheduleJobForPeriodic(jobStatus); startTrackingJob(rescheduledPeriodic, jobStatus); &#125; reportActive(); mHandler.obtainMessage(MSG_CHECK_JOB_GREEDY).sendToTarget();&#125; 这里首先调用了 stopTrackingJob 将这个 job 从 JobStore 和 controller 中移除，因为之前已经移除过了，所以这个 stopTrackingJob 的返回值为 false1234567891011121314151617181920/** * Called when we want to remove a JobStatus object that we've finished executing. Returns the * object removed. */private boolean stopTrackingJob(JobStatus jobStatus, JobStatus incomingJob, boolean writeBack) &#123; synchronized (mLock) &#123; // Remove from store as well as controllers. // 尝试从 JobStore 中移除这个 job，注意，在之前已经移除过了，所以，这里的 removed 为 false！ final boolean removed = mJobs.remove(jobStatus, writeBack); if (removed &amp;&amp; mReadyToRock) &#123; for (int i=0; i&lt;mControllers.size(); i++) &#123; StateController controller = mControllers.get(i); // 从 Controller 的跟踪队列中移除！ controller.maybeStopTrackingJobLocked(jobStatus, incomingJob, false); &#125; &#125; return removed; &#125;&#125; 可以看出，对于用户主动 cancel 的任务，无论 onStopJob 的返回值是什么，都不会 reschedule 了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"JobScheduler第 3 篇 - JobSchedulerService - schedule","slug":"JobScheduler3-JobSchedulerService-schedule","date":"2016-04-18T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/04/18/JobScheduler3-JobSchedulerService-schedule/","link":"","permalink":"https://coolqi.top/2016/04/18/JobScheduler3-JobSchedulerService-schedule/","excerpt":"","text":"基于 Android 7.1.1 源码分析，本文为作者原创，转载请说明出处，谢谢。 前言我们先从基本的方法开始，也就是 schedule 方法，方法参数传递： JobInfo job：需要 schedule 的任务！ int uId：调用方的 uid！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public int schedule(JobInfo job, int uId) &#123; return scheduleAsPackage(job, uId, null, -1, null);&#125;public int scheduleAsPackage(JobInfo job, int uId, String packageName, int userId, String tag) &#123; // 创建新的 jobStatus JobStatus jobStatus = JobStatus.createFromJobInfo(job, uId, packageName, userId, tag); try &#123; if (ActivityManagerNative.getDefault().getAppStartMode(uId, job.getService().getPackageName()) == ActivityManager.APP_START_MODE_DISABLED) &#123; Slog.w(TAG, \"Not scheduling job \" + uId + \":\" + job.toString() + \" -- package not allowed to start\"); return JobScheduler.RESULT_FAILURE; &#125; &#125; catch (RemoteException e) &#123; &#125; if (DEBUG) Slog.d(TAG, \"SCHEDULE: \" + jobStatus.toShortString()); JobStatus toCancel; synchronized (mLock) &#123; // 判断应用设置的任务数量是否超过上限：100 if (ENFORCE_MAX_JOBS &amp;&amp; packageName == null) &#123; if (mJobs.countJobsForUid(uId) &gt; MAX_JOBS_PER_APP) &#123; Slog.w(TAG, \"Too many jobs for uid \" + uId); throw new IllegalStateException(\"Apps may not schedule more than \" + MAX_JOBS_PER_APP + \" distinct jobs\"); &#125; &#125; // 如果同一个id，之前已经注册了一个任务，取消上一个任务 toCancel = mJobs.getJobByUidAndJobId(uId, job.getId()); if (toCancel != null) &#123; cancelJobImpl(toCancel, jobStatus); &#125; // 开始追踪该任务 startTrackingJob(jobStatus, toCancel); &#125; // 向 system_server 进程的主线程发送 message：MSG_CHECK_JOB mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget(); return JobScheduler.RESULT_SUCCESS;&#125; 这里的 ENFORCE_MAX_JOBS 是一个 boolean 值，表示是否限制每个应用的 job 数！ private static final int MAX_JOBS_PER_APP = 100; 这里 MAX_JOBS_PER_APP 表示每个应用最大的 Job 数！ 这里总结一下 schedule 方法的主要流程： 根据传入的 JobInfo，创建 JobStatus； 如果已经注册过一个相同 uid，相同 jobId 的 job，就取消之前注册过的； 将新 job 加入到 JobStore 中，并通知 controller 开始监控新 schedule 的 job！ 发送 MSG_CHECK_JOB 消息给 JobHandler，执行 job！ 我们是使用 schedule 方法将我们需要的任务注册到系统中的，传入的参数主要是： JobInfo：封装任务的基本信息！ uId：调用者的 uid！ 我们接着来看，先调用 JobStatus 的 createFromJobInfo ，创建 JobStatus： 1 JobStatus.createFromJobInfo参数传递：job, uId, null, -1, null：1234567891011121314151617181920public static JobStatus createFromJobInfo(JobInfo job, int callingUid, String sourcePackageName, int sourceUserId, String tag) &#123; // 从开机到现在的时间 final long elapsedNow = SystemClock.elapsedRealtime(); final long earliestRunTimeElapsedMillis, latestRunTimeElapsedMillis; // 判断这个任务是否是周期性的 if (job.isPeriodic()) &#123; latestRunTimeElapsedMillis = elapsedNow + job.getIntervalMillis(); earliestRunTimeElapsedMillis = latestRunTimeElapsedMillis - job.getFlexMillis(); &#125; else &#123; earliestRunTimeElapsedMillis = job.hasEarlyConstraint() ? elapsedNow + job.getMinLatencyMillis() : NO_EARLIEST_RUNTIME; latestRunTimeElapsedMillis = job.hasLateConstraint() ? elapsedNow + job.getMaxExecutionDelayMillis() : NO_LATEST_RUNTIME; &#125; // 创建对应的 JobStatus 对象！ return new JobStatus(job, callingUid, sourcePackageName, sourceUserId, tag, 0, earliestRunTimeElapsedMillis, latestRunTimeElapsedMillis);&#125; 这里通过 JobInfo 创建了对应的 JobStatus 对象，参数传递：job, uId, null, -1, null，0，earliestRunTimeElapsedMillis，latestRunTimeElapsedMillis。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private JobStatus(JobInfo job, int callingUid, String sourcePackageName, int sourceUserId, String tag, int numFailures, long earliestRunTimeElapsedMillis, long latestRunTimeElapsedMillis) &#123; this.job = job; this.callingUid = callingUid; int tempSourceUid = -1; if (sourceUserId != -1 &amp;&amp; sourcePackageName != null) &#123; try &#123; tempSourceUid = AppGlobals.getPackageManager().getPackageUid(sourcePackageName, 0, sourceUserId); &#125; catch (RemoteException ex) &#123; // Can't happen, PackageManager runs in the same process. &#125; &#125; if (tempSourceUid == -1) &#123; this.sourceUid = callingUid; this.sourceUserId = UserHandle.getUserId(callingUid); this.sourcePackageName = job.getService().getPackageName(); this.sourceTag = null; &#125; else &#123; this.sourceUid = tempSourceUid; this.sourceUserId = sourceUserId; this.sourcePackageName = sourcePackageName; this.sourceTag = tag; &#125; this.batteryName = this.sourceTag != null ? this.sourceTag + \":\" + job.getService().getPackageName() : job.getService().flattenToShortString(); this.tag = \"*job*/\" + this.batteryName; this.earliestRunTimeElapsedMillis = earliestRunTimeElapsedMillis; this.latestRunTimeElapsedMillis = latestRunTimeElapsedMillis; this.numFailures = numFailures; int requiredConstraints = 0; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_ANY) &#123; requiredConstraints |= CONSTRAINT_CONNECTIVITY; &#125; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_UNMETERED) &#123; requiredConstraints |= CONSTRAINT_UNMETERED; &#125; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_NOT_ROAMING) &#123; requiredConstraints |= CONSTRAINT_NOT_ROAMING; &#125; if (job.isRequireCharging()) &#123; requiredConstraints |= CONSTRAINT_CHARGING; &#125; if (earliestRunTimeElapsedMillis != NO_EARLIEST_RUNTIME) &#123; requiredConstraints |= CONSTRAINT_TIMING_DELAY; &#125; if (latestRunTimeElapsedMillis != NO_LATEST_RUNTIME) &#123; requiredConstraints |= CONSTRAINT_DEADLINE; &#125; if (job.isRequireDeviceIdle()) &#123; requiredConstraints |= CONSTRAINT_IDLE; &#125; if (job.getTriggerContentUris() != null) &#123; requiredConstraints |= CONSTRAINT_CONTENT_TRIGGER; &#125; this.requiredConstraints = requiredConstraints;&#125; 我们后面会详细的开一篇，来讲讲这些参数的，这里先不看！ 2 JobStore.countJobsForUid这里是统计 uid 对用的应用有多少个任务：123public int countJobsForUid(int uid) &#123; return mJobSet.countJobsForUid(uid);&#125; JobStore 有一个集合，用来存放所有的 Job！ final JobSet mJobSet; 我们来看看这个 JobSet1234567891011121314151617181920212223242526static class JobSet &#123; // Key is the getUid() originator of the jobs in each sheaf // mJobs 的 key 是应用的 uid！ private SparseArray&lt;ArraySet&lt;JobStatus&gt;&gt; mJobs; public JobSet() &#123; mJobs = new SparseArray&lt;ArraySet&lt;JobStatus&gt;&gt;(); &#125; ... ... ... ... // We only want to count the jobs that this uid has scheduled on its own // behalf, not those that the app has scheduled on someone else's behalf. // 统计 uid 对应的应用注册的任务数！ public int countJobsForUid(int uid) &#123; int total = 0; ArraySet&lt;JobStatus&gt; jobs = mJobs.get(uid); if (jobs != null) &#123; for (int i = jobs.size() - 1; i &gt;= 0; i--) &#123; JobStatus job = jobs.valueAt(i); if (job.getUid() == job.getSourceUid()) &#123; total++; &#125; &#125; &#125; return total; &#125; ... ... ... ...&#125; JobSet 有很多的其他方法：getJobsByXXX，add，remove，getXXX，等等的方法，这里我们先不看！ 3 JobStore.getJobByUidAndJobId接着是根据 uid 和 jobId，来获得一个任务，这里的目的是判断是否之前已经注册过了一个相同的任务：123public JobStatus getJobByUidAndJobId(int uid, int jobId) &#123; return mJobSet.get(uid, jobId);&#125; 还是调用的是 JobSet.get 方法：123456789101112public JobStatus get(int uid, int jobId) &#123; ArraySet&lt;JobStatus&gt; jobs = mJobs.get(uid); if (jobs != null) &#123; for (int i = jobs.size() - 1; i &gt;= 0; i--) &#123; JobStatus job = jobs.valueAt(i); if (job.getJobId() == jobId) &#123; return job; &#125; &#125; &#125; return null;&#125; 这个很简单，不详细说了！ 4 JSS.cancelJobImpl如果之前已经注册过一个任务了，需要先取消掉之前的任务！12345678910111213141516171819private void cancelJobImpl(JobStatus cancelled, JobStatus incomingJob) &#123; if (DEBUG) Slog.d(TAG, \"CANCEL: \" + cancelled.toShortString()); // 停止追踪任务! stopTrackingJob(cancelled, incomingJob, true /* writeBack */); synchronized (mLock) &#123; // 如果这个任务在等待队列中，移除它。 if (mPendingJobs.remove(cancelled)) &#123; mJobPackageTracker.noteNonpending(cancelled); &#125; // 如果正在运行，取消这个任务！ stopJobOnServiceContextLocked(cancelled, JobParameters.REASON_CANCELED); // 更新 jss 的状态！ reportActive(); &#125;&#125; 这里主要做的是：停止对这个任务的监视，同时，将这个任务移除等待队列，如果这个任务正在运行，那么就要取消它，我们一个一个来看！ 4.1 JSS.stopTrackingJob我们先来看第一个方法，参数传递： JobStatus jobStatus：要被取消的任务； JobStatus incomingJob：本次要注册的任务； boolean writeBack：true； 12345678910111213141516private boolean stopTrackingJob(JobStatus jobStatus, JobStatus incomingJob, boolean writeBack) &#123; synchronized (mLock) &#123; // 从 JobStore 和 controller 的监控队列中移除这个 job！ final boolean removed = mJobs.remove(jobStatus, writeBack); if (removed &amp;&amp; mReadyToRock) &#123; for (int i=0; i&lt;mControllers.size(); i++) &#123; StateController controller = mControllers.get(i); // 停止 job 监控！ controller.maybeStopTrackingJobLocked(jobStatus, incomingJob, false); &#125; &#125; return removed; &#125;&#125; 这里的 mJobs 是 JobStore 对象！ 4.1.1 JobStore.remove我们来看看这个移除操作：12345678910111213141516public boolean remove(JobStatus jobStatus, boolean writeBack) &#123; // 先从 mJobSet 中移除要删除的 JobStatus！ boolean removed = mJobSet.remove(jobStatus); if (!removed) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Couldn't remove job: didn't exist: \" + jobStatus); &#125; return false; &#125; // 如果 writeBack 是 true，并且 jobStatus 是 isPersisted 的，那就要更新 Jobs.xml 文件！ if (writeBack &amp;&amp; jobStatus.isPersisted()) &#123; maybeWriteStatusToDiskAsync(); &#125; return removed;&#125; 从 JobSet 集合中移除 Job，并且，如果需要写入操作，并且这个 Job 是设备重启后仍然需要保留的，那就要调用 remove 方法，将更新后的 JobSet 写入到 system/job/jobs.xml，因为所有 Persisted 为 true 的 Job ，都是会被写入到这个文件中去的，用于重启恢复！！ 我们来看 maybeWriteStatusToDiskAsync 方法：123456789101112131415161718192021222324252627282930313233343536373839private void maybeWriteStatusToDiskAsync() &#123; mDirtyOperations++; if (mDirtyOperations &gt;= MAX_OPS_BEFORE_WRITE) &#123; if (DEBUG) &#123; Slog.v(TAG, \"Writing jobs to disk.\"); &#125; mIoHandler.post(new WriteJobsMapToDiskRunnable()); &#125;&#125;... ... ... ... ... ... private class WriteJobsMapToDiskRunnable implements Runnable &#123; @Override public void run() &#123; final long startElapsed = SystemClock.elapsedRealtime(); final List&lt;JobStatus&gt; storeCopy = new ArrayList&lt;JobStatus&gt;(); synchronized (mLock) &#123; // Clone the jobs so we can release the lock before writing. // 这里是将 mJobSet 拷贝一份到 storeCopy 中。 mJobSet.forEachJob(new JobStatusFunctor() &#123; @Override public void process(JobStatus job) &#123; if (job.isPersisted()) &#123; storeCopy.add(new JobStatus(job)); &#125; &#125; &#125;); &#125; // 将更新后的拷贝写入 jobs.xml。 writeJobsMapImpl(storeCopy); if (JobSchedulerService.DEBUG) &#123; Slog.v(TAG, \"Finished writing, took \" + (SystemClock.elapsedRealtime() - startElapsed) + \"ms\"); &#125; &#125; ... ... ... ... &#125; 我们接着看！ 4.1.2 SC.maybeStopTrackingJobLocked接着，就是遍历控制器集合，让控制器停止对该任务的监视，参数传递： JobStatus jobStatus：要被删除的 Job！ JobStatus incomingJob：同一个 uid，同一个 jobId 的要被注册执行的 Job！ boolean forUpdate：false 12345/** * Remove task - this will happen if the task is cancelled, completed, etc. */public abstract void maybeStopTrackingJobLocked(JobStatus jobStatus, JobStatus incomingJob, boolean forUpdate); StateController 是一个抽象类，具体的实现，我们在 JobSchedulerService 的构造器中有看到：1234567mControllers.add(ConnectivityController.get(this));mControllers.add(TimeController.get(this));mControllers.add(IdleController.get(this));mControllers.add(BatteryController.get(this));mControllers.add(AppIdleController.get(this));mControllers.add(ContentObserverController.get(this));mControllers.add(DeviceIdleJobsController.get(this)); 这里有很多的控制器： 4.1.2.1 ConnectivityController我们先来看看 ConnectivityController 类的方法：12345678@Overridepublic void maybeStopTrackingJobLocked(JobStatus jobStatus, JobStatus incomingJob, boolean forUpdate) &#123; if (jobStatus.hasConnectivityConstraint() || jobStatus.hasUnmeteredConstraint() || jobStatus.hasNotRoamingConstraint()) &#123; mTrackedJobs.remove(jobStatus); &#125;&#125; 其他控制器的方法很类似的哦！ 4.2 JobPackageTracker.noteNonpending这个就是这样的12345public void noteNonpending(JobStatus job) &#123; final long now = SystemClock.uptimeMillis(); mCurDataSet.decPending(job.getSourceUid(), job.getSourcePackageName(), now); rebatchIfNeeded(now);&#125; 这里我们先不看！ 4.3 JSS.stopJobOnServiceContextLocked如果 Job 有在运行，那就停止它，参数传递：cancelled, JobParameters.REASON_CANCELED12345678910111213private boolean stopJobOnServiceContextLocked(JobStatus job, int reason) &#123; // 遍历 mActiveServices 集合； for (int i=0; i&lt;mActiveServices.size(); i++) &#123; JobServiceContext jsc = mActiveServices.get(i); final JobStatus executing = jsc.getRunningJob(); // 找到匹配的 jobStatus 对象； if (executing != null &amp;&amp; executing.matches(job.getUid(), job.getJobId())) &#123; jsc.cancelExecutingJob(reason); return true; &#125; &#125; return false;&#125; 这里调用了 JobServiceContext 的 cancelExecutingJob 这个方法，取消正在运行中的 job！ 4.3.1 JobServiceContext.cancelExecutingJob我们进入 JobServiceContext 文件中来看看：123456/** Called externally when a job that was scheduled for execution should be cancelled. */void cancelExecutingJob(int reason) &#123; // 发送一个 MSG_CANCEL 消息给 JobServiceHandler！ mCallbackHandler.obtainMessage(MSG_CANCEL, reason, 0 /* unused */).sendToTarget();&#125; 其中：mCallbackHandler = new JobServiceHandler(looper)，这里的 looper 是 system_server 的主线程的 looper，这个在第二篇初始化和启动就可以看到！ 这里我们向 JobServiceHandler 发送了一个 MSG_CANCEL 的消息，我们去看看：123456789101112131415161718192021222324252627282930313233343536373839404142434445 private class JobServiceHandler！ extends Handler &#123; @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; ... ... ... ... // 收到 MSG_CANCEL 的消息！ case MSG_CANCEL: // 如果这个 Job，已经完成了，就不处理！ if (mVerb == VERB_FINISHED) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Trying to process cancel for torn-down context, ignoring.\"); &#125; return; &#125; // 保存停止的原因！ mParams.setStopReason(message.arg1); if (message.arg1 == JobParameters.REASON_PREEMPT) &#123; // 如果原因是因为优先级取代，就用 mPreferredUid 保存被取代的 job 的 uid！ mPreferredUid = mRunningJob != null ? mRunningJob.getUid() : NO_PREFERRED_UID; &#125; // 执行取消任务～ handleCancelH(); break; case MSG_TIMEOUT: handleOpTimeoutH(); break; case MSG_SHUTDOWN_EXECUTION: closeAndCleanupJobH(true /* needsReschedule */); break; default: Slog.e(TAG, \"Unrecognised message: \" + message); &#125; &#125; ... ... ... ...&#125; 我们进入到 handleCancelH 方法中来看看：1234567891011121314151617181920212223242526272829303132private void handleCancelH() &#123; if (JobSchedulerService.DEBUG) &#123; Slog.d(TAG, \"Handling cancel for: \" + mRunningJob.getJobId() + \" \" + VERB_STRINGS[mVerb]); &#125; switch (mVerb) &#123; // 判断当前的 job 的状态！ case VERB_BINDING: case VERB_STARTING: // 将变量 mCancelled 置为 true； mCancelled.set(true); break; case VERB_EXECUTING: // 如果当前的 job 是正在执行状态，就先判断应用是否调用过 jobFinished 主动结束任务 // 如果有，就取消这次 cancel！ if (hasMessages(MSG_CALLBACK)) &#123; // If the client has called jobFinished, ignore this cancel. return; &#125; // 发送停止的消息！ sendStopMessageH(); break; case VERB_STOPPING: // Nada. break; default: Slog.e(TAG, \"Cancelling a job without a valid verb: \" + mVerb); break; &#125;&#125; mVerb 使用来保存 Job 的状态的，一个 Job 在 JobServiceContext 中会有如下的几种状态： static final int VERB_BINDING = 0; static final int VERB_STARTING = 1; static final int VERB_EXECUTING = 2; static final int VERB_STOPPING = 3; static final int VERB_FINISHED = 4; 这里我先不看！ 4.4 JSS.reportActive最后，调用 reportActive 方法，通知 JSS 的状态！1234567891011121314151617181920212223242526void reportActive() &#123; // active is true if pending queue contains jobs OR some job is running. boolean active = mPendingJobs.size() &gt; 0; if (mPendingJobs.size() &lt;= 0) &#123; for (int i=0; i&lt;mActiveServices.size(); i++) &#123; final JobServiceContext jsc = mActiveServices.get(i); final JobStatus job = jsc.getRunningJob(); if (job != null &amp;&amp; (job.getJob().getFlags() &amp; JobInfo.FLAG_WILL_BE_FOREGROUND) == 0 &amp;&amp; !job.dozeWhitelisted) &#123; // We will report active if we have a job running and it is not an exception // due to being in the foreground or whitelisted. active = true; break; &#125; &#125; &#125; // 当状态发生改变时，通知 DeviceIdleController 当前 JSS 的状态！ if (mReportedActive != active) &#123; mReportedActive = active; if (mLocalDeviceIdleController != null) &#123; mLocalDeviceIdleController.setJobsActive(active); &#125; &#125;&#125; 这个 reportActive 是将 JSS 的状态通知给 DeviceIdleController，用于 DOZE 模式，这里简单介绍下 DOZE 模式： 当用户在连续的一段时间内没有使用手机，就延缓终端中 APP 后台的CPU和网络活动，以达到减少电量消耗的目的，这时就进入 DOZE 模式，进入 DOZE 模式后的系统有如下约束： 暂停网络访问。 系统忽略所有的 WakeLock。 标准的 AlarmManager alarms 被延缓到下一个 maintenance window。 但使用 AlarmManager 的 setAndAllowWhileIdle、setExactAndAllowWhileIdle 和 setAlarmClock 时，alarms 定义的事件仍会启动，在这些 alarms 启动前，系统会短暂地退出Doze模式。 系统不再进行 WiFi 扫描。 系统不允许 sync adapters 运行。 系统不允许 JobScheduler 运行。 注意到最后一条了吧，这个就是 reportActive 的意义，我们继续看： 5 JSS.startTrackingJob接下来，就是开始 track 任务，参数传递： JobStatus jobStatus：本次注册的 job！ JobStatus lastJob：同一个 uid，同一个 jobId，上次注册的已经被取消的任务，可以为 null！ 123456789101112131415161718192021private void startTrackingJob(JobStatus jobStatus, JobStatus lastJob) &#123; synchronized (mLock) &#123; // 添加到 JobStore 中! final boolean update = mJobs.add(jobStatus); if (mReadyToRock) &#123; // 遍历控制器，执行监控操作！ for (int i = 0; i &lt; mControllers.size(); i++) &#123; StateController controller = mControllers.get(i); if (update) &#123; // 发生了相同 uid 和 jobId 的取代操作，先停止对旧的 job 的监控！ controller.maybeStopTrackingJobLocked(jobStatus, null, true); &#125; // 监控新的 jobStatus！ controller.maybeStartTrackingJobLocked(jobStatus, lastJob); &#125; &#125; &#125;&#125; 第一步，可以看到，先将这一次要注册执行的任务，加入到 JobStore 中： 5.1 JobStore.add这里是将要好注册执行的 Job 添加到 JobStore 中，这里和上面有些类似：12345678910111213141516public boolean add(JobStatus jobStatus) &#123; // 取代之前已经被添加过相同 uid 和 jobId 的 jobStatus！ boolean replaced = mJobSet.remove(jobStatus); // 将新的 job 添加到 JobSets 集合中！ mJobSet.add(jobStatus); if (jobStatus.isPersisted()) &#123; // 如果是 persist 类型的 job，还需要写到 Job.xml 文件中去！ maybeWriteStatusToDiskAsync(); &#125; if (DEBUG) &#123; Slog.d(TAG, \"Added job status to store: \" + jobStatus); &#125; return replaced; // 返回是否有取代发生！&#125; 返回值表示是否有取代发生，在 add 的过程中，会判断是否有相同 uid 和 jobId 的 jobStatus 存在，如果有，就要取代之前的！ 如果这个 Job 是 isPersisted 的，那就需要更新 Jobs.xml 文件！ 5.2 SC.maybeStopTrackingJobLocked这里先要停止 track 这个任务，参数传递： JobStatus jobStatus：要被注册执行的新的 Job！ JobStatus incomingJob：null boolean forUpdate：true12345/** * Remove task - this will happen if the task is cancelled, completed, etc. */public abstract void maybeStopTrackingJobLocked(JobStatus jobStatus, JobStatus incomingJob, boolean forUpdate); 具体的实现代码是在每个 Controller 中实现的，我们来看一个最简单的 Controller： 5.2.1 ConnectivityController代码如下，逻辑很简单：123456789@Overridepublic void maybeStopTrackingJobLocked(JobStatus jobStatus, JobStatus incomingJob, boolean forUpdate) &#123; if (jobStatus.hasConnectivityConstraint() || jobStatus.hasUnmeteredConstraint() || jobStatus.hasNotRoamingConstraint()) &#123; // 从监控列表中移除这个 job！ mTrackedJobs.remove(jobStatus); &#125;&#125; 接着看： 5.3 SC.maybeStartTrackingJobLocked接着，调用这个方法，来开始 track 任务，方法参数： JobStatus jobStatus：这次要注册的任务 JobStatus lastJob：同一个 uid，同一个 jobId 已经被取消掉的上一个任务，可以为 null！ 1public abstract void maybeStartTrackingJobLocked(JobStatus jobStatus, JobStatus lastJob); 这里同样是一个抽象接口，具体的实现是子类： 5.3.1 ConnectivityController让我们来看看 ConnectivityController 对象的这个方法：12345678910@Overridepublic void maybeStartTrackingJobLocked(JobStatus jobStatus, JobStatus lastJob) &#123; if (jobStatus.hasConnectivityConstraint() || jobStatus.hasUnmeteredConstraint() || jobStatus.hasNotRoamingConstraint()) &#123; // 判断当前的 job 约束条件是否满足，如果满足，就可以立即执行！ updateConstraintsSatisfied(jobStatus); // 将这个 Job 添加到 ConnectivityController 的跟踪列表中！ mTrackedJobs.add(jobStatus); &#125;&#125; 首先，判断 Job 是否有设置和 Connectivity 网络相关的属性： jobStatus.hasConnectivityConstraint() jobStatus.hasUnmeteredConstraint() jobStatus.hasNotRoamingConstraint() 调用了 updateConstraintsSatisfied 方法来判断当前的约束条件是否满足，同时更新 JobStatus 的状态！123456789101112131415161718private boolean updateConstraintsSatisfied (JobStatus jobStatus) &#123; final boolean ignoreBlocked = (jobStatus.getFlags() &amp; JobInfo.FLAG_WILL_BE_FOREGROUND) != 0; // 获得当前的网络状态信息：NetworkInfo final NetworkInfo info = mConnManager.getActiveNetworkInfoForUid(jobStatus.getSourceUid(), ignoreBlocked); // 判断约束条件是否满足； final boolean connected = (info != null) &amp;&amp; info.isConnected(); final boolean unmetered = connected &amp;&amp; !info.isMetered(); final boolean notRoaming = connected &amp;&amp; !info.isRoaming(); boolean changed = false; // 根据约束条件来更新 JobStatus 的信息！ changed |= jobStatus.setConnectivityConstraintSatisfied(connected); changed |= jobStatus.setUnmeteredConstraintSatisfied(unmetered); changed |= jobStatus.setNotRoamingConstraintSatisfied(notRoaming); return changed;&#125; 返回的 changed 表示：约束条件是否变化！ 最后将 jobStatus 加入到指定的 Controller 的监控列表中！ 6 [JSS.JobHandler].MSG_CHECK_JOB接着，就是向 JobHandler 发送了 MSG_CHECK_JOB 的消息，我们来看看：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 private class JobHandler extends Handler &#123; public JobHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message message) &#123; synchronized (mLock) &#123; if (!mReadyToRock) &#123; return; &#125; &#125; switch (message.what) &#123; case MSG_JOB_EXPIRED: ... ... ... ... break; case MSG_CHECK_JOB: // 接收到 MSG_CHECK_JOB 的消息！ synchronized (mLock) &#123; if (mReportedActive) &#123; // 为 true，表示 JSS 通知了设备管理器，自己处于活跃状态！ // if jobs are currently being run, queue all ready jobs for execution. queueReadyJobsForExecutionLockedH(); &#125; else &#123; // Check the list of jobs and run some of them if we feel inclined. maybeQueueReadyJobsForExecutionLockedH(); &#125; &#125; break; case MSG_CHECK_JOB_GREEDY: synchronized (mLock) &#123; queueReadyJobsForExecutionLockedH(); &#125; break; case MSG_STOP_JOB: cancelJobImpl((JobStatus)message.obj, null); break; &#125; // 处理 mPendingJobs 中的任务！ maybeRunPendingJobsH(); // Don&apos;t remove JOB_EXPIRED in case one came along while processing the queue. removeMessages(MSG_CHECK_JOB); &#125; ... ... ... ... ...&#125; mReportActive 为 true 的情况：有等待中的 job （mPendingJobs.size 大于 0）或者有正在执行中的 job （JobServiceContext.getRunningJob 不为 null） 接着，收到了 MSG_CHECK_JOB 的消息，开始遍历队列，执行准备好的任务！ 6.1 queueReadyJobsForExecutionLockedH当 mReport 下面是这个方法的代码：12345678910111213141516171819private void queueReadyJobsForExecutionLockedH() &#123; if (DEBUG) &#123; Slog.d(TAG, \"queuing all ready jobs for execution:\"); &#125; noteJobsNonpending(mPendingJobs); mPendingJobs.clear(); mJobs.forEachJob(mReadyQueueFunctor); mReadyQueueFunctor.postProcess(); if (DEBUG) &#123; final int queuedJobs = mPendingJobs.size(); if (queuedJobs == 0) &#123; Slog.d(TAG, \"No jobs pending.\"); &#125; else &#123; Slog.d(TAG, queuedJobs + \" jobs queued.\"); &#125; &#125;&#125; 这个方法和 maybeQueueReadyJobsForExecutionLockedH 很类似，我们先来看下面的这个方法： 6.2 maybeQueueReadyJobsForExecutionLockedH123456789101112private void maybeQueueReadyJobsForExecutionLockedH() &#123; if (DEBUG) Slog.d(TAG, \"Maybe queuing ready jobs...\"); noteJobsNonpending(mPendingJobs); // 先清空 mPendingJobs 集合! mPendingJobs.clear(); // 将准备好的 Job 加入到 JobHandler 内部的 runnableJobs 集合中。 mJobs.forEachJob(mMaybeQueueFunctor); // 将 runnableJobs 加入到 mPendingJobs 集合中! mMaybeQueueFunctor.postProcess();&#125; 6.2.1 mPendingJobs.clear首先清除了：mPendingJobs 集合，为这次执行做准备： mPendingJobs.clear(); 接着，这里传入了 mMaybeQueueFunctor 对象！123public void forEachJob(JobStatusFunctor functor) &#123; mJobSet.forEachJob(functor);&#125; 进入了 JobSet：123456789101112public void forEachJob(JobStatusFunctor functor) &#123; for (int uidIndex = mJobs.size() - 1; uidIndex &gt;= 0; uidIndex--) &#123; // 遍历 JobStore 中的所有 job！ ArraySet&lt;JobStatus&gt; jobs = mJobs.valueAt(uidIndex); for (int i = jobs.size() - 1; i &gt;= 0; i--) &#123; // 对每个 uid 的应用程序的 Job，执行下面操作： functor.process(jobs.valueAt(i)); &#125; &#125;&#125; 可以看出，这对所有的 Job，都调用了 MaybeReadyJobQueueFunctor 的 process 方法： 6.2.2 MaybeReadyJobQueueFunctor.process123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MaybeReadyJobQueueFunctor implements JobStatusFunctor &#123; int chargingCount; int idleCount; int backoffCount; int connectivityCount; int contentCount; List&lt;JobStatus&gt; runnableJobs; // 符合条件的即将运行的 Job public MaybeReadyJobQueueFunctor() &#123; reset(); &#125; // Functor method invoked for each job via JobStore.forEachJob() @Override public void process(JobStatus job) &#123; // 判断这个 Job 是否是准备了！ if (isReadyToBeExecutedLocked(job)) &#123; try &#123; if (ActivityManagerNative.getDefault().getAppStartMode(job.getUid(), job.getJob().getService().getPackageName()) == ActivityManager.APP_START_MODE_DISABLED) &#123; Slog.w(TAG, \"Aborting job \" + job.getUid() + \":\" + job.getJob().toString() + \" -- package not allowed to start\"); mHandler.obtainMessage(MSG_STOP_JOB, job).sendToTarget(); return; &#125; &#125; catch (RemoteException e) &#123; &#125; if (job.getNumFailures() &gt; 0) &#123; backoffCount++; &#125; if (job.hasIdleConstraint()) &#123; idleCount++; &#125; if (job.hasConnectivityConstraint() || job.hasUnmeteredConstraint() || job.hasNotRoamingConstraint()) &#123; connectivityCount++; &#125; if (job.hasChargingConstraint()) &#123; chargingCount++; &#125; if (job.hasContentTriggerConstraint()) &#123; contentCount++; &#125; if (runnableJobs == null) &#123; runnableJobs = new ArrayList&lt;&gt;(); &#125; // 将满足条件的 Job，先加入到 runnableJobs 集合！ runnableJobs.add(job); &#125; else if (areJobConstraintsNotSatisfiedLocked(job)) &#123; stopJobOnServiceContextLocked(job, JobParameters.REASON_CONSTRAINTS_NOT_SATISFIED); &#125; &#125; 这里调用了 isReadyToBeExecutedLocked 方法来判断，这个 job 是否已经准备好了： 123456789101112131415161718192021222324private boolean isReadyToBeExecutedLocked(JobStatus job) &#123; final boolean jobReady = job.isReady(); // job 是否准备好了 final boolean jobPending = mPendingJobs.contains(job); // job 是否已经在等待队列中 final boolean jobActive = isCurrentlyActiveLocked(job); // job 是否已经在 JobSerivceContext 中运行了！ final int userId = job.getUserId(); final boolean userStarted = ArrayUtils.contains(mStartedUsers, userId); // job 所在的设备用户是否运行！ final boolean componentPresent; // 表示 job 对应的应用程序的 JobService 组件是否存在！ try &#123; componentPresent = (AppGlobals.getPackageManager().getServiceInfo( job.getServiceComponent(), PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId) != null); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; if (DEBUG) &#123; Slog.v(TAG, \"isReadyToBeExecutedLocked: \" + job.toShortString() + \" ready=\" + jobReady + \" pending=\" + jobPending + \" active=\" + jobActive + \" userStarted=\" + userStarted + \" componentPresent=\" + componentPresent); &#125; return userStarted &amp;&amp; componentPresent &amp;&amp; jobReady &amp;&amp; !jobPending &amp;&amp; !jobActive;&#125; 可以看出，一个准备好的 Job 要满足这些条件： It’s ready. It’s not pending. It’s not already running on a JSC. The user that requested the job is running. The component is enabled and runnable. 最后，调用 MaybeQueueFunctor.postProcess 方法： 6.2.3 MaybeReadyJobQueueFunctor.postProcess1234567891011121314151617181920212223242526public void postProcess() &#123; // 判断一下条件！ if (backoffCount &gt; 0 || idleCount &gt;= mConstants.MIN_IDLE_COUNT || connectivityCount &gt;= mConstants.MIN_CONNECTIVITY_COUNT || chargingCount &gt;= mConstants.MIN_CHARGING_COUNT || contentCount &gt;= mConstants.MIN_CONTENT_COUNT || (runnableJobs != null &amp;&amp; runnableJobs.size() &gt;= mConstants.MIN_READY_JOBS_COUNT)) &#123; if (DEBUG) &#123; Slog.d(TAG, \"maybeQueueReadyJobsForExecutionLockedH: Running jobs.\"); &#125; noteJobsPending(runnableJobs); // 将 runnableJobs 加入到 mPendingJobs 集合中! mPendingJobs.addAll(runnableJobs); &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"maybeQueueReadyJobsForExecutionLockedH: Not running anything.\"); &#125; &#125; // Be ready for next time reset();&#125; 该功能: 先将 JobStore 的 JobSet 中满足条件的 job 对应的 JobStatus 加入 runnableJobs 队列； 再将 runnableJobs 中满足触发条件的 JobStatus 加入到 mPendingJobs 队列； 6.3 maybeRunPendingJobsH接着，就是处理 mPendingJobs 中的 Job：12345678910111213private void maybeRunPendingJobsH() &#123; synchronized (mLock) &#123; if (DEBUG) &#123; Slog.d(TAG, \"pending queue: \" + mPendingJobs.size() + \" jobs.\"); &#125; // 分配 Job 给 JSC! assignJobsToContextsLocked(); // 更新 JSS 的状态！ reportActive(); &#125;&#125; 结合就是调用 JSS 的 assignJobsToContextLocked 方法： 6.3.1 JSS.assignJobsToContextsLocked这个方法其实从名字上就可以看出，就是把 Job 分配给 JobServiceContext 方法，我们去那个方法里面看一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187private void assignJobsToContextsLocked() &#123; if (DEBUG) &#123; Slog.d(TAG, printPendingQueue()); &#125; // 根据当前系统的内存级别，设定最大的活跃 Job 数，保存到 mMaxActiveJobs！ int memLevel; try &#123; memLevel = ActivityManagerNative.getDefault().getMemoryTrimLevel(); &#125; catch (RemoteException e) &#123; memLevel = ProcessStats.ADJ_MEM_FACTOR_NORMAL; &#125; switch (memLevel) &#123; case ProcessStats.ADJ_MEM_FACTOR_MODERATE: mMaxActiveJobs = mConstants.BG_MODERATE_JOB_COUNT; break; case ProcessStats.ADJ_MEM_FACTOR_LOW: mMaxActiveJobs = mConstants.BG_LOW_JOB_COUNT; break; case ProcessStats.ADJ_MEM_FACTOR_CRITICAL: mMaxActiveJobs = mConstants.BG_CRITICAL_JOB_COUNT; break; default: mMaxActiveJobs = mConstants.BG_NORMAL_JOB_COUNT; break; &#125; JobStatus[] contextIdToJobMap = mTmpAssignContextIdToJobMap; // 大小为 16，和 mActiveServices 相对应！ boolean[] act = mTmpAssignAct; int[] preferredUidForContext = mTmpAssignPreferredUidForContext; // 大小为 16，和 mActiveServices 相对应！ int numActive = 0; int numForeground = 0; for (int i = 0; i &lt; MAX_JOB_CONTEXTS_COUNT; i++) &#123; // 获得每一个 JobSchedulerContext 和其内部运行着的 JobStatus（可为 null） final JobServiceContext js = mActiveServices.get(i); final JobStatus status = js.getRunningJob(); // 初始化 contextIdToJobMap，里面保存当前运行着的 Job，和空闲的用于增加的 Job 位置! // 然后，分别计算活跃 job 和前台 job 的个数！ if ((contextIdToJobMap[i] = status) != null) &#123; numActive++; if (status.lastEvaluatedPriority &gt;= JobInfo.PRIORITY_TOP_APP) &#123; numForeground++; &#125; &#125; act[i] = false; // 如果当前的 JSC 之前有发生过 job 优先级取代，将上一次的被取代的 job 的 uid 保存到 preferredUidForContext[i] = js.getPreferredUid(); &#125; if (DEBUG) &#123; Slog.d(TAG, printContextIdToJobMap(contextIdToJobMap, \"running jobs initial\")); &#125; // 遍历 mPendingJos 任务集合，尽可能为每一个 job 找到合适的 JobSchedulerContext! for (int i=0; i&lt;mPendingJobs.size(); i++) &#123; JobStatus nextPending = mPendingJobs.get(i); // 判断当前的 Job 是不是在 contextIdToJobMap 中了，即他是不是已经在运行了! int jobRunningContext = findJobContextIdFromMap(nextPending, contextIdToJobMap); if (jobRunningContext != -1) &#123; continue; &#125; // 计算 Job 的优先级! final int priority = evaluateJobPriorityLocked(nextPending); nextPending.lastEvaluatedPriority = priority; // 遍历 contextIdToJobMap // 给这个即将被执行的 Job 找一个合适的 context，至少要满足两个中的一个要求：1、可利用；2、优先级最低！ int minPriority = Integer.MAX_VALUE; int minPriorityContextId = -1; for (int j=0; j &lt; MAX_JOB_CONTEXTS_COUNT; j++) &#123; JobStatus job = contextIdToJobMap[j]; int preferredUid = preferredUidForContext[j]; if (job == null) &#123; if ((numActive &lt; mMaxActiveJobs || (priority &gt;= JobInfo.PRIORITY_TOP_APP &amp;&amp; numForeground &lt; mConstants.FG_JOB_COUNT)) &amp;&amp; (preferredUid == nextPending.getUid() || preferredUid == JobServiceContext.NO_PREFERRED_UID)) &#123; // 如果 context 原有的 job 为空，并且同时满足以下 2 个条件： // 1、当前活跃 job 数小于最大活跃数，或者 job 优先级不低于 PRIORITY_TOP_APP 且前台 job 数小于 mConstants.FG_JOB_COUNT // 2、JobSchedulerContext 中保存的之前被取代的 job 的 uid 等于当前的 job 的 id 或者等于 NO_PREFERRED_UID // 这个 JobSchedulerContext 是合适的，退出循环，处理下一个 job！ minPriorityContextId = j; break; &#125; continue; &#125; // 如果 context 原有的 job 不为空，且 uid 和即将执行的 job 不一样，那么这个 JobSchedulerContext 不合适! if (job.getUid() != nextPending.getUid()) &#123; continue; &#125; // 如果 context 原有的 job 不为空，且 uid 相同，已有 job 优先级大于等于即将执行的 job，那么这个 JobSchedulerContext 不合适! if (evaluateJobPriorityLocked(job) &gt;= nextPending.lastEvaluatedPriority) &#123; continue; &#125; // 如果存在 JobSchedulerContext 原有的 job 不为空，且 uid 相同，已有 job 优先级低于即将执行的 job，那么就选择优先级最低的那个！ if (minPriority &gt; nextPending.lastEvaluatedPriority) &#123; minPriority = nextPending.lastEvaluatedPriority; // 用来存储优先级最低的 JobSchedulerContext 所在的数组下标！ minPriorityContextId = j; &#125; &#125; // 找到了合适的 JobSchedulerContext 的下标! if (minPriorityContextId != -1) &#123; // 先将这个要被执行的 Job 放入 contextIdToJobMap 的 minPriorityContextId 位置！ contextIdToJobMap[minPriorityContextId] = nextPending; // 对应的 act 位置为 true，表示可以运行! act[minPriorityContextId] = true; // 活跃 job 数加 1； numActive++; if (priority &gt;= JobInfo.PRIORITY_TOP_APP) &#123; // 如果 job 的权限不低于 PRIORITY_TOP_APP，前台 job 数加 1； numForeground++; &#125; &#125; &#125; if (DEBUG) &#123; Slog.d(TAG, printContextIdToJobMap(contextIdToJobMap, \"running jobs final\")); &#125; mJobPackageTracker.noteConcurrency(numActive, numForeground); // 执行所有已经分配了 JobSchedulerContext 的 job ! for (int i=0; i &lt; MAX_JOB_CONTEXTS_COUNT; i++) &#123; boolean preservePreferredUid = false; if (act[i]) &#123; // art 为 true，表示可运行！ JobStatus js = mActiveServices.get(i).getRunningJob(); if (js != null) &#123; if (DEBUG) &#123; Slog.d(TAG, \"preempting job: \" + mActiveServices.get(i).getRunningJob()); &#125; // preferredUid will be set to uid of currently running job. // 如果这个 context 已经在运行了一个优先级低的 job，那就要取消它！ mActiveServices.get(i).preemptExecutingJob(); preservePreferredUid = true; &#125; else &#123; // 从 contextIdToJobMap 中获得即将执行的 Job! final JobStatus pendingJob = contextIdToJobMap[i]; if (DEBUG) &#123; Slog.d(TAG, \"About to run job on context \" + String.valueOf(i) + \", job: \" + pendingJob); &#125; // 通知控制器! for (int ic=0; ic&lt;mControllers.size(); ic++) &#123; mControllers.get(ic).prepareForExecutionLocked(pendingJob); &#125; // 使用对应的 JobServiceContext 来执行 Job if (!mActiveServices.get(i).executeRunnableJob(pendingJob)) &#123; Slog.d(TAG, \"Error executing \" + pendingJob); &#125; // Job 已经开始执行了，从 mPendingJobs 中移除这个 Job! if (mPendingJobs.remove(pendingJob)) &#123; mJobPackageTracker.noteNonpending(pendingJob); &#125; &#125; &#125; // 如果 preservePreferredUid 为 false，说明本次执行，没有发生 job 优先级取代 // 那就要调用 JobServiceContext 的 clearPreferredUid 清除上一次取代（如果有）保存的 uid！ if (!preservePreferredUid) &#123; mActiveServices.get(i).clearPreferredUid(); &#125; &#125;&#125; 接着我们继续来看： 6.3.1.1 JSS.findJobContextIdFromMap这个方法的作用很简单，就是判断 job 是否已经在 map 集合中了！123456789int findJobContextIdFromMap(JobStatus jobStatus, JobStatus[] map) &#123; for (int i=0; i&lt;map.length; i++) &#123; // 在 contextIdToJobMap 匹配 JobId 和 uid 相同的一个 job！ if (map[i] != null &amp;&amp; map[i].matches(jobStatus.getUid(), jobStatus.getJobId())) &#123; return i; &#125; &#125; return -1;&#125; 6.3.1.2 JSS.evaluateJobPriorityLocked这个方法是为 job 计算优先级：12345678910111213141516171819202122232425262728293031323334353637private int adjustJobPriority(int curPriority, JobStatus job) &#123; // 如果 curPriority 小于 PRIORITY_TOP_APP （40） if (curPriority &lt; JobInfo.PRIORITY_TOP_APP) &#123; // 获得计算因子，根据计算因子，计算优先级！ float factor = mJobPackageTracker.getLoadFactor(job); if (factor &gt;= mConstants.HEAVY_USE_FACTOR) &#123; curPriority += JobInfo.PRIORITY_ADJ_ALWAYS_RUNNING; &#125; else if (factor &gt;= mConstants.MODERATE_USE_FACTOR) &#123; curPriority += JobInfo.PRIORITY_ADJ_OFTEN_RUNNING; &#125; &#125; // 返回 curPriority； return curPriority;&#125;private int evaluateJobPriorityLocked(JobStatus job) &#123; // 获得 job 的优先级 int priority = job.getPriority(); // 如果 job 的优先级大于等于 PRIORITY_FOREGROUND_APP（30） if (priority &gt;= JobInfo.PRIORITY_FOREGROUND_APP) &#123; // 直接利用 job 的 priority 计算优先级！ return adjustJobPriority(priority, job); &#125; // 如果 job 的优先级小于 PRIORITY_FOREGROUND_APP（30） // 就先判断当前的 job 的 uid 是否是前台 uid！ int override = mUidPriorityOverride.get(job.getSourceUid(), 0); if (override != 0) &#123; // 如果当前 job 的 uid 是前台 uid，那就以这个 uid 对应的优先级计算当前 job 的优先级！ return adjustJobPriority(override, job); &#125; // 直接利用 job 的 priority 计算优先级！ return adjustJobPriority(priority, job);&#125; 这里的 mUidPriorityOverride 用来保存当前所有在前台的 uid，以及 uid 所有的 job 的优先级，下面是 Jss 中定义的一些优先级：1234567public static final int PRIORITY_ADJ_ALWAYS_RUNNING = -80;public static final int PRIORITY_ADJ_OFTEN_RUNNING = -40;public static final int PRIORITY_DEFAULT = 0;public static final int PRIORITY_SYNC_EXPEDITED = 10;public static final int PRIORITY_SYNC_INITIALIZATION = 20;public static final int PRIORITY_FOREGROUND_APP = 30;public static final int PRIORITY_TOP_APP = 40; 值越小，则优先级越高！ 接着源码继续分析： 6.3.1.3 JSC.preemptExecutingJob这里调用了 JobServiceContext 的 preemptExecutingJob 方法来取消相同 uid 但是优先级更低的任务，之前有说过，如果 Context 已经在执行一个优先级 job，并且这个 job 和即将被执行的 job 属于同一个 uid，那么要取消优先级低的！1234567void preemptExecutingJob() &#123; Message m = mCallbackHandler.obtainMessage(MSG_CANCEL); // 参数为 JobParameters.REASON_PREEMPT，表示要取代！ m.arg1 = JobParameters.REASON_PREEMPT; m.sendToTarget();&#125; 发送一个 MSG_CANCEL 消息给 JSC 内部的 JobServiceHandler ，附带一个参数，表示原因：JobParameters.REASON_PREEMPT！ JobServiceHandler.MSG_CANCEL我们接着来看：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private class JobServiceHandler extends Handler &#123; JobServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; ... ... ... ... case MSG_CANCEL: if (mVerb == VERB_FINISHED) &#123; // 这个 mVerb 表示的是，这个 Context 的 job 的当前状态! if (DEBUG) &#123; Slog.d(TAG, \"Trying to process cancel for torn-down context, ignoring.\"); &#125; return; &#125; mParams.setStopReason(message.arg1); if (message.arg1 == JobParameters.REASON_PREEMPT) &#123; // 如果是取消的原因是优先级取代，就用 mPreferredUid 保存 uid！ mPreferredUid = mRunningJob != null ? mRunningJob.getUid() : NO_PREFERRED_UID; &#125; // 执行取消操作! handleCancelH(); break; case MSG_TIMEOUT: handleOpTimeoutH(); break; case MSG_SHUTDOWN_EXECUTION: closeAndCleanupJobH(true /* needsReschedule */); break; default: Slog.e(TAG, \"Unrecognised message: \" + message); &#125; &#125; ... ... ... ... ... ... private void handleCancelH() &#123; if (JobSchedulerService.DEBUG) &#123; Slog.d(TAG, \"Handling cancel for: \" + mRunningJob.getJobId() + \" \" + VERB_STRINGS[mVerb]); &#125; // 这里因为是取消的是这个 context 里面正在执行的 job，所以 mVerb 的值为 VERB_EXECUTING! switch (mVerb) &#123; case VERB_BINDING: case VERB_STARTING: mCancelled.set(true); break; case VERB_EXECUTING: // 如果 client 已经调用了 jobFinished 方法结束了 job，那就 return! if (hasMessages(MSG_CALLBACK)) &#123; // If the client has called jobFinished, ignore this cancel. return; &#125; sendStopMessageH(); // 否则，就发送停止的消息! break; case VERB_STOPPING: // Nada. break; default: Slog.e(TAG, \"Cancelling a job without a valid verb: \" + mVerb); break; &#125; &#125; ... ... ... ...&#125; 如果有优先级低的 job 正在运行，那就 stop job，这时 mVerb 会从：VERB_EXECUTING -&gt; VERB_STOPPING.1234567891011121314151617181920212223/** * Already running, need to stop. Will switch &#123;@link #mVerb&#125; from VERB_EXECUTING -&gt; * VERB_STOPPING. */private void sendStopMessageH() &#123; removeOpTimeOut(); if (mVerb != VERB_EXECUTING) &#123; Slog.e(TAG, &quot;Sending onStopJob for a job that isn&apos;t started. &quot; + mRunningJob); closeAndCleanupJobH(false /* reschedule */); return; &#125; try &#123; // mVerb 状态变为 VERB_STOPPING！ mVerb = VERB_STOPPING; scheduleOpTimeOut(); // binder 通信，调用 JobService 的 stopJob 方法 service.stopJob(mParams); &#125; catch (RemoteException e) &#123; Slog.e(TAG, &quot;Error sending onStopJob to client.&quot;, e); closeAndCleanupJobH(false /* reschedule */); &#125;&#125; 这里的 service 是一个 IJobService 对象，本质是一个 Binder 对象，对应着应用程序进程中的 JobService！ JobService.stopJob注意：这里对于 Binder 机制来说：应用程序的 JobService 所在进程是 Binder 服务端，JobServiceContext 所在的进程 system_server 是 Binder 客户端！也就是说，应用程序定义的 JobService 是被 JobSerivceContext 来 bind 的，所以，你会发现，你无法 override JobService 的 onbind 方法！12345678910111213141516171819202122232425262728static final class JobInterface extends IJobService.Stub &#123; final WeakReference&lt;JobService&gt; mService; JobInterface(JobService service) &#123; mService = new WeakReference&lt;&gt;(service); &#125; @Override public void startJob(JobParameters jobParams) throws RemoteException &#123; JobService service = mService.get(); if (service != null) &#123; service.ensureHandler(); Message m = Message.obtain(service.mHandler, MSG_EXECUTE_JOB, jobParams); m.sendToTarget(); &#125; &#125; @Override public void stopJob(JobParameters jobParams) throws RemoteException &#123; // 通过 binder 机制来来调用指定应用的 JobService 的 stopJob 方法！ JobService service = mService.get(); if (service != null) &#123; service.ensureHandler(); // 发送到 JobService 内部的 JobHandler 对象中！ Message m = Message.obtain(service.mHandler, MSG_STOP_JOB, jobParams); m.sendToTarget(); &#125; &#125;&#125; 这里发送了 MSG_STOP_JOB 消息给 JobService.JobHandler，我们去 JobHandler 内部去看看： JobHandler.MSG_STOP_JOBJobHandler 位于应用程序的主线程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class JobHandler extends Handler &#123; JobHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // 这里获得传递过来的 JobParameters final JobParameters params = (JobParameters) msg.obj; switch (msg.what) &#123; ... ... ... case MSG_STOP_JOB: try &#123; // 调用 JobService onStopJob 方法，把参数传递过去，这里是不是很熟悉，就不多说! // onStopJob 会返回 true / false， true 表示还会 reschedule 这个 job! boolean ret = JobService.this.onStopJob(params); ackStopMessage(params, ret); &#125; catch (Exception e) &#123; Log.e(TAG, \"Application unable to handle onStopJob.\", e); throw new RuntimeException(e); &#125; break; ... ... ... ... default: Log.e(TAG, \"Unrecognised message received.\"); break; &#125; &#125; ... ... ... ... ... private void ackStopMessage(JobParameters params, boolean reschedule) &#123; // 这里获得了 IJobCallback 对象，这里显示是 Binder 机制，服务端是 JobServiceContext final IJobCallback callback = params.getCallback(); final int jobId = params.getJobId(); if (callback != null) &#123; try &#123; // 发送消息给 JobServiceContext callback.acknowledgeStopMessage(jobId, reschedule); &#125; catch(RemoteException e) &#123; Log.e(TAG, \"System unreachable for stopping job.\"); &#125; &#125; else &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"Attempting to ack a job that has already been processed.\"); &#125; &#125; &#125;&#125; 这里的 IJobCallback 又是使用了 Binder 机制，Binder 客户端是应用程序的 JobService 所在进程，Binder 服务端是 JobServiceContext 所在的进程，最后调用的是 JobServiceContext.acknowledgeStopMessage 方法： JobServiceContext.acknowledgeStopMessage通过 Binder 机制，将回调信息发回给 JobServiceContext：12345678910@Overridepublic void acknowledgeStopMessage(int jobId, boolean reschedule) &#123; if (!verifyCallingUid()) &#123; return; &#125; // 发送 MSG_CALLBACK 给 JobServiceHandler mCallbackHandler.obtainMessage(MSG_CALLBACK, jobId, reschedule ? 1 : 0) .sendToTarget();&#125; 然后又会发送 MSG_CALLBACK 给 JobServiceContext.JobServiceHandler，这里我们只看关键代码： JobServiceHandler.MSG_CALLBACKJobServiceHandler 同样的也是位于主线程：12345678910111213141516171819202122case MSG_CALLBACK: if (DEBUG) &#123; Slog.d(TAG, \"MSG_CALLBACK of : \" + mRunningJob + \" v:\" + VERB_STRINGS[mVerb]); &#125; removeOpTimeOut(); if (mVerb == VERB_STARTING) &#123; final boolean workOngoing = message.arg2 == 1; handleStartedH(workOngoing); &#125; else if (mVerb == VERB_EXECUTING || mVerb == VERB_STOPPING) &#123; // 从前面跟代码，可以看出 mVerb 的值为 VERB_STOPPING. final boolean reschedule = message.arg2 == 1; handleFinishedH(reschedule); &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"Unrecognised callback: \" + mRunningJob); &#125; &#125; break; 接着，调用 JobServiceContext 的 handleFinishedH 方法： JobServiceContext.handleFinishedH123456789101112 private void handleFinishedH(boolean reschedule) &#123; switch (mVerb) &#123; case VERB_EXECUTING: case VERB_STOPPING: // 进入这个分支！ closeAndCleanupJobH(reschedule); // 调用了 closeAndCleanupJobH break;、 default: Slog.e(TAG, \"Got an execution complete message for a job that wasn't being\" + \"executed. Was \" + VERB_STRINGS[mVerb] + \".\"); &#125; &#125; 接着进入 closeAndCleanupJobH 方法，参数 reschedule 表示是否再次执行这个 job！1234567891011121314151617181920212223242526272829303132333435363738 private void closeAndCleanupJobH(boolean reschedule) &#123; final JobStatus completedJob; synchronized (mLock) &#123; if (mVerb == VERB_FINISHED) &#123; return; &#125; completedJob = mRunningJob; mJobPackageTracker.noteInactive(completedJob); try &#123; mBatteryStats.noteJobFinish(mRunningJob.getBatteryName(), mRunningJob.getSourceUid()); &#125; catch (RemoteException e) &#123; // Whatever. &#125; if (mWakeLock != null) &#123; mWakeLock.release(); &#125; mContext.unbindService(JobServiceContext.this); // 取消绑定 JobService mWakeLock = null; mRunningJob = null; mParams = null; mVerb = VERB_FINISHED; // mVerb 状态置为 VERB_FINISHED； mCancelled.set(false); service = null; mAvailable = true; &#125; removeOpTimeOut(); // 移除已经处理的消息 removeMessages(MSG_CALLBACK); removeMessages(MSG_SERVICE_BOUND); removeMessages(MSG_CANCEL); removeMessages(MSG_SHUTDOWN_EXECUTION); // 调用了 mCompletedListener 的 onJobCompleted 方法! mCompletedListener.onJobCompleted(completedJob, reschedule); &#125;&#125; 这个方法很简单，就是对当前的 JobSchedulerContext 进行初始化操作，为执行下一个 job 做准备！ 这里 mCompletedListener 大家去看 JobServiceContext 的初始化，也就是第二篇，其实就是 JobSchedulerService： JobSchedulerService.onJobCompleted1234567891011121314151617181920212223242526272829303132@Overridepublic void onJobCompleted(JobStatus jobStatus, boolean needsReschedule) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Completed \" + jobStatus + \", reschedule=\" + needsReschedule); &#125; // 停止 track 这个 job，如果是周期性 job 不更新本地的 jobs.xml 文件! if (!stopTrackingJob(jobStatus, null, !jobStatus.getJob().isPeriodic())) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Could not find job to remove. Was job removed while executing?\"); &#125; // We still want to check for jobs to execute, because this job may have // scheduled a new job under the same job id, and now we can run it. mHandler.obtainMessage(MSG_CHECK_JOB_GREEDY).sendToTarget(); return; &#125; // 重新 schedule 这个 job，注意这时候 if (needsReschedule) &#123; JobStatus rescheduled = getRescheduleJobForFailure(jobStatus); startTrackingJob(rescheduled, jobStatus); &#125; else if (jobStatus.getJob().isPeriodic()) &#123; JobStatus rescheduledPeriodic = getRescheduleJobForPeriodic(jobStatus); startTrackingJob(rescheduledPeriodic, jobStatus); &#125; reportActive(); // 发送 MSG_CHECK_JOB_GREEDY 给 JobSchedulerService.JobHandler mHandler.obtainMessage(MSG_CHECK_JOB_GREEDY).sendToTarget();&#125; 这里首先调用了 stopTrackingJob 将这个 job 从 JobStore 和 controller 中移除：123456789101112131415161718private boolean stopTrackingJob(JobStatus jobStatus, JobStatus incomingJob, boolean writeBack) &#123; synchronized (mLock) &#123; // 从 JobStore 中移除这个 job，如果 writeback 为 true，还要更新本地的 job.xml 文件! final boolean removed = mJobs.remove(jobStatus, writeBack); if (removed &amp;&amp; mReadyToRock) &#123; for (int i=0; i&lt;mControllers.size(); i++) &#123; StateController controller = mControllers.get(i); // 从 Controller 的跟踪队列中移除！ controller.maybeStopTrackingJobLocked(jobStatus, incomingJob, false); &#125; &#125; return removed; &#125;&#125; 最后是发 MSG_CHECK_JOB_GREEDY 给 JobHandler： JobHandler.MSG_CHECK_JOB_GREEDY123456789101112131415161718192021222324252627private class JobHandler extends Handler &#123; @Override public void handleMessage(Message message) &#123; synchronized (mLock) &#123; if (!mReadyToRock) &#123; return; &#125; &#125; switch (message.what) &#123; ... ... ... ... case MSG_CHECK_JOB_GREEDY: synchronized (mLock) &#123; // 作用和 maybeQueueReadyJobsForExecutionLockedH 一样的都是更新 mPendingJobs 集合！ queueReadyJobsForExecutionLockedH(); &#125; break; ... ... ... ... &#125; // 再次执行 mPendingJobs 中的 job maybeRunPendingJobsH(); // Don't remove JOB_EXPIRED in case one came along while processing the queue. removeMessages(MSG_CHECK_JOB); &#125; ... ... ... ...&#125; 最后继续 maybeRunPendingJobsH，这里又回到了上面的第 6 节了，就不多说了！ 6.3.1.4 JSC.prepareForExecutionLocked如果不需要优先级取代，取消优先级低的 job，那就直接执行当前的新 job，在执行那个前，调用 prepareForExecutionLocked 做准备工作。 这个方法其实很简单，就是一个抽象类的方法：12345/** * Optionally implement logic here to prepare the job to be executed. */public void prepareForExecutionLocked(JobStatus jobStatus) &#123;&#125; 表示通知 StateController，做好准备，具体实现是在 Controller 中，我们先看看 ConnectivityController，其他类似： 6.3.1.5 JSC.executeRunnableJob这里就是调用 JobSchedulerContext 方法来执行 Job：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566boolean executeRunnableJob(JobStatus job) &#123; synchronized (mLock) &#123; if (!mAvailable) &#123; Slog.e(TAG, \"Starting new runnable but context is unavailable &gt; Error.\"); return false; &#125; mPreferredUid = NO_PREFERRED_UID; // 保存到 mRunningJob 中 mRunningJob = job; final boolean isDeadlineExpired = job.hasDeadlineConstraint() &amp;&amp; (job.getLatestRunTimeElapsed() &lt; SystemClock.elapsedRealtime()); Uri[] triggeredUris = null; if (job.changedUris != null) &#123; triggeredUris = new Uri[job.changedUris.size()]; job.changedUris.toArray(triggeredUris); &#125; String[] triggeredAuthorities = null; if (job.changedAuthorities != null) &#123; triggeredAuthorities = new String[job.changedAuthorities.size()]; job.changedAuthorities.toArray(triggeredAuthorities); &#125; // 创建 job 需要的 JobParamters mParams = new JobParameters(this, job.getJobId(), job.getExtras(), isDeadlineExpired, triggeredUris, triggeredAuthorities); mExecutionStartTimeElapsed = SystemClock.elapsedRealtime(); // mVerb 的值变为 VERB_BINDING! mVerb = VERB_BINDING; scheduleOpTimeOut(); // 这里很关键，bind 应用程序中注册的 JobService，并返回结果！ final Intent intent = new Intent().setComponent(job.getServiceComponent()); boolean binding = mContext.bindServiceAsUser(intent, this, Context.BIND_AUTO_CREATE | Context.BIND_NOT_FOREGROUND, new UserHandle(job.getUserId())); if (!binding) &#123; // 如果 bind 失败，异常处理！ if (DEBUG) &#123; Slog.d(TAG, job.getServiceComponent().getShortClassName() + \" unavailable.\"); &#125; mRunningJob = null; mParams = null; mExecutionStartTimeElapsed = 0L; mVerb = VERB_FINISHED; removeOpTimeOut(); return false; &#125; // 记录信息! try &#123; mBatteryStats.noteJobStart(job.getBatteryName(), job.getSourceUid()); &#125; catch (RemoteException e) &#123; // Whatever. &#125; mJobPackageTracker.noteActive(job); mAvailable = false; return true; &#125;&#125; 这便是由 system_server 进程的主线程来执行 bind Service 的方式来拉起的进程，当服务启动后回调到发起端的 onServiceConnected。 6.3.1.5.1 JSC.onServiceConnectedbind 成功后，JobServiceContext 的 onServiceConnected 方法会执行：12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void onServiceConnected(ComponentName name, IBinder service) &#123; JobStatus runningJob; synchronized (mLock) &#123; runningJob = mRunningJob; &#125; // 异常检测，如果 runningJob 为 null 或者 JobService 组件不匹配，发送 MSG_SHUTDOWN_EXECUTION 终止执行！ if (runningJob == null || !name.equals(runningJob.getServiceComponent())) &#123; mCallbackHandler.obtainMessage(MSG_SHUTDOWN_EXECUTION).sendToTarget(); return; &#125; // 获得了应用程序的 JobService 的代理对象！ this.service = IJobService.Stub.asInterface(service); // 申请 wakeLock 锁！ final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, runningJob.getTag()); wl.setWorkSource(new WorkSource(runningJob.getSourceUid())); wl.setReferenceCounted(false); wl.acquire(); synchronized (mLock) &#123; if (mWakeLock != null) &#123; Slog.w(TAG, \"Bound new job \" + runningJob + \" but live wakelock \" + mWakeLock + \" tag=\" + mWakeLock.getTag()); mWakeLock.release(); &#125; mWakeLock = wl; &#125; // 发送 MSG_SERVICE_BOUND 给 JobServiceHandler 中！ mCallbackHandler.obtainMessage(MSG_SERVICE_BOUND).sendToTarget();&#125; 可以看到，这里会发送消息到 JobServiceHandler 中： 6.3.1.5.2 JSC.JobServiceHandlerJobServiceHandler 方法也是在主线程中！12345678910111213141516171819202122232425private class JobServiceHandler extends Handler &#123; JobServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; case MSG_SERVICE_BOUND: // 绑定成功！ removeOpTimeOut(); handleServiceBoundH(); break; ... ... ... ... case MSG_SHUTDOWN_EXECUTION: // 绑定是出现异常的消息！ closeAndCleanupJobH(true /* needsReschedule */); break; default: Slog.e(TAG, \"Unrecognised message: \" + message); &#125; &#125; ... ... ... ...&#125; 接着我们来分别看一下： 6.3.1.5.2.1 JSS.handleServiceBoundH收到这个消息后，调用 handleServiceBoundH 方法：1234567891011121314151617181920212223242526272829303132333435/** Start the job on the service. */private void handleServiceBoundH() &#123; if (DEBUG) &#123; Slog.d(TAG, \"MSG_SERVICE_BOUND for \" + mRunningJob.toShortString()); &#125; if (mVerb != VERB_BINDING) &#123; // 状态异常 Slog.e(TAG, \"Sending onStartJob for a job that isn't pending. \" + VERB_STRINGS[mVerb]); closeAndCleanupJobH(false /* reschedule */); return; &#125; // 如果 mCancelled.get() 为 true，表示 job 被取消了，那就执行舒适化 JSC，并 return！ if (mCancelled.get()) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Job cancelled while waiting for bind to complete. \" + mRunningJob); &#125; closeAndCleanupJobH(true /* reschedule */); return; &#125; try &#123; // mVerb 的值设置为 VERB_STARTING！ mVerb = VERB_STARTING; scheduleOpTimeOut(); // 这里调用了 JobService 的 startJob 方法 service.startJob(mParams); &#125; catch (RemoteException e) &#123; Slog.e(TAG, \"Error sending onStart message to '\" + mRunningJob.getServiceComponent().getShortClassName() + \"' \", e); &#125;&#125; 这里就不细看了！ 7 总结7.1 schedule 流程终于跟完了代码。我们来总结一下，整个流程： 根据传入的 JobInfo，创建 JobStatus； 如果已经注册过一个相同 uid 和 jobId 的 job，就 cancel 之前注册过的 job； 停止监控这个 job： 从 JobStore 和 controller 的监控队列中移除这个 job，并停止 controller 对这个 job 的监控； 如果这个任务在 mPendingJobs 队列中，移除它； 如果正在运行，取消这个任务； 更新 JSS 的状态！ 将新 job 加入到 JobStore 中，并通知 controller 开始监控新 schedule 的 job！ 如果 JobStore 中已经存在相同 uid 和 jobId 的 job，就取代这个 job ，并停止对这个旧 job 的监控！ 发送 MSG_CHECK_JOB 消息给 JobHandler，进行执行 job 前的检查！ 清空 mPendingJobs，为本次执行做准备，将 JobStore 中所有准备好的 job，加入到 runnableJobs 可执行列表中，再将 runnableJobs 列表中的所有 job 添加到 mPendingJobs 集合中！ 给 mPendingJobs 集合中的 job 分配 JobSchedulerContext！ 7.2 JSC 和 JS 的关系先空着，后续补上！ 7.3 JSC 的 Job 分配算法这里我们来总结一些 job 的分配算法：","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"Process篇 4 - 进程的 priority 和 oomAdj 简析","slug":"Process4-thePriorityAndOomAdj","date":"2016-04-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/04/13/Process4-thePriorityAndOomAdj/","link":"","permalink":"https://coolqi.top/2016/04/13/Process4-thePriorityAndOomAdj/","excerpt":"","text":"基于 Android 7.1.1 源码，分析和总结进程相关的知识！ 本文参考： 1https://developer.android.com/guide/components/processes-and-threads.html 1 进程的重要性层次进程的重要性层次一共有 5 级，以下的部分内容截取自 Android Developer Guide！ From Android Developer Guide 【前台进程 Foreground Process】 定义：用户当前操作所必需的进程。 如果一个进程满足以下任一条件，即视为前台进程： 托管用户正在交互的 Activity。（即已调用 Activity 的 onResume() 方法） 托管某个 Service，后者绑定到用户正在交互的 Activity。 托管正在 “前台” 运行的 Service。（服务已调用 startForeground()） 托管正执行一个生命周期回调的 Service。（比如：onCreate()，onStart()或 onDestroy()） 托管正执行其 onReceive() 方法的 BroadcastReceiver 通常，在任意给定时间前台进程都为数不多。前台进程的优先级最高，只有在内存不足，万不得已的时候，系统才会杀掉他们！ 【可见进程 Visible Process】 定义：没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。 例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一个 Activity，则有可能会发生这种情况。 托管绑定到可见（或前台）Activity 的 Service。 可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 【服务进程 Service Process】 定义：正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程，那就属于服务进程！ 可以看到管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 【后台进程 Background Process】 定义：包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。 这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。 如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 【空进程 Empty Process】 定义：不含任何活动应用组件的进程。 保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 End From 通过 Android developer guide 我们能可以知道进程优先级的 5 分类以及其满足的条件，这里我用一张思维导图简单的总结一下： 注意：这只是一个粗略的划分。其实，在系统的内部实现中，优先级远不止这么五种。 2 进程的优先级和状态在 ActivityManager.java 中，我们可以通过一个方法来获得系统中所有正在运行中的应用进程的信息： 1234567public List&lt;RunningAppProcessInfo&gt; getRunningAppProcesses() &#123; try &#123; return ActivityManagerNative.getDefault().getRunningAppProcesses(); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 该方法会返回一个 List 列表，每一个进程都被封装成了一个 RunningAppProcessInfo 对象，RunningAppProcessInfo 中有几个重要的成员变量，用于表示进程的重要性和状态； 12public int importance;public int processState; 其中，processState 表示的是进程的状态，系统是通过这个值来动态调节进程的优先级的；importance 则是进程的重要级别，它是系统暴露给外部的参数，用于获得自身或者其他一个应用进程的重要性级别，下面我们来看看二者的关系和定义！ 2.1 进程的优先级首先，来看看 importance，其表示进程的重要性级别，取值有如下的 10 种，定义在 ActivityManager.java 中！ 123456789101112131415161718192021222324252627282930313233// 该进程持有前台 UI 界面，该 UI 界面正在和用户交互！public static final int IMPORTANCE_FOREGROUND = 100;// 该进程运行着一个前台服务，比如进程在播放音乐，即使用户没有在应用中，// 这种状态表明进程正在做一些用户非常关心的事情！public static final int IMPORTANCE_FOREGROUND_SERVICE = 125;// 该进程虽然用户无法直接感知到，但在某种程度上他们仍然可以察觉到!public static final int IMPORTANCE_PERCEPTIBLE = 130;// 该进程运行着一个前台 UI 界面，但是由于设备进入了睡眠状态，因此对用户不可见，用户此时无法和其交互！// 用户也无法感知该进程，但是当用户唤醒设备后，用户又可以与之交互，所以这种状态下的进程也是很重要的！public static final int IMPORTANCE_TOP_SLEEPING = 150;// 该进程中运行的应用，我们不能保存它的状态，所以当该进程退到后台时，我们不能杀死它！public static final int IMPORTANCE_CANT_SAVE_STATE = 170;// 该进程运行着一些没有在前台，但是对用户是可见的内容，其内部可能运行着一个在前台 UI 下面的窗口//（其处于暂停状态，系统将其状态保存了下来，其没有和用户交互，但是一定程度来说对用户是可见的）；// 其内部也可能运行着在系统控制下的服务！public static final int IMPORTANCE_VISIBLE = 200;// 服务进程，该进程包含一些在后台运行的服务，这些服务用户是无感知的，所以它们可以由系统相对自由地杀死！public static final int IMPORTANCE_SERVICE = 300;// 后台进程，用户完全无法感知到进程的存在public static final int IMPORTANCE_BACKGROUND = 400;// 空进程public static final int IMPORTANCE_EMPTY = 500;// 此进程不存在public static final int IMPORTANCE_GONE = 1000; 2.2 进程的状态接着，我们来看看 processState，其表示进程的状态，其取值范围有如下的 17 种，同样定义在 ActivityManager.java 中！ 进程的状态是从 android 系统管理角度进行的分级，和 lmk 的分级不同！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 进程不存在！public static final int PROCESS_STATE_NONEXISTENT = -1;// persist 系统进程public static final int PROCESS_STATE_PERSISTENT = 0;// persist 系统进程，并且正在进行 UI 相关的操作！public static final int PROCESS_STATE_PERSISTENT_UI = 1;// 该进程拥有当前用户可见的 top activity，其他可见的 activity 都在其下面！public static final int PROCESS_STATE_TOP = 2;// 该进程拥有一个前台服务，该服务是由系统绑定的！public static final int PROCESS_STATE_BOUND_FOREGROUND_SERVICE = 3;// 该进程拥有一个前台服务！public static final int PROCESS_STATE_FOREGROUND_SERVICE = 4;// 该进程拥有当前用户可见的 top activity，和 PROCESS_STATE_TOP 一样！// 但此时设备处于休眠状态！public static final int PROCESS_STATE_TOP_SLEEPING = 5;// 对用户很重要的进程，用户可感知其存在public static final int PROCESS_STATE_IMPORTANT_FOREGROUND = 6;// 对用户很重要的进程，用户不可感知其存在public static final int PROCESS_STATE_IMPORTANT_BACKGROUND = 7;// 后台进程，正在执行备份 / 恢复操作！public static final int PROCESS_STATE_BACKUP = 8;// 后台进程，但是我们不能恢复其状态，所以尽量避免杀死该进程public static final int PROCESS_STATE_HEAVY_WEIGHT = 9;// 后台进程，正在运行一个服务，执行某个操作！public static final int PROCESS_STATE_SERVICE = 10;// 后台进程，正在运行一个广播接收者，处理广播！public static final int PROCESS_STATE_RECEIVER = 11;// 后台进程，桌面 home activity 位于该进程中public static final int PROCESS_STATE_HOME = 12;// 后台进程，拥有上一次显示给用户的 activitypublic static final int PROCESS_STATE_LAST_ACTIVITY = 13;// 缓存进程，供以后使用，内部包含 activity。public static final int PROCESS_STATE_CACHED_ACTIVITY = 14;// 缓存进程，供以后使用，其为另一个内含 activity 的缓存进程的 client 端进程！public static final int PROCESS_STATE_CACHED_ACTIVITY_CLIENT = 15;// 缓存进程，供以后使用，内部为空public static final int PROCESS_STATE_CACHED_EMPTY = 16; 我们知道，每一个进程在系统中都有一个 ProcessRecord 对象与之对应，其内部封装着该进程的数据和组件信息，ProcessRecord 也有一些成员变量，其取值也是上面的这 17 种！ 1234int curProcState = PROCESS_STATE_NONEXISTENT; // Currently computed process stateint repProcState = PROCESS_STATE_NONEXISTENT; // Last reported process stateint setProcState = PROCESS_STATE_NONEXISTENT; // Last set process state in process trackerint pssProcState = PROCESS_STATE_NONEXISTENT; // Currently requesting pss for ActivityManagerService 就是通过这些变量来设置和调整进程的状态的，这个我们后面再看！ 2.3 进程优先级和状态的转换在系统中 processState 和 importance 是有相应的映射和转换关系的，其映射方法的定义在 ActivityManager.java 中！ 123456789101112@SystemApipublic int getPackageImportance(String packageName) &#123; try &#123; //【1】获得进程的状态值！ int procState = ActivityManagerNative.getDefault().getPackageProcessState(packageName, mContext.getOpPackageName()); //【2】将进程的状态映射为所属的重要性级别 return RunningAppProcessInfo.procStateToImportance(procState); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 最终的映射函数在 RunningAppProcessInfo.procStateToImportance： 123456789101112131415161718192021222324252627282930public static int procStateToImportance(int procState) &#123; //【1】将进程的状态转为对应的重要性级别！ if (procState == PROCESS_STATE_NONEXISTENT) &#123; // -1 return IMPORTANCE_GONE; &#125; else if (procState &gt;= PROCESS_STATE_HOME) &#123; // 12 return IMPORTANCE_BACKGROUND; &#125; else if (procState &gt;= PROCESS_STATE_SERVICE) &#123; // 10 return IMPORTANCE_SERVICE; &#125; else if (procState &gt; PROCESS_STATE_HEAVY_WEIGHT) &#123; // 9 return IMPORTANCE_CANT_SAVE_STATE; &#125; else if (procState &gt;= PROCESS_STATE_IMPORTANT_BACKGROUND) &#123; // 7 return IMPORTANCE_PERCEPTIBLE; &#125; else if (procState &gt;= PROCESS_STATE_IMPORTANT_FOREGROUND) &#123; // 6 return IMPORTANCE_VISIBLE; &#125; else if (procState &gt;= PROCESS_STATE_TOP_SLEEPING) &#123; // 5 return IMPORTANCE_TOP_SLEEPING; &#125; else if (procState &gt;= PROCESS_STATE_FOREGROUND_SERVICE) &#123; // 4 return IMPORTANCE_FOREGROUND_SERVICE; &#125; else &#123; return IMPORTANCE_FOREGROUND; &#125;&#125; 通过该方法，我们可以知道，某个应用进程所属的重要性级别了！ 这里不解的是，对应关系中忽略掉了一些 IMPORTANCE 级别，不只是为什么！ 3 进程的 oomAdj 值说到 oomAdj，我们就要谈到 Android 中的一个很重要的机制 Low Memory Killer，也叫做低内存杀手！对于 Low Memory Killer，我后面会单独写一篇文章来分析和总结！ Low Memory Killer 基于 Linux 的 OOM 机制，在 Linux 中，内存是以页面为单位分配的，当申请页面分配时如果内存不足会通过以下流程选择 bad 进程来杀掉从而释放内存： 1alloc_pages -&gt; out_of_memory() -&gt; select_bad_process() -&gt; badness() 而 Low Memory Killer 杀进程依据就是进程的 oom_adj 值，oom_adj 越小越不容易被杀死，对于 oomAdj 值，定义在 ProcessList.java 中; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 初始化值static final int INVALID_ADJ = -10000;// 该值用于用于某些我们还没法确定具体值的地方，一般是指当一个进程要被缓存了，但我们还不知道要给它分配的// 缓存进程的 adj 的具体值！static final int UNKNOWN_ADJ = 1001;// 缓存进程，其 adj 的最大致和最小值，该进程仅托管不可见的 activity，他们容易就会被杀死！static final int CACHED_APP_MAX_ADJ = 906;static final int CACHED_APP_MIN_ADJ = 900;// B list 列表中的服务所在进程，该进程中的服务很老旧，使用率小，不像 A list 中的服务那样活跃和使用频繁！static final int SERVICE_B_ADJ = 800;// 用户所在的上一个应用的进程static final int PREVIOUS_APP_ADJ = 700;// 托管着桌面 HOME 应用的进程，我们要尽量避免杀掉它，即使其退到了后台！因为用户和其交互的频率很高！static final int HOME_APP_ADJ = 600;// 托管着应用 Service 的进程，杀掉这类进程对用户不会有太大的影响！static final int SERVICE_ADJ = 500;// 高权重 \"heavy-weight\" 应用所在进程，虽然该进程是在后台，但是我们要避免杀掉它// 该 adj 是 \"system/rootdir/init.rc\" 在启动时设置的！static final int HEAVY_WEIGHT_APP_ADJ = 400;// 正在执行备份 backup 操作的进程，// 虽然杀掉这类进程不会导致严重问题，但是会导致备份的数据异常，所以杀掉它不是明智之举！static final int BACKUP_APP_ADJ = 300;// 仅持有用户可感知组件的进程，比如在后台播放音乐，虽然其对用户不是立即可见，但是我们也要比避免杀死它！static final int PERCEPTIBLE_APP_ADJ = 200;// 持有对用户可见的 activity 的进程，我们也要避免杀死他们！static final int VISIBLE_APP_ADJ = 100;static final int VISIBLE_APP_LAYER_MAX = PERCEPTIBLE_APP_ADJ - VISIBLE_APP_ADJ - 1;// 运行着当前前台应用的进程，我们不能杀掉这类进程！static final int FOREGROUND_APP_ADJ = 0;// 被系统进程或者 persistent 进程绑定的进程！static final int PERSISTENT_SERVICE_ADJ = -700;// 系统 persistent 进程，比如 telephony，这种类型的进程系统一定是不会杀死的！static final int PERSISTENT_PROC_ADJ = -800;// 系统进程，默认分配！static final int SYSTEM_ADJ = -900;// native 进程，不受系统的管控！static final int NATIVE_ADJ = -1000; 我们在前面知道了进程的重要性级别和进程的状态的映射关系，那么对于进程的状态和进程的 oomAdj 之间是否也有一定的联系呢？这里就要谈到 oomAdj 的调度算法，我会单独开一篇文章来分析！ 接下来，我介绍下 ProcessRecord 中和 oomAdj 相关的几个重要变量，我们后续分析 oomAdj 的时候会遇到： 123456789101112int maxAdj; // 该进程最大的 Adj，进程的 adj 的设定不能超过该值int curRawAdj; // 在第一个过程评估后该进程具有的 adj 值，int setRawAdj; // 上一次经过第一次评估后该进程具有的 adj 值，curRawAdj 被更新后，旧值会保存到 setRawAdj int curAdj; // 进程当前的 adj 值，经过了两个过程评估，这才是进程实际的 adj 值int setAdj; // 上一次设置的 adj 值， curAdj 被更新了，旧值会被保存到 setAdj 中！int verifiedAdj; // The last adjustment that was verified as actually being setint curSchedGroup; // Currently desired scheduling classint setSchedGroup; // Last set to background scheduling class 对于 low memory killer，当系统的可用内存不够的时候，他会根据一定的策略来杀掉进程，释放内存，针对 low memory killer 我后续也会单独写一篇博文来分析！ 4 ActivityManager 相关接口1234/** @hide Should this process state be considered a background state? */public static final boolean isProcStateBackground(int procState) &#123; return procState &gt;= PROCESS_STATE_BACKUP;&#125; 该方法用来判断，一个进程是否是后台进程！！ http://melove.net/blog/2017/03/android-daemon-service-1488942411000.html http://www.cnblogs.com/angeldevil/category/336548.html http://blog.csdn.net/ccjhdopc/article/details/52818012 http://blog.csdn.net/ccjhdopc/article/details/52818012","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Process进程","slug":"AndroidFramework源码分析/Process进程","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Process进程/"}],"tags":[{"name":"Process进程","slug":"Process进程","permalink":"https://coolqi.top/tags/Process进程/"}]},{"title":"Serivce 篇 3 - stopService 流程分析","slug":"Serivce3-stopService","date":"2016-04-03T12:46:25.000Z","updated":"2018-11-20T16:33:44.000Z","comments":true,"path":"2016/04/03/Serivce3-stopService/","link":"","permalink":"https://coolqi.top/2016/04/03/Serivce3-stopService/","excerpt":"","text":"本文基于 Android 7.1.1 源码分析，转载请说明出处！ 0 综述我们通过 startService 启动的服务，需要通过 stopService 来停止： 1context.stopService(intent); 以前我们只是会调用，但是其底层的调用到底是什么样的呢？知其然知其所以然，今天我们就来学习下 stopService 的过程！ 如果之前并不了解这块逻辑的话，那该如何去学习呢？ follow the funtion path！ 1 发起端进程1.1 ContextWrapper.stopService12345678910111213public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; @Override public boolean stopService(Intent name) &#123; return mBase.stopService(name); &#125; &#125; ContextWrapper 提供了两个方法来启动 Service，其中一个是隐藏方法：startServiceAsUser！ mBase 是 ContextImpl 对象，继续看！ 1.2 ContextImpl.stopService1234567891011class ContextImpl extends Context &#123; @Override public boolean stopService(Intent service) &#123; // 这里判断调用者是否是系统进程； warnIfCallingFromSystemProcess(); //【1】继续停止服务！ return stopServiceCommon(service, mUser); &#125;&#125; 这里调用了 warnIfCallingFromSystemProcess，判断是否是系统进程调用！123456private void warnIfCallingFromSystemProcess() &#123; if (Process.myUid() == Process.SYSTEM_UID) &#123; Slog.w(TAG, \"Calling a method in the system process without a qualified user: \" + Debug.getCallers(5)); &#125;&#125; ContextImpl 和 ContextWrapper 的具体关系，请来看另一博文：Android 系统的 Context 分析，这里我们不再详细说明！ mUser：表示的是当前的设备 user！ 最终，调用了 stopServiceCommon 方法； 1.3 ContextImpl.stopServiceCommon123456789101112131415161718private boolean stopServiceCommon(Intent service, UserHandle user) &#123; try &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); //【1】进入到系统进程，停止服务！ int res = ActivityManagerNative.getDefault().stopService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( \"Not allowed to stop service \" + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; validateServiceIntent 方法用用来校验启动用的 intent 是否安全：123456789101112private void validateServiceIntent(Intent service) &#123; if (service.getComponent() == null &amp;&amp; service.getPackage() == null) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; IllegalArgumentException ex = new IllegalArgumentException( \"Service Intent must be explicit: \" + service); throw ex; &#125; else &#123; Log.w(TAG, \"Implicit intents with startService are not safe: \" + service + \" \" + Debug.getCallers(2, 3)); &#125; &#125;&#125; 如果 intent 既没有设置 component 也没有设置 package，那就要判断一下系统的版本了: 如果系统版本不低于 L，那就要抛出异常，提示必须是显示启动； 如果系统版本低于 L，那只提示隐式启动不安全； 接着，调用 ActivityManagerNative.getDefault() 方法，获得 AMS 的代理对象 ActivityManagerProxy！ ActivityManagerProxy 是 ActivityManagerN 的内部类，通过 getDefault 方法创建了对应的单例模式，保存在 ActivityManagerNative 的类变量 getDefault 中！ 1.4 ActivityManagerP.stopService12345678910111213141516171819202122public int stopService(IApplicationThread caller, Intent service, String resolvedType, int userId) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); service.writeToParcel(data, 0); data.writeString(resolvedType); data.writeInt(userId); //【1】binder 通信，阻塞式通信！！ mRemote.transact(STOP_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); reply.recycle(); data.recycle(); return res;&#125; 通过 binder 进程间通信，进入系统进程，参数分析： IApplicationThread caller：调用者进程的 ApplicationThread 对象，实现了 IApplicationThread 接口； Intent service：启动的 intent； String resolvedType：这个 intent 的 MIME 类型； String callingPackage：启动者所属包名； int userId：设备用户 id； 2 系统进程接下来，进入系统进程的 ActivityManagerService 中！ 首先要进入 ActivityManagerN.onTransact 方法！1234567891011121314151617case STOP_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); Intent service = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); int userId = data.readInt(); //【1】继续调用 stopService 方法！ int res = stopService(app, service, resolvedType, userId); reply.writeNoException(); reply.writeInt(res); return true;&#125; 2.1 ActivityManagerS.stopService123456789101112131415161718@Overridepublic int stopService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; // 隔离进程不能调用这个方法！ enforceNotIsolatedCaller(\"stopService\"); // 不能用 intent 传递文件描述符！ if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; //【1】进入 ActiveServices return mServices.stopServiceLocked(caller, service, resolvedType, userId); &#125;&#125; mServices 是 ActivityManagerService 的一个内部管理对象，用于管理所有的 Service！ 2.2 ActiveServices.stopServiceLocked1234567891011121314151617181920212223242526272829303132333435int stopServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"stopService: \" + service + \" type=\" + resolvedType); // 获得调用者所在进程！ final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (caller != null &amp;&amp; callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when stopping service \" + service); &#125; //【1】查询要停止的服务的信息！ ServiceLookupResult r = retrieveServiceLocked(service, resolvedType, null, Binder.getCallingPid(), Binder.getCallingUid(), userId, false, false, false); if (r != null) &#123; if (r.record != null) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; //【2】继续停止服务！ stopServiceLocked(r.record); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return 1; &#125; return -1; &#125; return 0;&#125; 2.2.1 ActiveServices.retrieveServiceLocked根据 intent 来查询被启动服务的 ServiceRecord 对象，参数传递： boolean createIfNeeded：传入的是 true； boolean callingFromFg：表示是从前台调用，还是后台调用； boolean isBindExternal：表示 bind 的是否是 isolated, external 类型的服务，我们这里默认为 false； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207private ServiceLookupResult retrieveServiceLocked(Intent service, String resolvedType, String callingPackage, int callingPid, int callingUid, int userId, boolean createIfNeeded, boolean callingFromFg, boolean isBindExternal) &#123; ServiceRecord r = null; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"retrieveServiceLocked: \" + service + \" type=\" + resolvedType + \" callingUid=\" + callingUid); userId = mAm.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE, \"service\", null); // 从 ActiveServices 的 mServiceMap 中获得设备用户 userId 下的所有服务列表！ ServiceMap smap = getServiceMap(userId); // 如果 intent 有设置组件名，就从 smap.mServicesByName 中获取！ final ComponentName comp = service.getComponent(); if (comp != null) &#123; r = smap.mServicesByName.get(comp); &#125; // 如果 intent 没有设置组件名，就从 smap.mServicesByIntent 通过 filter 获得！ if (r == null &amp;&amp; !isBindExternal) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(service); r = smap.mServicesByIntent.get(filter); &#125; // 对于 external 类型的服务，只能限制其应用程序自己 bind！ if (r != null &amp;&amp; (r.serviceInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 &amp;&amp; !callingPackage.equals(r.packageName)) &#123; r = null; &#125; if (r == null) &#123; try &#123; // 通过 PMS，查询能够匹配 intent 的服务！ ResolveInfo rInfo = AppGlobals.getPackageManager().resolveService(service, resolvedType, ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING, userId); // 获得服务信息！ ServiceInfo sInfo = rInfo != null ? rInfo.serviceInfo : null; if (sInfo == null) &#123; Slog.w(TAG_SERVICE, \"Unable to start service \" + service + \" U=\" + userId + \": not found\"); return null; &#125; ComponentName name = new ComponentName( sInfo.applicationInfo.packageName, sInfo.name); // 如果服务类型是 external 的，那么 bind 时必须加 BIND_EXTERNAL_SERVICE 的标志！ // 不然会抛出安全异常！ if ((sInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) &#123; if (isBindExternal) &#123; if (!sInfo.exported) &#123; // 对于 external 类型的服务，必须要设置 android:exported 的值为 true，不然抛异常！ throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name + \" is not exported\"); &#125; // 对于 external 类型的服务，必须运行在隔离进程中！ if ((sInfo.flags &amp; ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name + \" is not an isolatedProcess\"); &#125; // 获得调用者应用的 ApplicationInfo 信息 ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo( callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId); if (aInfo == null) &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + \"could not resolve client package \" + callingPackage); &#125; sInfo = new ServiceInfo(sInfo); sInfo.applicationInfo = new ApplicationInfo(sInfo.applicationInfo); sInfo.applicationInfo.packageName = aInfo.packageName; sInfo.applicationInfo.uid = aInfo.uid; // 设置 ComponentName 对象！ name = new ComponentName(aInfo.packageName, name.getClassName()); service.setComponent(name); &#125; else &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE required for \" + name); &#125; &#125; else if (isBindExternal) &#123; throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name + \" is not an externalService\"); &#125; // 处理多用户的情况！ if (userId &gt; 0) &#123; if (mAm.isSingleton(sInfo.processName, sInfo.applicationInfo, sInfo.name, sInfo.flags) &amp;&amp; mAm.isValidSingletonCall(callingUid, sInfo.applicationInfo.uid)) &#123; userId = 0; smap = getServiceMap(0); &#125; sInfo = new ServiceInfo(sInfo); sInfo.applicationInfo = mAm.getAppInfoForUser(sInfo.applicationInfo, userId); &#125; // 根据 ComponentName 获得 ServiceRecord 对象！ r = smap.mServicesByName.get(name); if (r == null &amp;&amp; createIfNeeded) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(service.cloneFilter()); // 创建服务重启对象，这是一个 Runnable 对象！！ ServiceRestarter res = new ServiceRestarter(); BatteryStatsImpl.Uid.Pkg.Serv ss = null; BatteryStatsImpl stats = mAm.mBatteryStatsService.getActiveStatistics(); synchronized (stats) &#123; ss = stats.getServiceStatsLocked( sInfo.applicationInfo.uid, sInfo.packageName, sInfo.name); &#125; // 创建新的 ServiceRecord 对象！ r = new ServiceRecord(mAm, ss, name, filter, sInfo, callingFromFg, res); res.setService(r); // 将新的 ServiceRecord 添加到 smap.mServicesByName 和 smap.mServicesByIntent 中！ smap.mServicesByName.put(name, r); smap.mServicesByIntent.put(filter, r); // 从 mPendingServices 中移除这个 ServiceRecord！ for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord pr = mPendingServices.get(i); if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid &amp;&amp; pr.name.equals(name)) &#123; mPendingServices.remove(i); &#125; &#125; &#125; &#125; catch (RemoteException ex) &#123; // pm is in same process, this will never happen. &#125; &#125; // 下面对查询的数据进行封装！ if (r != null) &#123; if (mAm.checkComponentPermission(r.permission, callingPid, callingUid, r.appInfo.uid, r.exported) != PackageManager.PERMISSION_GRANTED) &#123; // 检查权限如果不授予！ if (!r.exported) &#123; Slog.w(TAG, \"Permission Denial: Accessing service \" + r.name + \" from pid=\" + callingPid + \", uid=\" + callingUid + \" that is not exported from uid \" + r.appInfo.uid); // 异常返回，_record 为 null，无法启动！ return new ServiceLookupResult(null, \"not exported from uid \" + r.appInfo.uid); &#125; Slog.w(TAG, \"Permission Denial: Accessing service \" + r.name + \" from pid=\" + callingPid + \", uid=\" + callingUid + \" requires \" + r.permission); // 异常返回，_record 为 null，无法启动！ return new ServiceLookupResult(null, r.permission); &#125; else if (r.permission != null &amp;&amp; callingPackage != null) &#123; final int opCode = AppOpsManager.permissionToOpCode(r.permission); if (opCode != AppOpsManager.OP_NONE &amp;&amp; mAm.mAppOpsService.noteOperation( opCode, callingUid, callingPackage) != AppOpsManager.MODE_ALLOWED) &#123; Slog.w(TAG, \"Appop Denial: Accessing service \" + r.name + \" from pid=\" + callingPid + \", uid=\" + callingUid + \" requires appop \" + AppOpsManager.opToName(opCode)); // 异常返回，无法启动！ return null; &#125; &#125; if (!mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid, resolvedType, r.appInfo)) &#123; // 异常返回，无法启动！ return null; &#125; // 返回最终的服务封装类！！ return new ServiceLookupResult(r, null); &#125; return null;&#125; 这个方法的最终目的是返回要启动的服务的信息封装对象 ServiceLookupResult！ 2.3 ActiveServices.stopServiceLocked1234567891011121314151617181920212223242526272829303132private void stopServiceLocked(ServiceRecord service) &#123; //【1】如果服务是延迟启动的，但是还没有启动！ if (service.delayed) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Delaying stop of pending: \" + service); // 那就设置 delayedStop 为 true，这样服务在延迟启动时会判断这个变量，如果为 true，就不会启动这个服务！ service.delayedStop = true; return; &#125; synchronized (service.stats.getBatteryStats()) &#123; service.stats.stopRunningLocked(); &#125; //【2】因为要停止服务了，所以设 startRequested 为 false！ service.startRequested = false; if (service.tracker != null) &#123; // 停止监控！ service.tracker.setStarted(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); &#125; //【3】设置 callStart 为 false！ service.callStart = false; //【4】停止服务！！ bringDownServiceIfNeededLocked(service, false, false);&#125; 2.4 ActiveServices.bringDownServiceIfNeededLocked12345678910111213141516private final void bringDownServiceIfNeededLocked(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; //【1】如果这个服务还被需要，就不能停止！ if (isServiceNeeded(r, knowConn, hasConn)) &#123; return; &#125; // 如果该服务正在等待其进程启动，就不能停止！ if (mPendingServices.contains(r)) &#123; return; &#125; //【2】继续停止服务！ bringDownServiceLocked(r);&#125; 如果这个服务仍然被需要，或者服务所在的进程正在启动，这两种情况下，不能停止服务！ 2.4.1 ActiveServices.isServiceNeeded123456789101112131415private final boolean isServiceNeeded(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; if (r.startRequested) &#123; // 显然 r.startRequested 已经被置为 false！ return true; &#125; // 如果仍然有自动创建的连接，那就不能 stop 该服务！ if (!knowConn) &#123; hasConn = r.hasAutoCreateConnections(); &#125; if (hasConn) &#123; return true; &#125; return false;&#125; 判断一个服务是否仍被需要，有两种情况： 服务已经被请求启动，stopService 前面会被置为 false； 服务被应用通过自动创建的方式绑定，即 bindService 时，flags 为 Context.BIND_AUTO_CREATE； 继续来看！ 2.5 ActiveServices.bringDownServiceLocked我们来看看 bringDownServiceLocked 方法做了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171private final void bringDownServiceLocked(ServiceRecord r) &#123; //Slog.i(TAG, \"Bring down service:\"); //r.dump(\" \"); //【1】首先，遍历 r.connections 集合，终止所有的 bind 连接 for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; c = r.connections.valueAt(conni); for (int i=0; i&lt;c.size(); i++) &#123; ConnectionRecord cr = c.get(i); // 设置 serviceDead 为 true，表示服务要被 stop 掉，连接断开！ cr.serviceDead = true; try &#123; // 1、Binder 调用，进入应用进程触发 ServiceConnection 的 onServiceDisconnected，这是非阻塞的！ // 这里第二个参数，为 null，所以会触发 onServiceDisconnected！ cr.conn.connected(r.name, null); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Failure disconnecting service \" + r.name + \" to connection \" + c.get(i).conn.asBinder() + \" (in \" + c.get(i).binding.client.processName + \")\", e); &#125; &#125; &#125; //【2】处理所有的 r.bindings 集合中的 IntentBindRecord 对象！ if (r.app != null &amp;&amp; r.app.thread != null) &#123; for (int i=r.bindings.size()-1; i&gt;=0; i--) &#123; IntentBindRecord ibr = r.bindings.valueAt(i); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing down binding \" + ibr + \": hasBound=\" + ibr.hasBound); if (ibr.hasBound) &#123; try &#123; // 设置 unbind 超时处理 bumpServiceExecutingLocked(r, false, \"bring down unbind\"); mAm.updateOomAdjLocked(r.app); // 置 IntentBindRecord 对象的 hasBound 为 false，表示 bind 断开； ibr.hasBound = false; //【2.1】通过 bind 通信，进入服务的应用进程，调用 AT.scheduleUnbindService 方法 // ，拉起服务的 onUnbind 方法，接触绑定！ r.app.thread.scheduleUnbindService(r, ibr.intent.getIntent()); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when unbinding service \" + r.shortName, e); serviceProcessGoneLocked(r); &#125; &#125; &#125; &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing down \" + r + \" \" + r.intent); // 设置服务的销毁时间 r.destroyTime = SystemClock.uptimeMillis(); if (LOG_SERVICE_START_STOP) &#123; EventLogTags.writeAmDestroyService( r.userId, System.identityHashCode(r), (r.app != null) ? r.app.pid : -1); &#125; final ServiceMap smap = getServiceMap(r.userId); // 从 ActiveServices 的 mServiceMap 中移除服务 ServiceRecord 对象！ smap.mServicesByName.remove(r.name); smap.mServicesByIntent.remove(r.intent); // 重启参数置为 0 r.totalRestartCount = 0; // 取消重启任务 unscheduleServiceRestartLocked(r, 0, true); // 从 mPendingServices 列表中移除！ for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; if (mPendingServices.get(i) == r) &#123; mPendingServices.remove(i); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Removed pending: \" + r); &#125; &#125; // 取消前台的通知！ cancelForegroudNotificationLocked(r); r.isForeground = false; r.foregroundId = 0; r.foregroundNoti = null; // 清理启动项集合！ r.clearDeliveredStartsLocked(); r.pendingStarts.clear(); if (r.app != null) &#123; synchronized (r.stats.getBatteryStats()) &#123; r.stats.stopLaunchedLocked(); &#125; // 将服务从其所在进程的 app.services 集合中删除！ r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; if (r.app.thread != null) &#123; updateServiceForegroundLocked(r.app, false); try &#123; // 设置 destroy 超时处理！ bumpServiceExecutingLocked(r, false, \"destroy\"); // 将其添加到 AS 的 mDestroyingServices 机和中，表示服务正在销毁！ mDestroyingServices.add(r); r.destroying = true; mAm.updateOomAdjLocked(r.app); // 3、通过 binder 通信，回调 AT 的 scheduleStopService 方法！ r.app.thread.scheduleStopService(r); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Exception when destroying service \" + r.shortName, e); serviceProcessGoneLocked(r); &#125; &#125; else &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Removed service that has no process: \" + r); &#125; &#125; else &#123; if (DEBUG_SERVICE) Slog.v( TAG_SERVICE, \"Removed service that is not running: \" + r); &#125; // 清空服务的 bindings 集合！ if (r.bindings.size() &gt; 0) &#123; r.bindings.clear(); &#125; // 将服务的重启任务对象置空！ if (r.restarter instanceof ServiceRestarter) &#123; ((ServiceRestarter)r.restarter).setService(null); &#125; int memFactor = mAm.mProcessStats.getMemFactorLocked(); long now = SystemClock.uptimeMillis(); if (r.tracker != null) &#123; r.tracker.setStarted(false, memFactor, now); r.tracker.setBound(false, memFactor, now); if (r.executeNesting == 0) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; smap.ensureNotStartingBackground(r);&#125; 这段代码很简单，主要逻辑如下： 首先进入绑定服务的应用进程，回调 ServiceConnection 的 onServiceDisconnected 方法，取消所有进程对该服务的绑定； 接着，进入服务所在的进程，拉起服务的 onUnbind 方法； 最后，拉起服务的 onDestroy 方法，销毁服务； 整个过程，还会清空和重置一些关键变量！！ 下面我们重点分析一下上面的三个过程！ 3 绑定者进程系统进程会调用 IServiceConnection.Proxy 代理对象的 connected 方法，通过 binder 调用，进入绑定服务的应用进程，这个是异步调用： 1cr.conn.connected(r.name, null); 我们去看看！ 3.1 InnerConnection.connected123456789101112131415161718private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; // 调用 mDispatcher 对象的 connected，这里的 service 为 null； sd.connected(name, service); &#125; &#125;&#125; 继续来看： 3.2 ServiceDispatcher.connected123456789public void connected(ComponentName name, IBinder service) &#123; if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnected(name, service); &#125;&#125; 看过 bindService 一文的朋友，应该知道，最后都会调用 doConnected 方法： 3.3 ServiceDispatcher.doConnected参数 service 这里为 null！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void doConnected(ComponentName name, IBinder service) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; if (mForgotten) &#123; return; &#125; // 获得已有的活跃的 connection 对象！ old = mActiveConnections.get(name); if (old != null &amp;&amp; old.binder == service) &#123; // 因为 service 为 null，所以这里不会进入该分支！ return; &#125; if (service != null) &#123; // A new service is being connected... set it all up. info = new ConnectionInfo(); info.binder = service; info.deathMonitor = new DeathMonitor(name, service); try &#123; service.linkToDeath(info.deathMonitor, 0); mActiveConnections.put(name, info); &#125; catch (RemoteException e) &#123; // This service was dead before we got it... just // don't do anything with it. mActiveConnections.remove(name); return; &#125; &#125; else &#123; // service 为 null，说明是解除绑定，所以要从 mActiveConnections 中移除绑定对象！ mActiveConnections.remove(name); &#125; // 取消死亡通知监控器 if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // 之前是有连接的，所以会进入这分支！！ if (old != null) &#123; // 拉起服务的 onServiceDisconnected 方法！ mConnection.onServiceDisconnected(name); &#125; // 不进入这个分支！ if (service != null) &#123; mConnection.onServiceConnected(name, service); &#125;&#125; 这里，最后会进入应用的 ServiceConnection 对象！123456private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125; 注意，onServiceDisconnected 方法是非阻塞的，即，系统进程不会等 onServiceDisconnected 执行完才继续执行！！ 4 服务所在进程我们先回到系统进程 bringDownServiceLocked 方法中：12345678// 拉起服务的 onUnbind 方法；r.app.thread.scheduleUnbindService(r, ibr.intent.getIntent()); ... ... ... ...// 拉起服务的 onDestroy 方法；r.app.thread.scheduleStopService(r); 这两个方法，都通过 ApplicationThreadProxy 对象进行 bind 通信，我们下面来逐个分析： 4.1 ApplicationThread.scheduleUnbindService参数 IBinder token 就是 ServiceRecord 对象！ 12345678910111213public final void scheduleUnbindService(IBinder token, Intent intent) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); intent.writeToParcel(data, 0); // 这里也是异步调用 IBinder.FLAG_ONEWAY！ mRemote.transact(SCHEDULE_UNBIND_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 可以看出 scheduleUnbindService 方法的 binder 通信是 IBinder.FLAG_ONEWAY 方式！ 4.2 ApplicationThreadP.scheduleStopService参数 IBinder token 就是 ServiceRecord 对象！ 123456789101112public final void scheduleStopService(IBinder token) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); // 这里也是异步调用 IBinder.FLAG_ONEWAY！ mRemote.transact(SCHEDULE_STOP_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 可以看出 scheduleStopService 方法的 binder 通信是 IBinder.FLAG_ONEWAY 方式！ 下面是真正进入了应用程序进程！ 4.3 ApplicationThreadN.onTransact12345678910111213141516171819202122case SCHEDULE_UNBIND_SERVICE_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder token = data.readStrongBinder(); Intent intent = Intent.CREATOR.createFromParcel(data); // 进入 ActivityThread.scheduleUnbindService ! scheduleUnbindService(token, intent); return true;&#125;case SCHEDULE_STOP_SERVICE_TRANSACTION:&#123; data.enforceInterface(IApplicationThread.descriptor); IBinder token = data.readStrongBinder(); // 进入 ActivityThread.scheduleStopService！ scheduleStopService(token); return true;&#125; 4.4 ApplicationThread接着，进入 ApplicationThread！！ 4.4.1 ApplicationThread.scheduleUnbindService12345678910public final void scheduleUnbindService(IBinder token, Intent intent) &#123; BindServiceData s = new BindServiceData(); // ServiceRecord 对象！ s.token = token; s.intent = intent; // 发送 msg：H.UNBIND_SERVICE sendMessage(H.UNBIND_SERVICE, s);&#125; 4.4.2 ApplicationThread.scheduleStopService12345public final void scheduleStopService(IBinder token) &#123; // 发送 msg：H.STOP_SERVICE sendMessage(H.STOP_SERVICE, token);&#125; 4.5 ActivityThread.H1234567891011121314151617181920private class H extends Handler &#123; public void handleMessage(Message msg) &#123; case UNBIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceUnbind\"); handleUnbindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceStop\"); handleStopService((IBinder)msg.obj); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125;&#125; 这里很简单，我们继续看： 4.5.1 ActivityThread.handleUnbindService首先会拉起 Serivce 的 onUnbind 方法！ 1234567891011121314151617181920212223242526272829303132333435363738private void handleUnbindService(BindServiceData data) &#123; // 从 AT 的托管集合 mServices 获得 Service 对象！ Service s = mServices.get(data.token); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); // 拉起服务的 onUnbind，onUnbind 的返回值表示，是否重新 rebind 服务，默认返回 false！ boolean doRebind = s.onUnbind(data.intent); try &#123; if (doRebind) &#123; // 如果 doRebind 为 true，进入这里！ ActivityManagerNative.getDefault().unbindFinished( data.token, data.intent, doRebind); &#125; else &#123; // 默认为 false，进入这里！ ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to unbind to service \" + s + \" with \" + data.intent + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; 如果 onUnbind 方法返回 true，并且服务被解绑后没有被销毁，下次被绑定时，会拉起 onRebind 方法！ 4.5.2 ActivityThread.handleStopService最后，拉起 Serivce 的 onDestroy 方法！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void handleStopService(IBinder token) &#123; // 将服务从 AT 的托管集合 mServices 中移除！ Service s = mServices.remove(token); if (s != null) &#123; try &#123; if (localLOGV) Slog.v(TAG, \"Destroying service \" + s); // 拉起 onDestory 方法！ s.onDestroy(); Context context = s.getBaseContext(); if (context instanceof ContextImpl) &#123; final String who = s.getClassName(); // 执行清理操作！ ((ContextImpl) context).scheduleFinalCleanup(who, \"Service\"); &#125; QueuedWork.waitToFinish(); try &#123; // 最后，执行 serviceDoneExecuting 方法！ ActivityManagerNative.getDefault().serviceDoneExecuting( token, SERVICE_DONE_EXECUTING_STOP, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to stop service \" + s + \": \" + e.toString(), e); &#125; Slog.i(TAG, \"handleStopService: exception for \" + token, e); &#125; &#125; else &#123; Slog.i(TAG, \"handleStopService: token=\" + token + \" not found.\"); &#125; //Slog.i(TAG, \"Running services: \" + mServices);&#125; 这里逻辑很清楚，我们继续来看，接下来，调用 ActivityManagerP 相关的方法！ 4.6 ActivityManagerProxy123456789101112131415161718192021222324252627282930313233343536373839// 对于 onUnbind 返回 true 的情况!public void unbindFinished(IBinder token, Intent intent, boolean doRebind) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(token); intent.writeToParcel(data, 0); data.writeInt(doRebind ? 1 : 0); // flags 为 0 mRemote.transact(UNBIND_FINISHED_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125;// 对于 onUnbind 返回默认 false 的情况// 和拉起 onDestory 方法后！public void serviceDoneExecuting(IBinder token, int type, int startId, int res) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(token); data.writeInt(type); data.writeInt(startId); data.writeInt(res); // flags 为 IBinder.FLAG_ONEWAY，非阻塞式的 mRemote.transact(SERVICE_DONE_EXECUTING_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY); reply.readException(); data.recycle(); reply.recycle();&#125; 发送了 UNBIND_FINISHED_TRANSACTION 和 SERVICE_DONE_EXECUTING_TRANSACTION 消息！ unbindFinished 的 binder 通信是同步的，serviceDoneExecuting 的 binder 通信是异步的！ 5 系统进程首先会进入 ActivityManagerNative 的 onTransact 方法中：12345678910111213141516171819202122232425262728case UNBIND_FINISHED_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); Intent intent = Intent.CREATOR.createFromParcel(data); boolean doRebind = data.readInt() != 0; // 继续来看！ unbindFinished(token, intent, doRebind); reply.writeNoException(); return true;&#125;case SERVICE_DONE_EXECUTING_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); int type = data.readInt(); int startId = data.readInt(); int res = data.readInt(); // 继续来看！ serviceDoneExecuting(token, type, startId, res); reply.writeNoException(); return true;&#125; 接下来，进入 AMS! 5.1 ActivityManagerS.unbindFinished12345678910111213public void unbindFinished(IBinder token, Intent intent, boolean doRebind) &#123; // 不能通过 intent 传递文件描述符！ if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; // 进入 ActiveServices！ mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind); &#125;&#125; 5.1.1 ActiveServices.unbindFinishedLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void unbindFinishedLocked(ServiceRecord r, Intent intent, boolean doRebind) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; if (r != null) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(intent); // 获得绑定 Serivce 的 intent 对应的 IntentBindRecord 对象！ IntentBindRecord b = r.bindings.get(filter); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"unbindFinished in \" + r + \" at \" + b + \": apps=\" + (b != null ? b.apps.size() : 0)); // 这里的 inDestroying 的值为 false，因为还没有添加！ boolean inDestroying = mDestroyingServices.contains(r); // 显然，这里不会为 null！ if (b != null) &#123; if (b.apps.size() &gt; 0 &amp;&amp; !inDestroying) &#123; // Applications have already bound since the last // unbind, so just rebind right here. boolean inFg = false; for (int i=b.apps.size()-1; i&gt;=0; i--) &#123; ProcessRecord client = b.apps.valueAt(i).client; if (client != null &amp;&amp; client.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND) &#123; inFg = true; break; &#125; &#125; try &#123; requestServiceBindingLocked(r, b, inFg, true); &#125; catch (TransactionTooLargeException e) &#123; // Don't pass this back to ActivityThread, it's unrelated. &#125; &#125; else &#123; // 将 doRebind 置为 true！ b.doRebind = true; &#125; &#125; // 最后进入 serviceDoneExecutingLocked 方法！ serviceDoneExecutingLocked(r, inDestroying, false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 接着来看！ 5.1.2 ActiveServices.serviceDoneExecutingLocked参数传递： boolean inDestroying：传入 false； boolean finishing：传入 false； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&lt;&lt;&lt; DONE EXECUTING \" + r + \": nesting=\" + r.executeNesting + \", inDestroying=\" + inDestroying + \", app=\" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&lt;&lt;&lt; DONE EXECUTING \" + r.shortName); r.executeNesting--; if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); // 从所在进程的 executingServices 中删除该服务！ r.app.execServicesFg = false; r.app.executingServices.remove(r); if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); // 如果进程中没有在执行指定代码逻辑的服务了，就取消超市任务！ mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // 如果进程还有在执行指定代码逻辑的服务，并且有服务在前台执行，那就要将进程的 execServicesFg 置为 ture for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; // 不进入！ if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); mDestroyingServices.remove(r); r.bindings.clear(); &#125; // 更新 oomAdj 值！ mAm.updateOomAdjLocked(r.app); &#125; // 置服务的 executeFg 为 false； r.executeFg = false; if (r.tracker != null) &#123; r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); if (finishing) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; if (finishing) &#123; // 不进入这个分支！ if (r.app != null &amp;&amp; !r.app.persistent) &#123; r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; &#125; r.app = null; &#125; &#125;&#125; 这里就不再详细说了！！ 5.2 ActivityManagerS.serviceDoneExecuting对于拉起 onDestroy 方法，最后会调用1234567891011public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; Slog.e(TAG, \"serviceDoneExecuting: Invalid service token=\" + token); throw new IllegalArgumentException(\"Invalid service token\"); &#125; // 最后，进入 AS！ mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res); &#125;&#125; 接着，进入 ActiveServices！ 5.2.1 ActiveServices.serviceDoneExecutingLocked根据参数传递： int type：传入 ActivityThread.SERVICE_DONE_EXECUTING_STOP； int startId：传入 0； int res：传入 0； 1234567891011121314151617181920212223242526272829303132333435363738394041424344void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123; // 这里的 inDestroying 为 true，因为我们之前已经将该服务添加到 mDestroyingServices！ boolean inDestroying = mDestroyingServices.contains(r); if (r != null) &#123; if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123; ... ... ... // 这里是和 startService 服务有关，我们这里不看！ &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123; // This is the final call from destroying the service... we should // actually be getting rid of the service at this point. Do some // validation of its state, and ensure it will be fully removed. if (!inDestroying) &#123; // Not sure what else to do with this... if it is not actually in the // destroying list, we don't need to make sure to remove it from it. // If the app is null, then it was probably removed because the process died, // otherwise wtf if (r.app != null) &#123; Slog.w(TAG, \"Service done with onDestroy, but not inDestroying: \" + r + \", app=\" + r.app); &#125; &#125; else if (r.executeNesting != 1) &#123; Slog.w(TAG, \"Service done with onDestroy, but executeNesting=\" + r.executeNesting + \": \" + r); // Fake it to keep from ANR due to orphaned entry. r.executeNesting = 1; &#125; &#125; final long origId = Binder.clearCallingIdentity(); // 最后，再次调用 serviceDoneExecutingLocked！ serviceDoneExecutingLocked(r, inDestroying, inDestroying); Binder.restoreCallingIdentity(origId); &#125; else &#123; Slog.w(TAG, \"Done executing unknown service from pid \" + Binder.getCallingPid()); &#125;&#125; 5.2.2 ActiveServices.serviceDoneExecutingLocked参数传递： boolean inDestroying：传入 true； boolean finishing：传入 true； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&lt;&lt;&lt; DONE EXECUTING \" + r + \": nesting=\" + r.executeNesting + \", inDestroying=\" + inDestroying + \", app=\" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&lt;&lt;&lt; DONE EXECUTING \" + r.shortName); r.executeNesting--; if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); // 从所在进程的 executingServices 中删除该服务！ r.app.execServicesFg = false; r.app.executingServices.remove(r); if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); // 如果进程中没有在执行指定代码逻辑的服务了，就取消超市任务！ mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // 如果进程还有在执行指定代码逻辑的服务，并且有服务在前台执行，那就要将进程的 execServicesFg 置为 ture for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; // inDestroying 为 true 进入！ if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); // 从 mDestroyingServices 中删除 ServiceRecord！ mDestroyingServices.remove(r); // 清空其 bindings 集合！ r.bindings.clear(); &#125; // 更新 oomAdj 值！ mAm.updateOomAdjLocked(r.app); &#125; // 置服务的 executeFg 为 false； r.executeFg = false; if (r.tracker != null) &#123; r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); // 取消对服务的监控！ if (finishing) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; if (finishing) &#123; // finishing 为 true ，进入这个分支！ if (r.app != null &amp;&amp; !r.app.persistent) &#123; // 如果服务所在的进程不是常驻进程，从进程的 services 中移除这个服务！ r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; &#125; r.app = null; &#125; &#125;&#125; 到这里，stopService 的整个过程，就分析完了！！ 6 总结我们来回顾一下，整个 stopService 的过程，都遇到了那些重要的数据结构！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"JobScheduler第 2 篇 - JobSchedulerService 的启动","slug":"JobScheduler2-JobSchedulerServiceStartProcess","date":"2016-04-02T12:46:25.000Z","updated":"2018-11-20T17:41:54.000Z","comments":true,"path":"2016/04/02/JobScheduler2-JobSchedulerServiceStartProcess/","link":"","permalink":"https://coolqi.top/2016/04/02/JobScheduler2-JobSchedulerServiceStartProcess/","excerpt":"","text":"基于 Android 7.1.1 源码分析，本文为原创，转载请说明出处。。。 0 前言JobSchedulerService 服务的启动，是在 SystemServer 的 startOtherServices 方法中：123456789private void startOtherServices() &#123; ... mSystemServiceManager.startService(JobSchedulerService.class); ...&#125; 这个方法首先会调用服务的 Constructer，然后调用服务的 onStart 方法！ 同时，在 ActivityManagerService.systemReady 方法中，会调用如下的方法： 12// 启动当前的设备用户！mSystemServiceManager.startUser(currentUserId); 该方法的细节如下：12345678910111213141516public void startUser(final int userHandle) &#123; final int serviceLen = mServices.size(); for (int i = 0; i &lt; serviceLen; i++) &#123; final SystemService service = mServices.get(i); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"onStartUser \" + service.getClass().getName()); try &#123; // 拉起所有 SystemService 的子类的 onStartUser 方法！ service.onStartUser(userHandle); &#125; catch (Exception ex) &#123; Slog.wtf(TAG, \"Failure reporting start of user \" + userHandle + \" to service \" + service.getClass().getName(), ex); &#125; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125;&#125; 1 JobSchedulerService我们先来看 JobSchedulerService 的构造器：12345678910111213141516171819202122public JobSchedulerService(Context context) &#123; super(context); // 创建主线程的 looper，创建对应的 Handler mHandler = new JobHandler(context.getMainLooper()); mConstants = new Constants(mHandler); // 创建 binder 服务端 mJobSchedulerStub = new JobSchedulerStub(); // 初始化 JobStore 对象！ mJobs = JobStore.initAndGet(this); // Create the controllers. mControllers = new ArrayList&lt;StateController&gt;(); mControllers.add(ConnectivityController.get(this)); mControllers.add(TimeController.get(this)); mControllers.add(IdleController.get(this)); mControllers.add(BatteryController.get(this)); mControllers.add(AppIdleController.get(this)); mControllers.add(ContentObserverController.get(this)); mControllers.add(DeviceIdleJobsController.get(this));&#125; 这里构造器其中，创建了一些很重要的成员变量，其中多个控制器： ConnectivityController：用于监听网络连接状态的广播； DeviceIdleJobsController： ContentObserverController：用于监听数据库的变化； AppIdleController：用于监听 app 是否处于空闲状态； BatteryController：用于监听电池是否充电,电量状态的广播； IdleController：用于监听屏幕亮 / 灭，进入 / 退出睡眠，状态改变的广播； TimeController：用于监听 job 时间范围的广播； 下图展示了 这几个主要的 Controller 之间的关系： （图先省略啦，后续补上，哈哈） 可以看到，他们都继承了 StateController 类，我们后面来分析控制器！ 1.1 JobStoreJobStore 方法的作用是存储了管理系统中存储的所有注册过的 JobStore： 1234567891011121314151617181920212223242526272829303132333435363738public class JobStore &#123; private static final String TAG = \"JobStore\"; private static final boolean DEBUG = JobSchedulerService.DEBUG; /** Threshold to adjust how often we want to write to the db. */ private static final int MAX_OPS_BEFORE_WRITE = 1; final Object mLock; final JobSet mJobSet; // per-caller-uid tracking // 存储 jobs.xml 中的数据 final Context mContext; private int mDirtyOperations; private static final Object sSingletonLock = new Object(); private final AtomicFile mJobsFile; // 只向本地文件: /system/job/jobs.xml /** Handler backed by IoThread for writing to disk. */ private final Handler mIoHandler = IoThread.getHandler(); private static JobStore sSingleton; /** Used by the &#123;@link JobSchedulerService&#125; to instantiate the JobStore. */ static JobStore initAndGet(JobSchedulerService jobManagerService) &#123; synchronized (sSingletonLock) &#123; if (sSingleton == null) &#123; sSingleton = new JobStore(jobManagerService.getContext(), jobManagerService.getLock(), Environment.getDataDirectory()); &#125; return sSingleton; &#125; &#125; /** * Construct the instance of the job store. This results in a blocking read from disk. */ private JobStore(Context context, Object lock, File dataDir) &#123; mLock = lock; mContext = context; mDirtyOperations = 0; File systemDir = new File(dataDir, \"system\"); File jobDir = new File(systemDir, \"job\"); jobDir.mkdirs(); mJobsFile = new AtomicFile(new File(jobDir, \"jobs.xml\")); mJobSet = new JobSet(); readJobMapFromDisk(mJobSet); // 从 Jobs.xml 中读取数据，初始化 JobSet！ &#125; 上面是 JobStore 的初始化操作，该方法会创建 job 目录以及 jobs.xml 文件, 以及从文件中读取所有的 JobStatus。 1.1.1 readJobMapFromDisk这个方法创建了一个 Runnable 去实现具体的业务！1234@VisibleForTestingpublic void readJobMapFromDisk(JobSet jobSet) &#123; new ReadJobMapFromDiskRunnable(jobSet).run();&#125; 从 Jobs.xml 文件中读取数据：12345678910111213141516171819202122232425262728293031323334353637383940private class ReadJobMapFromDiskRunnable implements Runnable &#123; private final JobSet jobSet; /** * @param jobSet Reference to the (empty) set of JobStatus objects that back the JobStore, * so that after disk read we can populate it directly. */ ReadJobMapFromDiskRunnable(JobSet jobSet) &#123; this.jobSet = jobSet; &#125; @Override public void run() &#123; try &#123; List&lt;JobStatus&gt; jobs; FileInputStream fis = mJobsFile.openRead(); synchronized (mLock) &#123; jobs = readJobMapImpl(fis); if (jobs != null) &#123; for (int i=0; i&lt;jobs.size(); i++) &#123; this.jobSet.add(jobs.get(i)); &#125; &#125; &#125; fis.close(); &#125; catch (FileNotFoundException e) &#123; if (JobSchedulerService.DEBUG) &#123; Slog.d(TAG, \"Could not find jobs file, probably there was nothing to load.\"); &#125; &#125; catch (XmlPullParserException e) &#123; if (JobSchedulerService.DEBUG) &#123; Slog.d(TAG, \"Error parsing xml.\", e); &#125; &#125; catch (IOException e) &#123; if (JobSchedulerService.DEBUG) &#123; Slog.d(TAG, \"Error parsing xml.\", e); &#125; &#125; &#125; ... ... ... ... &#125; 可以看出，调用了 readJobMapImpl 方法来解析 Jobs.xml ！ 1.1.2 readJobMapImpl123456789101112131415161718192021222324252627282930313233343536373839404142private List&lt;JobStatus&gt; readJobMapImpl(FileInputStream fis) throws XmlPullParserException, IOException &#123; ... ... ... ... String tagName = parser.getName(); if (\"job-info\".equals(tagName)) &#123; // 解析 &lt;job-info&gt; 标签，校验版本是否有问题 final List&lt;JobStatus&gt; jobs = new ArrayList&lt;JobStatus&gt;(); // Read in version info. try &#123; int version = Integer.parseInt(parser.getAttributeValue(null, \"version\")); if (version != JOBS_FILE_VERSION) &#123; Slog.d(TAG, \"Invalid version number, aborting jobs file read.\"); return null; &#125; &#125; catch (NumberFormatException e) &#123; Slog.e(TAG, \"Invalid version number, aborting jobs file read.\"); return null; &#125; eventType = parser.next(); do &#123; // Read each &lt;job/&gt; if (eventType == XmlPullParser.START_TAG) &#123; tagName = parser.getName(); // Start reading job. if (\"job\".equals(tagName)) &#123; // 解析&lt;job&gt; 标签，获得每个job 对应的 jobStatus 对象 JobStatus persistedJob = restoreJobFromXml(parser); if (persistedJob != null) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Read out \" + persistedJob); &#125; jobs.add(persistedJob); // 加入到缓存集合中，最后返回！ &#125; else &#123; Slog.d(TAG, \"Error reading job from file.\"); &#125; &#125; &#125; eventType = parser.next(); &#125; while (eventType != XmlPullParser.END_DOCUMENT); return jobs; &#125; return null;&#125; 这里是通过循环处理 jobs.xml 文件中的标签 1.1.3 restoreJobFromXml这个方法负责解析每个标签，返回每个任务对应的 JobStatus。注意这里只有重启设备后需要保留的 Job，才会写入 jobs.xml 文件中，即：这个 Job 是 isPersisted 的！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private JobStatus restoreJobFromXml(XmlPullParser parser) throws XmlPullParserException, IOException &#123; JobInfo.Builder jobBuilder; int uid, sourceUserId; try &#123; jobBuilder = buildBuilderFromXml(parser); jobBuilder.setPersisted(true); // 解析基本信息: uid、priority、flags 和 sourceUserId ！ uid = Integer.parseInt(parser.getAttributeValue(null, \"uid\")); String val = parser.getAttributeValue(null, \"priority\"); if (val != null) &#123; jobBuilder.setPriority(Integer.parseInt(val)); &#125; val = parser.getAttributeValue(null, \"flags\"); if (val != null) &#123; jobBuilder.setFlags(Integer.parseInt(val)); &#125; val = parser.getAttributeValue(null, \"sourceUserId\"); sourceUserId = val == null ? -1 : Integer.parseInt(val); &#125; catch (NumberFormatException e) &#123; Slog.e(TAG, \"Error parsing job's required fields, skipping\"); return null; &#125; // 解析获得 sourcePackageName 和 sourceTag！ String sourcePackageName = parser.getAttributeValue(null, \"sourcePackageName\"); final String sourceTag = parser.getAttributeValue(null, \"sourceTag\"); int eventType; // Read out constraints tag. do &#123; eventType = parser.next(); &#125; while (eventType == XmlPullParser.TEXT); // Push through to next START_TAG. if (!(eventType == XmlPullParser.START_TAG &amp;&amp; XML_TAG_PARAMS_CONSTRAINTS.equals(parser.getName()))) &#123; // Expecting a &lt;constraints&gt; start tag. return null; &#125; try &#123; buildConstraintsFromXml(jobBuilder, parser); &#125; catch (NumberFormatException e) &#123; Slog.d(TAG, \"Error reading constraints, skipping.\"); return null; &#125; parser.next(); // Consume &lt;/constraints&gt; // Read out execution parameters tag. do &#123; eventType = parser.next(); &#125; while (eventType == XmlPullParser.TEXT); if (eventType != XmlPullParser.START_TAG) &#123; return null; &#125; // Tuple of (earliest runtime, latest runtime) in elapsed realtime after disk load. Pair&lt;Long, Long&gt; elapsedRuntimes; try &#123; elapsedRuntimes = buildExecutionTimesFromXml(parser); &#125; catch (NumberFormatException e) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Error parsing execution time parameters, skipping.\"); &#125; return null; &#125; final long elapsedNow = SystemClock.elapsedRealtime(); if (XML_TAG_PERIODIC.equals(parser.getName())) &#123; try &#123; String val = parser.getAttributeValue(null, \"period\"); final long periodMillis = Long.valueOf(val); val = parser.getAttributeValue(null, \"flex\"); final long flexMillis = (val != null) ? Long.valueOf(val) : periodMillis; jobBuilder.setPeriodic(periodMillis, flexMillis); // As a sanity check, cap the recreated run time to be no later than flex+period // from now. This is the latest the periodic could be pushed out. This could // happen if the periodic ran early (at flex time before period), and then the // device rebooted. if (elapsedRuntimes.second &gt; elapsedNow + periodMillis + flexMillis) &#123; final long clampedLateRuntimeElapsed = elapsedNow + flexMillis + periodMillis; final long clampedEarlyRuntimeElapsed = clampedLateRuntimeElapsed - flexMillis; ... ... ... ... elapsedRuntimes = Pair.create(clampedEarlyRuntimeElapsed, clampedLateRuntimeElapsed); &#125; &#125; catch (NumberFormatException e) &#123; Slog.d(TAG, \"Error reading periodic execution criteria, skipping.\"); return null; &#125; &#125; else if (XML_TAG_ONEOFF.equals(parser.getName())) &#123; try &#123; if (elapsedRuntimes.first != JobStatus.NO_EARLIEST_RUNTIME) &#123; jobBuilder.setMinimumLatency(elapsedRuntimes.first - elapsedNow); &#125; if (elapsedRuntimes.second != JobStatus.NO_LATEST_RUNTIME) &#123; jobBuilder.setOverrideDeadline( elapsedRuntimes.second - elapsedNow); &#125; &#125; catch (NumberFormatException e) &#123; Slog.d(TAG, \"Error reading job execution criteria, skipping.\"); return null; &#125; &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"Invalid parameter tag, skipping - \" + parser.getName()); &#125; // Expecting a parameters start tag. return null; &#125; maybeBuildBackoffPolicyFromXml(jobBuilder, parser); parser.nextTag(); // Consume parameters end tag. // Read out extras Bundle. do &#123; eventType = parser.next(); &#125; while (eventType == XmlPullParser.TEXT); if (!(eventType == XmlPullParser.START_TAG &amp;&amp; XML_TAG_EXTRAS.equals(parser.getName()))) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Error reading extras, skipping.\"); &#125; return null; &#125; PersistableBundle extras = PersistableBundle.restoreFromXml(parser); jobBuilder.setExtras(extras); parser.nextTag(); // Consume &lt;/extras&gt; // Migrate sync jobs forward from earlier, incomplete representation if (\"android\".equals(sourcePackageName) &amp;&amp; extras != null &amp;&amp; extras.getBoolean(\"SyncManagerJob\", false)) &#123; sourcePackageName = extras.getString(\"owningPackage\", sourcePackageName); if (DEBUG) &#123; Slog.i(TAG, \"Fixing up sync job source package name from 'android' to '\" + sourcePackageName + \"'\"); &#125; &#125; // And now we're done JobStatus js = new JobStatus( jobBuilder.build(), uid, sourcePackageName, sourceUserId, sourceTag, elapsedRuntimes.first, elapsedRuntimes.second); return js;&#125; 这里面以后很多的细节，继续看： 1.1.3.1 buildBuilderFromXml用来创建 JobInfo：12345678private JobInfo.Builder buildBuilderFromXml(XmlPullParser parser) throws NumberFormatException &#123; // Pull out required fields from &lt;job&gt; attributes. int jobId = Integer.parseInt(parser.getAttributeValue(null, \"jobid\")); String packageName = parser.getAttributeValue(null, \"package\"); String className = parser.getAttributeValue(null, \"class\"); ComponentName cname = new ComponentName(packageName, className); return new JobInfo.Builder(jobId, cname);&#125; 这里使用了建造者模式：12345678910111213141516171819202122232425262728293031323334353637public static final class Builder &#123; private final int mJobId; private final ComponentName mJobService; private PersistableBundle mExtras = PersistableBundle.EMPTY; private int mPriority = PRIORITY_DEFAULT; private int mFlags; // Requirements. private boolean mRequiresCharging; private boolean mRequiresDeviceIdle; private int mNetworkType; private ArrayList&lt;TriggerContentUri&gt; mTriggerContentUris; private long mTriggerContentUpdateDelay = -1; private long mTriggerContentMaxDelay = -1; private boolean mIsPersisted; // One-off parameters. private long mMinLatencyMillis; private long mMaxExecutionDelayMillis; // Periodic parameters. private boolean mIsPeriodic; private boolean mHasEarlyConstraint; private boolean mHasLateConstraint; private long mIntervalMillis; private long mFlexMillis; // Back-off parameters. private long mInitialBackoffMillis = DEFAULT_INITIAL_BACKOFF_MILLIS; private int mBackoffPolicy = DEFAULT_BACKOFF_POLICY; /** Easy way to track whether the client has tried to set a back-off policy. */ private boolean mBackoffPolicySet = false; public Builder(int jobId, ComponentName jobService) &#123; mJobService = jobService; mJobId = jobId; &#125; ... ... ... ... &#125; 返回了 JobInfo 的内部类 Builder 的对象！ 1.1.3.2 buildConstraintsFromXml传入参数：JobInfo.Buidlder 和 XmlPullParser ：12345678910111213141516171819202122private void buildConstraintsFromXml(JobInfo.Builder jobBuilder, XmlPullParser parser) &#123; String val = parser.getAttributeValue(null, \"connectivity\"); if (val != null) &#123; jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); &#125; val = parser.getAttributeValue(null, \"unmetered\"); if (val != null) &#123; jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED); &#125; val = parser.getAttributeValue(null, \"not-roaming\"); if (val != null) &#123; jobBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_NOT_ROAMING); &#125; val = parser.getAttributeValue(null, \"idle\"); if (val != null) &#123; jobBuilder.setRequiresDeviceIdle(true); &#125; val = parser.getAttributeValue(null, \"charging\"); if (val != null) &#123; jobBuilder.setRequiresCharging(true); &#125; &#125; 显然，这个方法也很简单，解析剩下的参数！ 1.1.3.3 buildExecutionTimesFromXml计算这个 Job 的最早运行时间和最晚的结束时间：123456789101112131415161718192021222324 private Pair&lt;Long, Long&gt; buildExecutionTimesFromXml(XmlPullParser parser) throws NumberFormatException &#123; // Pull out execution time data. final long nowWallclock = System.currentTimeMillis(); final long nowElapsed = SystemClock.elapsedRealtime(); long earliestRunTimeElapsed = JobStatus.NO_EARLIEST_RUNTIME; long latestRunTimeElapsed = JobStatus.NO_LATEST_RUNTIME; String val = parser.getAttributeValue(null, \"deadline\"); if (val != null) &#123; long latestRuntimeWallclock = Long.valueOf(val); long maxDelayElapsed = Math.max(latestRuntimeWallclock - nowWallclock, 0); latestRunTimeElapsed = nowElapsed + maxDelayElapsed; &#125; val = parser.getAttributeValue(null, \"delay\"); if (val != null) &#123; long earliestRuntimeWallclock = Long.valueOf(val); long minDelayElapsed = Math.max(earliestRuntimeWallclock - nowWallclock, 0); earliestRunTimeElapsed = nowElapsed + minDelayElapsed; &#125; return Pair.create(earliestRunTimeElapsed, latestRunTimeElapsed); &#125;&#125; 接着来看： 1.1.3.4 maybeBuildBackoffPolicyFromXml123456789private void maybeBuildBackoffPolicyFromXml(JobInfo.Builder jobBuilder, XmlPullParser parser) &#123; String val = parser.getAttributeValue(null, \"initial-backoff\"); if (val != null) &#123; long initialBackoff = Long.valueOf(val); val = parser.getAttributeValue(null, \"backoff-policy\"); int backoffPolicy = Integer.parseInt(val); // Will throw NFE which we catch higher up. jobBuilder.setBackoffCriteria(initialBackoff, backoffPolicy); &#125;&#125; 接着： 1.1.3.5 PersistableBundle.restoreFromXml1234567891011121314151617/** @hide */public static PersistableBundle restoreFromXml(XmlPullParser in) throws IOException, XmlPullParserException &#123; final int outerDepth = in.getDepth(); final String startTag = in.getName(); final String[] tagName = new String[1]; int event; while (((event = in.next()) != XmlPullParser.END_DOCUMENT) &amp;&amp; (event != XmlPullParser.END_TAG || in.getDepth() &lt; outerDepth)) &#123; if (event == XmlPullParser.START_TAG) &#123; return new PersistableBundle((ArrayMap&lt;String, Object&gt;) XmlUtils.readThisArrayMapXml(in, startTag, tagName, new MyReadMapCallback())); &#125; &#125; return EMPTY;&#125; 接着： 1.1.3.6 JobInfo.buidler.build根据解析的结果，创建 JobInfo 对象，这里调用了 JobInfo.buidler 的 build 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960... ... ... ... public JobInfo build() &#123; // Allow jobs with no constraints - What am I, a database? if (!mHasEarlyConstraint &amp;&amp; !mHasLateConstraint &amp;&amp; !mRequiresCharging &amp;&amp; !mRequiresDeviceIdle &amp;&amp; mNetworkType == NETWORK_TYPE_NONE &amp;&amp; mTriggerContentUris == null) &#123; throw new IllegalArgumentException(\"You're trying to build a job with no \" + \"constraints, this is not allowed.\"); &#125; mExtras = new PersistableBundle(mExtras); // Make our own copy. // Check that a deadline was not set on a periodic job. if (mIsPeriodic &amp;&amp; (mMaxExecutionDelayMillis != 0L)) &#123; throw new IllegalArgumentException(\"Can't call setOverrideDeadline() on a \" + \"periodic job.\"); &#125; if (mIsPeriodic &amp;&amp; (mMinLatencyMillis != 0L)) &#123; throw new IllegalArgumentException(\"Can't call setMinimumLatency() on a \" + \"periodic job\"); &#125; if (mIsPeriodic &amp;&amp; (mTriggerContentUris != null)) &#123; throw new IllegalArgumentException(\"Can't call addTriggerContentUri() on a \" + \"periodic job\"); &#125; if (mIsPersisted &amp;&amp; (mTriggerContentUris != null)) &#123; throw new IllegalArgumentException(\"Can't call addTriggerContentUri() on a \" + \"persisted job\"); &#125; if (mBackoffPolicySet &amp;&amp; mRequiresDeviceIdle) &#123; throw new IllegalArgumentException(\"An idle mode job will not respect any\" + \" back-off policy, so calling setBackoffCriteria with\" + \" setRequiresDeviceIdle is an error.\"); &#125; JobInfo job = new JobInfo(this); if (job.isPeriodic()) &#123; if (job.intervalMillis != job.getIntervalMillis()) &#123; StringBuilder builder = new StringBuilder(); builder.append(\"Specified interval for \") .append(String.valueOf(mJobId)) .append(\" is \"); formatDuration(mIntervalMillis, builder); builder.append(\". Clamped to \"); formatDuration(job.getIntervalMillis(), builder); Log.w(TAG, builder.toString()); &#125; if (job.flexMillis != job.getFlexMillis()) &#123; StringBuilder builder = new StringBuilder(); builder.append(\"Specified flex for \") .append(String.valueOf(mJobId)) .append(\" is \"); formatDuration(mFlexMillis, builder); builder.append(\". Clamped to \"); formatDuration(job.getFlexMillis(), builder); Log.w(TAG, builder.toString()); &#125; &#125; return job; &#125; ... ... ... ... 这里返回了 JobInfo 对象！ 1.1.3.7 new JobStatus最后，根据创建的 JobInfo 对象和前面的解析结果，创建 JobStatus 对象！12345public JobStatus(JobInfo job, int callingUid, String sourcePackageName, int sourceUserId, String sourceTag, long earliestRunTimeElapsedMillis, long latestRunTimeElapsedMillis) &#123; this(job, callingUid, sourcePackageName, sourceUserId, sourceTag, 0, earliestRunTimeElapsedMillis, latestRunTimeElapsedMillis);&#125; 这个构造器调用了下面这个：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private JobStatus(JobInfo job, int callingUid, String sourcePackageName, int sourceUserId, String tag, int numFailures, long earliestRunTimeElapsedMillis, long latestRunTimeElapsedMillis) &#123; this.job = job; this.callingUid = callingUid; int tempSourceUid = -1; if (sourceUserId != -1 &amp;&amp; sourcePackageName != null) &#123; try &#123; tempSourceUid = AppGlobals.getPackageManager().getPackageUid(sourcePackageName, 0, sourceUserId); &#125; catch (RemoteException ex) &#123; // Can't happen, PackageManager runs in the same process. &#125; &#125; if (tempSourceUid == -1) &#123; this.sourceUid = callingUid; this.sourceUserId = UserHandle.getUserId(callingUid); this.sourcePackageName = job.getService().getPackageName(); this.sourceTag = null; &#125; else &#123; this.sourceUid = tempSourceUid; this.sourceUserId = sourceUserId; this.sourcePackageName = sourcePackageName; this.sourceTag = tag; &#125; this.batteryName = this.sourceTag != null ? this.sourceTag + \":\" + job.getService().getPackageName() : job.getService().flattenToShortString(); this.tag = \"*job*/\" + this.batteryName; this.earliestRunTimeElapsedMillis = earliestRunTimeElapsedMillis; this.latestRunTimeElapsedMillis = latestRunTimeElapsedMillis; this.numFailures = numFailures; int requiredConstraints = 0; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_ANY) &#123; requiredConstraints |= CONSTRAINT_CONNECTIVITY; &#125; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_UNMETERED) &#123; requiredConstraints |= CONSTRAINT_UNMETERED; &#125; if (job.getNetworkType() == JobInfo.NETWORK_TYPE_NOT_ROAMING) &#123; requiredConstraints |= CONSTRAINT_NOT_ROAMING; &#125; if (job.isRequireCharging()) &#123; requiredConstraints |= CONSTRAINT_CHARGING; &#125; if (earliestRunTimeElapsedMillis != NO_EARLIEST_RUNTIME) &#123; requiredConstraints |= CONSTRAINT_TIMING_DELAY; &#125; if (latestRunTimeElapsedMillis != NO_LATEST_RUNTIME) &#123; requiredConstraints |= CONSTRAINT_DEADLINE; &#125; if (job.isRequireDeviceIdle()) &#123; requiredConstraints |= CONSTRAINT_IDLE; &#125; if (job.getTriggerContentUris() != null) &#123; requiredConstraints |= CONSTRAINT_CONTENT_TRIGGER; &#125; this.requiredConstraints = requiredConstraints;&#125; 暂时看到这里！ 1.2 JobHandler接下来，我们来看看 JobHander 的消息处理：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private class JobHandler extends Handler &#123; public JobHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message message) &#123; synchronized (mLock) &#123; // 在系统刚刚启动的时候，mReadyToRock 的值为 false，当系统启动到 phase 600，则 mReadyToRock=true. if (!mReadyToRock) &#123; return; &#125; &#125; switch (message.what) &#123; case MSG_JOB_EXPIRED: synchronized (mLock) &#123; JobStatus runNow = (JobStatus) message.obj; // runNow can be null, which is a controller's way of indicating that its // state is such that all ready jobs should be run immediately. if (runNow != null &amp;&amp; !mPendingJobs.contains(runNow) &amp;&amp; mJobs.containsJob(runNow)) &#123; mJobPackageTracker.notePending(runNow); mPendingJobs.add(runNow); &#125; queueReadyJobsForExecutionLockedH(); &#125; break; case MSG_CHECK_JOB: // 检查任务 synchronized (mLock) &#123; if (mReportedActive) &#123; // if jobs are currently being run, queue all ready jobs for execution. queueReadyJobsForExecutionLockedH(); &#125; else &#123; // Check the list of jobs and run some of them if we feel inclined. maybeQueueReadyJobsForExecutionLockedH(); &#125; &#125; break; case MSG_CHECK_JOB_GREEDY: synchronized (mLock) &#123; queueReadyJobsForExecutionLockedH(); &#125; break; case MSG_STOP_JOB: // 停止任务 cancelJobImpl((JobStatus)message.obj, null); break; &#125; maybeRunPendingJobsH(); // Don't remove JOB_EXPIRED in case one came along while processing the queue. removeMessages(MSG_CHECK_JOB); &#125; ... ... ... ... private final ReadyJobQueueFunctor mReadyQueueFunctor = new ReadyJobQueueFunctor(); ... ... ... ... private final MaybeReadyJobQueueFunctor mMaybeQueueFunctor = new MaybeReadyJobQueueFunctor(); ... ... ... ...&#125; 这里，我们省略了一些方法，以后再慢慢分析！ 1.3 Controllers对于控制器，后面会有单独的博文详细分析，这里我们先看看 ConnectivityController!! 1.3.1 ConnectivityController我们先来看一个控制器 ConnectivityController，先来看看他的代码：1234567891011121314151617181920212223242526272829public class ConnectivityController extends StateController implements ConnectivityManager.OnNetworkActiveListener &#123; private static final String TAG = \"JobScheduler.Conn\"; private final ConnectivityManager mConnManager; private final NetworkPolicyManager mNetPolicyManager; @GuardedBy(\"mLock\") private final ArrayList&lt;JobStatus&gt; mTrackedJobs = new ArrayList&lt;JobStatus&gt;(); /** Singleton. */ private static ConnectivityController mSingleton; private static Object sCreationLock = new Object(); public static ConnectivityController get(JobSchedulerService jms) &#123; synchronized (sCreationLock) &#123; if (mSingleton == null) &#123; mSingleton = new ConnectivityController(jms, jms.getContext(), jms.getLock()); &#125; return mSingleton; &#125; &#125; private ConnectivityController(StateChangedListener stateChangedListener, Context context, Object lock) &#123; super(stateChangedListener, context, lock); mConnManager = mContext.getSystemService(ConnectivityManager.class); mNetPolicyManager = mContext.getSystemService(NetworkPolicyManager.class); // 注册监听网络连接状态的广播，且采用 BackgroundThread 线程 final IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); mContext.registerReceiverAsUser( mConnectivityReceiver, UserHandle.SYSTEM, intentFilter, null, null); mNetPolicyManager.registerListener(mNetPolicyListener); &#125; 当监听到 CONNECTIVITY_ACTION 广播，onReceive 方法的执行位于 “android.bg” 线程。其他的控制器很类似，我们在后面的文章中，会集中分析这些控制器！ 1.4 JobSchedulerStubJobSchedulerStub 继承了 IJobScheduler.Stub，作为 Binder 机制的服务端的桩对象，为 Binder 客户端提供服务！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class JobSchedulerStub extends IJobScheduler.Stub &#123; private final SparseArray&lt;Boolean&gt; mPersistCache = new SparseArray&lt;Boolean&gt;(); private void enforceValidJobRequest(int uid, JobInfo job) &#123; ... ... ... ... ... &#125; private boolean canPersistJobs(int pid, int uid) &#123; ... ... ... ... ... &#125; // IJobScheduler implementation @Override public int schedule(JobInfo job) throws RemoteException &#123; ... ... ... ... ... &#125; @Override public int scheduleAsPackage(JobInfo job, String packageName, int userId, String tag) throws RemoteException &#123; ... ... ... ... ... &#125; @Override public List&lt;JobInfo&gt; getAllPendingJobs() throws RemoteException &#123; ... ... ... ... ... &#125; @Override public JobInfo getPendingJob(int jobId) throws RemoteException &#123; ... ... ... ... ... &#125; @Override public void cancelAll() throws RemoteException &#123; ... ... ... ... ... &#125; @Override public void cancel(int jobId) throws RemoteException &#123; ... ... ... ... ... &#125; /** * \"dumpsys\" infrastructure */ @Override public void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123; ... ... ... ... ... &#125; @Override public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ResultReceiver resultReceiver) throws RemoteException &#123; ... ... ... ... ... &#125;&#125;; 我们简单的分析下上面的方法： 1.4.1 enforceValidJobRequest当一个应用想通过 JobScheduler 来注册一个任务的时候，需要实现一个服务：JobService，当任务注册到 JobScheduler 后，JobScheduler 通过注册时，设置的条件，当满足条件时，就调用 onJobStart 方法拉起 JobService 来执行任务；当不满足条件，就调用 onJobStop 方法，挂起 JobService 来停止任务！1234567891011121314151617181920212223private void enforceValidJobRequest(int uid, JobInfo job) &#123; final IPackageManager pm = AppGlobals.getPackageManager(); final ComponentName service = job.getService(); try &#123; ServiceInfo si = pm.getServiceInfo(service, PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, UserHandle.getUserId(uid)); if (si == null) &#123; throw new IllegalArgumentException(\"No such service \" + service); &#125; if (si.applicationInfo.uid != uid) &#123; throw new IllegalArgumentException(\"uid \" + uid + \" cannot schedule job in \" + service.getPackageName()); &#125; if (!JobService.PERMISSION_BIND.equals(si.permission)) &#123; throw new IllegalArgumentException(\"Scheduled service \" + service + \" does not require android.permission.BIND_JOB_SERVICE permission\"); &#125; &#125; catch (RemoteException e) &#123; // Can't happen; the Package Manager is in this same process &#125;&#125; 这个方法主要的作用是校验如下几项：1、是否有这个 JobService，2、JobService 的 uid 是否等于调用者的 uid，就是说，这个 JobService 是否属于这个应用！2、JobService 是否在 AndroidManifest.xml 文件中配置了相应的权限： 1.4.2 canPersistJobs判断应用是否有 android.Manifest.permission.RECEIVE_BOOT_COMPLETED 的权限，如果有这个权限的话，设备重启后，能够保留该应用的任务！123456789101112131415161718private boolean canPersistJobs(int pid, int uid) &#123; final boolean canPersist; synchronized (mPersistCache) &#123; Boolean cached = mPersistCache.get(uid); if (cached != null) &#123; canPersist = cached.booleanValue(); &#125; else &#123; // Persisting jobs is tantamount to running at boot, so we permit // it when the app has declared that it uses the RECEIVE_BOOT_COMPLETED // permission int result = getContext().checkPermission( android.Manifest.permission.RECEIVE_BOOT_COMPLETED, pid, uid); canPersist = (result == PackageManager.PERMISSION_GRANTED); mPersistCache.put(uid, canPersist); &#125; &#125; return canPersist;&#125; 最终的结果会保存在 mPersistCache 集合中！ 1.4.3 schedule这个方法是我们最常用的，来注册Job的！12345678910111213141516171819202122232425// 我们是实际上调用的是这个方法！@Overridepublic int schedule(JobInfo job) throws RemoteException &#123; if (DEBUG) &#123; Slog.d(TAG, \"Scheduling job: \" + job.toString()); &#125; // 获得调用方的 pid 和 uid！ final int pid = Binder.getCallingPid(); final int uid = Binder.getCallingUid(); // 校验操作 enforceValidJobRequest(uid, job); // 如果这个Job是重启后可保留的，检查权限！ if (job.isPersisted()) &#123; if (!canPersistJobs(pid, uid)) &#123; throw new IllegalArgumentException(\"Error: requested job be persisted without\" + \" holding RECEIVE_BOOT_COMPLETED permission.\"); &#125; &#125; long ident = Binder.clearCallingIdentity(); try &#123; return JobSchedulerService.this.schedule(job, uid); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 最后 调用服务端的 schedule 方法继续注册！ 1.4.4 scheduleAsPackage接下来，我们来看一个和 schedule 方法很类似的方法：1234567891011121314151617181920212223242526272829@Overridepublic int scheduleAsPackage(JobInfo job, String packageName, int userId, String tag) throws RemoteException &#123; final int callerUid = Binder.getCallingUid(); if (DEBUG) &#123; Slog.d(TAG, \"Caller uid \" + callerUid + \" scheduling job: \" + job.toString() + \" on behalf of \" + packageName); &#125; if (packageName == null) &#123; throw new NullPointerException(\"Must specify a package for scheduleAsPackage()\"); &#125; int mayScheduleForOthers = getContext().checkCallingOrSelfPermission( android.Manifest.permission.UPDATE_DEVICE_STATS); if (mayScheduleForOthers != PackageManager.PERMISSION_GRANTED) &#123; throw new SecurityException(\"Caller uid \" + callerUid + \" not permitted to schedule jobs for other apps\"); &#125; if ((job.getFlags() &amp; JobInfo.FLAG_WILL_BE_FOREGROUND) != 0) &#123; getContext().enforceCallingOrSelfPermission( android.Manifest.permission.CONNECTIVITY_INTERNAL, TAG); &#125; long ident = Binder.clearCallingIdentity(); try &#123; return JobSchedulerService.this.scheduleAsPackage(job, callerUid, packageName, userId, tag); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 最后 调用服务端的 scheduleAsPackage 方法继续注册！ 1.4.5 getXXXPendingJobs下面来看这两个方法：getAllPendingJobs：获得应用注册的所有的正在等待的 Job！getPendingJob：获得应用程序注册的 jobId 指定的正在等待的 Job！1234567891011121314151617181920@Overridepublic List&lt;JobInfo&gt; getAllPendingJobs() throws RemoteException &#123; final int uid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); try &#123; return JobSchedulerService.this.getPendingJobs(uid); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125;@Overridepublic JobInfo getPendingJob(int jobId) throws RemoteException &#123; final int uid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); try &#123; return JobSchedulerService.this.getPendingJob(uid, jobId); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 最后 调用服务端的 scheduleAsPackage 方法! 1.4.6 cancelXXX接着是取消任务的相关方法： cancelAll：取消应用注册的所有任务！ cancel：取消 jobId 对应的任务！ 1234567891011121314151617181920@Overridepublic void cancelAll() throws RemoteException &#123; final int uid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); try &#123; JobSchedulerService.this.cancelJobsForUid(uid, true); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125;@Overridepublic void cancel(int jobId) throws RemoteException &#123; final int uid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); try &#123; JobSchedulerService.this.cancelJob(uid, jobId); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; 最后分别调用的是客户端的 cancelJobForUid 方法和 cancelJob 方法！ 1.4.7 dump这个方法是用来为控制台 dumpsys 命令提供数据的：12345678910@Overridepublic void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123; getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG); long identityToken = Binder.clearCallingIdentity(); try &#123; JobSchedulerService.this.dumpInternal(pw, args); &#125; finally &#123; Binder.restoreCallingIdentity(identityToken); &#125;&#125; 接着看： 1.4.8 onShellCommand123456@Overridepublic void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ResultReceiver resultReceiver) throws RemoteException &#123; (new JobSchedulerShellCommand(JobSchedulerService.this)).exec( this, in, out, err, args, resultReceiver);&#125; 2 onStart在 onStart 方法中，又调用了如下的方法：12345@Overridepublic void onStart() &#123; publishLocalService(JobSchedulerInternal.class, new LocalService()); publishBinderService(Context.JOB_SCHEDULER_SERVICE, mJobSchedulerStub);&#125; 主要有两个作用： 公开本地服务：LocalService，类型为 JobSchedulerInternal.class，只能被系统进程访问。 公开 Binder 通信服务，名称为：jobscheduler，服务的实体对象是：mJobSchedulerStub，实现了 IJobScheduler.Stub 接口，其实就是将 JobSchedulerService 自身注册进 SystemManager 中，是其能被其他服务和应用访问到！ 接下来，我们一个一个来看： 2.1 publishLocalService这个方法是继承自 SystemService 的：123protected final &lt;T&gt; void publishLocalService(Class&lt;T&gt; type, T service) &#123; LocalServices.addService(type, service);&#125; 调用了 LocalServices的静态方法，addService：123456789101112131415161718public final class LocalServices &#123; private LocalServices() &#123;&#125; private static final ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects = new ArrayMap&lt;Class&lt;?&gt;, Object&gt;(); ... ... ... ... public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123; synchronized (sLocalServiceObjects) &#123; if (sLocalServiceObjects.containsKey(type)) &#123; throw new IllegalStateException(\"Overriding service registration\"); &#125; sLocalServiceObjects.put(type, service); &#125; &#125; ... ... ... ...&#125; 接着来看： 2.2 publishBinderService这个方法也是继承了 SystemServer 的方法：12345678protected final void publishBinderService(String name, IBinder service) &#123; publishBinderService(name, service, false);&#125;protected final void publishBinderService(String name, IBinder service, boolean allowIsolated) &#123; ServiceManager.addService(name, service, allowIsolated);&#125; 其实就是将自身加入到 SystemManager 中去！ 3 onBootPhase我们知道，设备在开机的时候，会处于不同的状态，在每个状态时，都要通知服务，服务会根据不同的状态，进行不同是开始初始化操作！！ 3.1 SystemServiceM.startBootPhase具体的调用在这里：123456789101112131415161718192021222324252627public void startBootPhase(final int phase) &#123; if (phase &lt;= mCurrentPhase) &#123; throw new IllegalArgumentException(\"Next phase must be larger than previous\"); &#125; mCurrentPhase = phase; Slog.i(TAG, \"Starting phase \" + mCurrentPhase); try &#123; Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"OnBootPhase \" + phase); // 遍历所有的系统服务！ final int serviceLen = mServices.size(); for (int i = 0; i &lt; serviceLen; i++) &#123; final SystemService service = mServices.get(i); try &#123; //【1】调用服务的 onBootPhase 方法！ service.onBootPhase(mCurrentPhase); &#125; catch (Exception ex) &#123; throw new RuntimeException(\"Failed to boot service \" + service.getClass().getName() + \": onBootPhase threw an exception during phase \" + mCurrentPhase, ex); &#125; &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125;&#125; 对于 JobSchedulerService 服务，他需要在如下的 2 个阶段进行初始化！1234// 表示系统服务已经准备好了！public static final int PHASE_SYSTEM_SERVICES_READY = 500;// 表示第三方应用已经可以启动了！public static final int PHASE_THIRD_PARTY_APPS_CAN_START = 600; 我们来看看 JobSchedulerService 在不同的状态下做了什么初始化： 3.2 JobSchedulerS.onBootPhase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overridepublic void onBootPhase(int phase) &#123; //【1】500，表示系统服务准备就绪。 if (PHASE_SYSTEM_SERVICES_READY == phase) &#123; mConstants.start(getContext().getContentResolver()); //【1.1】注册第一个 BroadcastReceiver，监听 package 的操作！ final IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_PACKAGE_REMOVED); filter.addAction(Intent.ACTION_PACKAGE_CHANGED); filter.addAction(Intent.ACTION_PACKAGE_RESTARTED); filter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); filter.addDataScheme(\"package\"); getContext().registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, filter, null, null); //【1.2】注册第二个 BroadcastReceiver，监听 user 的移除操作！ final IntentFilter userFilter = new IntentFilter(Intent.ACTION_USER_REMOVED); getContext().registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, userFilter, null, null); mPowerManager = (PowerManager)getContext().getSystemService(Context.POWER_SERVICE); try &#123; // 注册 uid 观察者，用于回调！ ActivityManagerNative.getDefault().registerUidObserver(mUidObserver, ActivityManager.UID_OBSERVER_PROCSTATE | ActivityManager.UID_OBSERVER_GONE | ActivityManager.UID_OBSERVER_IDLE); &#125; catch (RemoteException e) &#123; // ignored; both services live in system_server &#125; //【2】600，表示三方应用已经可以被启动了！ &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123; synchronized (mLock) &#123; // JobSchedulerService 已经准备好了！ mReadyToRock = true; mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService( BatteryStats.SERVICE_NAME)); // 获得本地设备控制器! mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class); // Create the \"runners\". //【2.1】初始化 JobServiceContext，最多允许一次执行 16 个任务！ for (int i = 0; i &lt; MAX_JOB_CONTEXTS_COUNT; i++) &#123; // 需要被执行的任务，都会保存到 JobServiceContext 对象中！ mActiveServices.add( new JobServiceContext(this, mBatteryStats, mJobPackageTracker, getContext().getMainLooper())); &#125; // Attach jobs to their controllers. // 将每个任务绑定到对应的控制器中。 mJobs.forEachJob(new JobStatusFunctor() &#123; @Override public void process(JobStatus job) &#123; for (int controller = 0; controller &lt; mControllers.size(); controller++) &#123; final StateController sc = mControllers.get(controller); sc.maybeStartTrackingJobLocked(job, null); &#125; &#125; &#125;); //【2.2】发送 MSG_CHECK_JOB 消息给 JobHandler，检查并执行任务！ mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget(); &#125; &#125;&#125; 这里的是根据开机的阶段，进行不同的初始化操作，这里我们来看看 JobServiceContext！ 3.3 JobServiceContext创建 JobServiceContext 对象，参数传递： Context context： JobSchedulerService.getContext。 Object lock： JobSchedulerService.getObject。 IBatteryStats batteryStats： JobSchedulerService.mBatteryStats。 JobPackageTracker tracker： JobSchedulerService.tracker。 JobCompletedListener completedListener： JobSchedulerService，其本身实现了这个接口。 Looper looper： getContext().getMainLooper()，JobSchedulerService 所在主线程的 Looper。 123456789101112131415161718JobServiceContext(JobSchedulerService service, IBatteryStats batteryStats, JobPackageTracker tracker, Looper looper) &#123; this(service.getContext(), service.getLock(), batteryStats, tracker, service, looper);&#125;@VisibleForTestingJobServiceContext(Context context, Object lock, IBatteryStats batteryStats, JobPackageTracker tracker, JobCompletedListener completedListener, Looper looper) &#123; mContext = context; mLock = lock; mBatteryStats = batteryStats; mJobPackageTracker = tracker; mCallbackHandler = new JobServiceHandler(looper); mCompletedListener = completedListener; mAvailable = true; mVerb = VERB_FINISHED; mPreferredUid = NO_PREFERRED_UID;&#125; 此处的 JobServiceHandler 绑定的是 system_server 进程的主线程。 3.3.1 JobServiceHandler每一个 JobServiceContext 都有一个 JobServiceHandler 对象，JobSchedulerService 通过这个 handler 对象向 JSC 发送消息！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private class JobServiceHandler extends Handler &#123; JobServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message message) &#123; switch (message.what) &#123; case MSG_SERVICE_BOUND: // 绑定 jobService 服务！ removeOpTimeOut(); handleServiceBoundH(); break; case MSG_CALLBACK: // job 周期变化的回调！ if (DEBUG) &#123; Slog.d(TAG, \"MSG_CALLBACK of : \" + mRunningJob + \" v:\" + VERB_STRINGS[mVerb]); &#125; removeOpTimeOut(); if (mVerb == VERB_STARTING) &#123; final boolean workOngoing = message.arg2 == 1; handleStartedH(workOngoing); &#125; else if (mVerb == VERB_EXECUTING || mVerb == VERB_STOPPING) &#123; final boolean reschedule = message.arg2 == 1; handleFinishedH(reschedule); &#125; else &#123; if (DEBUG) &#123; Slog.d(TAG, \"Unrecognised callback: \" + mRunningJob); &#125; &#125; break; case MSG_CANCEL: // 取消 job！ if (mVerb == VERB_FINISHED) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Trying to process cancel for torn-down context, ignoring.\"); &#125; return; &#125; mParams.setStopReason(message.arg1); if (message.arg1 == JobParameters.REASON_PREEMPT) &#123; mPreferredUid = mRunningJob != null ? mRunningJob.getUid() : NO_PREFERRED_UID; &#125; handleCancelH(); break; case MSG_TIMEOUT: // job 超时！ handleOpTimeoutH(); break; case MSG_SHUTDOWN_EXECUTION: closeAndCleanupJobH(true /* needsReschedule */); break; default: Slog.e(TAG, \"Unrecognised message: \" + message); &#125; &#125; ... ... ... ... ...&#125; 对于 JobServiceHandler 的细节，我们在后续的分析中会详细介绍，这里就不多说了！ 4 startUser我们来看看 startUser 方法中的细节： 123456@Overridepublic void onStartUser(int userHandle) &#123; mStartedUsers = ArrayUtils.appendInt(mStartedUsers, userHandle); // Let's kick any outstanding jobs for this user. mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget();&#125; 目的就是：为当前的用户执行 job！ 5 总结 JSS.JobHandler：运行在 system_server 进程的主线程； JobServiceContext.JobServiceHandler：运行在 system_server 进程的主线程； JobSchedulerStub：作为实现接口 IJobScheduler 的 binder 服务端； JobStore：其成员变量 mIoHandler 运行在 android.io 线程； JobStatus：JSS 从 /data/system/job/jobs.xml 文件中读取每个 JobInfo，再解析成 JobStatus 对象，添加到 mJobSet。 可见 JobSchedulerService 启动过程，最主要工作是从 jobs.xml 文件收集所有的需要重启保留的 jobs，放入到 JobStore 的成员变量 mJobSet。 我们来先简单的看看 JobSchedulerService 的类关系图： 哈哈，是不是蒙圈了呢？后面我会陆续分析的，这一篇就到这里，累死我了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"JobScheduler任务调度","slug":"AndroidFramework源码分析/JobScheduler任务调度","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/JobScheduler任务调度/"}],"tags":[{"name":"JobScheduler任务调度","slug":"JobScheduler任务调度","permalink":"https://coolqi.top/tags/JobScheduler任务调度/"}]},{"title":"Process篇 2 - Android 进程的创建","slug":"Process2-theCreateOfProcess","date":"2016-03-19T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/03/19/Process2-theCreateOfProcess/","link":"","permalink":"https://coolqi.top/2016/03/19/Process2-theCreateOfProcess/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码，分析进程的创建！ 1 前言当 Android 系统在启动一个应用进程时，如果发现某个进程没有创建，那就要先创建这个进程， Android 系统中每一个应用进程，包括 SystemServer 进程都是由 Zygote 直接孵化出来的！ 本片文章，就来总结下进程的 fork 流程！ 2 Process - prepare fork我们来继续看： 2.1 Process.start框架层开始创建进程会调用 Process.start 方法，我们进入这个方法来看看：1234567891011121314151617181920212223public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; //【1】这里是进入 Zygote 方法了！ return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; 2.2 Process.startViaZygote我们接着来看，进入了：startViaZygote 方法，参数传递： final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, tring abi, String instructionSet, String appDataDir, String[] extraArgs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; //【1】创建 cmd 命令libeia！ ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) &#123; argsForZygote.add(\"--enable-jni-logging\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != 0) &#123; argsForZygote.add(\"--enable-safemode\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != 0) &#123; argsForZygote.add(\"--enable-debugger\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != 0) &#123; argsForZygote.add(\"--enable-checkjni\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) &#123; argsForZygote.add(\"--generate-debug-info\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ALWAYS_JIT) != 0) &#123; argsForZygote.add(\"--always-jit\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_NATIVE_DEBUGGABLE) != 0) &#123; argsForZygote.add(\"--native-debuggable\"); &#125; if ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != 0) &#123; argsForZygote.add(\"--enable-assert\"); &#125; if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(\"--mount-external-default\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123; argsForZygote.add(\"--mount-external-read\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123; argsForZygote.add(\"--mount-external-write\"); &#125; argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); //TODO optionally enable debuger //argsForZygote.add(\"--enable-debugger\"); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125; //【2.3】接着调用 zygoteSendArgsAndGetResult 方法，让爱更进一步！ return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; 这个的过程是生成 argsForZygote 数组，里面分装了 Zygote 需要的参数！！ 2.2.1 Process.openZygoteSocketIfNeeded这里调用了 openZygoteSocketIfNeeded 方法，根据当前的 abi 选择 Zygote 的位数：32 位还是 64 位的,然后连接 Zygote，并返回 Zygote 的引用对象： 12345678910111213141516171819202122232425262728293031private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; //【1】连接主zygote！ primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; //【2】主 Zygote 能和 abi 匹配，返回主 Zygote！ return primaryZygoteState; &#125; if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; //【3】主 Zygote 不能匹配，连接第二个zygote！ secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; //【4】返回第二个 Zygote！ return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 我们接着下面来看！ 2.3 Process.zygoteSendArgsAndGetResult最后，发送参数列表给 Zygote 进程，Zygote 进程会 fork 一个子进程，并返回子进程的 pid！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; //【1】判断输入参数格式是是否正确，中间不能有换行符！ int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; if (args.get(i).indexOf('\\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx(\"embedded newlines not allowed\"); &#125; &#125; final BufferedWriter writer = zygoteState.writer; // 用于向 Zygote 写入数据！ final DataInputStream inputStream = zygoteState.inputStream; // 用于获得 Zygote 的返回数据！ //【2】首先，写入参数的个数！ writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); //【2.1】写入每一个参数 writer.write(arg); writer.newLine(); &#125; //【3】flush BufferedWriter，参数会被写到 ZygoteConnection 对象的 abiList 集合中！ writer.flush(); //【4】创建 ProcessStartResult 实例，记录启动结果，包括 pid ProcessStartResult result = new ProcessStartResult(); //【5】systemServer 进入阻塞等待状态，直到进程创建成功，返回子进程的 pid！ result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; 这个方法的主要功能：通过 socket 向 Zygote 进程发送一个参数列表，然后进入阻塞等待状态，直到远端的 Socket 服务端发送回来新创建的进程 pid 才返回！！ 以上这些过程仍然在 SystemServer 进程中，接下来，就要进入 Zygote 进程了！！！ 3 Zygote - fork Process3.1 ZygoteInit.main接着是，进入了 Zygote 进程，我们先去看看 Zygote 的 main 方法看看：1234567891011121314151617181920212223public static void main(String argv[]) &#123; ZygoteHooks.startZygoteNoThreadCreation(); try &#123; ... ... ...// 这部分代码是启动 Zygote 时触发的，这个省略不看！ Log.i(TAG, \"Accepting command socket connections\"); //【3.2】进入 runSeletLoop 方法！ runSelectLoop(abiList); closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; //【3.4】上面的 runSelectLoop 方法会抛出 MethodAndArgsCaller 异常就会进入 caller.run 方法 // 我们后面再看！ caller.run(); &#125; catch (Throwable ex) &#123; Log.e(TAG, \"Zygote died with exception\", ex); closeServerSocket(); throw ex; &#125;&#125; 接着来看，进入了 runSelectLoop 方法，runSelectLoop 是一个死循环，不断的读取发送到 Zygote 的消息！ 3.2 ZygoteInit.runSelectLoop这个方法很关键，在 openZygoteSocketIfNeeded 方法中，System Sever 会通过 Socket 建立和 Zygote 进程的连接，并向 Zygote 写入执行参数！ 而 ZygoteInit.runSelectLoop 会创建一个循环，不断的读取 abiList 中的指令，进行处理！ 12345678910111213141516171819202122232425262728293031323334353637383940414243private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; //【1】采用 I / O 多路复用机制，当客户端发出连接请求或者数据处理请求时，跳过 continue，执行后面的代码 StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; //【2】接收到客户端的连接请求，创建 ZygoteConnection 对象！ ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; //【3.3】执行 ZygoteConnection 的 runOnce 方法！ boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125;&#125; 没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒 Zygote 进程，创建 Socket 通道 ZygoteConnection，然后执行 ZygoteConnection 的 runOnce() 方法。 3.3 ZygoteConnection.runOnce这里我们看到 runOnce 方法会抛出一个 MethodAndArgsCaller 异常，但实际上 MethodAndArgsCaller 并不是在 runOnce 中抛出的！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; //【1】读取socket客户端发送过来的参数列表。 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"IOException on command socket \" + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; /** the stderr of the most recent request, if avail */ PrintStream newStderr = null; if (descriptors != null &amp;&amp; descriptors.length &gt;= 3) &#123; newStderr = new PrintStream( new FileOutputStream(descriptors[2])); &#125; int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try &#123; //【2】将 Socket 客户端传递过来的参数，解析成 Arguments 对象格式。 parsedArgs = new Arguments(args); if (parsedArgs.abiListQuery) &#123; return handleAbiListQuery(); &#125; if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) &#123; throw new ZygoteSecurityException(\"Client may not specify capabilities: \" + \"permitted=0x\" + Long.toHexString(parsedArgs.permittedCapabilities) + \", effective=0x\" + Long.toHexString(parsedArgs.effectiveCapabilities)); &#125; applyUidSecurityPolicy(parsedArgs, peer); applyInvokeWithSecurityPolicy(parsedArgs, peer); applyDebuggerSystemProperty(parsedArgs); applyInvokeWithSystemProperty(parsedArgs); int[][] rlimits = null; if (parsedArgs.rlimits != null) &#123; rlimits = parsedArgs.rlimits.toArray(intArray2d); &#125; if (parsedArgs.invokeWith != null) &#123; FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC); childPipeFd = pipeFds[1]; serverPipeFd = pipeFds[0]; Os.fcntlInt(childPipeFd, F_SETFD, 0); &#125; int [] fdsToClose = &#123; -1, -1 &#125;; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) &#123; fdsToClose[0] = fd.getInt$(); &#125; fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) &#123; fdsToClose[1] = fd.getInt$(); &#125; fd = null; //【3.3.1】这边是 Zygote 处理传入的参数，fork 子进程，返回 2 次 // 分别进入父进程 Zygote 和新子进程中去！ pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, \"Exception creating pipe\", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, \"Invalid zygote arguments\", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, \"Zygote security policy prevents request: \", ex); &#125; try &#123; //【4】fork一次，会返回两次，如果返回的是 0，表示当前是是在子进程中， // 如果返回值 &gt; 0，那当前就是在父进程中！ if (pid == 0) &#123; //【4.1】pid 为 0，在子进程中处理！ IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //【3.3.2】子进程执行，这里会抛出异常：MethodAndArgsCaller！ handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; &#125; else &#123; //【4.2】pid 大于 0，在父进程！ IoUtils.closeQuietly(childPipeFd); childPipeFd = null; //【3.3.3】父进程 Zygote 执行！ return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 3.3.1 Zygote.forkAndSpecialize - fork 子进程核心阶段这里开始 Fork 子进程！！12345678910111213141516171819202122public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, String instructionSet, String appDataDir) &#123; //【3.3.1.1】fork 前的准备工作 VM_HOOKS.preFork(); //【3.3.1.2】这里是 fork 子进程，调用了一个 naitve 方法。这个方法会返回 2 次！ int pid = nativeForkAndSpecialize( uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose, instructionSet, appDataDir); if (pid == 0) &#123; // 监控子进程，直到 handleChildProc 结束！ Trace.setTracingEnabled(true); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\"); &#125; //【3.3.1.3】fork 结束后的相关操作！ VM_HOOKS.postForkCommon(); return pid;&#125; 这里有一变量： 1private static final ZygoteHooks VM_HOOKS = new ZygoteHooks(); nativeForkAndSpecialize 方法会返回 2 次，一次 pid 为 0，表示是在子进程中；一次 pid 大于 0，表示是在 Zygote 进程中，意味着，postForkCommon 会执行 2 次！ 接着来看： 3.3.1.1 ZygoteHooks.preFork - fork 准备工作ZygoteHooks 的源码位于：D:\\google\\libcore\\dalvik\\src\\main\\java\\dalvik\\system\\ZygoteHooks.java 12345678public void preFork() &#123; //【3.3.1.1.1】停止 4 个 Daemon 子线程 Daemons.stop(); //【3.3.1.1.2】等待所有子线程结束 waitUntilAllThreadsStopped(); //【3.3.1.1.3】完成 gc 堆的初始化工作 token = nativePreFork(); &#125; 3.3.1.1.1 Daemons.stop123456public static void stop() &#123; HeapTaskDaemon.INSTANCE.stop(); // Java堆整理线程 ReferenceQueueDaemon.INSTANCE.stop(); // 引用队列线程 FinalizerDaemon.INSTANCE.stop(); // 析构线程 FinalizerWatchdogDaemon.INSTANCE.stop(); // 析构监控线程&#125; Zygote 是有 4 个子线程的，这里是需要停止这四个子线程，为 fork 操作空出资源来！ 此处守护线程 Stop 方式是先调用目标线程 interrrupt 方法，然后再调用目标线程 join 方法，等待线程执行完成。 3.3.1.1.2 ZygoteHooks.waitUntilAllThreadsStopped12345678private static void waitUntilAllThreadsStopped() &#123; File tasks = new File(\"/proc/self/task\"); //【1】判断 \"/proc/self/task\" 这个文件的长度！！ while (tasks.list().length &gt; 1) &#123; //【2】调用 yield 方法，出让 cpu！ Thread.yield(); &#125;&#125; 3.3.1.1.3 ZygoteHooks.nativePreForknativePreFork 通过 JNI 最终调用的是 dalvik_system_ZygoteHooks.cc 中的 ZygoteHooks_nativePreFork() 方法，如下： 1234567891011static jlong ZygoteHooks_nativePreFork(JNIEnv* env, jclass) &#123; Runtime* runtime = Runtime::Current(); CHECK(runtime-&gt;IsZygote()) &lt;&lt; \"runtime instance not started with -Xzygote\"; //【3.3.1.1.3.1】运行时堆的初始化！ runtime-&gt;PreZygoteFork(); if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123; Trace::Pause(); &#125; //【1】将线程类型转换为 long 型并保存到 token，该过程是非安全的。 return reinterpret_cast&lt;jlong&gt;(ThreadForEnv(env));&#125; 可以看出：ZygoteHooks.preFork 方法主要的作用是：停止 Zygote 的停止这四个子线程，确保 fork 进程时，Zygote 是单线程的，同时初始化 gc 堆！！ ZygoteHooks_nativePreFork 3.3.1.1.3.1 Runtime:nativePreFork1234void Runtime::PreZygoteFork() &#123; // 堆的初始化工作。这里是关于 art 虚拟机的，这里后面再说。 heap_-&gt;PreZygoteFork();&#125; 3.3.1.2 Zygote.nativeForkAndSpecialize - fork 子进程调用这个方法 nativeForkAndSpecialize 来进行 fork 进程！ 123native private static int nativeForkAndSpecialize(int uid, int gid, int[] gids,int debugFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, String instructionSet, String appDataDir); 这是一个本地方法，最后调用的是 com_android_internal_os_Zygote_nativeForkAndSpecialize 方法，位于 frameworks\\base\\core\\jni\\com_android_internal_os_Zygote.cpp 中： 12345678910111213141516171819202122232425262728293031323334353637383940414243static jint com_android_internal_os_Zygote_nativeForkAndSpecialize( JNIEnv* env, jclass, jint uid, jint gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring se_name, jintArray fdsToClose, jstring instructionSet, jstring appDataDir) &#123; jlong capabilities = 0; //【1】这里对子进程的 uid 如果是 AID_BLUETOOTH 的情况做了处理！ // 给你额外增加了一些权限和功能！！ if (multiuser_get_app_id(uid) == AID_BLUETOOTH) &#123; capabilities |= (1LL &lt;&lt; CAP_WAKE_ALARM); capabilities |= (1LL &lt;&lt; CAP_NET_RAW); capabilities |= (1LL &lt;&lt; CAP_NET_BIND_SERVICE); &#125; //【2】如果子进程的 gid 是 AID_WAKELOCK，我们会授予他 CAP_BLOCK_SUSPEND 的权限！ bool gid_wakelock_found = false; if (gid == AID_WAKELOCK) &#123; gid_wakelock_found = true; &#125; else if (gids != NULL) &#123; //【3】如果子进程的 gids 中有 AID_WAKELOCK，会授予他 CAP_BLOCK_SUSPEND 的权限！ jsize gids_num = env-&gt;GetArrayLength(gids); ScopedIntArrayRO ar(env, gids); if (ar.get() == NULL) &#123; RuntimeAbort(env, __LINE__, \"Bad gids array\"); &#125; for (int i = 0; i &lt; gids_num; i++) &#123; if (ar[i] == AID_WAKELOCK) &#123; gid_wakelock_found = true; break; &#125; &#125; &#125; if (gid_wakelock_found) &#123; capabilities |= (1LL &lt;&lt; CAP_BLOCK_SUSPEND); &#125; //【next】继续调用 ForkAndSpecializeCommon 方法！ return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, capabilities, capabilities, mount_external, se_info, se_name, false, fdsToClose, instructionSet, appDataDir);&#125; 接着，继续调用：ForkAndSpecializeCommon 方法，继续 fork！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; //【1】设置子进程的 signal 信号处理函数! SetSigChldHandler();#ifdef ENABLE_SCHED_BOOST SetForkLoad(true);#endif sigset_t sigchld; sigemptyset(&amp;sigchld); sigaddset(&amp;sigchld, SIGCHLD); // 调用 sigprocmask() 来暂时屏蔽/阻塞 SIGCHLD 信号，不然 SIGCHLD 信号会产生log，而被我们关闭掉的 // logging 文件描述符会对这个信号进行响应，所以会报错 // 到这里，zygote 进程就只有一个线程了！ if (sigprocmask(SIG_BLOCK, &amp;sigchld, nullptr) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_BLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; // 关闭 log 系统 __android_log_close(); // 如果是第一次 fork 进程，那么会创建 open FD table；否则，只需要检查 open FD 是否变化！ if (gOpenFdTable == NULL) &#123; gOpenFdTable = FileDescriptorTable::Create(); if (gOpenFdTable == NULL) &#123; RuntimeAbort(env, __LINE__, \"Unable to construct file descriptor table.\"); &#125; &#125; else if (!gOpenFdTable-&gt;Restat()) &#123; RuntimeAbort(env, __LINE__, \"Unable to restat file descriptor table.\"); &#125; //【2】这里是调用了 Linux 的 fork 方法，fork 进程，返回 2 次！ pid_t pid = fork(); //【3】根据 fork 的返回值，进行不同的处理！ if (pid == 0) &#123; //【3.1】pid 返回 0，进入子进程中执行！ gMallocLeakZygoteChild = 1; // 清理掉那些需要被立刻关闭的文件描述符 DetachDescriptors(env, fdsToClose); // Re-open all remaining open file descriptors so that they aren't shared // with the zygote across a fork. if (!gOpenFdTable-&gt;ReopenOrDetach()) &#123; RuntimeAbort(env, __LINE__, \"Unable to reopen whitelisted descriptors.\"); &#125; if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; //【3.1.1】非 root，禁止动态改变进程权限！ if (uid != 0) &#123; EnableKeepCapabilities(env); &#125; //【3.1.2】取消进程已有的 Capabilities 权限 DropCapabilitiesBoundingSet(env); // 判断是否使用 native bridge，这个模块基本上就是为了在JNI调用时进行动态转码用的！ // 要使用 native bridge，至少要满足一下条件： // 1、不是 SystemServer 进程，NativeBridge 主要是用来解决 JNI 函数的兼容性问题的，SystemServer 是 fork 自 Zygote， // 但是它属于系统的一部分，肯定是根据所在平台而编译的，因此肯定不需要转指令集； // 2、NativeBridge 已经准备好了； // 3、dataDir 也不能为 null； bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL) &amp;&amp; android::NativeBridgeAvailable(); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); use_native_bridge = android::NeedsNativeBridge(isa_string.c_str()); &#125; if (use_native_bridge &amp;&amp; dataDir == NULL) &#123;. use_native_bridge = false; ALOGW(\"Native bridge will not be used because dataDir == NULL.\"); &#125; if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123; ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno)); if (errno == ENOTCONN || errno == EROFS) &#123; &#125; else &#123; RuntimeAbort(env, __LINE__, \"Cannot continue without emulated storage\"); &#125; &#125; //【3.1.3】如果当前 fork 的子进程不是 system server 而是普通的应用进程的话，我们会创建进程组！ if (!is_system_server) &#123; int rc = createProcessGroup(uid, getpid()); if (rc != 0) &#123; if (rc == -EROFS) &#123; ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\"); &#125; else &#123; ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, pid, strerror(-rc)); &#125; &#125; &#125; //【3.1.4】设置进程所属的 group！ SetGids(env, javaGids); //【3.1.5】设置资源 limit！ SetRLimits(env, javaRlimits); if (use_native_bridge) &#123; ScopedUtfChars isa_string(env, instructionSet); ScopedUtfChars data_dir(env, dataDir); android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str()); &#125; //【3.1.6】设置真实的、有效的和保存过的 gid int rc = setresgid(gid, gid, gid); if (rc == -1) &#123; ALOGE(\"setresgid(%d) failed: %s\", gid, strerror(errno)); RuntimeAbort(env, __LINE__, \"setresgid failed\"); &#125; //【3.1.7】设置真实的、有效的和保存过的 uid rc = setresuid(uid, uid, uid); if (rc == -1) &#123; ALOGE(\"setresuid(%d) failed: %s\", uid, strerror(errno)); RuntimeAbort(env, __LINE__, \"setresuid failed\"); &#125; if (NeedsNoRandomizeWorkaround()) &#123; // Work around ARM kernel ASLR lossage (http://b/5817320). int old_personality = personality(0xffffffff); int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE); if (new_personality == -1) &#123; ALOGW(\"personality(%d) failed: %s\", new_personality, strerror(errno)); &#125; &#125; //【3.1.8】设置新的 capabilities 权限 SetCapabilities(env, permittedCapabilities, effectiveCapabilities); //【3.1.9】设置调度策略 SetSchedulerPolicy(env); // 获得进程的主线程的 nice name const char* se_info_c_str = NULL; ScopedUtfChars* se_info = NULL; if (java_se_info != NULL) &#123; se_info = new ScopedUtfChars(env, java_se_info); se_info_c_str = se_info-&gt;c_str(); if (se_info_c_str == NULL) &#123; RuntimeAbort(env, __LINE__, \"se_info_c_str == NULL\"); &#125; &#125; const char* se_name_c_str = NULL; ScopedUtfChars* se_name = NULL; if (java_se_name != NULL) &#123; se_name = new ScopedUtfChars(env, java_se_name); se_name_c_str = se_name-&gt;c_str(); if (se_name_c_str == NULL) &#123; RuntimeAbort(env, __LINE__, \"se_name_c_str == NULL\"); &#125; &#125; //【3.1.10】设置进程 selinux 上下文 rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str); if (rc == -1) &#123; ALOGE(\"selinux_android_setcontext(%d, %d, \\\"%s\\\", \\\"%s\\\") failed\", uid, is_system_server, se_info_c_str, se_name_c_str); RuntimeAbort(env, __LINE__, \"selinux_android_setcontext failed\"); &#125; //【3.1.11】设置进程的主线程的 nice name，用于方便调试！ if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123; se_name_c_str = \"system_server\"; &#125; if (se_info_c_str != NULL) &#123; SetThreadName(se_name_c_str); &#125; delete se_info; delete se_name; // 将子进程的 SIGCHLD 信号的处理函数修改回系统默认函数 UnsetSigChldHandler(); //【*3.3.1.2.1】JNI 调，相当于 zygote.callPostForkChildHooks()，在子进程中执行 env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server, instructionSet); if (env-&gt;ExceptionCheck()) &#123; RuntimeAbort(env, __LINE__, \"Error calling post fork hooks.\"); &#125; &#125; else if (pid &gt; 0) &#123; //【3.2】pid 大于 0 ，在父进程中执行，返回的 pid 的子进程的 pid！#ifdef ENABLE_SCHED_BOOST // unset scheduler knob SetForkLoad(false);#endif // 调用 sigprocmask() 取消屏蔽/阻塞 SIGCHLD 信号 if (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -1) &#123; ALOGE(\"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s\", strerror(errno)); RuntimeAbort(env, __LINE__, \"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed.\"); &#125; &#125; return pid;&#125; Zygote 进程是所有 Android 进程的母体，包括 system_server 进程以及 App 进程都是由 Zygote 进程孵化而来。 zygote 利用 fork() 方法生成新进程，对于新进程 A 复用 Zygote 进程本身的资源，再加上新进程 A 相关的资源，构成新的应用进程 A 。 关于 native bridge，我没有过多研究，大家可以看看这个博客： https://blog.csdn.net/sinat_38172893/article/details/73274591 3.3.1.2.1 Zygote.CallPostForkChildHooks - 子进程调用上面通过反射再次调用了 Zygote 的 CallPostForkChildHooks 方法： 12345private static void callPostForkChildHooks(int debugFlags, boolean isSystemServer, String instructionSet) &#123; //【3.3.1.2.1.1】继续调用！ VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);&#125; 这边有调用了 ZygoteHooks 的 postForkChild 方法： 3.3.1.2.1.1 ZygoteHooks.postForkChild这个方法是在 Zygote fork 出的子进程中调用的！！ 123456public void postForkChild(int debugFlags, boolean isSystemServer, String instructionSet) &#123; //【3.3.1.2.1.2】继续调用！ nativePostForkChild(token, debugFlags, isSystemServer, instructionSet); Math.setRandomSeedInternal(System.currentTimeMillis());&#125; 我们可以看到，这里传入了一个 token，这是是一个 long 型的值，用来保存线程的类型，在前面：13.3.1.1.3 ZygoteHooks.nativePreFork nativePreFork 会将 Zygote 主线程的类型转换为 long 型，保存到 ZygoteHooks.token 中！ 3.3.1.2.1.2 ZygoteHooks.nativePostForkChild我们继续看：12private static native void nativePostForkChild(long token, int debugFlags, boolean isSystemServer, String instructionSet); 这是一个 navtive 方法，最终调用 “\\art\\runtime\\native\\dalvik_system_ZygoteHooks.cc” 的 ZygoteHooks_nativePostForkChild 方法： 12345678910111213141516171819202122232425262728293031323334353637383940static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint debug_flags, jboolean is_system_server, jstring instruction_set) &#123; Thread* thread = reinterpret_cast&lt;Thread*&gt;(token); // Our system thread ID, etc, has changed so reset Thread state. //【1】初始化子进程的主线程！ // 该方法主要是获得主线程的 tid！ thread-&gt;InitAfterFork(); EnableDebugFeatures(debug_flags); // Update tracing. if (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123; ... ... ... ... // 这里是和 tracing 相关，不是重点！ &#125; if (instruction_set != nullptr &amp;&amp; !is_system_server) &#123; //【2.1】非 SystemServer 子进程，走这里！ ScopedUtfChars isa_string(env, instruction_set); InstructionSet isa = GetInstructionSetFromString(isa_string.c_str()); Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload; if (isa != kNone &amp;&amp; isa != kRuntimeISA) &#123; action = Runtime::NativeBridgeAction::kInitialize; &#125; //【3.3.1.2.1.3】调用 Runtime 的 InitNonZygoteOrPostFork 方法！！ Runtime::Current()-&gt;InitNonZygoteOrPostFork( env, is_system_server, action, isa_string.c_str()); &#125; else &#123; //【2.2】SystemServer 进程，走这里，请看开机流程相关的内容！ Runtime::Current()-&gt;InitNonZygoteOrPostFork( env, is_system_server, Runtime::NativeBridgeAction::kUnload, nullptr); &#125;&#125; 这里我们主要分析下，非 SystemServer 子进程的逻辑处理，对于 SystemServer 进程的处理，请看开机启动流程文章内容！ 3.3.1.2.1.3 Runtime.InitNonZygoteOrPostFork1234567891011121314151617181920212223242526272829303132333435363738void Runtime::InitNonZygoteOrPostFork( JNIEnv* env, bool is_system_server, NativeBridgeAction action, const char* isa) &#123; is_zygote_ = false; if (is_native_bridge_loaded_) &#123; // native bridge 相关逻辑！ switch (action) &#123; case NativeBridgeAction::kUnload: UnloadNativeBridge(); is_native_bridge_loaded_ = false; break; case NativeBridgeAction::kInitialize: InitializeNativeBridge(env, isa); break; &#125; &#125; // 创建堆处理的线程池！ heap_-&gt;CreateThreadPool(); // Reset the gc performance data at zygote fork so that the GCs // before fork aren't attributed to an app. heap_-&gt;ResetGcPerformanceInfo(); // 非 SystemServer 进程会进入这里！ if (!is_system_server &amp;&amp; !safe_mode_ &amp;&amp; (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp; jit_.get() == nullptr) &#123; // 创建 JIT! CreateJit(); &#125; // 设置信号处理函数！ StartSignalCatcher(); // 启动 JDWP 线程，当命令行 debuger 的 flags 指定\"suspend=y\"时，则暂停 runtime Dbg::StartJdwp();&#125; 3.3.1.3 ZygoteHooks.postForkCommon - fork 结束这个方法会在父进程 Zygote 和子进程中各调用一次，也就是说，在父进程 Zygote 中是恢复 4 个 Daemon 线程，而在子进程中，是启动 4 个 Daemon 线程！ 1234public void postForkCommon() &#123; //【3.3.1.3.1】启动 Deamons 线程！ Daemons.start();&#125; 3.3.1.3.1 Daemons.startZygoteHooks.postForkCommon 方法很简单，启动 4 个 Daemon 线程，java堆整理，引用队列，以及析构线程。 123456public static void start() &#123; ReferenceQueueDaemon.INSTANCE.start(); FinalizerDaemon.INSTANCE.start(); FinalizerWatchdogDaemon.INSTANCE.start(); HeapTaskDaemon.INSTANCE.start();&#125; 3.3.1.4 阶段总结首先来看看调用函数流程： 123456789101112131415161718Zygote.forkAndSpecialize ZygoteHooks.preFork // 停掉 zygote 的子线程，为 fork 做准备！ Daemons.stop ZygoteHooks.nativePreFork dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork Runtime::PreZygoteFork heap_-&gt;PreZygoteFork() Zygote.nativeForkAndSpecialize // fork 阶段，该这个方法会返回 2 次！ com_android_internal_os_Zygote.ForkAndSpecializeCommon fork() Zygote.callPostForkChildHooks ZygoteHooks.postForkChild dalvik_system_ZygoteHooks.nativePostForkChild Runtime::InitNonZygoteOrPostFork ZygoteHooks.postForkCommon // 启动 4 个 Deamon 子线程！ Daemons.start 这个流程很清楚啦，不都说了啦，嘿嘿嘿！ 3.3.2 ZygoteConncection.handleChildProc - 子进程处理我们知道，Zygote.forkAndSpecialize 会返回 2 次，当返回值为 0 时，进入子进程：123456789101112131415161718192021222324252627282930313233343536373839404142private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; // 抛出异常！ //【1】进程创建完毕，关闭 Socket 连接！ closeSocket(); ZygoteInit.closeServerSocket(); if (descriptors != null) &#123; try &#123; Os.dup2(descriptors[0], STDIN_FILENO); Os.dup2(descriptors[1], STDOUT_FILENO); Os.dup2(descriptors[2], STDERR_FILENO); for (FileDescriptor fd: descriptors) &#123; IoUtils.closeQuietly(fd); &#125; newStderr = System.err; &#125; catch (ErrnoException ex) &#123; Log.e(TAG, \"Error reopening stdio\", ex); &#125; &#125; if (parsedArgs.niceName != null) &#123; //【2】设置进程的 niceName Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; //【3.3.2.1】看前面的参数传递，parsedArgs.invokeWith 为 null，进入这个分支！ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; 我们继续看： 3.3.2.1 RuntimeInit.zygoteInit12345678910111213public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); //【3.3.2.1.1】进程的通用初始化 commonInit(); //【3.3.2.1.2】本地的 Zygote 初始化 nativeZygoteInit(); //【3.3.2.1.3】应用初始化！ applicationInit(targetSdkVersion, argv, classLoader);&#125; 啦啦啦啦啦 3.3.2.1.1 RuntimeInit.commonInit - 进程通用初始化进程的通用初始化： 123456789101112131415161718192021222324252627282930313233343536private static final void commonInit() &#123; if (DEBUG) Slog.d(TAG, \"Entered RuntimeInit!\"); //【1】设置该进程中所有线程的默认 crash handler！！ Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); //【2】设置时区！ TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get(\"persist.sys.timezone\"); &#125; &#125;); TimeZone.setDefault(null); //【3】重置 LogManager LogManager.getLogManager().reset(); new AndroidConfig(); //【4】设置默认的 http 用户代理，这个是 HttpURLConnection 必须的！ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); //【5】安装网络 NetworkManagementSocketTagger.install(); //【6】设置模拟器相关参数！ String trace = SystemProperties.get(\"ro.kernel.android.tracing\"); if (trace.equals(\"1\")) &#123; Slog.i(TAG, \"NOTE: emulator trace profiling enabled\"); Debug.enableEmulatorTraceOutput(); &#125; //【7】表示初始化完成！ initialized = true;&#125; 3.3.2.1.2 RuntimeInit.nativeZygoteInit - 进程本地初始化nativeZygoteInit 是一个 native 方法： 1private static final native void nativeZygoteInit(); 显然这是一个 native 方法，对应的 native 方法为 com_android_internal_os_RuntimeInit_nativeZygoteInit 方法，位于 AndroidRuntime.cpp 文件中：12345static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; //【1】调用了运行时的 onZygoteInit 方法！ gCurRuntime-&gt;onZygoteInit();&#125; 接着，进入 App_main.cpp 文件中：123456789virtual void onZygoteInit()&#123; //【1】获得当前进程的 ProcessState 对象！！ sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); //【2】创建一个新的 Binder 线程，不断的 talkWithDriver！！ proc-&gt;startThreadPool();&#125; 这里的 ProcessState 对象是一个单例模式，他会打开 /dev/binder 驱动设备，分配内核空间，然后 start 一个 binder 线程，不断地 talkWithDriver，用于进行进程间通信！ 3.3.2.1.3 RuntimeInit.applicationInit - 初始化进程的 Application 对象这里很重要，初始化进程的 Application 对象！1234567891011121314151617181920212223242526272829private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true); //【1】设置 java 堆内存的利用率为 75%，以及目标 sdk 平台的版本！ VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; //【2】解析参数！ args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); return; &#125; //【3】结束对子进程的监控！ Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //【3.3.2.1.3.1】进一步解析参数，执行 startClass 类的 main 方法！！ invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; 这里有人要问了，这个 startClass 是什么类，此处 args.startClass 为 “android.app.ActivityThread”。 3.3.2.1.3.1 RuntimeInit.invokeStaticMain1234567891011121314151617181920212223242526272829303132333435private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; //【1】反射获得 ActivityThread 类！ cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; //【2】获得 ActivityThread 的 main 方法！ m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; //【3.4】这个地方抛出了 MethodAndArgsCaller 异常！！！ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 这里通过反射，获得了 ActivityThread.main 方法，然后创建了一个异常：MethodAndArgsCaller，抛了出去！ 这个异常会通过 ZygoteConnection.runOnce 方法传递出去，进入了 ZygoteInit.main 方法，那里会对这个异常进行 catch 并处理！ 3.3.3 ZygoteConncection.handleParentProc - 父进程处理当 fork 的返回值大于 0，那就进入父进程 Zygote，返回 pid 的值是子进程的进程值：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private boolean handleParentProc(int pid, FileDescriptor[] descriptors, FileDescriptor pipeFd, Arguments parsedArgs) &#123; //【1】判断一下返回值，若大于 0，说明 fork 成功， // 设置子进程的 pgid！ if (pid &gt; 0) &#123; //【*3.3.3.1】设置进程的 pgid！ setChildPgid(pid); &#125; if (descriptors != null) &#123; for (FileDescriptor fd: descriptors) &#123; IoUtils.closeQuietly(fd); &#125; &#125; boolean usingWrapper = false; if (pipeFd != null &amp;&amp; pid &gt; 0) &#123; DataInputStream is = new DataInputStream(new FileInputStream(pipeFd)); int innerPid = -1; try &#123; innerPid = is.readInt(); &#125; catch (IOException ex) &#123; Log.w(TAG, \"Error reading pid from wrapped process, child may have died\", ex); &#125; finally &#123; try &#123; is.close(); &#125; catch (IOException ex) &#123; &#125; &#125; // Ensure that the pid reported by the wrapped process is either the // child process that we forked, or a descendant of it. if (innerPid &gt; 0) &#123; int parentPid = innerPid; while (parentPid &gt; 0 &amp;&amp; parentPid != pid) &#123; parentPid = Process.getParentPid(parentPid); &#125; if (parentPid &gt; 0) &#123; Log.i(TAG, \"Wrapped process has pid \" + innerPid); pid = innerPid; usingWrapper = true; &#125; else &#123; Log.w(TAG, \"Wrapped process reported a pid that is not a child of \" + \"the process that we forked: childPid=\" + pid + \" innerPid=\" + innerPid); &#125; &#125; &#125; try &#123; mSocketOutStream.writeInt(pid); mSocketOutStream.writeBoolean(usingWrapper); &#125; catch (IOException ex) &#123; Log.e(TAG, \"Error writing to command socket\", ex); return true; &#125; return false;&#125; 3.3.3.1 setChildPgid设置 fork 出的进程的 pgid： 12345678910111213private void setChildPgid(int pid) &#123; // Try to move the new child into the peer's process group. try &#123; Os.setpgid(pid, Os.getpgid(peer.getPid())); &#125; catch (ErrnoException ex) &#123; // This exception is expected in the case where // the peer is not in our session // TODO get rid of this log message in the case where // getsid(0) != getsid(peer.getPid()) Log.i(TAG, \"Zygote: setpgid failed. This is \" + \"normal if peer is not in our session\"); &#125;&#125; 3.4 MethodAndArgsCaller.run - 处理异常MethodAndArgsCaller 类位于 ZygoteInit.java 中： 123456789101112131415161718192021222324252627282930public static class MethodAndArgsCaller extends Exception implements Runnable &#123; /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; //【1】执行进程的 ActivityThread.main 方法！！ mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; 这里就正式进入了新进程的 ActivityThread.main 方法，我们知道 ActivityThread.main 是应用程序进程的入口，到这里就将从 native 进入 java 层了，进行进一步的进程启动！ 4 总结4.1 通信方式总结可以看出，主要有以下的两种通信方式：Binder 和 Socket !! 启动方进程 -&gt; SystemServer 进程: Binder SystemServer 进程 -&gt; Zygote 进程：Socket Zygote 进程 -&gt; 被启动进程：Socket 主要的流程图如下： 4.2 调用流程总结UML 序列图先埋坑，以后再填。。","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Process进程","slug":"AndroidFramework源码分析/Process进程","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Process进程/"}],"tags":[{"name":"Process进程","slug":"Process进程","permalink":"https://coolqi.top/tags/Process进程/"}]},{"title":"Process篇 1 - Android 进程的启动","slug":"Process1-theStartOfProcess","date":"2016-03-13T12:46:25.000Z","updated":"2018-11-20T15:29:10.000Z","comments":true,"path":"2016/03/13/Process1-theStartOfProcess/","link":"","permalink":"https://coolqi.top/2016/03/13/Process1-theStartOfProcess/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析，进程 1 前言我们知道，在 Android 系统中，每一个 app 都至少运行在一个进程中的，可以通过配置 Android:process 属性，来使 app 的某个组件运行在不同的进程中的，从而达到一个 app 在运行在多个进程中！ 本文将总结和分析 Android 进程启动进程的主要流程，更深入地理解 Android 系统的架构！ 2 启动进程的方法AMS 中进程启动相关的方法有如下的 2 组：123456789101112private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; //【1】进一步调用 startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */);&#125;private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ... ... ... ...&#125; 第一组，可以看出启动方式是通过进程的 ProcessRecord 对象来启动的！参数传递： ProcessRecord app：进程对应的 ProcessRecord 对象！ String hostingType： String hostingNameStr： String abiOverride：null String entryPoint：null String[] entryPointArgs：null 接着来看：1234567891011121314151617181920212223242526272829303132final ProcessRecord startProcessLocked(String processName, ApplicationInfo info， boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123; // 进一步调用 return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,null /* crashHandler */);&#125;final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123; ... ... ... ... // 最后又调用了第一组方法中的第二个方法！！ startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, \"startProcess: done starting proc!\"); return (app.pid != 0) ? app : null;&#125; 第二组，可以看出启动方式是通过应用的进程名和 ApplicationInfo来启动进程的！参数传递： String processName：进程名字，默认为包名！ ApplicationInfo info：进程所属应用的信息对象！ boolean knownToBeDead：父进程是否需要在该进程死亡后接到通知！ int intentFlags：intent 启动的 flags 参数！ String hostingType：值为 “activity”，“service”，“broadcast” 或者 “content provider”； String hostingNameStr：数据类型为 ComponentName，代表的是具体相对应的组件名！ boolean allowWhileBooting：这个在AMS的启动篇里有涉及过，表示开机时是否拉起该进程! boolean isolated：表示该进程是否是一个隔离进程！ int isolatedUid：0 隔离进程的 uid！ boolean keepIfLarge： String abiOverride：null String entryPoint：null String[] entryPointArgs：null Runnable crashHandler：null 最后，都调用了：123private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ... ... ... ... 接着，我们进入今天的正文，进程的启动！！ 3 startProcessLocked - 启动接下来，我们来看看用进程名 precessName 和应用的 ApplicationInfo 对象启动进程的方法，这个方法略微有些长，我们来仔细的分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123; long startTime = SystemClock.elapsedRealtime(); ProcessRecord app; //【1】如果该进程不是一个隔离进程！ if (!isolated) &#123; //【1】尝试获得其对应的 ProcessRecord 对象！ app = getProcessRecordLocked(processName, info.uid, keepIfLarge); checkTime(startTime, \"startProcess: after getProcessRecord\"); if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != 0) &#123; // 如果是后台操作启动该进程，需要判断该进程是否是一个 bad 进程，如果是，启动失败！ if (mAppErrors.isBadProcessLocked(info)) &#123; if (DEBUG_PROCESSES) Slog.v(TAG, \"Bad process: \" + info.uid + \"/\" + info.processName); return null; &#125; &#125; else &#123; if (DEBUG_PROCESSES) Slog.v(TAG, \"Clearing bad process: \" + info.uid + \"/\" + info.processName); // 如果是用户交互，主动启动这个进程，那么，就要清空这个进程的 crash 次数 // 并且将该进程从 bad 列表中移除，变为一个 good 进程！ // 直到下一次再次 crash 才会变成一个 bad 进程！ mAppErrors.resetProcessCrashTimeLocked(info); if (mAppErrors.isBadProcessLocked(info)) &#123; EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, UserHandle.getUserId(info.uid), info.uid, info.processName); mAppErrors.clearBadProcessLocked(info); if (app != null) &#123; app.bad = false; &#125; &#125; &#125; &#125; else &#123; // 对于隔离进程，不能利用已存在的 ProcessRecord！ app = null; &#125; // app launch boost for big.little configurations // use cpusets to migrate freshly launched tasks to big cores nativeMigrateToBoost(); mIsBoosted = true; mBoostStartTime = SystemClock.uptimeMillis(); Message msg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG); mHandler.sendMessageDelayed(msg, APP_BOOST_MESSAGE_DELAY); if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, \"startProcess: name=\" + processName + \" app=\" + app + \" knownToBeDead=\" + knownToBeDead + \" thread=\" + (app != null ? app.thread : null) + \" pid=\" + (app != null ? app.pid : -1)); // 如果 app 不为 null，且 pid 大于 0，说明这个进程已经或者正在启动！ if (app != null &amp;&amp; app.pid &gt; 0) &#123; // 如果调用者不知道该进程已死亡，并且进程并没有被 kill（正在运行） // 或是该 ProcessRecord 没有绑定应用程序进程的 ApplicationThread 对象！ if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123; if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, \"App already running: \" + app); // 如果这是该进程中的一个新应用 package，将其加入到进程的列表中！ app.addPackage(info.packageName, info.versionCode, mProcessStats); checkTime(startTime, \"startProcess: done, added package to proc\"); // 直接返回这个已经存在的 ProcessRecord，退出！ return app; &#125; // An application record is attached to a previous process, // clean it up now. if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_PROCESSES, \"App died: \" + app); checkTime(startTime, \"startProcess: bad proc running, killing\"); // 该 ProcessRecord 已经绑定了上一个进程，杀死并清理该进程！ killProcessGroup(app.uid, app.pid); handleAppDiedLocked(app, true, true); checkTime(startTime, \"startProcess: done killing old proc\"); &#125; String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null; if (app == null) &#123; // 如果 app 为 null，那说明这是一个新进程！ checkTime(startTime, \"startProcess: creating new process record\"); // 创建新进程对应的 ProcessRecord 对象！ app = newProcessRecordLocked(info, processName, isolated, isolatedUid); if (app == null) &#123; Slog.w(TAG, \"Failed making new process record for \" + processName + \"/\" + info.uid + \" isolated=\" + isolated); return null; &#125; // 设置进程的 crashHandler，默认为 null！ app.crashHandler = crashHandler; checkTime(startTime, \"startProcess: done creating new process record\"); &#125; else &#123; // 如果这是该进程中的一个新应用 package，将其加入到进程的列表中！ app.addPackage(info.packageName, info.versionCode, mProcessStats); checkTime(startTime, \"startProcess: added package to existing proc\"); &#125; // 如果系统还没准备好，则将当前进程加入到 mPorcessOnHold 中！ if (!mProcessesReady &amp;&amp; !isAllowedWhileBooting(info) &amp;&amp; !allowWhileBooting) &#123; if (!mProcessesOnHold.contains(app)) &#123; mProcessesOnHold.add(app); &#125; if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, \"System not ready, putting on hold: \" + app); checkTime(startTime, \"startProcess: returning with proc on hold\"); // 返回这个进程对应的 ProcessRecord 对象！ return app; &#125; checkTime(startTime, \"startProcess: stepping in to startProcess\"); // 到这里，说明进程还没有创建，接着调用 startRrocessLocked 方法，进行进一步的启动！ startProcessLocked( app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, \"startProcess: done starting proc!\"); return (app.pid != 0) ? app : null;&#125; 继续分析！ 3.1 AMS.newProcessRecordLocked创建进程对应的 ProcessRecord 结构体，参数传递： ApplicationInfo info：应用程序的 info 对象！ String customProcess：进程名 boolean isolated：是否是隔离进程！ int isolatedUid：隔离进程的 uid，默认传入 0！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) &#123; String proc = customProcess != null ? customProcess : info.processName; BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); final int userId = UserHandle.getUserId(info.uid); int uid = info.uid; if (isolated) &#123; // 隔离进程！ if (isolatedUid == 0) &#123; //如果传入的值的是默认值 0，系统会给隔离进程分配 uid！ int stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + 1; while (true) &#123; if (mNextIsolatedProcessUid &lt; Process.FIRST_ISOLATED_UID || mNextIsolatedProcessUid &gt; Process.LAST_ISOLATED_UID) &#123; mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID; &#125; uid = UserHandle.getUid(userId, mNextIsolatedProcessUid); mNextIsolatedProcessUid++; if (mIsolatedProcesses.indexOfKey(uid) &lt; 0) &#123; // No process for this uid, use it. break; &#125; stepsLeft--; if (stepsLeft &lt;= 0) &#123; return null; &#125; &#125; &#125; else &#123; // 如果传入的不是默认值 0，那隔离进程的 uid 就由传入参数指定！ uid = isolatedUid; &#125; // Register the isolated UID with this application so BatteryStats knows to // attribute resource usage to the application. // // NOTE: This is done here before addProcessNameLocked, which will tell BatteryStats // about the process state of the isolated UID *before* it is registered with the // owning application. mBatteryStatsService.addIsolatedUid(uid, info.uid); &#125; // 创建 ProcessRecord 对象！ final ProcessRecord r = new ProcessRecord(stats, info, proc, uid); if (!mBooted &amp;&amp; !mBooting &amp;&amp; userId == UserHandle.USER_SYSTEM &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; // 设置其 persistent 属性 为 true！ r.persistent = true; &#125; // 见 3.1.1 addProcessNameLocked(r); return r;&#125; 3.1.1 AMS.addProcessNameLocked接着，调用该方法，将新创建的 ProcessRecord 加入到 AMS 对应的集合：12345678910111213141516171819202122232425262728293031323334353637383940414243private final void addProcessNameLocked(ProcessRecord proc) &#123; // We shouldn't already have a process under this name, but just in case we // need to clean up whatever may be there now. // 移除相同的之前被添加过的进程！ ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid); if (old == proc &amp;&amp; proc.persistent) &#123; // We are re-adding a persistent process. Whatevs! Just leave it there. Slog.w(TAG, \"Re-adding persistent process \" + proc); &#125; else if (old != null) &#123; Slog.wtf(TAG, \"Already have existing proc \" + old + \" when adding \" + proc); &#125; // 给这个进程的所属 uid 创建 UidRecord 对象，如果已创建过了，就不创建！！ UidRecord uidRec = mActiveUids.get(proc.uid); if (uidRec == null) &#123; uidRec = new UidRecord(proc.uid); // This is the first appearance of the uid, report it now! if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, \"Creating new process uid: \" + uidRec); // 第一次创建时，要加入到 mActiveUids 集合中去！ mActiveUids.put(proc.uid, uidRec); noteUidProcessState(uidRec.uid, uidRec.curProcState); enqueueUidChangeLocked(uidRec, -1, UidRecord.CHANGE_ACTIVE); &#125; // 添加 proc 对 UidRecord 引用！ proc.uidRecord = uidRec; // Reset render thread tid if it was already set, so new process can set it again. proc.renderThreadTid = 0; // UidRecord 的被引用计数加 1 uidRec.numProcs++; // 将新创建的 ProcessRecord 对象加入到 ams 的 ProcessNames 中！ mProcessNames.put(proc.processName, proc.uid, proc); if (proc.isolated) &#123; // 如果该进程是隔离进程，还要添加到 mIsolatedProcesses 集合中去！！ mIsolatedProcesses.put(proc.uid, proc); &#125;&#125; 这里有提到 AMS 的几个成员对象： mActiveUids：当前活跃的 uid 集合； mProcessNames：以进程的 processName 为 key，存储所有的 ProcessRecord 对象！ mIsolatedProcesses：以进程的 pid 为 key，存储所有的 ProcessRecord 对象！ 4 startProcessLocked - ProcessRecord接着们就要进入最关键的一个方法哦，启动进程！参数传递： ProcessRecord app, String hostingType, String hostingNameStr： String abiOverride： String entryPoint：null String[] entryPointArg：null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; long startTime = SystemClock.elapsedRealtime(); // 如果要启动的进程不是 systemServer 进程，也就是应用进程！ if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; checkTime(startTime, \"startProcess: removing from pids map\"); synchronized (mPidsSelfLocked) &#123; // 将进程从 mPidsSelfLocked 中移除！ mPidsSelfLocked.remove(app.pid); mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); &#125; checkTime(startTime, \"startProcess: done removing from pids map\"); // 先设置进程的 pid 为 0！ app.setPid(0); &#125; if (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES, \"startProcessLocked removing on hold: \" + app); // 记得前面的 mProcessesOnHold 吗？也要把进程从这里 remove 掉！ mProcessesOnHold.remove(app); checkTime(startTime, \"startProcess: starting to update cpu stats\"); updateCpuStats(); checkTime(startTime, \"startProcess: done updating cpu stats\"); try &#123; try &#123; // 获得设备用户 id! final int userId = UserHandle.getUserId(app.uid); AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; int uid = app.uid; int[] gids = null; int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; if (!app.isolated) &#123; // 对于非隔离的进程！ int[] permGids = null; try &#123; checkTime(startTime, \"startProcess: getting gids from package manager\"); final IPackageManager pm = AppGlobals.getPackageManager(); permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId); MountServiceInternal mountServiceInternal = LocalServices.getService( MountServiceInternal.class); mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; /* * Add shared application and profile GIDs so applications can share some * resources like shared libraries and access user-wide resources */ if (ArrayUtils.isEmpty(permGids)) &#123; gids = new int[2]; &#125; else &#123; gids = new int[permGids.length + 2]; System.arraycopy(permGids, 0, gids, 2, permGids.length); &#125; gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid)); gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid)); &#125; checkTime(startTime, \"startProcess: building args\"); if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopComponent != null &amp;&amp; app.processName.equals(mTopComponent.getPackageName())) &#123; uid = 0; &#125; if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL &amp;&amp; (app.info.flags&amp;ApplicationInfo.FLAG_FACTORY_TEST) != 0) &#123; uid = 0; &#125; &#125; // 处理 debugFlags 相关的取值！ int debugFlags = 0; ... ... ... ...// 此处是设置调试相关的代码，暂时省略！ // 设置 app 要运行的硬件环境！ String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) &#123; requiredAbi = Build.SUPPORTED_ABIS[0]; &#125; String instructionSet = null; if (app.info.primaryCpuAbi != null) &#123; instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi); &#125; // 设置进程的 gids，运行的环境等等！ app.gids = gids; app.requiredAbi = requiredAbi; app.instructionSet = instructionSet; // 设置新进程创建后的入口：\"android.app.ActivityThread\" boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = \"android.app.ActivityThread\"; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); // 这里很关键！！调用了 Process.Start 方法，创建新进程，并返回创建结果！ // 这类返回 startResult 包含子进程的 pid 等信息！ Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, \"startProcess: returned from zygote!\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); mBatteryStatsService.noteProcessStart(app.processName, app.info.uid); checkTime(startTime, \"startProcess: done updating battery stats\"); EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : \"\"); try &#123; AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid); &#125; catch (RemoteException ex) &#123; // Ignore &#125; if (app.persistent) &#123; // 如果是 persistent 的进程，启动 WathDog 进行监控！ Watchdog.getInstance().processStarted(app.processName, startResult.pid); &#125; checkTime(startTime, \"startProcess: building log message\"); StringBuilder buf = mStringBuilder; buf.setLength(0); buf.append(\"Start proc \"); buf.append(startResult.pid); buf.append(':'); buf.append(app.processName); buf.append('/'); UserHandle.formatUid(buf, uid); if (!isActivityProcess) &#123; buf.append(\" [\"); buf.append(entryPoint); buf.append(\"]\"); &#125; buf.append(\" for \"); buf.append(hostingType); if (hostingNameStr != null) &#123; buf.append(\" \"); buf.append(hostingNameStr); &#125; Slog.i(TAG, buf.toString()); // 根据创建进程的返回结果设置对应的 ProcessRecord 的参数：pid 等等！ app.setPid(startResult.pid); app.usingWrapper = startResult.usingWrapper; app.removed = false; app.killed = false; app.killedByAm = false; checkTime(startTime, \"startProcess: starting to update pids map\"); ProcessRecord oldApp; synchronized (mPidsSelfLocked) &#123; oldApp = mPidsSelfLocked.get(startResult.pid); &#125; // 如果已经有一个应用进程占用了分配的 pid，那就对这个进程进行清理！ if (oldApp != null &amp;&amp; !app.isolated) &#123; // Clean up anything relating to this pid first Slog.w(TAG, \"Reusing pid \" + startResult.pid + \" while app is still mapped to it\"); cleanUpApplicationRecordLocked(oldApp, false, false, -1, true /*replacingPid*/); &#125; synchronized (mPidsSelfLocked) &#123; // 将新创建的进程加入到 mPidsSelfLocked，用于 AMS 进行管理！ this.mPidsSelfLocked.put(startResult.pid, app); if (isActivityProcess) &#123; Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG); msg.obj = app; mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT); &#125; &#125; checkTime(startTime, \"startProcess: done updating pids map\"); &#125; catch (RuntimeException e) &#123; Slog.e(TAG, \"Failure starting process \" + app.processName, e); // 进程启动失败：比如，进程被冻结了等等，就调用 forceStopPackageLocked 清理进程！ forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), \"start failure\"); &#125;&#125; 这个方法很长，我们回顾一下它的主要作用： 先将进程的 pid 设置为 0， 根据不同参数，设置相应的 debugFlags，比如在 AndroidManifest.xml 中设置 androidd:debuggable 为 true，代表 app 运行在 debug 模式，则增加 debugger 标识以及开启 JNI check 功能等等。 调用 Process.start 进入 Zygote，来创建新进程，并返回创建的结果 ProcessStartResult 。 根据 fork 的结果，再次设置 ProcessRecord 的成员变量， 包括 pid， killded，killedByAm 等等属性！ 可以看出，这个方法的关键，就在于 Process.start 方法，是用来创建进程的，这个方法我们在第二篇：进程的创建一文中有讲，这里因为篇幅关系，就省略了！ 接着就要进入这个新进程的 ActivityThread.main 方法了： 5 ActivityThread.main这个方法是应用程序进程的入口：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); // 将当前进程所在 userId 赋值给 sCurrentUser Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); // 创建主线程的 Looper 对象！ Looper.prepareMainLooper(); // 创建该进程的 ActivityThread 对象！ ActivityThread thread = new ActivityThread(); // attach 到 ActiviyManagerService ，保持进程和 SystemServer 的 binder 通信！ // 这里我们下面重点讲！ thread.attach(false); if (sMainThreadHandler == null) &#123; // 获得主线程的 Handler 对象 mH； sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; // 当设置为 true 时，可打开消息队列的 debug log 信息 Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // 进入消息循环，没消息进入休眠状态，有消息进入唤醒状态! Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 这个方法的作用有如下： 创建主线程的 Looper 对象，主线程的 Looper 对象是在进程创建后自动创建的！ 创建该进程的 ActivityThread 对象，每一个进程都有一个 ActivityThread 对象！ mAppThread = new ApplicationThread()，创建 ApplicationThread 对象，他是应用进程和 AMS 通信的桥梁； mLooper = Looper.myLooper()，获得主线程的 Looper 对象； mH = new H()，H 继承于 Handler 对象，主线程的 Handler，用于处理组件的生命周期！ … … … 获得主线程的 Handler 对象 mH： 进入消息循环：Looper.loop，没有消息进入休眠，有消息就被唤醒，处理消息！ 注意：这里要先说一下：ActivityThread 和 ApplicationThread 对象，二者都不是线程对象！一个应用程序进程对应一个 ActivityThread 实例，应用程序进程由 ActivityThread.main 打开消息循环；同时，一个应用程序进程也对应一个 ApplicationThread 对象，此对象是 ActivityThread 与 ActivityManagerService 连接的桥梁！ 6 ActivityThread.attach参数传递： system：表示是否是系统进程的 ActivityThread，调用传入 false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private void attach(boolean system) &#123; // 表示当前进程的 ActivityThread sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; // 应用进程，进入这个分支。 ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; // 开启虚拟机的 jit 即时编译功能 ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); // 获得 AMS final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; // 调用 ams 的 attachApplication 方法 mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; // Watch for getting close to heap limit. // 观察是否快接近 heap 的上限 BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); // 当进程虚拟机的已用内存超过最大内存的 3/4 if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, \"Dalvik max=\" + (dalvikMax/1024) + \" total=\" + (runtime.totalMemory()/1024) + \" used=\" + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; // 调用 AMS 的 releaseSomeActivities 方法释放进程的内存！ mgr.releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; &#125;); &#125; else &#123; // 这里是处理系统进程的：SystemServer，这里不看 android.ddm.DdmHandleAppName.setAppName(\"system_process\", UserHandle.myUserId()); try &#123; mInstrumentation = new Instrumentation(); ContextImpl context = ContextImpl.createAppContext(this, getSystemContext().mPackageInfo); // 创建系统进程的 Application 对象！ mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate Application():\" + e.toString(), e); &#125; &#125; // add dropbox logging to libcore DropBox.setReporter(new DropBoxReporter()); // 添加 Config 回调接口 ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; synchronized (mResourcesManager) &#123; // We need to apply this change to the resources // immediately, because upon returning the view // hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) &#123; updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(), mResourcesManager.getConfiguration().getLocales()); // This actually changed the resources! Tell // everyone about it. if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123; mPendingConfiguration = newConfig; sendMessage(H.CONFIGURATION_CHANGED, newConfig); &#125; &#125; &#125; &#125; @Override public void onLowMemory() &#123; &#125; @Override public void onTrimMemory(int level) &#123; &#125; &#125;);&#125; 对于应用进程的 attach 主要流程： 创建线程来开启虚拟机的 JIT 即时编译。 通过 binder，调用到 AMS.attachApplication，其参数 mAppThread 的数据类型为 ApplicationThread。 观察是否快接近 heap 的上限，当已用内存超过最大内存的 3 / 4，则请求释放内存空间。 添加 dropbox 日志到 libcore。 添加 Config 回调接口。 7 ActivityManagerProxy.attachApplication 参数传递：IApplicationThread app，这里传入的是 ApplicationThread 对象！ 123456789101112public void attachApplication(IApplicationThread app) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); // binder 通信！ mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle();&#125; 以上是在应用进程里面，下面就要通过 Binder 通信，进入系统进程中：此处：descriptor = “android.app.IActivityManager”，用来校验使用的！ 8 ActivityManagerNative.onTransact123456789101112131415161718192021222324252627282930@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; ... ... ... ... case ATTACH_APPLICATION_TRANSACTION: &#123; // 校验 binder 通信是否匹配! data.enforceInterface(IActivityManager.descriptor); // 通过 asInterface 接口，将 ApplicationThread 对象转为 ApplicationTreadProxy 对象！ IApplicationThread app = ApplicationThreadNative.asInterface( data.readStrongBinder()); if (app != null) &#123; // 调用 IActivityManager 的方法，接下来，进入 AMS！ attachApplication(app); &#125; reply.writeNoException(); return true; &#125; ... ... ... ... &#125;&#125; 通过 Binder 通信，调用 AMS 的方法：！ 9 ActivityManagerService.attachApplication12345678910111213@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; // 获得调用方的 pid，这里是应用进程的 pid！ int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); // 调用 attachApplicationLocked 继续处理！ attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; 这里简单，再获得应用进程的 pid！ 10 ActivityManagerService.attachApplicationLocked传入参数： ApplicationThreadProxy 对象，应用程序进程的 pid 删掉了部分的注释！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ProcessRecord app; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; // 显然，调用方进程不是 SystemServer 进程！ synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); // 获得该进程的 ProcessRecord 对象！ &#125; &#125; else &#123; app = null; &#125; if (app == null) &#123; // 如果获得的 ProcessRecord 为 null，这里是属于异常情况！ Slog.w(TAG, \"No pending application record for pid \" + pid + \" (IApplicationThread \" + thread + \"); dropping process\"); EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid); if (pid &gt; 0 &amp;&amp; pid != MY_PID) &#123; // 如果调用方不是 SystemServer 进程，杀掉进程组！ Process.killProcessQuiet(pid); //TODO: killProcessGroup(app.info.uid, pid); &#125; else &#123; try &#123; thread.scheduleExit(); &#125; catch (Exception e) &#123; // Ignore exceptions. &#125; &#125; return false; &#125; // 如果 ProcessRecord 不为 null，且 ProcessRecord.thread 不为 null // 说明该 ProcessRecord 已经 attach 了另外一个进程，需要立即清空这个 ProcessRecord！ if (app.thread != null) &#123; handleAppDiedLocked(app, true, true); &#125; // Tell the process all about itself. if (DEBUG_ALL) Slog.v( TAG, \"Binding process pid \" + pid + \" to record \" + app); // 获得进程的名称! final String processName = app.processName; try &#123; // 创建进程死亡通知对象，并绑定死亡通知对象！ AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; &#125; catch (RemoteException e) &#123; app.resetPackageList(mProcessStats); startProcessLocked(app, \"link fail\", processName); return false; &#125; EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName); // 重置进程的信息！ // 这里将传入的 ApplicationThreadProxy 对象赋给 app.thread，完成 attach 操作！！ // 这里进程开始处于 active 状态! app.makeActive(thread, mProcessStats); app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ; app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.forcingToForeground = null; updateProcessForegroundLocked(app, false, false); app.hasShownUi = false; app.debugging = false; app.cached = false; app.killedByAm = false; app.unlocked = StorageManager.isUserKeyUnlocked(app.userId); mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); // 进程处于 ready 状态或者该进程为 FLAG_PERSISTENT 进程，即常驻进程，则 normalMode 为 true！ boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); // 获得该进程中的 providers！ List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null; // 检查新进程是否存在正在启动中的 provider， // 如果有，则超时 10s 后发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息！ if (providers != null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123; Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG); msg.obj = app; mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT); &#125; if (!normalMode) &#123; Slog.i(TAG, \"Launching preboot mode app: \" + app); &#125; if (DEBUG_ALL) Slog.v( TAG, \"New app record \" + app + \" thread=\" + thread.asBinder() + \" pid=\" + pid); try &#123; int testMode = IApplicationThread.DEBUG_OFF; if (mDebugApp != null &amp;&amp; mDebugApp.equals(processName)) &#123; testMode = mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON; app.debugging = true; if (mDebugTransient) &#123; mDebugApp = mOrigDebugApp; mWaitForDebugger = mOrigWaitForDebugger; &#125; &#125; String profileFile = app.instrumentationProfileFile; ParcelFileDescriptor profileFd = null; int samplingInterval = 0; boolean profileAutoStop = false; if (mProfileApp != null &amp;&amp; mProfileApp.equals(processName)) &#123; mProfileProc = app; profileFile = mProfileFile; profileFd = mProfileFd; samplingInterval = mSamplingInterval; profileAutoStop = mAutoStopProfiler; &#125; boolean enableTrackAllocation = false; if (mTrackAllocationApp != null &amp;&amp; mTrackAllocationApp.equals(processName)) &#123; enableTrackAllocation = true; mTrackAllocationApp = null; &#125; // If the app is being launched for restore or full backup, set it up specially boolean isRestrictedBackupMode = false; if (mBackupTarget != null &amp;&amp; mBackupAppName.equals(processName)) &#123; isRestrictedBackupMode = mBackupTarget.appInfo.uid &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL)); &#125; if (app.instrumentationClass != null) &#123; notifyPackageUse(app.instrumentationClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, \"Binding proc \" + processName + \" with config \" + mConfiguration); // 获得进程的所有者应用程序的信息！ ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info; app.compat = compatibilityInfoForPackageLocked(appInfo); if (profileFd != null) &#123; profileFd = profileFd.dup(); &#125; ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop); // 这里很关键了，之前通过 attach 的方式，实现了从 SystemServer 进程到应用程序进程的单向 bind // 通信，而这里的 bind 操作最终的结果，是实现了 SystemServer 进程和应用程序进程的双向 bind 通信！ thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); // 更新进程 LRU 队列！ updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); // 每当 bind 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。 startProcessLocked(app, \"bind fail\", processName); return false; &#125; // 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses！ // 和等待启动的进程集合 mProcessesOnHold 中移除！ mPersistentStartingProcesses.remove(app); mProcessesOnHold.remove(app); boolean badApp = false; boolean didSomething = false; if (normalMode) &#123; // 如果是正常启动的情况下！ try &#123; // 检查是否有 activity 组件要在这个新进程中运行！ if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e); // 检查异常，将 badApp 置为 true！ badApp = true; &#125; &#125; if (!badApp) &#123; try &#123; // 检查是否有 sevvce 组件要在这个新进程中运行！ didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown starting services in \" + app, e); badApp = true; &#125; &#125; // 检查是否有 broadcast 组件要在这个新进程中运行！ if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; // If the app died trying to launch the receiver we declare it 'bad' Slog.wtf(TAG, \"Exception thrown dispatching broadcasts in \" + app, e); badApp = true; &#125; &#125; // 检查是否在这个新进程中有下一个 backup 代理！ if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.appInfo.uid == app.uid) &#123; if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, \"New app is backup target, launching agent for \" + app); notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP); try &#123; thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown creating backup agent in \" + app, e); badApp = true; &#125; &#125; if (badApp) &#123; // badApp 为 true，就杀掉这个进程 app.kill(\"error during init\", true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; // 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！ updateOomAdjLocked(); &#125; return true;&#125; 我们来回顾一下这个方法： 根据 pid 从 mPidsSelfLocked 中查询到相应的 ProcessRecord 对象 app。 当 app==null，意味着本次创建的进程不存在，则直接返回，这属于异常。 判断 app.thread 是否为 null，此时 thread 应该为 null，若不为 null 则表示该 app 附到上一个进程，则调用 handleAppDiedLocked 清理。 绑定死亡通知，当进程 pid 死亡时会通过 binder 死亡回调，来通知 system_server 进程死亡的消息。 重置 ProcessRecord 进程信息，并设置 app.thread 为新进程的 ApplicationThreadProxy ，attach 操作完成 。 app 进程存在正在启动中的 provider，则超时 10s 后发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息。 调用 thread.bindApplication 绑定应用进程，后面再进一步说明。 检查是否有 Provider，Activity，Service，Broadcast 等组件运行在该新进程。 10.1 new AppDeathRecipient我们来看看死亡通知对象的创建！12345678910111213141516171819202122232425private final class AppDeathRecipient implements IBinder.DeathRecipient &#123; final ProcessRecord mApp; // 进程对应的 ProcessRecord 对象！ final int mPid; // 进程的 pid final IApplicationThread mAppThread; // 进程的 ApplicationThreadProxy 对象！ AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) &#123; if (DEBUG_ALL) Slog.v( TAG, \"New death recipient \" + this + \" for thread \" + thread.asBinder()); mApp = app; mPid = pid; mAppThread = thread; &#125; @Override public void binderDied() &#123; if (DEBUG_ALL) Slog.v( TAG, \"Death received in \" + this + \" for thread \" + mAppThread.asBinder()); synchronized(ActivityManagerService.this) &#123; appDiedLocked(mApp, mPid, mAppThread, true); &#125; &#125;&#125; 当进程死亡后，其对应的死亡通知对象就会收到通知，其 binderDied 方法就会被调用，接着进入 appDiedLocked 方法： 10.1 AMS.appDiedLocked参数 fromBinderDied 置为 true！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied) &#123; // First check if this ProcessRecord is actually active for the pid. synchronized (mPidsSelfLocked) &#123; ProcessRecord curProc = mPidsSelfLocked.get(pid); if (curProc != app) &#123; Slog.w(TAG, \"Spurious death for \" + app + \", curProc for \" + pid + \": \" + curProc); return; &#125; &#125; BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); synchronized (stats) &#123; stats.noteProcessDiedLocked(app.info.uid, pid); &#125; // 这里 killed 值为 false； if (!app.killed) &#123; if (!fromBinderDied) &#123; Process.killProcessQuiet(pid); &#125; // 杀掉进程所在的进程组！ killProcessGroup(app.uid, pid); app.killed = true; &#125; // Clean up already done if the process has been re-started. if (app.pid == pid &amp;&amp; app.thread != null &amp;&amp; app.thread.asBinder() == thread.asBinder()) &#123; boolean doLowMem = app.instrumentationClass == null; boolean doOomAdj = doLowMem; if (!app.killedByAm) &#123; Slog.i(TAG, \"Process \" + app.processName + \" (pid \" + pid + \") has died\"); mAllowLowerMemLevel = true; &#125; else &#123; // Note that we always want to do oom adj to update our state with the // new number of procs. mAllowLowerMemLevel = false; doLowMem = false; &#125; EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName); if (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP, \"Dying app: \" + app + \", pid: \" + pid + \", thread: \" + thread.asBinder()); // 杀掉进程后继续调用 handleAppDiedLocked 方法！ handleAppDiedLocked(app, false, true); if (doOomAdj) &#123; updateOomAdjLocked(); &#125; if (doLowMem) &#123; doLowMemReportIfNeededLocked(app); &#125; &#125; else if (app.pid != pid) &#123; // A new process has already been started. Slog.i(TAG, \"Process \" + app.processName + \" (pid \" + pid + \") has died and restarted (pid \" + app.pid + \").\"); EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName); &#125; else if (DEBUG_PROCESSES) &#123; Slog.d(TAG_PROCESSES, \"Received spurious death notification for thread \" + thread.asBinder()); &#125;&#125; 10.2 AMS.handleAppDiedLocked 参数 restarting 表示进程是否在重启，这里传入 false； 参数 allowRestart 表示是否允许进程重启，这里传入 true；1234567891011121314151617181920212223242526272829303132333435363738394041private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) &#123; int pid = app.pid; boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1, false /*replacingPid*/); if (!kept &amp;&amp; !restarting) &#123; removeLruProcessLocked(app); if (pid &gt; 0) &#123; ProcessList.remove(pid); &#125; &#125; if (mProfileProc == app) &#123; clearProfilerLocked(); &#125; // Remove this application's activities from active lists. boolean hasVisibleActivities = mStackSupervisor.handleAppDiedLocked(app); app.activities.clear(); if (app.instrumentationClass != null) &#123; Slog.w(TAG, \"Crash of app \" + app.processName + \" running instrumentation \" + app.instrumentationClass); Bundle info = new Bundle(); info.putString(\"shortMsg\", \"Process crashed.\"); finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info); &#125; if (!restarting &amp;&amp; hasVisibleActivities &amp;&amp; !mStackSupervisor.resumeFocusedStackTopActivityLocked()) &#123; // If there was nothing to resume, and we are not already restarting this process, but // there is a visible activity that is hosted by the process... then make sure all // visible activities are running, taking care of restarting this process. mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125;&#125; 10.2.1 AMS.cleanUpApplicationRecordLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) &#123; Slog.d(TAG, \"cleanUpApplicationRecord -- \" + app.pid); if (index &gt;= 0) &#123; removeLruProcessLocked(app); ProcessList.remove(app.pid); &#125; mProcessesToGc.remove(app); mPendingPssProcesses.remove(app); // 取消掉这个进程所有已经可见的 Dialog！ if (app.crashDialog != null &amp;&amp; !app.forceCrashReport) &#123; app.crashDialog.dismiss(); app.crashDialog = null; &#125; if (app.anrDialog != null) &#123; app.anrDialog.dismiss(); app.anrDialog = null; &#125; if (app.waitDialog != null) &#123; app.waitDialog.dismiss(); app.waitDialog = null; &#125; app.crashing = false; app.notResponding = false; app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); app.makeInactive(mProcessStats); app.waitingToKill = null; app.forcingToForeground = null; updateProcessForegroundLocked(app, false, false); app.foregroundActivities = false; app.hasShownUi = false; app.treatLikeActivity = false; app.hasAboveClient = false; app.hasClientActivities = false; // 杀掉进程中所有的 Service！ mServices.killServicesLocked(app, allowRestart); // restart 表示是否重启这个进程！ boolean restart = false; // 移除这个进程的所有 publish 的 provider！ for (int i = app.pubProviders.size() - 1; i &gt;= 0; i--) &#123; ContentProviderRecord cpr = app.pubProviders.valueAt(i); final boolean always = app.bad || !allowRestart; boolean inLaunching = removeDyingProviderLocked(app, cpr, always); if ((inLaunching || always) &amp;&amp; cpr.hasConnectionOrHandle()) &#123; // We left the provider in the launching list, need to // restart it. restart = true; &#125; cpr.provider = null; cpr.proc = null; &#125; app.pubProviders.clear(); // 移除这个进程的所有正在启动的 provider！ if (cleanupAppInLaunchingProvidersLocked(app, false)) &#123; restart = true; &#125; // 取消所有的 ContentProviderConnection 对象！ if (!app.conProviders.isEmpty()) &#123; for (int i = app.conProviders.size() - 1; i &gt;= 0; i--) &#123; ContentProviderConnection conn = app.conProviders.get(i); conn.provider.connections.remove(conn); stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.name); &#125; app.conProviders.clear(); &#125; // At this point there may be remaining entries in mLaunchingProviders // where we were the only one waiting, so they are no longer of use. // Look for these and clean up if found. // XXX Commented out for now. Trying to figure out a way to reproduce // the actual situation to identify what is actually going on. if (false) &#123; for (int i = mLaunchingProviders.size() - 1; i &gt;= 0; i--) &#123; ContentProviderRecord cpr = mLaunchingProviders.get(i); if (cpr.connections.size() &lt;= 0 &amp;&amp; !cpr.hasExternalProcessHandles()) &#123; synchronized (cpr) &#123; cpr.launchingApp = null; cpr.notifyAll(); &#125; &#125; &#125; &#125; skipCurrentReceiverLocked(app); // Unregister any receivers. for (int i = app.receivers.size() - 1; i &gt;= 0; i--) &#123; removeReceiverLocked(app.receivers.valueAt(i)); &#125; app.receivers.clear(); // If the app is undergoing backup, tell the backup manager about it if (mBackupTarget != null &amp;&amp; app.pid == mBackupTarget.app.pid) &#123; if (DEBUG_BACKUP || DEBUG_CLEANUP) Slog.d(TAG_CLEANUP, \"App \" + mBackupTarget.appInfo + \" died during backup\"); try &#123; IBackupManager bm = IBackupManager.Stub.asInterface( ServiceManager.getService(Context.BACKUP_SERVICE)); bm.agentDisconnected(app.info.packageName); &#125; catch (RemoteException e) &#123; // can't happen; backup manager is local &#125; &#125; for (int i = mPendingProcessChanges.size() - 1; i &gt;= 0; i--) &#123; ProcessChangeItem item = mPendingProcessChanges.get(i); if (item.pid == app.pid) &#123; mPendingProcessChanges.remove(i); mAvailProcessChanges.add(item); &#125; &#125; mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED_UI_MSG, app.pid, app.info.uid, null).sendToTarget(); // If the caller is restarting this app, then leave it in its // current lists and let the caller take care of it. if (restarting) &#123; return false; &#125; if (!app.persistent || app.isolated) &#123; if (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_CLEANUP, \"Removing non-persistent process during cleanup: \" + app); if (!replacingPid) &#123; removeProcessNameLocked(app.processName, app.uid); &#125; if (mHeavyWeightProcess == app) &#123; mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG, mHeavyWeightProcess.userId, 0)); mHeavyWeightProcess = null; &#125; &#125; else if (!app.removed) &#123; // This app is persistent, so we need to keep its record around. // If it is not already on the pending app list, add it there // and start a new process for it. if (mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); restart = true; &#125; &#125; if ((DEBUG_PROCESSES || DEBUG_CLEANUP) &amp;&amp; mProcessesOnHold.contains(app)) Slog.v( TAG_CLEANUP, \"Clean-up removing on hold: \" + app); mProcessesOnHold.remove(app); if (app == mHomeProcess) &#123; mHomeProcess = null; &#125; if (app == mPreviousProcess) &#123; mPreviousProcess = null; &#125; if (restart &amp;&amp; !app.isolated) &#123; // We have components that still need to be running in the // process, so re-launch it. if (index &lt; 0) &#123; ProcessList.remove(app.pid); &#125; addProcessNameLocked(app); startProcessLocked(app, \"restart\", app.processName); return true; &#125; else if (app.pid &gt; 0 &amp;&amp; app.pid != MY_PID) &#123; // Goodbye! boolean removed; synchronized (mPidsSelfLocked) &#123; mPidsSelfLocked.remove(app.pid); mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); &#125; mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid); if (app.isolated) &#123; mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid); &#125; app.setPid(0); &#125; return false;&#125; 从上面可以看到，如果已经进程是 persistent 进程，死亡通知对象接收到通知后会重启这个进程！ attach 结束了，接下来，是 SystemServer 进程 bind 应用程序进程！ 11 ApplicationThreadProxy.bindApplication这里是在 SystemServer 进程中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class ApplicationThreadProxy implements IApplicationThread &#123; private final IBinder mRemote; public ApplicationThreadProxy(IBinder remote) &#123; mRemote = remote; &#125; public final IBinder asBinder() &#123; return mRemote; &#125; ... ... ...// 省略其他暂时不需要的方法！ // 这里是 bind 操作！ @Override public final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeString(packageName); info.writeToParcel(data, 0); data.writeTypedList(providers); if (testName == null) &#123; data.writeInt(0); &#125; else &#123; data.writeInt(1); testName.writeToParcel(data, 0); &#125; if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; data.writeBundle(testArgs); data.writeStrongInterface(testWatcher); data.writeStrongInterface(uiAutomationConnection); data.writeInt(debugMode); data.writeInt(enableBinderTracking ? 1 : 0); data.writeInt(trackAllocation ? 1 : 0); data.writeInt(restrictedBackupMode ? 1 : 0); data.writeInt(persistent ? 1 : 0); config.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeMap(services); data.writeBundle(coreSettings); // binder 通信！ mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; ... ... ...&#125; 参数 Map&lt;String, IBinder&gt; services 是通过 AMS 的 getCommonServicesLocked 方法获得的：1234567891011121314151617181920private HashMap&lt;String, IBinder&gt; getCommonServicesLocked(boolean isolated) &#123; if (isolated) &#123; if (mIsolatedAppBindArgs == null) &#123; mIsolatedAppBindArgs = new HashMap&lt;&gt;(); mIsolatedAppBindArgs.put(\"package\", ServiceManager.getService(\"package\")); &#125; return mIsolatedAppBindArgs; &#125; if (mAppBindArgs == null) &#123; // 对于非隔离进程，这里会获得一些常用服务的 binder 对象！！ mAppBindArgs = new HashMap&lt;&gt;(); // Setup the application init args mAppBindArgs.put(\"package\", ServiceManager.getService(\"package\")); mAppBindArgs.put(\"window\", ServiceManager.getService(\"window\")); mAppBindArgs.put(Context.ALARM_SERVICE, ServiceManager.getService(Context.ALARM_SERVICE)); &#125; return mAppBindArgs;&#125; 这里的 IApplicationThread.descriptor = “android.app.IApplicationThread”ATP 经过 binder ipc 传递到 ATN 的 onTransact 方法。 12 ApplicationThreadNative.onTransact进入到 ATN 的 onTransact 方法中，这里进入了应用程序的进程中了：12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; ... case BIND_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); // 获得应用程序的包名！ String packageName = data.readString(); ApplicationInfo info = ApplicationInfo.CREATOR.createFromParcel(data); List&lt;ProviderInfo&gt; providers = data.createTypedArrayList(ProviderInfo.CREATOR); ComponentName testName = (data.readInt() != 0) ? new ComponentName(data) : null; ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; Bundle testArgs = data.readBundle(); IBinder binder = data.readStrongBinder(); IInstrumentationWatcher testWatcher = IInstrumentationWatcher.Stub.asInterface(binder); binder = data.readStrongBinder(); IUiAutomationConnection uiAutomationConnection = IUiAutomationConnection.Stub.asInterface(binder); int testMode = data.readInt(); boolean openGlTrace = data.readInt() != 0; boolean restrictedBackupMode = (data.readInt() != 0); boolean persistent = (data.readInt() != 0); Configuration config = Configuration.CREATOR.createFromParcel(data); CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); HashMap&lt;String, IBinder&gt; services = data.readHashMap(null); Bundle coreSettings = data.readBundle(); // [见流程3.11] bindApplication(packageName, info, providers, testName, profilerInfo, testArgs, testWatcher, uiAutomationConnection, testMode, openGlTrace, restrictedBackupMode, persistent, config, compatInfo, services, coreSettings); return true; &#125; ...&#125; 13 ApplicationThread.bindApplication我们接着看：1234567891011121314151617181920212223242526272829303132333435363738394041public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; if (services != null) &#123; // 这里将前面获得的系统公共 services 缓存到 ServiceManager 的 sCache 中, // 减少 binder 检索服务的次数. ServiceManager.initServiceCache(services); &#125; // 发送消息 H.SET_CORE_SETTINGS setCoreSettings(coreSettings); AppBindData data = new AppBindData(); // 初始化 AppBindData data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; // 发送 H.BIND_APPLICATION 消息！ sendMessage(H.BIND_APPLICATION, data);&#125; 其中 setCoreSettings() 过程就是调用 sendMessage(H.SET_CORE_SETTINGS, coreSettings) 来向主线程发送 SET_CORE_SETTINGS 消息，如下： 1234public void setCoreSettings(Bundle coreSettings) &#123; sendMessage(H.SET_CORE_SETTINGS, coreSettings);&#125; 总结一下：bindApplication 方法的主要功能是依次向主线程发送消息 H.SET_CORE_SETTINGS 和 H.BIND_APPLICATION。 14 ActivityThread.H - 消息处理进入到应用程序进程的主线程 Handler “H”： 123456789101112131415161718192021222324252627282930313233343536private class H extends Handler &#123; ... ... ... public void handleMessage(Message msg) &#123; ... ... ... case SET_CORE_SETTINGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"setCoreSettings\"); handleSetCoreSettings((Bundle) msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... ... ... case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... ... ... &#125; ... ... ... &#125; 我们继续来看吧： 14.1 消息 H.SET_CORE_SETTINGS处理 H.SET_CORE_SETTINGS 消息，调用 handleSetCoreSettings 方法：1234567891011121314151617181920212223private void handleSetCoreSettings(Bundle coreSettings) &#123; synchronized (mResourcesManager) &#123; mCoreSettings = coreSettings; &#125; onCoreSettingsChange();&#125;private void onCoreSettingsChange() &#123; boolean debugViewAttributes = mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0; if (debugViewAttributes != View.mDebugViewAttributes) &#123; View.mDebugViewAttributes = debugViewAttributes; // request all activities to relaunch for the changes to take place // 由于发生改变, 请求所有的 activities 重启启动！ for (Map.Entry&lt;IBinder, ActivityClientRecord&gt; entry : mActivities.entrySet()) &#123; requestRelaunchActivity(entry.getKey(), null, null, 0, false, null, null, false, false /* preserveWindow */); &#125; &#125;&#125; 14.2 消息 H.BIND_APPLICATION处理 H.BIND_APPLICATION 消息，调用 handleBindApplication 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267private void handleBindApplication(AppBindData data) &#123; // 将 UI 线程注册到 VMRuntime 中！ VMRuntime.registerSensitiveThread(); if (data.trackAllocation) &#123; DdmVmInternal.enableRecentAllocations(true); &#125; // 记录进程的开始时间！ Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis()); mBoundApplication = data; mConfiguration = new Configuration(data.config); mCompatConfiguration = new Configuration(data.config); mProfiler = new Profiler(); if (data.initProfilerInfo != null) &#123; mProfiler.profileFile = data.initProfilerInfo.profileFile; mProfiler.profileFd = data.initProfilerInfo.profileFd; mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval; mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler; &#125; // 设置进程名, 也就是说进程名是在进程真正创建以后的 BIND_APPLICATION 过程中才取名! Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId()); if (data.persistent) &#123; // 如果常驻进程，在低内存设备, 不采用硬件加速绘制,以节省内存使用量！ if (!ActivityManager.isHighEndGfx()) &#123; ThreadedRenderer.disable(false); &#125; &#125; if (mProfiler.profileFd != null) &#123; mProfiler.startProfiling(); &#125; // 如果应用程序的目标 sdk 小于等于 Honeycomb MR1 // 设置 AsyncTask 默认的线程池为 THREAD_POOL_EXECUTOR！ if (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123; AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR); &#125; Message.updateCheckRecycle(data.appInfo.targetSdkVersion); // 重置进程时区为系统时区！ TimeZone.setDefault(null); // 设置语言环境列表！ LocaleList.setDefault(data.config.getLocales()); synchronized (mResourcesManager) &#123; // 更新系统配置 mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo); mCurDefaultDisplayDpi = data.config.densityDpi; // This calls mResourcesManager so keep it within the synchronized block. applyCompatConfiguration(mCurDefaultDisplayDpi); &#125; // 创建应用程序的 LoadedApk 对象，每个进程都有一个。 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); // 如果需要的话，设置该进程为像素 if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) &#123; mDensityCompatMode = true; Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT); &#125; updateDefaultDensity(); // 设置时间显示的格式！ final boolean is24Hr = \"24\".equals(mCoreSettings.getString(Settings.System.TIME_12_24)); DateFormat.set24HourTimePref(is24Hr); View.mDebugViewAttributes = mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0; // 对于 userdebug/eng 编译方式的系统应用来说，使用 dropbox 工具来分析 log 堆栈！ if ((data.appInfo.flags &amp; (ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) != 0) &#123; StrictMode.conditionallyEnableDebugLogging(); &#125; // 如果应用的目标平台大于等于Honeycomb，就不允许在主线程使用网络相关功能 // 不然会抛出 NetworkOnMainThreadException 异常！ if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; StrictMode.enableDeathOnNetwork(); &#125; // 如果应用的目标平台不低于 Android N，那就不允许应用将 “file://” 这样的 Uri // 直接暴露出去，比如跨包传递等等，不然会抛出 FileUriExposedException if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N) &#123; StrictMode.enableDeathOnFileUriExposure(); &#125; NetworkSecurityPolicy.getInstance().setCleartextTrafficPermitted( (data.appInfo.flags &amp; ApplicationInfo.FLAG_USES_CLEARTEXT_TRAFFIC) != 0); if (data.debugMode != IApplicationThread.DEBUG_OFF) &#123; // XXX should have option to change the port. Debug.changeDebugPort(8100); if (data.debugMode == IApplicationThread.DEBUG_WAIT) &#123; Slog.w(TAG, \"Application \" + data.info.getPackageName() + \" is waiting for the debugger on port 8100...\"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.showWaitingForDebugger(mAppThread, true); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; Debug.waitForDebugger(); try &#123; mgr.showWaitingForDebugger(mAppThread, false); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; Slog.w(TAG, \"Application \" + data.info.getPackageName() + \" can be debugged on port 8100...\"); &#125; &#125; // 当处于调试模式,则运行应用生成 systrace 信息 boolean isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; Trace.setAppTracingAllowed(isAppDebuggable); if (isAppDebuggable &amp;&amp; data.enableBinderTracking) &#123; Binder.enableTracing(); &#125; /** * Initialize the default http proxy in this process for the reasons we set the time zone. */ // 初始化默认的 http 代理！ Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Setup proxies\"); final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE); if (b != null) &#123; // In pre-boot mode (doing initial launch to collect password), not // all system is up. This includes the connectivity service, so don't // crash if we can't get it. final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); try &#123; final ProxyInfo proxyInfo = service.getProxyForNetwork(null); Proxy.setHttpProxySystemProperty(proxyInfo); &#125; catch (RemoteException e) &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); throw e.rethrowFromSystemServer(); &#125; &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // Instrumentation 是谷歌提供的一个基本测试类，具有监控交互的作用！ // 每个进程都有一个 Instrumentation 对象，这里我们不看测试相关的！ final InstrumentationInfo ii; if (data.instrumentationName != null) &#123; ... ... ... ... &#125; else &#123; ii = null; // 进入此分支！ &#125; // 创建应用的上下文实例，更新本地语言平台列表！ final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); if (!Process.isIsolated() &amp;&amp; !\"android\".equals(appContext.getPackageName())) &#123; // 对于非隔离且所属包名不是 “android”（即系统进程）的进程 // 创建缓存目录，来存放模板文集，和图形编译相关的代码！ final File cacheDir = appContext.getCacheDir(); if (cacheDir != null) &#123; // Provide a usable directory for temporary files System.setProperty(\"java.io.tmpdir\", cacheDir.getAbsolutePath()); &#125; else &#123; Log.v(TAG, \"Unable to initialize \\\"java.io.tmpdir\\\" property \" + \"due to missing cache directory\"); &#125; final Context deviceContext = appContext.createDeviceProtectedStorageContext(); final File codeCacheDir = deviceContext.getCodeCacheDir(); if (codeCacheDir != null) &#123; setupGraphicsSupport(data.info, codeCacheDir); &#125; else &#123; Log.e(TAG, \"Unable to setupGraphicsSupport due to missing code-cache directory\"); &#125; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"NetworkSecurityConfigProvider.install\"); NetworkSecurityConfigProvider.install(appContext); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // Continue loading instrumentation. if (ii != null) &#123; ... ... ... ... &#125; else &#123; // 进入此分支，非测试情况，默认会创建一个 Instrumentation ！ mInstrumentation = new Instrumentation(); &#125; if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) != 0) &#123; dalvik.system.VMRuntime.getRuntime().clearGrowthLimit(); &#125; else &#123; dalvik.system.VMRuntime.getRuntime().clampGrowthLimit(); &#125; // Allow disk access during application and provider setup. This could // block processing ordered broadcasts, but later processing would // probably end up doing the same disk access. final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); try &#123; // 通过反射，创建目标应用程序的 Application 对象！ Application app = data.info.makeApplication(data.restrictedBackupMode, null); // 保存到 ActivityThread.mInitialApplication 中！ mInitialApplication = app; // don't bring up providers in restricted mode; they may depend on the // app's custom Application class if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); // For process that contains content providers, we want to // ensure that the JIT is enabled \"at some point\". mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); &#125; &#125; try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Exception thrown in onCreate() of \" + data.instrumentationName + \": \" + e.toString(), e); &#125; try &#123; // 调用 Application.onCreate() 回调方法. mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125; 总结一下，上面的方法的主要流程： 设置新进程的名字； 创建应用程序的 LoadedApk 对象； 创建应用的 ContextIpml 上下文实例； 创建应用程序的 Application 对象； 调用 Application.onCreate() 回调方法，初始化 app； 上面是这个方法的主要作用，下面我们一个一个看： 14.2.1 ContextImpl.createAppContext创建应用程序的上下文实例，参数传递： ActivityThread mainThread：当前进程的 ActivityThread 对象！ LoadedApk packageInfo：应用程序的信息对象; 123456static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123; if (packageInfo == null) throw new IllegalArgumentException(\"packageInfo\"); return new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);&#125; 这里调用了 new ContextImpl，创建了 ContextImpl 对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private ContextImpl(ContextImpl container, ActivityThread mainThread, LoadedApk packageInfo, IBinder activityToken, UserHandle user, boolean restricted, Display display, Configuration overrideConfiguration, int createDisplayWithId) &#123; mOuterContext = this; mMainThread = mainThread; mActivityToken = activityToken; mRestricted = restricted; if (user == null) &#123; user = Process.myUserHandle(); &#125; mUser = user; mPackageInfo = packageInfo; mResourcesManager = ResourcesManager.getInstance(); final int displayId = (createDisplayWithId != Display.INVALID_DISPLAY) ? createDisplayWithId : (display != null) ? display.getDisplayId() : Display.DEFAULT_DISPLAY; CompatibilityInfo compatInfo = null; if (container != null) &#123; compatInfo = container.getDisplayAdjustments(displayId).getCompatibilityInfo(); &#125; if (compatInfo == null) &#123; compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO; &#125; mDisplayAdjustments.setCompatibilityInfo(compatInfo); mDisplayAdjustments.setConfiguration(overrideConfiguration); mDisplay = (createDisplayWithId == Display.INVALID_DISPLAY) ? display : ResourcesManager.getInstance().getAdjustedDisplay(displayId, mDisplayAdjustments); Resources resources = packageInfo.getResources(mainThread); if (resources != null) &#123; if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null &amp;&amp; compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) &#123; resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(), packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo); &#125; &#125; mResources = resources; if (container != null) &#123; mBasePackageName = container.mBasePackageName; mOpPackageName = container.mOpPackageName; &#125; else &#123; mBasePackageName = packageInfo.mPackageName; ApplicationInfo ainfo = packageInfo.getApplicationInfo(); if (ainfo.uid == Process.SYSTEM_UID &amp;&amp; ainfo.uid != Process.myUid()) &#123; // Special case: system components allow themselves to be loaded in to other // processes. For purposes of app ops, we must then consider the context as // belonging to the package of this process, not the system itself, otherwise // the package+uid verifications in app ops will fail. mOpPackageName = ActivityThread.currentPackageName(); &#125; else &#123; mOpPackageName = mBasePackageName; &#125; &#125; mContentResolver = new ApplicationContentResolver(this, mainThread, user);&#125; 14.2.2 LoadedApk.makeApplication调用了 LoadedApk.makeApplication 方法，利用反射创建应用的 Application 对象，参数传入： boolean forceDefaultAppClass：data.restrictedBackupMode Instrumentation instrumentation：null123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; // 如果已经创建，就直接返回！ return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; // 要反射的类！ appClass = &quot;android.app.Application&quot;; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) &#123; // 如果应用不是 framework-res.apk initializeJavaContextClassLoader(); &#125; // 创建应用的上下文实例！ ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // 利用上下文实例，创建应用的 Application 对象！ app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); // 这里是实现 Context 和 Application 的相互引用！ appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate application &quot; + appClass + &quot;: &quot; + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; //这里不看！ ... ... ... &#125; // Rewrite the R &apos;constants&apos; for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; return app;&#125; 这里调用了 Instrumentation.newApplication 方法，创建 Application 的实例：1234567891011121314151617181920public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; // 继续调用 newApplication 方法！ return newApplication(cl.loadClass(className), context);&#125;static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; // 创建 Application 对象！ Application app = (Application)clazz.newInstance(); // 将 context 和 Application 绑定，我们直接通过 getApplicationContext // 获得的就是这个 context 实例！ app.attach(context); return app;&#125; 14.2.3 Instrumentation.callApplicationOnCreate这个方法很简单：12345public void callApplicationOnCreate(Application app) &#123; // 调用 onCreate 方法！ app.onCreate();&#125; 调用 Application 的 onCreate 方法！ 到这里，bind 操作也完成了，应用程序进程已经启动，并且完成了和 SystemServer 进程的双向 Binder 绑定，也创建了应用程序的 Application 对象，调用了Application.onCreate 方法，接下来，就是启动指定的组件了！ 回到 ActivityManagerService.attachApplicationLocked 方法中，bind 成功后，就会检测新进程中的组件了，组件的启动就在那里！！ 关于组件的启动，以后在说！！ 15 总结其实，我们可以看到，进程的启动和创建，还是相当复杂的，其中涉及的细节很多，当时，阅读源码，最忌讳死扣细节，我们需要对框架有个整体的理解，下面，我们来通过几张图来总结一下，进程的启动！！ 15.1 进程的创建和启动下面我们用一张图来回顾下这个流程： 其中，check/start 指定组件，也存在系统进程和应用进程间的多次 Binder 通信，这里我们不重点讨论，在后面分析四大组件时，会详细分析他们的生命周期过程，会重点分析这个部分！ 15.2 ActivityThread 关系图","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Process进程","slug":"AndroidFramework源码分析/Process进程","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Process进程/"}],"tags":[{"name":"Process进程","slug":"Process进程","permalink":"https://coolqi.top/tags/Process进程/"}]},{"title":"Service 篇 2 - startService 流程分析","slug":"Service2-startService","date":"2016-03-01T12:46:25.000Z","updated":"2018-11-20T16:27:20.000Z","comments":true,"path":"2016/03/01/Service2-startService/","link":"","permalink":"https://coolqi.top/2016/03/01/Service2-startService/","excerpt":"","text":"基于 Android 7.1.1 源码分析 startService 的流程，本文为作者原创，转载请说明出处！ 0 综述我们在应用中经常会启动 Service： 1startService(intent); 这个方法最终会拉起 Service 的 onStartCommand 方法：12345@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; OppoLog.d(TAG, \"onStartCommand\"); return super.onStartCommand(intent, flags, startId);&#125; 该方法有三个参数： Intent intent: 启动服务的 Intent！ int flags: 启动时的额外参数，取值可以为 0，START_FLAG_REDELIVERY 和 START_FLAG_RETRY！ int startId: 当前服务的唯一 ID，和 StopSelfResult(int startId) 配合使用！ 1、下面我们来看看 onStartCommand 的 flag 参数： START_FLAG_REDELIVERY 取值：x0001 解释：如果 Service 的 onStartCommand 返回值是 START_REDELIVER_INTENT，当服务被杀掉，服务会重启，这时 flag 会被传入这个值！ START_FLAG_RETRY 取值：0x0002 解释：当 onStartCommand 方法调用后一直没有返回时，会尝试重新去调用 onStartCommand 方法，这时 flag 会被传入这个值！ 2、而 onStartCommand 有如下的返回值，这里先简单的介绍下： START_STICKY_COMPATIBILITY 取值：0 START_STICKY 取值：1 说明： 如果 Service 进程启动后被杀掉了，服务被启动的状态会被保留并抛弃本次启动的 Intent，然后系统会尝试重新创建和启动一个新的服务实例! 如果在重启期间，没有任何新的启动项 Intent 传递给 Service，那么会传递一个空的 Intent 对象，所以在 onStartCommand 方法中要做 Intent 非空的判断！ 用途： 比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。 START_NOT_STICKY 取值：2 说明： 如果 Service 进程启动后被杀掉了，并且没有新的启动 Intent 分发给服务，那么会移除服务被启动的状态，也不会重新创建服务，直到下一次显示地通过 startService 启动服务！ 这种情况下，onStartCommand 不会传入空的 Intent 对象（因为在没有正在等待分发的 Intent 的情况下，该服务不会重启）！ 用途： 该模式比较适用于启动后需要做一些工作，但是在内存不够的情况下可以被停止，然后通过显示地再次启动去继续工作的情况！ 一个简单的例子：从服务器获得数据的服务，通过设置一个 alarm，间隔一定时间启动服务onStartCommand，然后设置新的 alarm，如果服务进程被杀掉，那服务不会被触发，知道下一次 alarm 触发！ START_REDELIVER_INTENT 取值： 3 说明： 如果 Service 进程启动后被杀掉了，该 Service 将会被重启，并且会将最后启动（startService）分发过的 Intent 再次通过 onStartCommand 方法传递给 Service ，该 Intent 将会被保留用于下一次的重启分发，除非 Service 调用 stopSelf(int startId) 方法停止运行！ 这种情况下，onStartCommand 也不会传入空的 Intent 对象，因为服务只有在没有完成处理所有分发给它的 Intent 的情况下或重启，一旦重启，就会将最后启动（startService）分发过的 Intent 再次通过 onStartCommand 方法传递给服务！ 用途： 这个模式适用于主动执行应该立即恢复的作业（例如下载文件）的服务。 START_CONTINUATION_MASK 0xf 这里是 Android 文档中的对这些参数的做的简单说明，下面我们来分析 startService 的过程！ 1 启动端进程1.1 ContextWrapper.startService12345678910@Overridepublic ComponentName startService(Intent service) &#123; return mBase.startService(service);&#125;/** @hide */@Overridepublic ComponentName startServiceAsUser(Intent service, UserHandle user) &#123; return mBase.startServiceAsUser(service, user);&#125; ContextWrapper 提供了两个方法来启动 Service，其中一个是隐藏方法：startServiceAsUser！ mBase 是 ContextImpl 对象，继续看！ 1.2 ContextImpl.startService12345678910111213class ContextImpl extends Context &#123; @Override public ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, mUser); &#125; @Override public ComponentName startServiceAsUser(Intent service, UserHandle user) &#123; return startServiceCommon(service, user); &#125;&#125; ContextImpl 和 ContextWrapper 的具体关系，请看博文，这里我们不再详细说明！ mUser 表示的是当前的设备 user！ 最终，调用了 startServiceCommon 方法； 1.3 ContextImpl.startServiceCommon12345678910111213141516171819202122232425262728private ComponentName startServiceCommon(Intent service, UserHandle user) &#123; try &#123; // 如果系统版本不低于 L，那就要抛出异常，提示必须是显示启动！ validateServiceIntent(service); service.prepareToLeaveProcess(this); //【1】启动指定的 Service！ ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(\"!\")) &#123; throw new SecurityException( \"Not allowed to start service \" + service + \" without permission \" + cn.getClassName()); &#125; else if (cn.getPackageName().equals(\"!!\")) &#123; throw new SecurityException( \"Unable to start service \" + service + \": \" + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; validateServiceIntent 方法用用来校验启动用的 intent 是否安全： 1.3.1 ContextImpl.validateServiceIntent123456789101112private void c(Intent service) &#123; if (service.getComponent() == null &amp;&amp; service.getPackage() == null) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; IllegalArgumentException ex = new IllegalArgumentException( \"Service Intent must be explicit: \" + service); throw ex; &#125; else &#123; Log.w(TAG, \"Implicit intents with startService are not safe: \" + service + \" \" + Debug.getCallers(2, 3)); &#125; &#125;&#125; 如果 intent 既没有设置 component 也没有设置 package，那就要判断一下系统的版本了: 如果系统版本不低于 L，那就要抛出异常，提示必须是显示启动； 如果系统版本低于 L，那只提示隐式启动不安全； 这里可以看出，Intent 必须要设置 component 或者 package 中的一个！ 1.3.2 ContextImpl.getOpPackageName通过 getOpPackageName 来获得启动者所在的包名：12345/** @hide */@Overridepublic String getOpPackageName() &#123; return mOpPackageName != null ? mOpPackageName : getBasePackageName();&#125; 这里的 mOpPackageName 是在创建 ContextImpl 的时候初始化的！ 1.4 ActivityManagerP.startService接着，通过 ActivityManagerP.startService 方法，启动服务！1234567891011121314151617181920212223public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); service.writeToParcel(data, 0); data.writeString(resolvedType); data.writeString(callingPackage); data.writeInt(userId); mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); ComponentName res = ComponentName.readFromParcel(reply); data.recycle(); reply.recycle(); return res;&#125; 通过 binder 进程间通信，进入系统进程，参数分析： IApplicationThread caller： 调用者进程的 ApplicationThread 对象，实现了 IApplicationThread 接口； Intent service： 启动的 intent String resolvedType： 这个 intent 的 MIME 类型； String callingPackage： 启动者所属包名； int userId： 设备用户 id； 2 系统进程接下来，进入系统进程的 ActivityManagerService 中！ 首先要进入 ActivityManagerN.onTransact 方法！123456789101112131415161718case START_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); Intent service = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); String callingPackage = data.readString(); int userId = data.readInt(); //【1】继续 startService！ ComponentName cn = startService(app, service, resolvedType, callingPackage, userId); reply.writeNoException(); ComponentName.writeToParcel(cn, reply); return true;&#125; 2.1 ActivityManagerS.startService123456789101112131415161718192021222324252627282930313233343536@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123; // 用来校验启动者进程是否是隔离的，如果是隔离进程，抛出异常！！ enforceNotIsolatedCaller(\"startService\"); // 不能通过 intent 传递文件描述符，否则抛出非法异常！ if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; // 调用者 package 为 null，抛出异常！ if (callingPackage == null) &#123; throw new IllegalArgumentException(\"callingPackage cannot be null\"); &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"startService: \" + service + \" type=\" + resolvedType); synchronized(this) &#123; // 获得调用者的 uid 和 pid！ final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); //【1】进入 ActiveServices，继续启动！ ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, callingPackage, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; mServices 是 ActivityManagerService 的一个内部管理对象，用于管理所有的 Service！ 2.2 ActiveServices.startServiceLoced参数和前面保持一致！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, String callingPackage, final int userId) throws TransactionTooLargeException &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"startService: \" + service + \" type=\" + resolvedType + \" args=\" + service.getExtras()); //【1】判断是否是前台调用！ final boolean callerFg; if (caller != null) &#123; // 获得调用者进程的 ProcessRecord 对象！ final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when starting service \" + service); &#125; callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND; &#125; else &#123; callerFg = true; &#125; //【2】检索要启动的服务的信息！ ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPackage, callingPid, callingUid, userId, true, callerFg, false); if (res == null) &#123; return null; &#125; if (res.record == null) &#123; return new ComponentName(\"!\", res.permission != null ? res.permission : \"private to package\"); &#125; //【3】获得要启动的服务的数据对象：ServiceRecord！ ServiceRecord r = res.record; // 如果服务所属的设备用户不存在，直接返回！ if (!mAm.mUserController.exists(r.userId)) &#123; Slog.w(TAG, \"Trying to start service with non-existent user! \" + r.userId); return null; &#125; //【4】如果服务还没有被请求启动，要先判断服务是否允许在后台启动，如果不允许就直接返回！ if (!r.startRequested) &#123; final long token = Binder.clearCallingIdentity(); try &#123; final int allowed = mAm.checkAllowBackgroundLocked( r.appInfo.uid, r.packageName, callingPid, true); if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123; Slog.w(TAG, \"Background start not allowed: service \" + service + \" to \" + r.name.flattenToShortString() + \" from pid=\" + callingPid + \" uid=\" + callingUid + \" pkg=\" + callingPackage); return null; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125; NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked( callingUid, r.packageName, service, service.getFlags(), null, r.userId); //【5】如果启动者属于前台应用，并且启动服务组件是需要校验权限，就需要弹出权限校验界面！ // 只有权限校验成功，才会继续启动！ if (Build.PERMISSIONS_REVIEW_REQUIRED) &#123; if (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage, callingUid, service, callerFg, userId)) &#123; return null; &#125; &#125; //【6】取消服务重启的任务！ if (unscheduleServiceRestartLocked(r, callingUid, false)) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"START SERVICE WHILE RESTART PENDING: \" + r); &#125; //【7】设置服务 ServiceRecord 的属性值； r.lastActivity = SystemClock.uptimeMillis(); // 设置 startRequested 为 true，表示被请求启动！ r.startRequested = true; // 设置 delayedStop 为 false；表示服务没有被延迟停止，只对后台服务有效！ r.delayedStop = false; // 将本次启动需要的数据，包括 intent，封装成 StartItem，保存到 pendingStarts 列表中！ r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), service, neededGrants)); // 获得 userId 下的所有 Service 的 Map 集合！ final ServiceMap smap = getServiceMap(r.userId); // 表示是否将服务添加到后台启动列表中； boolean addToStarting = false; //【8】对于后台启动的服务，需要做一些条件判断，看是延迟启动，还是立刻后台启动！ if (!callerFg &amp;&amp; r.app == null &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123; // 获得被启动的服务所在进程的 ProcessRecord 数据对象！ ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, false); // 下面判断当前启动服务的进程状态来确定是否需要延时启动这个服务！ // 对于非前台的启动，尝试延迟启动服务！ if (proc == null || proc.curProcState &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123; if (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, \"Potential start delay of \" + r + \" in \" + proc); if (r.delayed) &#123; // 如果该服务已经延迟启动，说明他已经被加入到了 smap.mDelayedStartList 列表中等待启动，直接返回！ if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Continuing to delay: \" + r); return r.name; &#125; // 当同一时间正在后台启动的服务数超过了最大后台启动服务数，延迟启动！ if (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123; Slog.i(TAG_SERVICE, \"Delaying start of: \" + r); // 就要将该服务加入 smap.mDelayedStartList 中； smap.mDelayedStartList.add(r); // 设置其 r.delayed 为 true！ r.delayed = true; return r.name; &#125; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Not delaying: \" + r); addToStarting = true; &#125; else if (proc.curProcState &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123; addToStarting = true; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Not delaying, but counting as bg: \" + r); &#125; else if (DEBUG_DELAYED_STARTS) &#123; // 和 debug 相关，只是输出一些 log 信息！ StringBuilder sb = new StringBuilder(128); sb.append(\"Not potential delay (state=\").append(proc.curProcState) .append(' ').append(proc.adjType); String reason = proc.makeAdjReason(); if (reason != null) &#123; sb.append(' '); sb.append(reason); &#125; sb.append(\"): \"); sb.append(r.toString()); Slog.v(TAG_SERVICE, sb.toString()); &#125; &#125; else if (DEBUG_DELAYED_STARTS) &#123; // 和 debug 相关，只是输出一些 log 信息！ if (callerFg) &#123; Slog.v(TAG_SERVICE, \"Not potential delay (callerFg=\" + callerFg + \" uid=\" + callingUid + \" pid=\" + callingPid + \"): \" + r); &#125; else if (r.app != null) &#123; Slog.v(TAG_SERVICE, \"Not potential delay (cur app=\" + r.app + \"): \" + r); &#125; else &#123; Slog.v(TAG_SERVICE, \"Not potential delay (user \" + r.userId + \" not started): \" + r); &#125; &#125; //【9】进一步调用！ return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);&#125; 该方法的主要流程： 判断是前台启动，还是后台启动； 检索需要启动的服务的信息； 如果不满足启动条件就取消本次启动； 创建本次启动对应的启动项； 对于后台启动的服务，需要判读是否延迟启动； 进一步启动服务！ 如何判断后台启动的服务是否需要延迟启动呢，依据如下： 这个地方会对进程的状态做一个判断： 如果是前台进程的调度，就直接进行启动； 如果是后台进程的调度，就要先判断一下，是否延迟执行； 对于如何判断进程是否是前台进程，还是后台进程，我会在另外一篇文章中说明！！ 2.2.1 ActiveServices.unscheduleServiceRestartLocked这里有一个方法，取消上一次的重启任务，参数传入： boolean force：传入 false！123456789101112131415161718192021222324private final boolean unscheduleServiceRestartLocked(ServiceRecord r, int callingUid, boolean force) &#123; if (!force &amp;&amp; r.restartDelay == 0) &#123; return false; &#125; //【1】将服务从重启列表中移除！ boolean removed = mRestartingServices.remove(r); if (removed || callingUid != r.appInfo.uid) &#123; // 清空 restartCount，restartDelay，restartTime！ r.resetRestartCounter(); &#125; if (removed) &#123; // 让 restartTracker 对 ServiceRecord 重新监控！ clearRestartingIfNeededLocked(r); &#125; //【2】移除重启任务！ mAm.mHandler.removeCallbacks(r.restarter); return true;&#125; 这里有一个数据结构：r.restarter，他是在创建 ServiceRecord 时传入的，他是一个 ServiceRestarter 对象！12345678910111213141516private class ServiceRestarter implements Runnable &#123; private ServiceRecord mService; void setService(ServiceRecord service) &#123; mService = service; &#125; public void run() &#123; synchronized(mAm) &#123; //【1】执行重启操作！ performServiceRestartLocked(mService); &#125; &#125;&#125; 我们再去看看 performServiceRestartLocked 方法，是如何实现服务的重启的！123456789101112131415161718192021final void performServiceRestartLocked(ServiceRecord r) &#123; //【1】mRestartingServices 没有当前服务，无法执行重启！ if (!mRestartingServices.contains(r)) &#123; return; &#125; //【2】不需要重启服务！ if (!isServiceNeeded(r, false, false)) &#123; Slog.wtf(TAG, \"Restarting service that is not needed: \" + r); return; &#125; try &#123; //【3】再次拉起服务！！ bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false); &#125; catch (TransactionTooLargeException e) &#123; // Ignore, it's been logged and nothing upstack cares. &#125;&#125; 用于执行重启操作，这里我们只是简单地看看！ 2.3 ActiveServices.startServiceInnerLocked接下来，进一步地启动服务，如果 addToStarting 为 true，表示该服务是后台启动的，需要将其添加到 mStartingBackground 集合中！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ServiceState stracker = r.getTracker(); if (stracker != null) &#123; // 通知服务的 tracker 对象，开始监控服务! stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); &#125; // 表示是否被启动了，在启动前初始化为 false！ r.callStart = false; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; //【1】拉起服务，这个方法会拉起服务的 onCreate 和 onStartCommand 方法！ String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); if (error != null) &#123; return new ComponentName(\"!!\", error); &#125; //【2】如果服务已经被请求启动（startRequested 为 true），且是后台启动（addToStarting 为 true） if (r.startRequested &amp;&amp; addToStarting) &#123; boolean first = smap.mStartingBackground.size() == 0; // 将服务添加到 mStartingBackground 列表中，表示正在后台启动！ smap.mStartingBackground.add(r); // 设置后台启动服务的超时时间！ r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT; if (DEBUG_DELAYED_SERVICE) &#123; RuntimeException here = new RuntimeException(\"here\"); here.fillInStackTrace(); Slog.v(TAG_SERVICE, \"Starting background (first=\" + first + \"): \" + r, here); &#125; else if (DEBUG_DELAYED_STARTS) &#123; Slog.v(TAG_SERVICE, \"Starting background (first=\" + first + \"): \" + r); &#125; //【2.1】如果 first 为 true，表示这是第一个后台启动的服务！那就需要初始化延迟启动的任务调度！ if (first) &#123; smap.rescheduleDelayedStarts(); &#125; &#125; else if (callerFg) &#123; //【2.2】如果是前台启动该服务，就取消该服务之前的后台运行任务！ smap.ensureNotStartingBackground(r); &#125; return r.name;&#125; 对于前台启动的方式：callerFg 为 true，addToStarting 为 false，就会执行 ensureNotStartingBackground 取消服务后台启动！对于后台启动的方式：callerFg 为 false，addToStarting 为 true，就会将服务添加到 mStartingBackground 集合中！ 2.3.1 ServiceMap.rescheduleDelayedStart对于后台启动的方式，如果 mStartingBackground.size() == 0，那就需要对延迟启动的调度做一次初始化，我们先来看看 rescheduleDelayedStarts 方法！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 void rescheduleDelayedStarts() &#123; // 移除 MSG_BG_START_TIMEOUT 后台启动超时消息！ removeMessages(MSG_BG_START_TIMEOUT); final long now = SystemClock.uptimeMillis(); //【1】对于后台启动的服务，如果后台启动超时，就从移除该服务！ 为延迟后台启动的服务腾出位置！ for (int i=0, N=mStartingBackground.size(); i&lt;N; i++) &#123; ServiceRecord r = mStartingBackground.get(i); if (r.startingBgTimeout &lt;= now) &#123; Slog.i(TAG, \"Waited long enough for: \" + r); mStartingBackground.remove(i); N--; i--; &#125; &#125; //【2】处理后台延迟启动的服务，如果此时延迟启动列表不为空，且正在后台启动的服务数不超过最大后台启动数 // 那这个时候就要处理后台延迟服务的启动了！ while (mDelayedStartList.size() &gt; 0 &amp;&amp; mStartingBackground.size() &lt; mMaxStartingBackground) &#123; //【2.1】从 mDelayedStartList 移除该服务，保存到 r 中！ ServiceRecord r = mDelayedStartList.remove(0); if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"REM FR DELAY LIST (exec next): \" + r); if (r.pendingStarts.size() &lt;= 0) &#123; Slog.w(TAG, \"**** NO PENDING STARTS! \" + r + \" startReq=\" + r.startRequested + \" delayedStop=\" + r.delayedStop); &#125; if (DEBUG_DELAYED_SERVICE) &#123; if (mDelayedStartList.size() &gt; 0) &#123; Slog.v(TAG_SERVICE, \"Remaining delayed list:\"); for (int i=0; i&lt;mDelayedStartList.size(); i++) &#123; Slog.v(TAG_SERVICE, \" #\" + i + \": \" + mDelayedStartList.get(i)); &#125; &#125; &#125; // 将 r.delayed 设为 false； r.delayed = false; try &#123; //【2.2】后台启动该服务（callerFg 为 false，addStarting 为 true） // 服务会被添加到 mStartingBackground 列表中！ startServiceInnerLocked(this, r.pendingStarts.get(0).intent, r, false, true); &#125; catch (TransactionTooLargeException e) &#123; &#125; &#125; //【3】设置后台启动的超时处理！ if (mStartingBackground.size() &gt; 0) &#123; // 设置后台超时消息的发送的时间 when 为 startingBgTimeout 和 now 中的最大值！ ServiceRecord next = mStartingBackground.get(0); long when = next.startingBgTimeout &gt; now ? next.startingBgTimeout : now; if (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, \"Top bg start is \" + next + \", can delay others up to \" + when); Message msg = obtainMessage(MSG_BG_START_TIMEOUT); sendMessageAtTime(msg, when); &#125; //【4】发送那些等待后台服务启动的后台广播！ if (mStartingBackground.size() &lt; mMaxStartingBackground) &#123; mAm.backgroundServicesFinishedLocked(mUserId); &#125; &#125;&#125; 我们看到，对于延迟后台启动的服务，最后又会调用 startServiceInnerLocked 后台启动，然后，该服务会被添加到 mStartingBackground 列表中，表示正在启动，这个我们后面会分析到！ 该方法的主要作用是： 移除 mStartingBackground 中已经启动超时的服务； 如果后台启动的服务数小于最大允许后台启动的服务数，且 mDelayedStartList 中有延迟启动的服务，就立刻启动并移除 mDelayedStartList 中的服务，然后将其添加到 mStartingBackground 列表中！ 设置后台启动的超时处理！ 发送那些等待后台服务启动的后台广播！ 这里要简单的说一下 ServiceMap： ServiceMap 是 Handler 的子类，其内部封装了指定设备用户所有的服务信息对象，还有后台启动的服务对象列表 mStartingBackground，以及延迟后台启动的服务对象列表 mDelayedStartList！ 其本身是 Handler，用于处理 MSG_BG_START_TIMEOUT消息：1234567891011@Overridepublic void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_BG_START_TIMEOUT: &#123; synchronized (mAm) &#123; //【1】 rescheduleDelayedStarts(); &#125; &#125; break; &#125;&#125; ServiceMap 收到该消息后，会再次触发 rescheduleDelayedStart 方法，该内部又会发送 MSG_BG_START_TIMEOUT 消息，这样就会不断的循环发送 MSG_BG_START_TIMEOUT 消息，不断的处理 mDelayedStartList 和 mStartingBackground列表，保证所有的后台延迟启动的服务能够即使启动，同时设置后台启动的超时处理！ 2.3.2 ServiceMap.ensureNotStartingBackground对于前台启动的方式，就需要更新 mStartingBackground 和 mDelayedStartList 集合中的元素了，尝试将当前的服务从这两个集合中删除，因为这里是前台启动，我们继续看：12345678910111213141516void ensureNotStartingBackground(ServiceRecord r) &#123; //【1】从 mStartingBackground 中删除当前服务； if (mStartingBackground.remove(r)) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"No longer background starting: \" + r); //【1.1】再次启动后台延迟服务的调度！ rescheduleDelayedStarts(); &#125; //【2】从 mDelayedStartList 中删除当前服务； if (mDelayedStartList.remove(r)) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"No longer delaying start: \" + r); &#125;&#125; 首先是尝试从 mStartingBackground 中删除当前服务，如果删除成功，就要再次调用 rescheduleDelayedStarts 方法，尝试后台启动被延迟后台启动的服务，并再次发送 MSG_BG_START_TIMEOUT 消息！ 2.3.3 阶段总结对于立刻后台启动的服务 r，启动时，都会被添加到 mStartingBackground 列表中，并且设置 r.startingBgTimeout 后台启动超时时间为 now + 15s；每个后台启动的服务 r，当其 r.startingBgTimeout 时间到了后，会从 mStartingBackground 列表中删除； 对于延迟后台启动的服务 r，都会添加到 mDelayedStartList 列表中，并且设置 r.delayed 为 true，每个延迟后台启动的服务的启动都依赖于一个条件：mStartingBackground.size() &lt; mMaxStartingBackground； 通过上面的分析，我们可以知道 rescheduleDelayedStarts 和 ensureNotStartingBackground 作用是什么了: 就是不断处理 mStartingBackground 中的服务，不断的根据 mStartingBackground 中服务的 r.startingBgTimeout 发送 MSG_BG_START_TIMEOUT 消息，不断的处理该消息，删除对应的服务，使得 mStartingBackground.size() &lt; mMaxStartingBackground，为 mDelayedStartList 中的服务腾出位置，保证这些延迟后台启动的服务能够后台启动！ 2.4 ActiveServices.bringUpServiceLocked下面我们来看看，系统进程是如何拉起 Serivce 的，传入参数分析： ServiceRecord r：服务的 ServiceRecord 对象； int intentFlags：启动服务的 intent 的 flag，通过 getFlags 获得； boolean execInFg：传入 callFg，表示本次启动是前台调用还是后台调用； boolean whileRestarting：表示是否是正在重启，传入 false； boolean permissionsReviewRequired：false； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; //【1】如果 r.app 和 r.app.thread 都不为 null。说明不仅服务所在进程已经被启动，服务也已经被创建（onCreate）； // 那就直接拉起 onStartCommand() 方法！这里我们先假设服务所在的进程还没有被启动！ if (r.app != null &amp;&amp; r.app.thread != null) &#123; sendServiceArgsLocked(r, execInFg, false); return null; &#125; //【2】如果服务正在等待重启，就退出！ if (!whileRestarting &amp;&amp; r.restartDelay &gt; 0) &#123; return null; &#125; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Bringing up \" + r + \" \" + r.intent); //【3】如果服务是被启动了，所以要从 mRestartingServices 列表中移除它，并清除内部的启动计数！ if (mRestartingServices.remove(r)) &#123; r.resetRestartCounter(); clearRestartingIfNeededLocked(r); &#125; //【4】如果这个服务被延迟后台启动，即 delayed 为 true，那就从 mDelayedStartList 中移除它， // 并置 r.delayed 为 false； if (r.delayed) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"REM FR DELAY LIST (bring up): \" + r); getServiceMap(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; // 如果这个服务所在的设备用户没有被启动，那就不允许启动这个服务！ if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123; String msg = \"Unable to launch app \" + r.appInfo.packageName + \"/\" + r.appInfo.uid + \" for service \" + r.intent.getIntent() + \": user \" + r.userId + \" is stopped\"; Slog.w(TAG, msg); // 停止这个服务！ bringDownServiceLocked(r); return msg; &#125; try &#123; // 服务将要被启动，所以要设置其 package 的停止状态为 false； AppGlobals.getPackageManager().setPackageStoppedState( r.packageName, false, r.userId); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + r.packageName + \": \" + e); &#125; // 判断这个服务是否属于隔离进程； final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; //【5】获得要启动的服务的目标进程名和进程对象； final String procName = r.processName; ProcessRecord app; if (!isolated) &#123; // 对于非隔离进程，先获得所在进程的 ProcessRecord 对象； app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (DEBUG_MU) Slog.v(TAG_MU, \"bringUpServiceLocked: appInfo.uid=\" + r.appInfo.uid + \" app=\" + app); if (app != null &amp;&amp; app.thread != null) &#123; // 如果进程已经启动； try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); //【5.1】启动指定服务！ realStartServiceLocked(r, app, execInFg); return null; &#125; catch (TransactionTooLargeException e) &#123; throw e; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting service \" + r.shortName, e); &#125; &#125; &#125; else &#123; // 对于隔离进程，获得服务之前所在的进程！ app = r.isolatedProc; &#125; // 如果服务所在的进程没有启动！ if (app == null &amp;&amp; !permissionsReviewRequired) &#123; //【6】首先要启动服务所在的进程，这里请去看进程启动和创建的博文！ if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, \"service\", r.name, false, isolated, false)) == null) &#123; String msg = \"Unable to launch app \" + r.appInfo.packageName + \"/\" + r.appInfo.uid + \" for service \" + r.intent.getIntent() + \": process is bad\"; Slog.w(TAG, msg); bringDownServiceLocked(r); // 进程启动失败； return msg; &#125; // 如果服务要运行在隔离进程中，就把创建的 ProcessRecord 保存到 r.isolatedProc 中！ if (isolated) &#123; r.isolatedProc = app; &#125; &#125; //【7】将这个服务加入到 mPendingServices 中，表示该服务正在其所在的进程启动； if (!mPendingServices.contains(r)) &#123; mPendingServices.add(r); &#125; if (r.delayedStop) &#123; // Oh and hey we've already been asked to stop! r.delayedStop = false; if (r.startRequested) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Applying delayed stop (in bring up): \" + r); stopServiceLocked(r); &#125; &#125; return null;&#125; 我们来总结一下，这个方法的流程： 第一阶段： 如果服务所在的进程已经启动，就调用 sendServiceArgsLocked，通过 ApplicationThread 拉起 onStartCommand 的方法，结束流程； 如果服务所在的进程没有被启动，进入下面的流程： 第二阶段： 如果服务正在等待重启，不处理，结束流程； 否则，进入下面的流程： 第三阶段： 当前服务要被启动了，就从等待重启 mRestartingServices 中移除它； 如果这个服务是被延迟启动（delayed 的值为 true）的，就从 mDelayedStartList 中移除它，并置其 delayed 为 false； 当前服务将要被启动，所以要设置其 package 的停止状态为 false； 判断这个进程是否是隔离进程： 如果是非隔离进程，根据进程名和 uid，获得其所在进程的 ProcessRecord 对象，如果进程已经启动，就启动指定服务，结束流程； 如果是隔离进程，获得服务之前所在的隔离进程的 ProcessRecord 对象； 第四阶段： 根据获得的 ProcessRecord 对象，判断，如果之前服务所在进程没有启动，就需要先启动进程； 将服务添加到 mPendingServices 中，表示正在启动该服务； 之前我们有说，我们假设要启动的服务所在的进程没有被启动，那么就要先启动目标进程，具体的启动过程，大家可以去看我的其他几篇博客：Android 进程的创建和启动 这里我们直接用之前的结果，进入 AMS.attachApplicationLocked 方法！ 2.5 ActivityManagerS.attachApplicationLocked当应用进程启动后，会通过 Binder 通信，调用 AMS.attachApplicationLocked，我们去看看：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ... ... ... // 这里会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们先不说！ thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); // 更新进程 LRU 队列！ updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); // 每当 bind 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。 startProcessLocked(app, \"bind fail\", processName); return false; &#125; // 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses // 和等待启动的进程集合 mProcessesOnHold 中移除！ mPersistentStartingProcesses.remove(app); mProcessesOnHold.remove(app); boolean badApp = false; boolean didSomething = false; ... ... ... ... if (!badApp) &#123; try &#123; // 检查是否有 sevvce 组件要在这个新进程中运行！ didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown starting services in \" + app, e); badApp = true; &#125; &#125; ... ... ... ... if (badApp) &#123; // badApp 为 true，就杀掉这个进程 app.kill(\"error during init\", true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; // 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！ updateOomAdjLocked(); &#125; return true;&#125; bindApplication 方法会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们不看！ 这里会调用 ActiveServices 的 attachApplicationLocked 方法！ 2.6 ActiveServices.attachApplicationLocked当应用进程启动成功，并且 Application 对象已经创建，其 onCreate 方法已经调用后，就要启动指定的服务了！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465boolean attachApplicationLocked(ProcessRecord proc, String processName) throws RemoteException &#123; boolean didSomething = false; //【1】启动该进程中所有的服务！ if (mPendingServices.size() &gt; 0) &#123; ServiceRecord sr = null; try &#123; // 遍历 mPendingServices 集合中的所有服务，启动属于这个进程的所有服务！ for (int i=0; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; continue; &#125; mPendingServices.remove(i); i--; // 将服务的包名，版本号以及 AMS 的进程状态对象保存到进程对象中！ proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode, mAm.mProcessStats); //【1】启动服务，这里又回到了之前的方法中！ realStartServiceLocked(sr, proc, sr.createdFromFg); didSomething = true; if (!isServiceNeeded(sr, false, false)) &#123; // 如果已经不需要启动了，就取消启动！ bringDownServiceLocked(sr); &#125; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception in new application when starting service \" + sr.shortName, e); throw e; &#125; &#125; //【2】接着启动那些需要重启的服务，重启的服务都会保存到 mRestartingServices 服务中！ // 因为重启的时间可能还没有到，所以这里并不是立刻启动它们，而是启动了一个任务，交给了 AMS 的 MainHandler 去做！ if (mRestartingServices.size() &gt; 0) &#123; ServiceRecord sr; for (int i=0; i&lt;mRestartingServices.size(); i++) &#123; sr = mRestartingServices.get(i); if (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; continue; &#125; // sr.restarter 是一个 ServiceRestarter 对象，是一个 Runnable，这里会执行重启！ mAm.mHandler.removeCallbacks(sr.restarter); mAm.mHandler.post(sr.restarter); &#125; &#125; return didSomething;&#125; 这里有一个方法 isServiceNeeded 是否需要启动服务：1234567891011121314private final boolean isServiceNeeded(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; if (r.startRequested) &#123; return true; &#125; if (!knowConn) &#123; hasConn = r.hasAutoCreateConnections(); &#125; if (hasConn) &#123; return true; &#125; return false;&#125; 判断依据很简单: r.startRequested 为 true，说明服务被请求启动，那么就需要； r.hasAutoCreateConnections 为 true；说明有应用已经和该服务建立了自动创建的连接，那么就需要； 我们发现无论进程是否已经被创建，最终都会调用 realStartServiceLocked 方法！ 2.7 AS.realStartServiceLocked通过调用 realStartServiceLocked 方法来启动进程中的指定服务：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"realStartServiceLocked, ServiceRecord.uid = \" + r.appInfo.uid + \", ProcessRecord.uid = \" + app.uid); // 设置服务的进程对象； r.app = app; // 设置服务的启动和活跃时间； r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); // 将被启动服务的 ServiceRecord 对象添加到所属进程的 app.services 中！ final boolean newService = app.services.add(r); //【1】针对 onCreate 方法，设置超时处理！ bumpServiceExecutingLocked(r, execInFg, \"create\"); // 更新 LruProcess 和 OomAdj！ mAm.updateLruProcessLocked(app, false, null); mAm.updateOomAdjLocked(); boolean created = false; try &#123; if (LOG_SERVICE_START_STOP) &#123; // log 相关！ String nameTerm; int lastPeriod = r.shortName.lastIndexOf('.'); nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName; EventLogTags.writeAmCreateService( r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid); &#125; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); // 将进程的状态更新为 ActivityManager.PROCESS_STATE_SERVICE！ app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //【2】通过 binder 通信，拉起服务的 onCreate 方法！ app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); // 如果服务通过 setForeground 方法设置了通知，就显示通知！ r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; Slog.w(TAG, \"Application dead when creating service \" + r); mAm.appDiedLocked(app); // 如果在服务启动时，应用进程死了，调用 appDiedLocked 通知死亡仆告对象！ throw e; &#125; finally &#123; if (!created) &#123; // 如果启动失败，并且不死一个被销毁的服务，那就尝试重启他！ final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); if (newService) &#123; app.services.remove(r); r.app = null; &#125; if (!inDestroying) &#123; scheduleServiceRestartLocked(r, false); &#125; &#125; &#125; if (r.whitelistManager) &#123; app.whitelistManager = true; &#125; // 拉起 onBind 相关的方法，但是这里是不会触发的，因为 r.bindings 集合只有在 bindService 才会有元素！ // 但是，如果之前 bindService 的标志位设置的不是 Context.BIND_AUTO_CREATE，而是其他参数，那么其 r.bindings // 是有元素的，这里才会调用服务的 onBind 方法，为之前的 bindService 返回代理对象！ requestServiceBindingsLocked(r, execInFg); updateServiceClientActivitiesLocked(app, null, true); // 如果服务被请求启动，但是其内部的启动项为 0，那就创建一个启动项，保证 Service 的 onStartCommand 可以被调用； if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null)); &#125; //【2】通过 binder 通信，拉起服务的 onStartCommand 方法！ sendServiceArgsLocked(r, execInFg, true); // 如果是延迟启动的话，在这里将其移除！ if (r.delayed) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"REM FR DELAY LIST (new proc): \" + r); getServiceMap(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; if (r.delayedStop) &#123; // Oh and hey we've already been asked to stop! r.delayedStop = false; if (r.startRequested) &#123; if (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, \"Applying delayed stop (from start): \" + r); stopServiceLocked(r); &#125; &#125;&#125; 这里要注意： 方法 requestServiceBindingsLocked，一般是不会触发的，因为 r.bindings 集合只有在 bindService 的情况才会被添加元素！但是，如果之前 bindService 的标志位没有设置 Context.BIND_AUTO_CREATE，而是其他标志位，那么其 r.bindings 是有元素的，这里就会调用服务的 onBind 方法，为之前的 bindService 返回代理对象！ 2.7.1 AS.bumpServiceExecutingLocked针对 onCreate 方法，设置超时处理，参数 fg 表示这个服务是前台执行，还是后台执行的！1234567891011121314151617181920212223242526272829303132333435363738394041424344private final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&gt;&gt;&gt; EXECUTING \" + why + \" of \" + r + \" in app \" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&gt;&gt;&gt; EXECUTING \" + why + \" of \" + r.shortName); long now = SystemClock.uptimeMillis(); if (r.executeNesting == 0) &#123; // executeNesting 用来记录是否有超时处理操作！ r.executeFg = fg; ServiceState stracker = r.getTracker(); if (stracker != null) &#123; // 对该服务进行内存监控处理！ stracker.setExecuting(true, mAm.mProcessStats.getMemFactorLocked(), now); &#125; if (r.app != null) &#123; // 将服务添加到 ProcessRecord 的 executingServices 集合中，表示服务正在执行某段代码！ r.app.executingServices.add(r); r.app.execServicesFg |= fg; // 如果正在执行指定函数的服务个数为 1，设置超时处理！ if (r.app.executingServices.size() == 1) &#123; scheduleServiceTimeoutLocked(r.app); &#125; &#125; &#125; else if (r.app != null &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123; r.app.execServicesFg = true; scheduleServiceTimeoutLocked(r.app); &#125; r.executeFg |= fg; r.executeNesting++; // 记录启动时间！ r.executingStart = now;&#125; 我们来看看超市处理的操作！ 2.7.1.1 AS.scheduleServiceTimeoutLocked123456789101112131415void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123; // 如果进程没有正在执行某段代码的服务就返回！ if (proc.executingServices.size() == 0 || proc.thread == null) &#123; return; &#125; long now = SystemClock.uptimeMillis(); Message msg = mAm.mHandler.obtainMessage( ActivityManagerService.SERVICE_TIMEOUT_MSG); msg.obj = proc; mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));&#125; 可以看到： 对于前台服务：超时时间是 20s 对于后台服务：超市时间是 200s 最后发送 SERVICE_TIMEOUT_MSG 消息到 AMS 的 MainHandler 中！ 2.7.1.2 ActivityServiceS.MainHandler12345678910111213141516171819202122232425final class MainHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... ... ... ... case SERVICE_TIMEOUT_MSG: &#123; if (mDidDexOpt) &#123; // 表示是否延迟执行 odex mDidDexOpt = false; Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG); nmsg.obj = msg.obj; mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT); return; &#125; // 调用 serviceTimeout，设置超时处理！ mServices.serviceTimeout((ProcessRecord)msg.obj); &#125; break; ... ... ... ... &#125; &#125;&#125; 接着进入 ActiveServices 中！ 2.7.1.3 ActiveServices.serviceTimeout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void serviceTimeout(ProcessRecord proc) &#123; String anrMessage = null; synchronized(mAm) &#123; if (proc.executingServices.size() == 0 || proc.thread == null) &#123; return; &#125; final long now = SystemClock.uptimeMillis(); final long maxTime = now - (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT); ServiceRecord timeout = null; long nextTime = 0; // 从正在执行代码逻辑的服务列表中，获得判断是否超时的服务！ for (int i=proc.executingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord sr = proc.executingServices.valueAt(i); if (sr.executingStart &lt; maxTime) &#123; // 服务启动已经超时，timeout 不为 null； timeout = sr; break; &#125; if (sr.executingStart &gt; nextTime) &#123; nextTime = sr.executingStart; &#125; &#125; if (timeout != null &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123; Slog.w(TAG, \"Timeout executing service: \" + timeout); // 启动服务超时了，进入这个分支! StringWriter sw = new StringWriter(); PrintWriter pw = new FastPrintWriter(sw, false, 1024); pw.println(timeout); timeout.dump(pw, \" \"); pw.close(); mLastAnrDump = sw.toString(); mAm.mHandler.removeCallbacks(mLastAnrDumpClearer); mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS); anrMessage = \"executing service \" + timeout.shortName; &#125; else &#123; // 继续发送超时消息，进行下一轮超时判断！ Message msg = mAm.mHandler.obtainMessage( ActivityManagerService.SERVICE_TIMEOUT_MSG); msg.obj = proc; mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT)); &#125; &#125; if (anrMessage != null) &#123; // 捕捉到 ANR！ mAm.mAppErrors.appNotResponding(proc, null, null, false, anrMessage); &#125;&#125; 我们可以看到，判断启动服务是否超时：不断的给 AMS 的 MainHandler 发送 SERVICE_TIMEOUT_MSG 消息，不断的判断时间是否超时！ 如果超时的话，会触发 AppErrors.appNotResponding 方法，这个我们以后再看！ 2.7.2 ApplicationThreadP.scheduleCreateService拉起其 onCreate 方法，参数说明： IBinder token：服务的 ServiceRecord 对象，实现了 IBinder 接口！ erviceInfo info：服务的组件信息； CompatibilityInfo compatInfo： int processState：服务所在进程的状态；123456789101112131415161718192021222324252627class ApplicationThreadProxy implements IApplicationThread &#123; public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); info.writeToParcel(data, 0); compatInfo.writeToParcel(data, 0); data.writeInt(processState); try &#123; // 通过 binder 通信！ mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); &#125; catch (TransactionTooLargeException e) &#123; Log.e(\"CREATE_SERVICE\", \"Binder failure starting service; service=\" + info); throw e; &#125; data.recycle(); &#125; &#125; binder 通信，进入应用进程！ 2.7.3 AS.sendServiceArgsLocked拉起其 onStartCommand 方法： 参数传递： ServiceRecord r：被启动的服务的数据对象，它实现了 Binder 接口，可以跨进程传递； boolean execInFg：callFg，表示本次启动是前台调用还是后台调用； oomAdjusted：传入 false； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) throws TransactionTooLargeException &#123; // 还记得 pendingStarts 吗，在前面启动的时候， // 会将 intent 等等的数据封装成 StartItem，保存到 pendingStarts 中； final int N = r.pendingStarts.size(); if (N == 0) &#123; // 如果 N 为 null，说明没有启动操作； return; &#125; while (r.pendingStarts.size() &gt; 0) &#123; // 遍历要启动服务 ServiceRecord 的 pendingStarts！ Exception caughtException = null; ServiceRecord.StartItem si = null; try &#123; // 将要处理的启动项从 pendingStarts 中移除！ si = r.pendingStarts.remove(0); if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Sending arguments to: \" + r + \" \" + r.intent + \" args=\" + si.intent); if (si.intent == null &amp;&amp; N &gt; 1) &#123; // 如果有启动项的 intent 为 null，且启动项目总数大于 1，那就会忽视掉这个 intent！ continue; &#125; // 将要处理的启动项添加到 deliveredStarts 中，表示启动项已经分发处理！ si.deliveredTime = SystemClock.uptimeMillis(); r.deliveredStarts.add(si); // 增加启动项目的 deliveryCount 计数，表示这个启动项的处理次数！ si.deliveryCount++; if (si.neededGrants != null) &#123; mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants, si.getUriPermissionsLocked()); &#125; // 为 onStartCommand 方法设置超时任务！ bumpServiceExecutingLocked(r, execInFg, \"start\"); if (!oomAdjusted) &#123; // 更新服务所在进程的 abj 值； oomAdjusted = true; mAm.updateOomAdjLocked(r.app); &#125; int flags = 0; if (si.deliveryCount &gt; 1) &#123; flags |= Service.START_FLAG_RETRY; &#125; if (si.doneExecutingCount &gt; 0) &#123; flags |= Service.START_FLAG_REDELIVERY; &#125; // thread 是 ApplicationThreadProxy 对象； r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent); &#125; catch (TransactionTooLargeException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Transaction too large: intent=\" + si.intent); caughtException = e; &#125; catch (RemoteException e) &#123; // Remote process gone... we'll let the normal cleanup take care of this. if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Crashed while sending args: \" + r); caughtException = e; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Unexpected exception\", e); caughtException = e; &#125; if (caughtException != null) &#123; // Keep nesting count correct final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); if (caughtException instanceof TransactionTooLargeException) &#123; throw (TransactionTooLargeException)caughtException; &#125; break; &#125; &#125;&#125; 可以看到，如果服务所在的进程已经被启动了，那就直接调用 sendServiceArgsLocked 方法，通过服务所属进程在系统进程中的 Binder 对象 ApplicationThreadProxy，通过 Binder 间通信，调用应用进程的 ApplicationThread 的 scheduleServiceArgs 对象，拉起指定服务的 onStartCommand 方法； 2.7.3.1 ApplicationThreadP.scheduleServiceArgs拉起 onStartCommand 方法，参数说明： IBinder token：服务的 ServiceRecord 对象，实现了 IBinder 接口！ boolean taskRemoved：启动项的 taskRemoved； int startId：启动项的 id，用来表示本次启动的 id 值！ int flags： Intent args：启动项用的 intent，用来启动 Service！ 123456789101112131415161718192021222324252627class ApplicationThreadProxy implements IApplicationThread &#123; public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId, int flags, Intent args) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); data.writeInt(taskRemoved ? 1 : 0); data.writeInt(startId); data.writeInt(flags); if (args != null) &#123; data.writeInt(1); args.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; // binder 通信，进入到应用进程 mRemote.transact(SCHEDULE_SERVICE_ARGS_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125;&#125; binder 通信，进入应用进程！ 3 被启动者进程在之前的进程启动分析中，当进程被拉起后，应用进程会创建进程的 ActivityThread 对象，用于托管进程的主线程，组件信息，ApplicationThread 对象等等的信息！ 首先会进入 ApplicationThreadNative.onTransact 方法！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** &#123;@hide&#125; */public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; // 拉起 onCreate 方法！ case SCHEDULE_CREATE_SERVICE_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder token = data.readStrongBinder(); ServiceInfo info = ServiceInfo.CREATOR.createFromParcel(data); CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); int processState = data.readInt(); // 继续来看！ scheduleCreateService(token, info, compatInfo, processState); return true; &#125; // 拉起 onStartCommand 方法！ case SCHEDULE_SERVICE_ARGS_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder token = data.readStrongBinder(); boolean taskRemoved = data.readInt() != 0; int startId = data.readInt(); int fl = data.readInt(); Intent args; if (data.readInt() != 0) &#123; args = Intent.CREATOR.createFromParcel(data); &#125; else &#123; args = null; &#125; // 继续来看！ scheduleServiceArgs(token, taskRemoved, startId, fl, args); return true; &#125; &#125;&#125; 接下来，进入 binder 通信服务端 ApplicationThread！ 3.1 ApplicationThread.scheduleCreateService12345678910111213141516private class ApplicationThread extends ApplicationThreadNative &#123; public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; // 发送 H.CREATE_SERVICE 到主线程的 Handler! sendMessage(H.CREATE_SERVICE, s); &#125;&#125; 可以看到，最后会调用 sendMessage 方法，将消息 H.CREATE_SERVICE 发送给进程的主线程！ 3.2 ApplicationThread.scheduleServiceArgs1234567891011121314151617private class ApplicationThread extends ApplicationThreadNative &#123; public final void scheduleServiceArgs(IBinder token, boolean taskRemoved, int startId, int flags ,Intent args) &#123; ServiceArgsData s = new ServiceArgsData(); s.token = token; s.taskRemoved = taskRemoved; s.startId = startId; s.flags = flags; s.args = args; // 发送 H.SERVICE_ARGS 到主线程的 Handler! sendMessage(H.SERVICE_ARGS, s); &#125;&#125; 可以看到，最后会调用 sendMessage 方法，将消息 H.SERVICE_ARGS 发送给进程的主线程！ 3.3 ApplicationThread.H12345678910111213141516171819202122private class H extends Handler &#123; public void handleMessage(Message msg) &#123; case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (\"serviceCreate: \" + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (\"serviceStart: \" + String.valueOf(msg.obj))); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125; &#125; 这里省略了其他消息的处理！ 最后分别调用：handleCreateService 和 handleServiceArgs 拉起指定的方法！ 3.3.1 ApplicationThread.handleCreateService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void handleCreateService(CreateServiceData data) &#123; // 如果此时准备要 GC，那就跳过本次 GC！ unscheduleGcIdler(); // 获得应用程序的加载信息，先会从缓存中获取，找不到才创建！ LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; // 通过反射创建要启动的服务的实例！ java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( \"Unable to instantiate service \" + data.info.name + \": \" + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); // 创建该 Serivce Context 对象！ ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); // 返回该进程的 Application 对象！ Application app = packageInfo.makeApplication(false, mInstrumentation); // 将服务实例和 context，Application 进行绑定！ service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); // 调用了服务的 onCreate 方法！ service.onCreate(); // 将创建的服务实例保存到 AT 的托管集合中！ mServices.put(data.token, service); try &#123; // 通知 AMS，操作完成； ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( \"Unable to create service \" + data.info.name + \": \" + e.toString(), e); &#125; &#125;&#125; 接着，进入了 Service 的 onCreate 方法中： 3.3.1.1 service.onCreate12345678910111213141516171819202122232425262728public abstract class Service extends ContextWrapper implements ComponentCallbacks2 &#123; /** * @hide */ public final void attach( Context context, ActivityThread thread, String className, IBinder token, Application application, Object activityManager) &#123; attachBaseContext(context); mThread = thread; // NOTE: unused - remove? mClassName = className; // 这个 mToken 在系统进程对应着的是服务的 ServiceRecord 对象 mToken = token; mApplication = application; mActivityManager = (IActivityManager)activityManager; mStartCompatibility = getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.ECLAIR; &#125; public void onCreate() &#123; // 由于用户实现具体的调用内容！ &#125; &#125; 注意这个 mToken， 它在系统进程对应着的是服务的 ServiceRecord 对象，之前在系统进程通过 ApplicationThreadP 传递对象的时候，会将 ServiceRecord 通过 binder 通信传递过来！ 3.3.2 ApplicationThread.handleServiceArgs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void handleServiceArgs(ServiceArgsData data) &#123; // 获得之前创建的服务对象！ Service s = mServices.get(data.token); if (s != null) &#123; try &#123; if (data.args != null) &#123; data.args.setExtrasClassLoader(s.getClassLoader()); data.args.prepareToEnterProcess(); &#125; int res; if (!data.taskRemoved) &#123; // 如果 data.taskRemoved 为 false，就拉起 onStartCommand 方法！ // 拉起服务的 onStartCommand 方法！ res = s.onStartCommand(data.args, data.flags, data.startId); &#125; else &#123; // 否则，拉起 onTaskRemoved 方法！ s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; QueuedWork.waitToFinish(); try &#123; // 通知 AMS，操作完成，并传递 onStartCommand 的返回结果； ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; ensureJitEnabled(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to start service \" + s + \" with \" + data.args + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; 3.3.2.1 service.onStartCommand1234public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId) &#123; onStart(intent, startId); return mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY;&#125; 最后进入了 Service 的 onStartCommand 方法！ 3.4 ActivityManagerP.serviceDoneExecuting当服务的指定方法被拉起后，会通知 AMS，拉起操作执行成功，代码如下：1234567// 通知 AMS，拉起 onCreate 操作完成；ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); // 通知 AMS，拉起 onStart 操作完成；ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); 这里进入 ActivityManagerP：123456789101112131415public void serviceDoneExecuting(IBinder token, int type, int startId, int res) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(token); data.writeInt(type); data.writeInt(startId); data.writeInt(res); mRemote.transact(SERVICE_DONE_EXECUTING_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY); reply.readException(); data.recycle(); reply.recycle();&#125; 这里再次进入系统进程，我们去看看发生了什么！！ 4 系统进程接下来，进入系统进程，处理反馈结果，首先要进入 ActivityManagerN.onTransact 方法！123456789101112131415case SERVICE_DONE_EXECUTING_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); int type = data.readInt(); int startId = data.readInt(); int res = data.readInt(); // 进入 AMS! serviceDoneExecuting(token, type, startId, res); reply.writeNoException(); return true;&#125; 4.1 ActivityManagerS.serviceDoneExecuting12345678910111213public void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123; synchronized(this) &#123; // 如果 token 不是 ServiceRecord 的实例，就会抛出异常！ if (!(token instanceof ServiceRecord)) &#123; Slog.e(TAG, \"serviceDoneExecuting: Invalid service token=\" + token); throw new IllegalArgumentException(\"Invalid service token\"); &#125; // 进入 ActiveServices！ mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res); &#125;&#125; 继续看！ 4.2 ActiveServices.serviceDoneExecutingLocked 对于拉起 onCreate 方法，type 的值为 SERVICE_DONE_EXECUTING_ANON； 对于拉起 onStartCommand 方法，type 的值为 SERVICE_DONE_EXECUTING_START； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123; // 判断这个服务是否正在被销毁！ boolean inDestroying = mDestroyingServices.contains(r); if (r != null) &#123; // 这里处理拉起 onStartCommand 方法后的，onStart 方法的返回值！ if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123; // 将 r.callStart 置为 true！ r.callStart = true; switch (res) &#123; case Service.START_STICKY_COMPATIBILITY: case Service.START_STICKY: &#123; // 从服务的 deliveredStarts 集合中删除本次启动对应的启动项！ r.findDeliveredStart(startId, true); // 表示服务被杀死后不会被停止，会被重启！ r.stopIfKilled = false; break; &#125; case Service.START_NOT_STICKY: &#123; // 从服务的 deliveredStarts 集合中删除本次启动对应的启动项！ r.findDeliveredStart(startId, true); // 判断服务最后一次启动的 id 是否为本次 id！ if (r.getLastStartId() == startId) &#123; // 表示服务被杀死后会被停止，不会被重启！ r.stopIfKilled = true; &#125; break; &#125; case Service.START_REDELIVER_INTENT: &#123; // 第二个参数为 false，并没有删除 startId 对应的启动项目，这里只是返回了！ // 这个启动项 Intent 被保留下来了！ ServiceRecord.StartItem si = r.findDeliveredStart(startId, false); if (si != null) &#123; si.deliveryCount = 0; si.doneExecutingCount++; // Don't stop if killed. r.stopIfKilled = true; &#125; break; &#125; case Service.START_TASK_REMOVED_COMPLETE: &#123; // Special processing for onTaskRemoved(). Don't // impact normal onStartCommand() processing. r.findDeliveredStart(startId, true); break; &#125; default: throw new IllegalArgumentException( \"Unknown service start result: \" + res); &#125; if (res == Service.START_STICKY_COMPATIBILITY) &#123; r.callStart = false; &#125; &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123; // 这里是处理 destroy 服务的情况，这里先不看！ &#125; // 对于拉起 onCreate 方法的返回 type，直接进入这里！！ final long origId = Binder.clearCallingIdentity(); serviceDoneExecutingLocked(r, inDestroying, inDestroying); Binder.restoreCallingIdentity(origId); &#125; else &#123; Slog.w(TAG, \"Done executing unknown service from pid \" + Binder.getCallingPid()); &#125;&#125; findDeliveredStart 方法用于从 ServiceRecord 的 deliveredStarts 集合中返回指定 id 的启动项，如果 remove 为 true，也要移除指定 id 的启动项！ 123456789101112public StartItem findDeliveredStart(int id, boolean remove) &#123; final int N = deliveredStarts.size(); for (int i=0; i&lt;N; i++) &#123; StartItem si = deliveredStarts.get(i); if (si.id == id) &#123; if (remove) deliveredStarts.remove(i); return si; &#125; &#125; return null;&#125; 这里我们来看看 Service 的 onStartCommand 方法的返回值的处理总结： START_STICKY： START_STICKY_COMPATIBILITY： 删除本次启动的 startId 对应的启动项； 设置服务的 stopIfKilled 为 false； START_NOT_STICKY： 删除本次启动的服务的 startId 对应的启动项； 如果最后一次启动的启动项的 id (lastStartId) 等于本次启动的启动项的 id； 设置服务的 stopIfKilled 为 true； START_REDELIVER_INTENT： 不删除本次启动的 startId 对应的启动项； 如果本次启动的启动项不为 null； 设置启动项的 deliveryCount 为 0； 设置启动项的 doneExecutingCount 加 1； 设置服务的 stopIfKilled 为 true； 那么，如果服务被启动后，因为一些原因，所在的进程被杀掉了，那么系统会根据服务以上的属性对服务进行重启！ 这里的 r.stopIfKilled 属性在 AS.killServicesLocked 的方法中会处理，用于判断服务在被 kill 掉后，是否被重启起！对于 Service 的重启，我会在另外一篇博文中分析，尽情期待！ 4.3 ActiveServices.serviceDoneExecutingLocked我们继续看，参数传递： boolean inDestroying：服务正在被销毁！ boolean finishing：服务正在完成！ 因为这里是刚刚启动服务，所以传入均为 false； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying, boolean finishing) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"&lt;&lt;&lt; DONE EXECUTING \" + r + \": nesting=\" + r.executeNesting + \", inDestroying=\" + inDestroying + \", app=\" + r.app); else if (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"&lt;&lt;&lt; DONE EXECUTING \" + r.shortName); r.executeNesting--; if (r.executeNesting &lt;= 0) &#123; if (r.app != null) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"Nesting at 0 of \" + r.shortName); r.app.execServicesFg = false; // 从 r.app.executingServices 移除该服务！ r.app.executingServices.remove(r); // 如果该进程中所有的服务都执行成功了，进入该分支！ if (r.app.executingServices.size() == 0) &#123; if (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, \"No more executingServices of \" + r.shortName); // 移除服务启动超时的消息！ mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app); &#125; else if (r.executeFg) &#123; // Need to re-evaluate whether the app still needs to be in the foreground. for (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123; if (r.app.executingServices.valueAt(i).executeFg) &#123; r.app.execServicesFg = true; break; &#125; &#125; &#125; if (inDestroying) &#123; // 不进入！ if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"doneExecuting remove destroying \" + r); mDestroyingServices.remove(r); r.bindings.clear(); &#125; // 更新 oomAdj！ mAm.updateOomAdjLocked(r.app); &#125; r.executeFg = false; if (r.tracker != null) &#123; r.tracker.setExecuting(false, mAm.mProcessStats.getMemFactorLocked(), SystemClock.uptimeMillis()); if (finishing) &#123; r.tracker.clearCurrentOwner(r, false); r.tracker = null; &#125; &#125; if (finishing) &#123; // 不进入！ if (r.app != null &amp;&amp; !r.app.persistent) &#123; r.app.services.remove(r); if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; &#125; r.app = null; &#125; &#125;&#125; 这里会让 AMS 的 MainHandler 不再处理超时的消息！ 5 总结到这里，startService 的启动流程就分析完了，我们来回顾一下！！ 6.1 数据结构总结我们先来看看，在 start 流程中，会涉及到的一些重要的数据结构，以及他们之间的关系！ 6.1.1 ProcessRecord启动者和被启动者所在进程的信息对象；12345int curProcState // 表示当前进程的状态，可以通过其来判断是否是前台进程调度，还是后台进调度int setSchedGroup // 进程的最新状态ArraySet&lt;ServiceRecord&gt; services // 运行在这个进程中的所有服务ArraySet&lt;ServiceRecord&gt; executingServices // 当前正在执行某段代码逻辑的服务列表，比如正在拉起 onCreate 等 属性解释： 6.1.2 ActivieServices用来保存和管理系统中所有活跃的 Service！12345 SparseArray&lt;ServiceMap&gt; mServiceMap // 所有设备用户下的 Service 集合，key 为 userId，value 是 ServiceMap 类型的实例； ArrayList&lt;ServiceRecord&gt; mRestartingServices // 因为 CRASH 需要重启的 ServiceRecord 集合！ ArrayList&lt;ServiceRecord&gt; mDestroyingServices // 进程被销毁的 ServiceRecord 集合！ArrayList&lt;ServiceRecord&gt; mPendingServices // 所有正在启动的 ServiceRecord 集合 属性解释： 6.1.3 ServiceMap是 Handler 的子类，用来保存制定 userId 目录下的所有 ServiceRecord！ 1234567int mUserId： // 指定的 uidArrayMap&lt;ComponentName, ServiceRecord&gt; mServicesByName：// 通过组件名为 key，存储对应的 ServiceRecordArrayMap&lt;Intent.FilterComparison, ServiceRecord&gt; mServicesByIntent；// 通过 intent 为 key，存储对应的 ServiceRecordArrayList&lt;ServiceRecord&gt; mDelayedStartList: // 延迟启动的 ServiceRecord 列表ArrayList&lt;ServiceRecord&gt; mStartingBackground：// 正在后台启动的 ServiceRecord 列表 属性解释： 6.1.4 ServiceRecord要启动的 Service 的数据对象！ 1234567891011121314151617181920212223242526272829 ServiceInfo serviceInfo // 该服务的解析信息，来自 PMS ApplicationInfo appInfo // 该服务所属应用的信息，来自 PMS int userId // 该服务所属的设备用户 Intent.FilterComparison intent // 用来匹配该服务的 intent 封装类，等价于 intent String permission // 访问该服务需要的权限 long createTime // 该服务创建的时间 boolean createdFromFg // 表示服务是通过前台进程调度创建的还是后台进程 long lastActivity // 服务的活跃时间； boolean startRequested // 服务是否被请求启动，开始启动时会置为 true； boolean delayedStop // 服务是否被延迟停止，开始启动时会置为 false；boolean delayed // 服务是否延迟启动，默认为 false；long restartDelay // 服务重启延迟时间！int restartCount // 服务重启次数！ long restartTime // 服务重启时间！ArrayList&lt;StartItem&gt; pendingStarts // 待处理的启动项列表；ArrayList&lt;StartItem&gt; deliveredStarts // 已经被处理的启动项列表；Runnable restarter // 这是一个 ServiceRestarter 对象，用于处理重启任务！boolean callStartProcessRecord app // 服务所在的进程boolean executeFg // 表示该服务是否是前台执行 int executeNesting // long executingStart // 表示服务开始执行的时间 属性解释： r.pendingStarts：AS 会把启动相关的信息封装成一个 StartItem，保存到 pendingStarts 中！ r.delayed：于后台启动的方式，如果 ServiceMap.mStartingBackground 的大小超过 mMaxStartingBackground 的话，会被置为 true，同时，将 ServiceRecord 添加到 ServiceMap.mDelayedStartList 中！ 6.1.5 StartItem这是一个启动项，封装一次 startService 的数据 123456789final ServiceRecord sr; // 要启动的服务final boolean taskRemoved; // final int id; // 启动项 id ，最小从 1 开始final Intent intent; // 启动用的 Intentfinal ActivityManagerService.NeededUriGrants neededGrants;long deliveredTime;int deliveryCount;int doneExecutingCount;UriPermissionOwner uriPermissions; 属性解释： 6.1.6 ServiceRestarter这是 Runnable 对象，用于处理服务的重启！ 1ServiceRecord mService // 对应的服务！ 属性解释： 6.1.7 CreateServiceDataActivityThread 的内部类，用于封装拉起 onCreate 方法的数据：1234IBinder token; // ServiceRecord 对象ServiceInfo info;CompatibilityInfo compatInfo;Intent intent; 属性解释： 6.1.8 ServiceArgsDataActivityThread 的内部类，用于封装拉起 onStartCommand 方法的数据： 12345IBinder token; // ServiceRecord 对象boolean taskRemoved;int startId; // 本次启动的 idint flags; // 如果Intent args; // 启动的 Intent 属性解释： 6.2 生命周期总结startService 方法周期很简单：1Serice.onCreate()(once) -&gt; Service.onStartCommand()(more) 6.3 流程总结下面是整个过程的 UML 序列图： （我先填个坑，毕竟画图太累） 我们来看一下，这里面的一些细节： 如果多次调用 startService，只有第一次会拉起服务的 onCreate 方法，因为 r.app 和 r.app.thread 为 null，r.app 是在创建 Serivce（onCreate）时被赋值的，多次调用 StartService，会直接进入 sendServiceArgsLocked 方法，拉起服务的 onStartCommand 方法； onCreate 方法的 startId 为 0，onStartCommand 方法的 startId 从 1 开始，一次递增！ 如果服务启动后，因为内存不足等情况，被杀掉了，那么系统会重启该服务，如果在重启之前，用户通过 startService 再次启动了服务，那么就会取消之前的重启任务！（r.restartDelay 是在设置服务重启任务时设置的，我们后面再看） onStartCommand 方法的返回值有多个，这些返回值会影响 Serivce 的重启，请看 Service reStart 流程处理的分析，这里就不再多说了！","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"Service服务","slug":"AndroidFramework源码分析/Service服务","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/Service服务/"}],"tags":[{"name":"Service服务","slug":"Service服务","permalink":"https://coolqi.top/tags/Service服务/"}]},{"title":"ActivityManager第 1 篇 - ActivityManagerService 的启动","slug":"ActivityManager1-ActivityManagerServiceStartProcess","date":"2016-02-19T12:46:25.000Z","updated":"2018-11-20T16:18:04.000Z","comments":true,"path":"2016/02/19/ActivityManager1-ActivityManagerServiceStartProcess/","link":"","permalink":"https://coolqi.top/2016/02/19/ActivityManager1-ActivityManagerServiceStartProcess/","excerpt":"","text":"[toc] 基于 Android 7.1.1 源码分析 AMS 的机制，本文为作者原创，转载请说明出处，谢谢！ 0 综述Android 系统开机时，在 SystemService 进程被 Zygote 启动后，SystemSevice 进程需要启动一些系统的重要服务：1234Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"StartServices\");startBootstrapServices();startCoreServices();startOtherServices(); AMS 的启动涉及到了以上的每个阶段，以为 AMS 需要和其他的系统服务进行交互，下面我们来逐一分析: 1 第一阶段 - startBootstrapServices我们来看看低级阶段，和 AMS 相关的代码； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void startBootstrapServices() &#123; // 启动 Installer 系统服务 Installer installer = mSystemServiceManager.startService(Installer.class); //【1】第一阶段：启动 AMS mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); //【2】第二阶段，启动 PowerManagerService，AMS 初始化电池管理属性 mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); mActivityManagerService.initPowerManagement(); // 启动 LED 和背光灯、显示、包管理这些重要的系统服务！ mSystemServiceManager.startService(LightsService.class); mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); // 获得系统属性 vold.decrypt 的值，表示是否只加载核心服务； String cryptState = SystemProperties.get(\"vold.decrypt\"); if (ENCRYPTING_STATE.equals(cryptState)) &#123; Slog.w(TAG, \"Detected encryption in progress - only parsing core apps\"); mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; Slog.w(TAG, \"Device encrypted - only parsing core apps\"); mOnlyCore = true; &#125; // 创建 PMS 服务对象， mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); // 和 A/B 升级相关！ if (!mOnlyCore) &#123; boolean disableOtaDexopt = SystemProperties.getBoolean(\"config.disable_otadexopt\", false); if (!disableOtaDexopt) &#123; traceBeginAndSlog(\"StartOtaDexOptService\"); try &#123; OtaDexoptService.main(mSystemContext, mPackageManagerService); &#125; catch (Throwable e) &#123; reportWtf(\"starting OtaDexOptService\", e); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125; &#125; &#125; // 启动用户管理服务！ mSystemServiceManager.startService(UserManagerService.LifeCycle.class); // 初始化属性缓存，用于缓存包资源 AttributeCache.init(mSystemContext); //【4】设置系统进程相关的参数！ mActivityManagerService.setSystemProcess(); // 启动 Sensor 相关的服务。这是一个 Native 方法，与硬件相关度较大，这里不关注。 startSensorService();&#125; 启动 AMS 之前，需要先连接 installd 进程， 通过 Installer 这个服务，就能完成一些重要目录的创建，譬如 /data/user，同时应用程序的安装，也需要这个服务。 启动 ActivityManagerService 服务； 启动 PowerManagerService 服务，AMS 需要使用 PowerManagerService 的服务：譬如，在启动 Activity 时，要避免系统进入休眠状态，就需要获取 WakeLock； 启动 LightsService、 DisplayManagerService、 PackageManagerService 系统服务； 启动 OtaDexoptService 服务，这里是和 A/B 升级相关的； 调用 AMS.setSystemProcess() 设置当前进程为系统进程，设置系统进程相关的参数； 因为 AMS 的职责之一就是维护系统中所有进程的状态，不管是应用进程还是系统进程，都是 AMS 的管辖范围。 接下来，我们来看看和 AMS 相关的流程！ 1.1 ActivityManagerService接下来，我们仔细的看看 AMS 的构造器！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public ActivityManagerService(Context systemContext) &#123; // 获得系统进程的上下文环境； mContext = systemContext; mFactoryTest = FactoryTest.getMode(); // 是否是工厂模式！ // 获得 SystemServer 进程的 ActivityThread 对象，每个进程都有一个！ mSystemThread = ActivityThread.currentActivityThread(); Slog.i(TAG, \"Memory class: \" + ActivityManager.staticGetMemoryClass()); // 创建处理消息的 HandlerThread 和 Handler 对象！ mHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false /*allowIo*/); mHandlerThread.start(); mHandler = new MainHandler(mHandlerThread.getLooper()); // 创建处理 ANR 相关的 Handler！ mUiHandler = new UiHandler(); // 这里的 sKillHandler 绑定了一个 handlerThread 线程对象，用于处理杀进程的消息！ if (sKillHandler == null) &#123; sKillThread = new ServiceThread(TAG + \":kill\", android.os.Process.THREAD_PRIORITY_BACKGROUND, true /* allowIo */); sKillThread.start(); sKillHandler = new KillHandler(sKillThread.getLooper()); &#125; // 集合管理前台广播和后台广播的集合，有前 / 后台之分，为了区分不同的广播消息超时时间。 mFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", BROADCAST_FG_TIMEOUT, false); mBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", BROADCAST_BG_TIMEOUT, true); mBroadcastQueues[0] = mFgBroadcastQueue; mBroadcastQueues[1] = mBgBroadcastQueue; mServices = new ActiveServices(this); // 创建管理 Service 组件的 ActiveServices 对象！ mProviderMap = new ProviderMap(this); // 创建管理 Provider 组件的 ProviderMap 对象！ mAppErrors = new AppErrors(mContext, this); // 创建管理 ANR 和 crash 的 AppError 对象！ // 创建 /data/system 目录，诸如包管理packages.xml, packages.list等文件都存放于此目录 File dataDir = Environment.getDataDirectory(); File systemDir = new File(dataDir, \"system\"); systemDir.mkdirs(); // 创建电量统计服务 BatteryStatsService 对象，并将 mHandler 传入，用于通信！ mBatteryStatsService = new BatteryStatsService(systemDir, mHandler); mBatteryStatsService.getActiveStatistics().readLocked(); mBatteryStatsService.scheduleWriteToDisk(); mOnBattery = DEBUG_POWER ? true : mBatteryStatsService.getActiveStatistics().getIsOnBattery(); mBatteryStatsService.getActiveStatistics().setCallback(this); // 创建进程状态监控服务 ProcessStatsService 对象，/data/system/procstats 文件会存储 // 进程的状态信息！ mProcessStats = new ProcessStatsService(this, new File(systemDir, \"procstats\")); // 创建应用操作监控服务 AppOpsService 对象，/data/system/appops.xml文件存储app的 // 权限设置和操作信息！ mAppOpsService = new AppOpsService(new File(systemDir, \"appops.xml\"), mHandler); // 监听是否允许应用在后台运行的操作 mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null, new IAppOpsCallback.Stub() &#123; @Override public void opChanged(int op, int uid, String packageName) &#123; if (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != null) &#123; if (mAppOpsService.checkOperation(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; runInBackgroundDisabled(uid); &#125; &#125; &#125; &#125;); // 创建 urigrants.xml 文件对象！ mGrantFile = new AtomicFile(new File(systemDir, \"urigrants.xml\")); // 创建 UserController 对象！ mUserController = new UserController(this); // 获取 OpenGL 版本号 GL_ES_VERSION = SystemProperties.getInt(\"ro.opengles.version\", ConfigurationInfo.GL_ES_VERSION_UNDEFINED); if (SystemProperties.getInt(\"sys.use_fifo_ui\", 0) != 0) &#123; mUseFifoUiScheduling = true; &#125; mTrackingAssociations = \"1\".equals(SystemProperties.get(\"debug.track-associations\")); // 配置区域、语言、字体、屏幕方向等，启动 Activity 时，需要用到这个配置！ mConfiguration.setToDefaults(); mConfiguration.setLocales(LocaleList.getDefault()); mConfigurationSeq = mConfiguration.seq = 1; // 初始化 processCpuTracker 对象，用来收集 ANR 情况下的 cpu 使用情况，电池状态等等！ mProcessCpuTracker.init(); // AndroidManifest.xml 中 compatible-screens 相关的解析工具 mCompatModePackages = new CompatModePackages(this, systemDir, mHandler); // 创建 instent 防火墙！ mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), mHandler); // 创建管理组件 Activity 的 ActivityStackSupervisor 和 ActivityStarter 对象！ mStackSupervisor = new ActivityStackSupervisor(this); mActivityStarter = new ActivityStarter(this, mStackSupervisor); // 创建最近任务对象！ mRecentTasks = new RecentTasks(this, mStackSupervisor); // 创建一个子线程，不断循环，更新 cpu 的状态信息！ mProcessCpuThread = new Thread(\"CpuTracker\") &#123; @Override public void run() &#123; while (true) &#123; try &#123; try &#123; synchronized(this) &#123; final long now = SystemClock.uptimeMillis(); long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now; long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now; //Slog.i(TAG, \"Cpu delay=\" + nextCpuDelay // + \", write delay=\" + nextWriteDelay); if (nextWriteDelay &lt; nextCpuDelay) &#123; nextCpuDelay = nextWriteDelay; &#125; if (nextCpuDelay &gt; 0) &#123; mProcessCpuMutexFree.set(true); this.wait(nextCpuDelay); &#125; &#125; &#125; catch (InterruptedException e) &#123; &#125; // 更新 cpu 的状态以及电池状态信息！ updateCpuStatsNow(); &#125; catch (Exception e) &#123; Slog.e(TAG, \"Unexpected exception collecting process stats\", e); &#125; &#125; &#125; &#125;; // 将自身加入到 Watchdog 的监控中！ Watchdog.getInstance().addMonitor(this); Watchdog.getInstance().addThread(mHandler);&#125; 我们总结一下，在 AMS 的构造器中，主要做了一下几个事情： 创建了系统目录：/data/system 创建了几个系统服务对象： BatteryStatsService：用于监控电池状态； ProcessStatsService：用于监控进程状态； AppOpsService：用于监控 app 的操作行为； UserController： 创建了四大组件的管理对象； Broadcast：mFgBroadcastQueue 和 mBgBroadcastQueue，分别管理前台后台广播； Service：ActiveServices； Provider：ProviderMap； Activity：mStackSupervisor，mActivityStarter； 创建了处理 ANR 和 Crash 的对象：mAppErrors； 创建最近任务对象：RecentTasks； 初次之外，还有： 初始化 processCpuTracker 对象！ 创建了几个 Handler，用于消息处理： MainHandler：绑定了子线程 ServiceThread 对象 mHandlerThread，AMS 会把它传递个给其他服务，用于交互； UiHandler：绑定了系统进程的主线程，用于处理 ANR 和 Crash 相关的信息！ sKillThread：绑定了子线程 ServiceThread 对象 sKillThread，用于处理杀进程的操作； 创建几个子线程 一个线程 mProcessCpuThread，不断的更新 cpu 和电池的状态信息； 两个 ServiceThread 子线程； 1.1.1 new ActivityStackSupervisorActivityStackSupervisor 是系统中所有的 ActivityStack 的管理对象！1234567public ActivityStackSupervisor(ActivityManagerService service) &#123; mService = service; // 创建了一个 ActivityStackSupervisorHandler 的 Handler 对象！ mHandler = new ActivityStackSupervisorHandler(mService.mHandler.getLooper()); mActivityMetricsLogger = new ActivityMetricsLogger(this, mService.mContext); mResizeDockedStackTimeout = new ResizeDockedStackTimeout(service, this, mHandler);&#125; 1.1.2 new ActivityStarterActivityStarter 对象负责启动 activity：12345ActivityStarter(ActivityManagerService service, ActivityStackSupervisor supervisor) &#123; mService = service; mSupervisor = supervisor; mInterceptor = new ActivityStartInterceptor(mService, mSupervisor);&#125; 1.1.3 new RecentTasks创建最近任务管理对象！123456789RecentTasks(ActivityManagerService service, ActivityStackSupervisor mStackSupervisor) &#123; // 对应 /data/system 目录 File systemDir = Environment.getDataSystemDirectory(); mService = service; // 创建 TaskPersister 对象，用于管理那些重启后可恢复的任务！ mTaskPersister = new TaskPersister(systemDir, mStackSupervisor, service, this); // 将最近任务对象传递给 StackSupervisor！ mStackSupervisor.setRecentTasks(this);&#125; TaskPersister 对象用于管理那些重启后可恢复的任务，下面我们去看看： 1.1.3.1 new TaskPersister用于管理系统中所有的 persisable 类型的 task：12345678910111213141516171819202122232425262728TaskPersister(File systemDir, ActivityStackSupervisor stackSupervisor, ActivityManagerService service, RecentTasks recentTasks) &#123; // 删除目录：/data/system/recent_images 和其子目录！ final File legacyImagesDir = new File(systemDir, IMAGES_DIRNAME); if (legacyImagesDir.exists()) &#123; if (!FileUtils.deleteContents(legacyImagesDir) || !legacyImagesDir.delete()) &#123; Slog.i(TAG, \"Failure deleting legacy images directory: \" + legacyImagesDir); &#125; &#125; // 删除目录：/data/system/recent_tasks 和其子目录！ final File legacyTasksDir = new File(systemDir, TASKS_DIRNAME); if (legacyTasksDir.exists()) &#123; if (!FileUtils.deleteContents(legacyTasksDir) || !legacyTasksDir.delete()) &#123; Slog.i(TAG, \"Failure deleting legacy tasks directory: \" + legacyTasksDir); &#125; &#125; // 创建目录 ：/data/system_de，保存了 persisable 任务的 id； mTaskIdsDir = new File(Environment.getDataDirectory(), \"system_de\"); mStackSupervisor = stackSupervisor; mService = service; mRecentTasks = recentTasks; // 创建一个线程对象，用于写数据！ mLazyTaskWriterThread = new LazyTaskWriterThread(\"LazyTaskWriterThread\");&#125; 这里我来简单的说一下： 在 /data/system_de 目录下，会有一个以设备用户 id 命名的文件夹，内部会有一个名为 persisted_taskIds.txt 的文件，内部保存了所有的 persisable 类型的 task 的 id； 12345678lishuaiqi:/data/system_de # ls -aldrwxrwx--- 3 system system 4096 2017-08-10 08:58 0lishuaiqi:/data/system_de/0 # ls -al-rw------- 1 system system 28 2017-08-14 01:30 persisted_taskIds.txtlishuaiqi:/data/system_de/0 # cat persisted_taskIds.txt278279320 在 /data/system_de 目录下，会有一个以设备用户 id 命名的文件夹，内部会有两个文件夹：recent_images 和 recent_tasks： 123lishuaiqi:/data/system_ce/0 # ls -aldrwx------ 2 system system 4096 2017-08-14 01:30 recent_imagesdrwx------ 2 system system 4096 2017-08-14 01:31 recent_tasks 其中，recent_images 用来保存 task 的截图信息，文件名的格式为：[task_id]_task_thumbnail.png123lishuaiqi:/data/system_ce/0/recent_images # ls -al-rw------- 1 system system 68019 2017-08-14 01:30 326_task_thumbnail.png-rw------- 1 system system 18394 2017-08-14 01:30 327_task_thumbnail.png 其中，recent_tasks 用来保存 task 的信息，文件名的格式为：[task_id]_task.xml123lishuaiqi:/data/system_ce/0/recent_tasks # ls -al-rw------- 1 system system 1107 2017-08-14 16:58 279_task.xml-rw------- 1 system system 1116 2017-08-19 19:06 320_task.xml 下面我们来看看 [task_id]_task.xml 文件中有那些奇葩的属性，这里以腾讯微信为例子：12345678910111213141516171819202122232425262728293031323334353637&lt;task task_id=\"278\" real_activity=\"com.tencent.mm/.ui.LauncherUI\" real_activity_suspended=\"false\" affinity=\"com.tencent.mm\" root_has_reset=\"true\" auto_remove_recents=\"false\" asked_compat_mode=\"false\" user_id=\"0\" user_setup_complete=\"true\" effective_uid=\"10109\" task_type=\"0\" first_active_time=\"1502678072409\" last_active_time=\"1502678115558\" last_time_moved=\"1502678078477\" never_relinquish_identity=\"true\" task_description_color=\"ff212121\" task_description_colorBackground=\"fffafafa\" task_thumbnailinfo_task_width=\"1080\" task_thumbnailinfo_task_height=\"1920\" task_thumbnailinfo_screen_orientation=\"1\" task_affiliation_color=\"-14606047\" task_affiliation=\"278\" prev_affiliation=\"-1\" next_affiliation=\"-1\" calling_uid=\"10109\" calling_package=\"com.tencent.mm\" resize_mode=\"4\" privileged=\"false\" min_width=\"-1\" min_height=\"-1\"&gt; &lt;intent action=\"android.intent.action.MAIN\" component=\"com.tencent.mm/.ui.LauncherUI\" flags=\"10200000\"&gt; &lt;categories category=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent&gt;&lt;/task&gt; 可以看到，所有的 persisable 类型的 task，系统会将这些属性保存到对应的文件中，开机后可以恢复！ 1.2 onStart调用构造器，创建完 AMS 的对象之后，要做的就是启动 AMS 哦，在上一篇中，我们有看到，启动先调用 LifeCircle 的 onStart ，然后会调用了 AMS 的 start 方法：123456789101112131415private void start() &#123; // 移除所有的进程组！ Process.removeAllProcessGroups(); // 启动 ProcessCpuThread，监控 cpu 和电池的状态！ mProcessCpuThread.start(); // 将 BatteryStatsService 服务和 AppOpsService 注册到 ServiceManager 中，用于进程间通讯！ mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(\"AppOps\", \"AppOpsService published\"); // 将 AMS 添加进入 LocalServices 集合中，用于同一进程内的本地通信！ LocalServices.addService(ActivityManagerInternal.class, new LocalService());&#125; 这个方法很简单，就不多说了： 移除所有的进程组；并启动 ProcessCpuThread，监控 cpu 和电池的状态！ 将 BatteryStatsService 服务和 AppOpsService 注册到 ServiceManager 中，用于 Binder 通讯！ 1.3 initPowerManagement接下来，初始化 电池管理：12345678910111213public void initPowerManagement() &#123; // 初始化电池管理！ mStackSupervisor.initPowerManagement(); mBatteryStatsService.initPowerManagement(); mLocalPowerManager = LocalServices.getService(PowerManagerInternal.class); PowerManager pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE); // 获得 WakeLock！ mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"*voice*\"); mVoiceWakeLock.setReferenceCounted(false);&#125; 这里主要是进一步的初始化电池管理！ 1.4 setSystemProcess接下来，是设置 SytemServer 系统进程的相关信息，我们来看看代码，这里要仔细的来看了！123456789101112131415161718192021222324252627282930313233343536373839404142434445public void setSystemProcess() &#123; try &#123; //【1】注册一些系统相关的服务 ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(\"meminfo\", new MemBinder(this)); ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this)); ServiceManager.addService(\"dbinfo\", new DbBinder(this)); if (MONITOR_CPU_USAGE) &#123; ServiceManager.addService(\"cpuinfo\", new CpuBinder(this)); &#125; ServiceManager.addService(\"permission\", new PermissionController(this)); ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); // 从 PackageManagerService 中获取 framework-res.apk (包名为 android) 的 ApplicationInfo 信息! ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(\"android\", STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY); //【2】保存 framework-res.apk 的信息到系统进程的主线程中！ mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) &#123; // 初始化系统进程的 ProcessRecord ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; // 设置为常驻进程 app.pid = MY_PID; // 设置 pid app.maxAdj = ProcessList.SYSTEM_ADJ; // 设置系统进程的 adj 为 -900，很难被杀死哦！ // 使系统进程处于活跃状态 app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) &#123; // 将 systemServer 进程对象加入到 mPidsSelfLocked 中，以便管理！ mPidsSelfLocked.put(app.pid, app); &#125; // 更新最近使用进程列表 updateLruProcessLocked(app, false, null); // 用于更新进程的oom_adj值 updateOomAdjLocked(); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException(\"Unable to find android system package\", e); &#125;&#125; 上面代码中用到了 mPidsSelfLocked 变量，我们看下这个变量的定义：1final SparseArray&lt;ProcessRecord&gt; mPidsSelfLocked = new SparseArray&lt;ProcessRecord&gt;(); mPidsSelfLocked 保存有 pid 组织起来的正在运行的进程，保存的是 pid，及 pid 对应的 ProcessRecord。 这里我们来总结一下，这方法主要做了什么： 注册一些系统相关的服务，我们可以通过 adb shell dumpsys 命令查看！ 获取 framework-res.apk 安装包信息，保存到系统进程的 ActivityThread 对象中！ 创建 SystemServer 系统进程的进程结构体，初始化属性，将其加入 mPidsSelfLocked ，用于管理！ 更新进程的优先级和 oomAdj，这两个方法，我们后面单开一贴！！！ 下面我们仔细的看看一些细节，有利于我们对 AMS 的结构有一个更深层次的理解！ 1.4.1 ServiceManager.addService第一步，注册一些重要的服务，包括 ActivityManagerService 自身！1234567891011// 注册一些系统相关的服务ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);ServiceManager.addService(\"meminfo\", new MemBinder(this));ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this));ServiceManager.addService(\"dbinfo\", new DbBinder(this));if (MONITOR_CPU_USAGE) &#123; ServiceManager.addService(\"cpuinfo\", new CpuBinder(this));&#125;ServiceManager.addService(\"permission\", new PermissionController(this));ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); 这里注册了哪些服务呢？这里用到了几个静态变量： Context.ACTIVITY_SERVICE = “activity”;ProcessStats.SERVICE_NAME = “procstats”; 这里注册了那些服务呢，我们来看看： 服务名 类名 功能 procstats ProcessStatsService 监控进程信息的服务 cpuinfo CpuBinder 监控CPU信息的服务 meminfo MemBinder dump系统中每个进程的内存使用状况的服务 gfxinfo GraphicsBinder dump系统中每个进程使用图形加速卡状态的服务 dbinfo DbBinder dump 系统中每个进程的db状况的服务 permission PermissionController 是检查Binder调用权限的服务 processinfo ProcessInfoService 进程信息 这些服务我们先不细看，后面遇到了，再具体分析！ 1.4.2 处理 framework-res.apk接着，处理 framework-res.apk 安装包，在 PMS 的启动过程中，PackageManagerService 会扫描 framework-res.apk 的信息，并将信息封装成 ApplicaitonInfo 并保存在一个集合中：1mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); mSystemThread 对象是 ActvityThread 实例，每一个进程都有一个 ActivityThread 对象，内部保存着进程的主线程对象，这里保存着 SystemServer进程的主线程对象！ 我们继续看方法调用： 1.4.2.1 ActivityThread.installSystemApplicaitonInfo我们进入 ActivityThread 的 installSystemApplicationInfo 的方法：12345678public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; synchronized (this) &#123; //【1】调用 ContextImpl 对象的 installSystemApplicationInfo 方法！ getSystemContext().installSystemApplicationInfo(info, classLoader); mProfiler = new Profiler(); &#125;&#125; getSystemContext 方法获得的是系统进程的 Context 对象，Context 的具体实现是 ContextImpl 类！ 1.4.2.2 ContextImpl.installSystemApplicaitonInfo进入 ContextImpl 对象中：12345void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; //【1】调用 LoadedApk.installSystemApplicationInfo 方法； mPackageInfo.installSystemApplicationInfo(info, classLoader);&#125; 其中 mPackageInfo 是 LoadedApk 对象，这里的 LoadedApk 是属于 SystemServer 进程的： 1.4.2.3 LoadedAPK.installSystemApplicaitonInfo最后，将 framework-res.apk 的安装信息，保存到 SystemServer 进程的主线程的 LoadedAPK 对象中！12345void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; assert info.packageName.equals(\"android\"); mApplicationInfo = info; mClassLoader = classLoader;&#125; 每一个进程都会有一个 LoadedApk 对象，最后 ApplicationInfo 和 ClassLoader 设置到了 LoadedApk 对象中！ 1.4.3 newProcessRecordLocked接下来，创建系统进程对应的 ProcessRecord 对象，传入参数： info：&quot;framework-res.apk&quot; 的 ApplicationInfo 对象！ customProcess：info.processName，所在进程名！ isolated：传入 false，表示不是隔离进程！ isolatedUid：传入 0，表示隔离进程的 uid； isolated 和 isolatedUid 用来表示这进程是不是一个隔离进程！12345678910111213141516171819202122232425262728293031323334353637383940414243444546final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) &#123; String proc = customProcess != null ? customProcess : info.processName; BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics(); final int userId = UserHandle.getUserId(info.uid); // 获得所属的设备用户！ int uid = info.uid; if (isolated) &#123; // isolated 为 false, 不进入这个分支! if (isolatedUid == 0) &#123; int stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + 1; while (true) &#123; if (mNextIsolatedProcessUid &lt; Process.FIRST_ISOLATED_UID || mNextIsolatedProcessUid &gt; Process.LAST_ISOLATED_UID) &#123; mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID; &#125; uid = UserHandle.getUid(userId, mNextIsolatedProcessUid); mNextIsolatedProcessUid++; if (mIsolatedProcesses.indexOfKey(uid) &lt; 0) &#123; // No process for this uid, use it. break; &#125; stepsLeft--; if (stepsLeft &lt;= 0) &#123; return null; &#125; &#125; &#125; else &#123; // Special case for startIsolatedProcess (internal only), where // the uid of the isolated process is specified by the caller. uid = isolatedUid; &#125; &#125; //【1】创建 ProcessRecord，用于存储系统进程的信息 final ProcessRecord r = new ProcessRecord(stats, info, proc, uid); if (!mBooted &amp;&amp; !mBooting &amp;&amp; userId == UserHandle.USER_SYSTEM &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; r.persistent = true; &#125; //【2】保存系统进程 ProcessRecord 对象到 AMS 的结构体中！ addProcessNameLocked(r); return r;&#125; 接着，调用 addProcessNameLocked 方法： 1.4.3.1 addProcessNameLocked保存系统进程 ProcessRecord 对象到 AMS 的结构体中！12345678910111213141516171819202122232425262728293031323334private final void addProcessNameLocked(ProcessRecord proc) &#123; //【1】如果已经有了相同的 ProcessRecord 对象，移除旧的！ ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid); if (old == proc &amp;&amp; proc.persistent) &#123; Slog.w(TAG, \"Re-adding persistent process \" + proc); &#125; else if (old != null) &#123; Slog.wtf(TAG, \"Already have existing proc \" + old + \" when adding \" + proc); &#125; //【2】创建 UidRecord 用来保存活跃的 uid，如果已经存在，就不创建！ UidRecord uidRec = mActiveUids.get(proc.uid); if (uidRec == null) &#123; uidRec = new UidRecord(proc.uid); // This is the first appearance of the uid, report it now! if (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS, \"Creating new process uid: \" + uidRec); // 添加到 mActiveUids 对象！ mActiveUids.put(proc.uid, uidRec); noteUidProcessState(uidRec.uid, uidRec.curProcState); enqueueUidChangeLocked(uidRec, -1, UidRecord.CHANGE_ACTIVE); &#125; proc.uidRecord = uidRec; uidRec.numProcs++; // 所属该 uid 的进程计数加 1 （uid 代表一个应用程序） //【3】非隔离进程保存到 mProcessNames 集合中，隔离进程保存到 mIsolatedProcesses 中！ mProcessNames.put(proc.processName, proc.uid, proc); if (proc.isolated) &#123; mIsolatedProcesses.put(proc.uid, proc); &#125;&#125; 1.4.4 ProcessRecord.makeActive参数传递： thread：mSystemThread.getApplicationThread()，系统进程的 ApplicationThread 对象！ tracker：mProcessStats，是 ProcessStatsService 服务对象，用来监听进程的状态！ 12345678910111213141516171819202122232425262728293031323334 public void makeActive(IApplicationThread _thread, ProcessStatsService tracker) &#123; // 第一次进来，为null！ if (thread == null) &#123; //【1】将旧的 ProcessState 对象设置为非活跃状态！ final ProcessState origBase = baseProcessTracker; if (origBase != null) &#123; origBase.setState(ProcessStats.STATE_NOTHING, tracker.getMemFactorLocked(), SystemClock.uptimeMillis(), pkgList); origBase.makeInactive(); &#125; // 为系统进程创建新的 ProcessState 监听对象，并设置其为活跃状态！ // info 为改应用程序所属的应用程序！ baseProcessTracker = tracker.getProcessStateLocked(info.packageName, uid, info.versionCode, processName); baseProcessTracker.makeActive(); for (int i=0; i&lt;pkgList.size(); i++) &#123; ProcessStats.ProcessStateHolder holder = pkgList.valueAt(i); if (holder.state != null &amp;&amp; holder.state != origBase) &#123; holder.state.makeInactive(); &#125; holder.state = tracker.getProcessStateLocked(pkgList.keyAt(i), uid, info.versionCode, processName); if (holder.state != baseProcessTracker) &#123; holder.state.makeActive(); &#125; &#125; &#125; //【2】将系统进程的 ActivityThread 保存到 ProcessRecord.thread，完成引用关系！ thread = _thread;&#125; 以上是在 SystemServer 启动系统服务的第一阶段做的一些主要的工作，接下来，我们来看第二阶段！ 2 第二阶段 - startCoreServices接下来，看看第二阶段的代码段：123456789101112private void startCoreServices() &#123; // 启动电池服务,必须是在 lightService 后启动 ； mSystemServiceManager.startService(BatteryService.class); //【1】启动应用统计服务，用于监控应用的使用频率等信息，并使得 AMS 持有其引用！ mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); // 启动 WebView 更新服务，这里不关注！ mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);&#125; 这里我们看看 setUsageStatsManager 2.1 setUsageStatsManager123public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) &#123; mUsageStatsService = usageStatsManager;&#125; 这个方法主要的作用是： 设置应用统计服务的应用，用于监控应用的使用频率等信息！ 3 第三阶段 - startOtherServices这里就要进入开机的最后阶段了，startOtherServices 方法非常的长，这里只列举和 ams 相关的代码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106private void startOtherServices() &#123; try &#123; ... ... ... ... //【1】安装系统进程的 provider！ traceBeginAndSlog(\"InstallSystemProviders\"); mActivityManagerService.installSystemProviders(); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); ... ... ... ... // 初始化 watch dog 实例！ traceBeginAndSlog(\"InitWatchdog\"); final Watchdog watchdog = Watchdog.getInstance(); watchdog.init(context, mActivityManagerService); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); // 启动 InputManagerService 和 WindowManagerService 服务！ traceBeginAndSlog(\"StartInputManagerService\"); inputManager = new InputManagerService(context); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); traceBeginAndSlog(\"StartWindowManagerService\"); wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore); ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); ... ... ... ... //【2】将 WMS 的引用实例保存到 ams 中！ mActivityManagerService.setWindowManager(wm); inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start(); ... ... ... ... &#125; catch (RuntimeException e) &#123; Slog.e(\"System\", \"******************************************\"); Slog.e(\"System\", \"************ Failure starting core service\", e); &#125; ... ... ... ... try &#123; wm.displayReady(); &#125; catch (Throwable e) &#123; reportWtf(\"making display ready\", e); &#125; ... ... ... ... try &#123; wm.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(\"making Window Manager Service ready\", e); &#125; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); if (safeMode) &#123; mActivityManagerService.showSafeModeOverlay(); &#125; // 更新显示相关的配置！ Configuration config = wm.computeNewConfiguration(); DisplayMetrics metrics = new DisplayMetrics(); WindowManager w = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); w.getDefaultDisplay().getMetrics(metrics); context.getResources().updateConfiguration(config, metrics); // 重置系统主题，因为可能依赖显示配置！ final Theme systemTheme = context.getTheme(); if (systemTheme.getChangingConfigurations() != 0) &#123; systemTheme.rebase(); &#125; ... ... ... ... //【3】进入 AMS 的 systemReady 方法，Runnable 任务中只要是启动一些其他的服务，这里我就省略了！ mActivityManagerService.systemReady(new Runnable() &#123; @Override public void run() &#123; Slog.i(TAG, \"Making services ready\"); ... ... ... ... try &#123; // 开始监听 native crash！ mActivityManagerService.startObservingNativeCrashes(); &#125; catch (Throwable e) &#123; reportWtf(\"observing native crashes\", e); &#125; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); ... ... ... ... // 启动 watch dog！ Watchdog.getInstance().start(); ... ... ... ... &#125; &#125;);&#125; 3.1 AMS.installSystemProviders安装系统数据库：1234567891011121314151617181920212223242526272829303132333435public final void installSystemProviders() &#123; List&lt;ProviderInfo&gt; providers; synchronized (this) &#123; //【1】获取系统进程的 ProcessRecord, 之前 setSystemProcess() 时，创建了系统进程对应的 ProcessRecord ProcessRecord app = mProcessNames.get(\"system\", Process.SYSTEM_UID); //【2】生成 ProviderInfo 的列表！ providers = generateApplicationProvidersLocked(app); if (providers != null) &#123; for (int i=providers.size()-1; i&gt;=0; i--) &#123; ProviderInfo pi = (ProviderInfo)providers.get(i); if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; Slog.w(TAG, \"Not installing system proc provider \" + pi.name + \": not system .apk\"); //【2.1】移除一些非系统的 provider！ providers.remove(i); &#125; &#125; &#125; &#125; if (providers != null) &#123; //【3】调用系统进程的 ActivityThread 的 installSystemProviders 方法，安装系统进程的数据库！ mSystemThread.installSystemProviders(providers); &#125; mCoreSettingsObserver = new CoreSettingsObserver(this); mFontScaleSettingObserver = new FontScaleSettingObserver(); //mUsageStatsService.monitorPackages();&#125; 这里指定了进程名为 system，进程 uid 为 Process.SYSTEM_UID，一般来说，会有以下 Provider 会出现在返回结果中： framework-res.apk 中的 Provider, 定义在：frameworks/base/core/res/AndroidManifest.xml SettingsProvider.apk 中的 Provider, 定义在：frameworks/base/packages/SettingsProvider/AndroidManifest.xml 对于手机厂商，可以对系统 apk 进行定制，比如让系统 apk 共享系统 uid，这样的话，就不止以上两种 provider 了！ 3.1.1 AMS.generateApplicationProvidersLocked参数传递： ProcessRecord app：系统进程的 ProcessRecord 对象！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private final List&lt;ProviderInfo&gt; generateApplicationProvidersLocked(ProcessRecord app) &#123; List&lt;ProviderInfo&gt; providers = null; try &#123; //【1】通过 PackageManagerService 获得系统进程的 provider！ providers = AppGlobals.getPackageManager() .queryContentProviders(app.processName, app.uid, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS | MATCH_DEBUG_TRIAGED_MISSING) .getList(); &#125; catch (RemoteException ex) &#123; &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"generateApplicationProvidersLocked, app.info.uid = \" + app.uid); //【2】将 Provider 和 ProcessRecord 绑定！ int userId = app.userId; if (providers != null) &#123; int N = providers.size(); //【2.1】确保 ProcessRecord 中的 Provider 映射表的容量！ app.pubProviders.ensureCapacity(N + app.pubProviders.size()); // 遍历 ProviderInfo 列表 for (int i=0; i&lt;N; i++) &#123; ProviderInfo cpi = (ProviderInfo) providers.get(i); // 判断是否是单例模式！ boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags); // 如果是单例模式的 provider，且其 uid 不是 system，跳过该 provider！ if (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123; providers.remove(i); N--; i--; continue; &#125; //【2.2】如果 mProviderMap 中不存在 ContentProviderRecord 对象，则新建一个！ ComponentName comp = new ComponentName(cpi.packageName, cpi.name); ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId); if (cpr == null) &#123; cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton); //【2.3】添加到 AMS.mProciderMap 管理集合中； mProviderMap.putProviderByClass(comp, cpr); &#125; if (DEBUG_MU) Slog.v(TAG_MU, \"generateApplicationProvidersLocked, cpi.uid = \" + cpr.uid); //【2.4】将当前的 provider 保存到系统进程的 ProcessRecord 的 pubProviders 中； app.pubProviders.put(cpi.name, cpr); if (!cpi.multiprocess || !\"android\".equals(cpi.packageName)) &#123; app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, mProcessStats); &#125; notifyPackageUse(cpi.applicationInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER); &#125; &#125; return providers;&#125; 我们通过一张类图，简单的了解一下 AMS 是如何管理 ContentProvider 的： AMS 为每一个 ContentProvider 创建了一个 ContentProviderRecord 对象，ContentProviderRecord 中保存着 provider 的配置信息 providerInfo；provider 所属进程的 uid；provider 所属应用的 ApplicaitonInfo 对象！ AMS 的 mProviderMap 对象管理着系统中所有的 ContentProviderRecord 对象，其内部保存着 Authority 或者 CompnentName 到指定 ContentProviderRecord 的映射！ AMS 内部还维护着和 ProcessRecord 相关的集合，用于管理进程，有前台进程集合，内存常驻进程集合，最近使用的进程等等，当 AMS 将一个 ContentProviderRecord 与 ProcessRecord 关联时，会将它保存到 ProcessRecord 内部的一个 pubProviders 集合中！ 3.1.2 ActivityThread.installSystemProviders接着调用 systemserver 进程的 ActivityThread 的 installSystemProvider 方法：1234567public final void installSystemProviders(List&lt;ProviderInfo&gt; providers) &#123; if (providers != null) &#123; //【1】mInitialApplication 是 SystemServer 的进程的 Application 对象！ installContentProviders(mInitialApplication, providers); &#125;&#125; 这里的 mInitialApplication 是系统进程的 Application 对象，接着调用了 installContentProviders 方法！ 3.1.3 ActivityThread.installContentProviders1234567891011121314151617181920212223242526272829303132333435private void installContentProviders(Context context, List&lt;ProviderInfo&gt; providers) &#123; final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results = new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;(); //【1】遍历系统进程的所有 provider，为每一个 provider 创建对应的 ContentProviderHolder 对象！ for (ProviderInfo cpi : providers) &#123; if (DEBUG_PROVIDER) &#123; StringBuilder buf = new StringBuilder(128); buf.append(\"Pub \"); buf.append(cpi.authority); buf.append(\": \"); buf.append(cpi.name); Log.i(TAG, buf.toString()); &#125; //【1.1】将每一个 ProviderInfo 封装为一个 ContentProviderHolder 对象！ IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi, false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/); if (cph != null) &#123; cph.noReleaseNeeded = true; // 添加到集合中！ results.add(cph); &#125; &#125; try &#123; //【2】调用 AMS 的 publish 方法， 注册 ContentProvider ActivityManagerNative.getDefault().publishContentProviders( getApplicationThread(), results); &#125; catch (RemoteException ex) &#123; &#125;&#125; 所有 ContentProvider 的创建都需要经过 installContentProvider() 函数，这个地方调用了 ActivityThread.installProvider 方法，继续安装 provider! 3.1.3.1 ActivityThread.installProvider让我们来继续看看这部分的代码 installProvider，参数传递： Context context：传入 context 对象，这里的 context 是 mInitialApplication 对象，是系统进程的上下文运行环境； IActivityManager.ContentProviderHolder holder：传入 null； ProviderInfo info：传入 ProviderInfo 对象，封装着 provider 的信息； boolean noisy：传入 false； boolean noReleaseNeeded：传入 true； boolean stable：传入 true； 接着来看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143private IActivityManager.ContentProviderHolder installProvider(Context context, IActivityManager.ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; IContentProvider provider; if (holder == null || holder.provider == null) &#123; // 进入这个分支! if (DEBUG_PROVIDER || noisy) &#123; Slog.d(TAG, \"Loading provider \" + info.authority + \": \" + info.name); &#125; Context c = null; ApplicationInfo ai = info.applicationInfo; //【1】通过包名，找到和 provider 匹配的 context！ // 如果当前已有的运行环境 Context 不匹配的话，就会创建一个新的 Context！ if (context.getPackageName().equals(ai.packageName)) &#123; c = context; &#125; else if (mInitialApplication != null &amp;&amp; mInitialApplication.getPackageName().equals(ai.packageName)) &#123; c = mInitialApplication; &#125; else &#123; try &#123; c = context.createPackageContext(ai.packageName, Context.CONTEXT_INCLUDE_CODE); &#125; catch (PackageManager.NameNotFoundException e) &#123; // Ignore &#125; &#125; if (c == null) &#123; Slog.w(TAG, \"Unable to get context for package \" + ai.packageName + \" while loading content provider \" + info.name); return null; &#125; //【2】根据包名，通过反射创建新的 ContentProvider 对象！ try &#123; final java.lang.ClassLoader cl = c.getClassLoader(); localProvider = (ContentProvider)cl. loadClass(info.name).newInstance(); provider = localProvider.getIContentProvider(); if (provider == null) &#123; Slog.e(TAG, \"Failed to instantiate class \" + info.name + \" from sourceDir \" + info.applicationInfo.sourceDir); return null; &#125; if (DEBUG_PROVIDER) Slog.v( TAG, \"Instantiating local provider \" + info.name); //【2.1】将创建的 provider 和 providerInfo 数据进行绑定； // 这个方法对 provider 会做初始化， localProvider.attachInfo(c, info); &#125; catch (java.lang.Exception e) &#123; if (!mInstrumentation.onException(null, e)) &#123; throw new RuntimeException( \"Unable to get provider \" + info.name + \": \" + e.toString(), e); &#125; return null; &#125; &#125; else &#123; provider = holder.provider; if (DEBUG_PROVIDER) Slog.v(TAG, \"Installing external provider \" + info.authority + \": \" + info.name); &#125; //【3】设置对应的 ContentProviderHolder 对象！ IActivityManager.ContentProviderHolder retHolder; synchronized (mProviderMap) &#123; if (DEBUG_PROVIDER) Slog.v(TAG, \"Checking to add \" + provider + \" / \" + info.name); IBinder jBinder = provider.asBinder(); if (localProvider != null) &#123; ComponentName cname = new ComponentName(info.packageName, info.name); // 尝试获得对应的 ProviderClientRecord 对象！ ProviderClientRecord pr = mLocalProvidersByName.get(cname); if (pr != null) &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"installProvider: lost the race, \" + \"using existing local provider\"); &#125; provider = pr.mProvider; &#125; else &#123; // 创建一个新的 ContentProviderHolder 对象! holder = new IActivityManager.ContentProviderHolder(info); holder.provider = provider; holder.noReleaseNeeded = true; // 创建一个新的 ProviderClientRecord 对象，并将映射关系保存起来！ pr = installProviderAuthoritiesLocked(provider, localProvider, holder); mLocalProviders.put(jBinder, pr); mLocalProvidersByName.put(cname, pr); &#125; retHolder = pr.mHolder; &#125; else &#123; ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; if (DEBUG_PROVIDER) &#123; Slog.v(TAG, \"installProvider: lost the race, updating ref count\"); &#125; if (!noReleaseNeeded) &#123; incProviderRefLocked(prc, stable); try &#123; ActivityManagerNative.getDefault().removeContentProvider( holder.connection, stable); &#125; catch (RemoteException e) &#123; // do nothing content provider object is dead any way &#125; &#125; &#125; else &#123; ProviderClientRecord client = installProviderAuthoritiesLocked( provider, localProvider, holder); if (noReleaseNeeded) &#123; prc = new ProviderRefCount(holder, client, 1000, 1000); &#125; else &#123; prc = stable ? new ProviderRefCount(holder, client, 1, 0) : new ProviderRefCount(holder, client, 0, 1); &#125; mProviderRefCountMap.put(jBinder, prc); &#125; retHolder = prc.holder; &#125; &#125; return retHolder;&#125; 首先，找到 ProviderInfo 对应的运行环境 Context： 对于 framework-res.apk 中定义的 com.android.server.am.DumpHeapProvider 而言，重新设置的 Context 就是 mInitialApplication，所以就直接使用； 对于 SettingProvider.apk 中定义的 SettingsProvider 而言，它的包名为 com.android.providers.settings，不等于 mInitialApplication 的包名 android，所以，会通过 Context.createPackageContext() 函数创建一个新的 Context 实例！ 接着，反射创建 ContentProvider 对象，然后，根据反射对象 ContentProvider，创建对应的 ContentProviderHolder 对象！ 3.1.3.2 AactivityManagerN.publishContentProviders最终会调用 ActivityManagerService 中的 publishContentProviders 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public final void publishContentProviders(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers) &#123; if (providers == null) &#123; return; &#125; enforceNotIsolatedCaller(\"publishContentProviders\"); synchronized (this) &#123; //【1】获得调用者所在进程的 ProcessRecord 对象！ final ProcessRecord r = getRecordForAppLocked(caller); if (DEBUG_MU) Slog.v(TAG_MU, \"ProcessRecord uid = \" + r.uid); if (r == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when publishing content providers\"); &#125; final long origId = Binder.clearCallingIdentity(); //【2】遍历传入的 ContentProviderHolder 集合！ final int N = providers.size(); for (int i = 0; i &lt; N; i++) &#123; ContentProviderHolder src = providers.get(i); if (src == null || src.info == null || src.provider == null) &#123; continue; &#125; // 从 ProcessRecord 中获得其对应的 ContentProviderRecord 对象！ ContentProviderRecord dst = r.pubProviders.get(src.info.name); if (DEBUG_MU) Slog.v(TAG_MU, \"ContentProviderRecord uid = \" + dst.uid); if (dst != null) &#123; ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name); // 将其保存到 AMS 的 mProviderMap 中！ mProviderMap.putProviderByClass(comp, dst); String names[] = dst.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; mProviderMap.putProviderByName(names[j], dst); &#125; int launchingCount = mLaunchingProviders.size(); int j; boolean wasInLaunchingProviders = false; for (j = 0; j &lt; launchingCount; j++) &#123; if (mLaunchingProviders.get(j) == dst) &#123; // 从正在启动的 provider 列表中删除！ mLaunchingProviders.remove(j); wasInLaunchingProviders = true; j--; launchingCount--; &#125; &#125; if (wasInLaunchingProviders) &#123; mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r); &#125; synchronized (dst) &#123; dst.provider = src.provider; dst.proc = r; dst.notifyAll(); &#125; // 更新 ommAdj 值，用于 LMK！ updateOomAdjLocked(r); // 更新 provider 的使用状态！ maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125; 关于 ContentProvider 的实现原理，我后续会有对应的博文分析，这里就不多说了！ 3.1.3 阶段总结我们总结一下： 首先，获得系统进程的 providerInfo 列表！ 通过 PMS，获得系统进程的 providerInfo 列表； 确保系统进程 ProcessRecord 有足够的空间存储 ContentProvider； 然后，对找到的 ProviderInfo 列表进行遍历, 如有需要, 则新建一个 ContentProviderRecord 对象, 将其添加到 AMS.mProviderMap 中以方便管理；同时, 也需要将其添加到 PrcoessRecord.mPubProviders 中。 最后返回 providerInfo 列表； 将 provider 注册到系统进程！ 3.2 ActivityManagerS.setWindowManager接着是就是设置 wms 的引用对象！123456789101112131415161718192021222324252627282930313233void setWindowManager(WindowManagerService wm) &#123; synchronized (mService) &#123; //【1】设置 wms 引用实例 mWindowManager = wm; //【2】获得 dms 的引用实力，并将 ams 注册进入 dms！ mDisplayManager = (DisplayManager)mService.mContext.getSystemService(Context.DISPLAY_SERVICE); mDisplayManager.registerDisplayListener(this, null); //【3】通过 dms 获得是当前安卓设备所有有效的逻辑显示器列表！ Display[] displays = mDisplayManager.getDisplays(); for (int displayNdx = displays.length - 1; displayNdx &gt;= 0; --displayNdx) &#123; final int displayId = displays[displayNdx].getDisplayId(); // 为每一个显示器创建一个 ActivityDisplay 对象，存储该显示器的信息； ActivityDisplay activityDisplay = new ActivityDisplay(displayId); if (activityDisplay.mDisplay == null) &#123; throw new IllegalStateException(\"Default Display does not exist\"); &#125; //【3.1】将其保存到 ams 的 mActivityDisplays 集合中，后续会用到！ mActivityDisplays.put(displayId, activityDisplay); calculateDefaultMinimalSizeOfResizeableTasks(activityDisplay); &#125; //【4】初始化 mHomeStack，mFocusedStack 和 mLastFocusedStack 这三个 stack！ mHomeStack = mFocusedStack = mLastFocusedStack = getStack(HOME_STACK_ID, CREATE_IF_NEEDED, ON_TOP); //【5】通过本地服务过得 ims 的调用接口； mInputManagerInternal = LocalServices.getService(InputManagerInternal.class); &#125;&#125; 这个方法逻辑很简单！这里重点看一下，在系统启动的时候，会初始化 mFocusedStack 和 mLastFocusedStack 为 HOME_STACK_ID 类型的 stack，这个是显而易见的，因为开机后，就会进入桌面，此时焦点 stack 一定是 home stack! 3.2.1 ActivityStackSupervisor.getStack该方法的作用是返回一个可用的 stack，createStaticStackIfNeeded 表示有必要的话是否创建一个静态 stack！ 12345678910111213141516ActivityStack getStack(int stackId, boolean createStaticStackIfNeeded, boolean createOnTop) &#123; //【1】获得 stackId 对应的 ActivityContainer 如果其不为 null，返回其内部的 Stack！ ActivityContainer activityContainer = mActivityContainers.get(stackId); if (activityContainer != null) &#123; return activityContainer.mStack; &#125; //【2】如果不能通过 ActivityContainer 来获得想要的 statck 话，就先判断是否需要创建一个 stack // 不需要创建一个新的 stack 或者 stack id 不是静态的，那就不能创建，返回一个空的 stack！ if (!createStaticStackIfNeeded || !StackId.isStaticStack(stackId)) &#123; return null; &#125; //【3】创建一个 stack，这里的 Display.DEFAULT_DISPLAY 对应的是默认的显示器 ！ return createStackOnDisplay(stackId, Display.DEFAULT_DISPLAY, createOnTop);&#125; 这里我们知道，在刚开机的时候，是没有任何的 ActivityContainer 的，所以这里会进入 createStackOnDisplay 方法中继续创建！ 3.2.2 ActivityStackSupervisor.createStackOnDisplay1234567891011121314151617ActivityStack createStackOnDisplay(int stackId, int displayId, boolean onTop) &#123; //【1】获得 displayId 对应的逻辑显示器的 ActivityDisplay 对象！ ActivityDisplay activityDisplay = mActivityDisplays.get(displayId); if (activityDisplay == null) &#123; // 这里显然不会进入！ return null; &#125; //【2】根据 stackId 创建了一个 ActivityContainer 对象爱！ ActivityContainer activityContainer = new ActivityContainer(stackId); //【3】将其加入到 mActivityContainers 中！ mActivityContainers.put(stackId, activityContainer); //【4】将 activityContainer 绑定到对应的显示器对象 activityDisplay 中！ activityContainer.attachToDisplayLocked(activityDisplay, onTop); return activityContainer.mStack;&#125; 这里其实很简单，针对于指定的显示器 ActivityDisplay，创建对应的 ActivityContainer，然后 ActivityContainer 内部再去创建 ActivityStack! 3.2.2.1 new ActivityContainer我们来去看看 ActivityContainer 的创建： 12345678910111213141516171819202122232425262728293031323334353637class ActivityContainer extends android.app.IActivityContainer.Stub &#123; final static int FORCE_NEW_TASK_FLAGS = FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION; final int mStackId; // stack 的 id！ IActivityContainerCallback mCallback = null; final ActivityStack mStack; // 对应的 ActivityStack 对象！ ActivityRecord mParentActivity = null; // 父亲 activity！ String mIdString; boolean mVisible = true; // 是否是可见的，默认为 true！ // 其所绑定到的 ActivityDisplay 对象，不为 null 说明绑定到了一个逻辑显示器， // 这样该 stack 中的 activity 就可以被显示出来！ ActivityDisplay mActivityDisplay; final static int CONTAINER_STATE_HAS_SURFACE = 0; final static int CONTAINER_STATE_NO_SURFACE = 1; final static int CONTAINER_STATE_FINISHING = 2; // container 的状态，取值有 3 种！ int mContainerState = CONTAINER_STATE_HAS_SURFACE; ActivityContainer(int stackId) &#123; synchronized (mService) &#123; mStackId = stackId; //【1】创建一个 ActivityStack mStack = new ActivityStack(this, mRecentTasks); mIdString = \"ActivtyContainer&#123;\" + mStackId + \"&#125;\"; if (DEBUG_STACK) Slog.d(TAG_STACK, \"Creating \" + this); &#125; &#125; ... ... ... &#125; 我们再去看看 ActivityStack 的创建： 3.2.2.2.1 new ActivityStack123456789101112131415161718ActivityStack(ActivityStackSupervisor.ActivityContainer activityContainer, RecentTasks recentTasks) &#123; //【1】设置 ActivityContainer 引用关系； mActivityContainer = activityContainer; // ActivityContainer 是 ActivityStackSupervisor 内部类，这里是通过 getOuter 获得外部类的实例； mStackSupervisor = activityContainer.getOuter(); mService = mStackSupervisor.mService; // ams 的引用实例； //【2】创建 ActivityStackHandler 用于处理 activity 的周期变化； mHandler = new ActivityStackHandler(mService.mHandler.getLooper()); mWindowManager = mService.mWindowManager; // wms 实例，不多说了； mStackId = activityContainer.mStackId; // stack id； mCurrentUser = mService.mUserController.getCurrentUserIdLocked(); // 当前的设备用户对象； mRecentTasks = recentTasks; // 最近任务； // 如果 stack id 为 FREEFORM_WORKSPACE_STACK_ID，才会创建对应实例，安卓手机默认是为 null mTaskPositioner = mStackId == FREEFORM_WORKSPACE_STACK_ID ? new LaunchingTaskPositioner() : null; &#125; 这里就不多说了！ 3.2.2.2 ActivityContainer.attachToDisplayLocked接下来就是很关键的一部，就是将 ActivityContainer 绑定到指定的 ActivityDisplay 对象上！ 123456789void attachToDisplayLocked(ActivityDisplay activityDisplay, boolean onTop) &#123; if (DEBUG_STACK) Slog.d(TAG_STACK, \"attachToDisplayLocked: \" + this + \" to display=\" + activityDisplay + \" onTop=\" + onTop); //【1】设置 mActivityDisplay 引用关系！ mActivityDisplay = activityDisplay; // mStack.attachDisplay(activityDisplay, onTop); activityDisplay.attachActivities(mStack, onTop);&#125; 3.2.2.2.1 ActivityStack.attachDisplay1234567891011121314151617void attachDisplay(ActivityStackSupervisor.ActivityDisplay activityDisplay, boolean onTop) &#123; mDisplayId = activityDisplay.mDisplayId; mStacks = activityDisplay.mStacks; mBounds = mWindowManager.attachStack(mStackId, activityDisplay.mDisplayId, onTop); mFullscreen = mBounds == null; if (mTaskPositioner != null) &#123; mTaskPositioner.setDisplay(activityDisplay.mDisplay); mTaskPositioner.configure(mBounds); &#125; if (mStackId == DOCKED_STACK_ID) &#123; // If we created a docked stack we want to resize it so it resizes all other stacks // in the system. mStackSupervisor.resizeDockedStackLocked( mBounds, null, null, null, null, PRESERVE_WINDOWS); &#125;&#125; 3.2.2.2.2 ActivityDisplay.attachActivities12345678910void attachActivities(ActivityStack stack, boolean onTop) &#123; if (DEBUG_STACK) Slog.v(TAG_STACK, \"attachActivities: attaching \" + stack + \" to displayId=\" + mDisplayId + \" onTop=\" + onTop); if (onTop) &#123; mStacks.add(stack); &#125; else &#123; mStacks.add(0, stack); &#125;&#125; 其实，整个过程就是创建容器，建立引用关系的过程，通过分析，我们知道，安卓系统的所有的 stack 的创建都是这样的！！ 3.3 ActivityManagerS.systemReadySystemServer 在启动完所有服务之后，将调用 AMS 的 systemReady() 方法。这个方法是 Android 进入用户交互阶段前最后进行的准备工作。这里就即将进入开机的最后阶段了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public void systemReady(final Runnable goingCallback) &#123; synchronized(this) &#123; //【3.3.1】最开始是不会进入这个分支的，即 mSystemReady 为 false，但是由于 systemReady 会被调用多次 // 后续 mSystemReady 会被置为 true，这样执行 goingCallback 后就会退出了！ if (mSystemReady) &#123; if (goingCallback != null) &#123; goingCallback.run(); &#125; return; &#125; mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class); // 通知 UserController、RecentTask 和 AppOpsService 服务，系统已经准备好了！ mUserController.onSystemReady(); mRecentTasks.onSystemReadyLocked(); mAppOpsService.systemReady(); //【2】mSystemReady 置为 true，表示系统进程已经准备完毕了！ mSystemReady = true; &#125; //【3.3.2】遍历 mPidsSelfLocked，找到已经启动但是没有带有 FLAG_PERSISTENT 标记的非 persistent 应用进程； // 然后杀掉它们，目的是在启动 Home 前准备一个干净的环境！ ArrayList&lt;ProcessRecord&gt; procsToKill = null; synchronized(mPidsSelfLocked) &#123; for (int i=mPidsSelfLocked.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = mPidsSelfLocked.valueAt(i); if (!isAllowedWhileBooting(proc.info))&#123; if (procsToKill == null) &#123; procsToKill = new ArrayList&lt;ProcessRecord&gt;(); &#125; procsToKill.add(proc); &#125; &#125; &#125; synchronized(this) &#123; if (procsToKill != null) &#123; for (int i=procsToKill.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = procsToKill.get(i); Slog.i(TAG, \"Removing system update proc: \" + proc); removeProcessLocked(proc, true, false, \"system update done\"); &#125; &#125; //【3.1】表示系统进程已经准备完毕，可以启动其他进程了！ mProcessesReady = true; &#125; Slog.i(TAG, \"System now ready\"); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis()); synchronized(this) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; ... ... ... ...// 测试模式，非正常情况，先不看！ &#125; &#125; //【3.3.3】读取设置信息！ retrieveSettings(); final int currentUserId; synchronized (this) &#123; // 获得当前设备用户 id！ currentUserId = mUserController.getCurrentUserIdLocked(); //【3.3.4】从 /data/system/urigrants.xml 文件中读取 Uri 相关的权限信息！ readGrantedUriPermissionsLocked(); &#125; //【5】执行传入的 callback 回调，主要是启动其他服务等等！ if (goingCallback != null) goingCallback.run(); mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(currentUserId), currentUserId); mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(currentUserId), currentUserId); // 启动当前的设备用户！ mSystemServiceManager.startUser(currentUserId); synchronized (this) &#123; //【3.3.5】启动那些 peristent 应用进程! startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); // Start up initial activity. mBooting = true; if (UserManager.isSplitSystemUser()) &#123; ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class); try &#123; AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; &#125; //【3.3.6】启动桌面 activity！ startHomeActivityLocked(currentUserId, \"systemReady\"); try &#123; if (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123; Slog.e(TAG, \"UIDs on the system are inconsistent, you need to wipe your\" + \" data partition or your device will be unstable.\"); mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget(); &#125; &#125; catch (RemoteException e) &#123; &#125; if (!Build.isBuildConsistent()) &#123; Slog.e(TAG, \"Build fingerprint is not consistent, warning user\"); mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_UI_MSG).sendToTarget(); &#125; long ident = Binder.clearCallingIdentity(); try &#123; // 发送 ACTION_USER_STARTED 广播！ Intent intent = new Intent(Intent.ACTION_USER_STARTED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, currentUserId); // 发送 ACTION_USER_STARTING 广播！ intent = new Intent(Intent.ACTION_USER_STARTING); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId); broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() &#123; @Override public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; &#125; &#125;, 0, null, null, new String[] &#123;INTERACT_ACROSS_USERS&#125;, AppOpsManager.OP_NONE, null, true, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL); &#125; catch (Throwable t) &#123; Slog.wtf(TAG, \"Failed sending first user broadcasts\", t); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; //【8】此时的桌面已经是 top activity，设置桌面 activity 为 resumed 状态！ mStackSupervisor.resumeFocusedStackTopActivityLocked(); // 发送设备用户已经切换的广播； mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId); &#125;&#125; 这里的代码逻辑比较复杂，里面有一些关键的点，我们来看看： 3.3.1 通知其他服务 - SystemReady代码如下：1234mUserController.onSystemReady();mRecentTasks.onSystemReadyLocked();mAppOpsService.systemReady();mSystemReady = true; 我们一个一个来看： 3.3.1.1 UserController.onSystemReady123void onSystemReady() &#123; updateCurrentProfileIdsLocked();&#125; 调用了 updateCurrentProfileIdsLocked：1234567891011121314151617181920212223private void updateCurrentProfileIdsLocked() &#123; final List&lt;UserInfo&gt; profiles = getUserManager().getProfiles(mCurrentUserId, false /* enabledOnly */); int[] currentProfileIds = new int[profiles.size()]; // profiles will not be null for (int i = 0; i &lt; currentProfileIds.length; i++) &#123; currentProfileIds[i] = profiles.get(i).id; &#125; mCurrentProfileIds = currentProfileIds; synchronized (mUserProfileGroupIdsSelfLocked) &#123; mUserProfileGroupIdsSelfLocked.clear(); final List&lt;UserInfo&gt; users = getUserManager().getUsers(false); // 保存所有设备用户的信息，用于以后权限校验使用！ for (int i = 0; i &lt; users.size(); i++) &#123; UserInfo user = users.get(i); if (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID) &#123; // 保存在这里！ mUserProfileGroupIdsSelfLocked.put(user.id, user.profileGroupId); &#125; &#125; &#125;&#125; 这个方法的作用是：Android 的许多系统调用都需要检查用户的 ID，所以这里调用 updateCurrnetProfileIdsLocked() 方法来通过 UserManagerService 读取系统保持的 Profile 信息，装载系统中已经存在的用户信息。 3.3.1.2 RecentTasks.onSystemReady代码如下：1234void onSystemReadyLocked() &#123; clear(); mTaskPersister.startPersisting();&#125; 从 Android5.0 开始支持带有 persistent 标记的 task，这些 task 在关机时，信息保存在 /data/system_ce/recent_tasks 目录下的 xxx_task.xml（xxx 表示 task id）中，系统重启时，通过这些文件中保存的信息重建 task，和 JobSchedulerService 很类似哦！ 12345void startPersisting() &#123; if (!mLazyTaskWriterThread.isAlive()) &#123; mLazyTaskWriterThread.start(); &#125;&#125; 该方法中启动了一个 mLazyTaskWriterThread 的线程，恢复那些 pesistable 类型的 task，这里不多说了！ 3.3.1.3 AppOpsService.onSystemReady这里调用了 AppOpsService 的 systemReady，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public void systemReady() &#123; synchronized (this) &#123; boolean changed = false; //【1】更新系统中所有的 uid 的状态！ for (int i = mUidStates.size() - 1; i &gt;= 0; i--) &#123; UidState uidState = mUidStates.valueAt(i); //【1.1】uid 对应的 package 为 null，移除该 uid！ String[] packageNames = getPackagesForUid(uidState.uid); if (ArrayUtils.isEmpty(packageNames)) &#123; uidState.clear(); mUidStates.removeAt(i); changed = true; continue; &#125; ArrayMap&lt;String, Ops&gt; pkgs = uidState.pkgOps; if (pkgs == null) &#123; continue; &#125; //【1.1】如果 uid 的某个 ops 发生变化，移除它！ Iterator&lt;Ops&gt; it = pkgs.values().iterator(); while (it.hasNext()) &#123; Ops ops = it.next(); int curUid = -1; try &#123; curUid = AppGlobals.getPackageManager().getPackageUid(ops.packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES, UserHandle.getUserId(ops.uidState.uid)); &#125; catch (RemoteException ignored) &#123; &#125; if (curUid != ops.uidState.uid) &#123; Slog.i(TAG, \"Pruning old package \" + ops.packageName + \"/\" + ops.uidState + \": new uid=\" + curUid); it.remove(); changed = true; &#125; &#125; if (uidState.isDefault()) &#123; mUidStates.removeAt(i); &#125; &#125; //【1.3】如果 uid 的状态发生变化，将其持久化到本地文件中！ if (changed) &#123; scheduleFastWriteLocked(); &#125; &#125; //【2】获得挂载服务，设置外置存储挂载策略！ MountServiceInternal mountServiceInternal = LocalServices.getService( MountServiceInternal.class); mountServiceInternal.addExternalStoragePolicy( new MountServiceInternal.ExternalStorageMountPolicy() &#123; @Override public int getMountMode(int uid, String packageName) &#123; if (Process.isIsolated(uid)) &#123; return Zygote.MOUNT_EXTERNAL_NONE; &#125; if (noteOperation(AppOpsManager.OP_READ_EXTERNAL_STORAGE, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; return Zygote.MOUNT_EXTERNAL_NONE; &#125; if (noteOperation(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; return Zygote.MOUNT_EXTERNAL_READ; &#125; return Zygote.MOUNT_EXTERNAL_WRITE; &#125; @Override public boolean hasExternalStorage(int uid, String packageName) &#123; final int mountMode = getMountMode(uid, packageName); return mountMode == Zygote.MOUNT_EXTERNAL_READ || mountMode == Zygote.MOUNT_EXTERNAL_WRITE; &#125; &#125;);&#125; 这个 AppOpsService 是谷歌原生的应用程序权限管理服务，在 Android M ( Android 6.0 ) 加入的 Application Permission Manager 的功能就是基于 AppOps 实现的！ AppOps 全称是 Application Operations，类似我们平时常说的应用程序的操作（权限）管理。目前 Google 在每次版本更新时都会隐藏掉 AppOps 的入口。 注意：AppOps 虽然涵盖了 App 的权限管理，但是 Google 原生的设计并不仅仅是对“权限”的管理，而是对 App 的“动作”的管理。我们平时讲的权限管理多是针对具体的权限（App 开发者在 Manifest 里申请的权限），而 AppOps 所管理的是所有可能涉及用户隐私和安全的操作，包括 access notification, keep weak lock, activate vpn, display toast 等等，有些操作是不需要 Manifest 里申请权限的。 不多说了，这不多关注！ 3.3.2 杀掉特定进程刚刚有讲到，AMS 会杀掉已经启动并且没有带有 FLAG_PERSISTENT 标记的进程，那如何判断是否具有这个标记呢： 3.3.2.1 isAllowedWhileBooting123boolean isAllowedWhileBooting(ApplicationInfo ai) &#123; return (ai.flags&amp;ApplicationInfo.FLAG_PERSISTENT) != 0;&#125; 如果某个进程没有 FLAG_PERSISTENT ，这个方法会返回 false！ 3.3.3 读取设置信息 - retrieveSettings该方法的目的是从前面已经配置好的系统 provider 中互动一些设置属性！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private void retrieveSettings() &#123; final ContentResolver resolver = mContext.getContentResolver(); //【1】获得一些系统属性！ final boolean freeformWindowManagement = mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT) || Settings.Global.getInt( resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0; // 是否支持画中画模式！ final boolean supportsPictureInPicture = mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE); // 是否支持分屏模式！ final boolean supportsMultiWindow = ActivityManager.supportsMultiWindow(); final String debugApp = Settings.Global.getString(resolver, DEBUG_APP); final boolean waitForDebugger = Settings.Global.getInt(resolver, WAIT_FOR_DEBUGGER, 0) != 0; final boolean alwaysFinishActivities = Settings.Global.getInt(resolver, ALWAYS_FINISH_ACTIVITIES, 0) != 0; final boolean lenientBackgroundCheck = Settings.Global.getInt(resolver, LENIENT_BACKGROUND_CHECK, 0) != 0; // 是否强制 RTL 显示！ final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0; // 是否强制 activity 显示尺寸可变化！ final boolean forceResizable = Settings.Global.getInt( resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0; final boolean supportsLeanbackOnly = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK_ONLY); SystemProperties.set(DEVELOPMENT_FORCE_RTL, forceRtl ? \"1\":\"0\"); final Configuration configuration = new Configuration(); Settings.System.getConfiguration(resolver, configuration); if (forceRtl) &#123; // This will take care of setting the correct layout direction flags configuration.setLayoutDirection(configuration.locale); &#125; //【2】根据获得的系统属性，初始化系统属性变量！ synchronized (this) &#123; mDebugApp = mOrigDebugApp = debugApp; mWaitForDebugger = mOrigWaitForDebugger = waitForDebugger; mAlwaysFinishActivities = alwaysFinishActivities; mLenientBackgroundCheck = lenientBackgroundCheck; mSupportsLeanbackOnly = supportsLeanbackOnly; mForceResizableActivities = forceResizable; mWindowManager.setForceResizableTasks(mForceResizableActivities); if (supportsMultiWindow || forceResizable) &#123; mSupportsMultiWindow = true; mSupportsFreeformWindowManagement = freeformWindowManagement || forceResizable; mSupportsPictureInPicture = supportsPictureInPicture || forceResizable; &#125; else &#123; mSupportsMultiWindow = false; mSupportsFreeformWindowManagement = false; mSupportsPictureInPicture = false; &#125; // This happens before any activities are started, so we can // change mConfiguration in-place. updateConfigurationLocked(configuration, null, true); if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, \"Initial config: \" + mConfiguration); // Load resources only after the current configuration has been set. final Resources res = mContext.getResources(); // 是否有最近任务！ mHasRecents = res.getBoolean(com.android.internal.R.bool.config_hasRecents); mThumbnailWidth = res.getDimensionPixelSize( com.android.internal.R.dimen.thumbnail_width); mThumbnailHeight = res.getDimensionPixelSize( com.android.internal.R.dimen.thumbnail_height); mDefaultPinnedStackBounds = Rect.unflattenFromString(res.getString( com.android.internal.R.string.config_defaultPictureInPictureBounds)); mAppErrors.loadAppsNotReportingCrashesFromConfigLocked(res.getString( com.android.internal.R.string.config_appsNotReportingCrashes)); if ((mConfiguration.uiMode &amp; UI_MODE_TYPE_TELEVISION) == UI_MODE_TYPE_TELEVISION) &#123; mFullscreenThumbnailScale = (float) res .getInteger(com.android.internal.R.integer.thumbnail_width_tv) / (float) mConfiguration.screenWidthDp; &#125; else &#123; mFullscreenThumbnailScale = res.getFraction( com.android.internal.R.fraction.thumbnail_fullscreen_scale, 1, 1); &#125; &#125;&#125; 这里不多说了！ 3.3.4 读取 Uri 权限信息3.3.4.1 读取 Uri 权限信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private void readGrantedUriPermissionsLocked() &#123; if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, \"readGrantedUriPermissions()\"); final long now = System.currentTimeMillis(); FileInputStream fis = null; try &#123; //【1】读取 /data/system/urigrants.xml 文件！ fis = mGrantFile.openRead(); final XmlPullParser in = Xml.newPullParser(); in.setInput(fis, StandardCharsets.UTF_8.name()); int type; while ((type = in.next()) != END_DOCUMENT) &#123; final String tag = in.getName(); if (type == START_TAG) &#123; if (TAG_URI_GRANT.equals(tag)) &#123; // uri-grants 标签 final int sourceUserId; final int targetUserId; final int userHandle = readIntAttribute(in, ATTR_USER_HANDLE, UserHandle.USER_NULL); // userHandle 属性 if (userHandle != UserHandle.USER_NULL) &#123; // For backwards compatibility. sourceUserId = userHandle; targetUserId = userHandle; &#125; else &#123; sourceUserId = readIntAttribute(in, ATTR_SOURCE_USER_ID); // sourceUserId 属性 targetUserId = readIntAttribute(in, ATTR_TARGET_USER_ID); // targetUserId 属性 &#125; final String sourcePkg = in.getAttributeValue(null, ATTR_SOURCE_PKG); // sourcePkg 属性 final String targetPkg = in.getAttributeValue(null, ATTR_TARGET_PKG); // targetPkg 属性 final Uri uri = Uri.parse(in.getAttributeValue(null, ATTR_URI)); // uri 属性 final boolean prefix = readBooleanAttribute(in, ATTR_PREFIX); // prefix 属性 final int modeFlags = readIntAttribute(in, ATTR_MODE_FLAGS); // modeFlags 属性 final long createdTime = readLongAttribute(in, ATTR_CREATED_TIME, now); // createdTime 属性 // Sanity check that provider still belongs to source package // Both direct boot aware and unaware packages are fine as we // will do filtering at query time to avoid multiple parsing. // 根据 uri 获得其所属的 ContentProvider 对象！ final ProviderInfo pi = getProviderInfoLocked( uri.getAuthority(), sourceUserId, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE); if (pi != null &amp;&amp; sourcePkg.equals(pi.packageName)) &#123; int targetUid = -1; try &#123; // 获得持有该 uri 权限的目标ingyon targetUid = AppGlobals.getPackageManager().getPackageUid( targetPkg, MATCH_UNINSTALLED_PACKAGES, targetUserId); &#125; catch (RemoteException e) &#123; &#125; // 创建 UriPermission，封装该应用的 uri 权限！ if (targetUid != -1) &#123; final UriPermission perm = findOrCreateUriPermissionLocked( sourcePkg, targetPkg, targetUid, new GrantUri(sourceUserId, uri, prefix)); perm.initPersistedModes(modeFlags, createdTime); &#125; &#125; else &#123; Slog.w(TAG, \"Persisted grant for \" + uri + \" had source \" + sourcePkg + \" but instead found \" + pi); &#125; &#125; &#125; &#125; &#125; catch (FileNotFoundException e) &#123; // Missing grants is okay &#125; catch (IOException e) &#123; Slog.wtf(TAG, \"Failed reading Uri grants\", e); &#125; catch (XmlPullParserException e) &#123; Slog.wtf(TAG, \"Failed reading Uri grants\", e); &#125; finally &#123; IoUtils.closeQuietly(fis); &#125;&#125; 3.3.4.2 ActivityManagerS.findOrCreateUriPermissionLocked1234567891011121314151617private UriPermission findOrCreateUriPermissionLocked(String sourcePkg, String targetPkg, int targetUid, GrantUri grantUri) &#123; ArrayMap&lt;GrantUri, UriPermission&gt; targetUris = mGrantedUriPermissions.get(targetUid); if (targetUris == null) &#123; targetUris = Maps.newArrayMap(); mGrantedUriPermissions.put(targetUid, targetUris); &#125; UriPermission perm = targetUris.get(grantUri); if (perm == null) &#123; // 创建一个 UriPermission 对象！ perm = new UriPermission(sourcePkg, targetPkg, targetUid, grantUri); targetUris.put(grantUri, perm); &#125; return perm;&#125; mGrantedUriPermissions 用来保存系统中所有已经授予的 uri 权限！ 下面去看看 UriPermission 对象！ 1234567UriPermission(String sourcePkg, String targetPkg, int targetUid, GrantUri uri) &#123; this.targetUserId = UserHandle.getUserId(targetUid); this.sourcePkg = sourcePkg; this.targetPkg = targetPkg; this.targetUid = targetUid; this.uri = uri;&#125; 接着调用了 initPersistedModes 初始化 persisted 相关属性，包括 persistableModeFlags，persistedModeFlags 和 persistedCreateTime！1234567891011121314151617181920212223242526void initPersistedModes(int modeFlags, long createdTime) &#123; // 初始化 persistableModeFlags 和 persistedModeFlags // 只包含 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION！ modeFlags &amp;= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); persistableModeFlags = modeFlags; persistedModeFlags = modeFlags; persistedCreateTime = createdTime; updateModeFlags(); // 更新 modeFlags!&#125;private void updateModeFlags() &#123; final int oldModeFlags = modeFlags; modeFlags = ownedModeFlags | globalModeFlags | persistableModeFlags | persistedModeFlags; if (Log.isLoggable(TAG, Log.VERBOSE) &amp;&amp; (modeFlags != oldModeFlags)) &#123; Slog.d(TAG, \"Permission for \" + targetPkg + \" to \" + uri + \" is changing from 0x\" + Integer.toHexString(oldModeFlags) + \" to 0x\" + Integer.toHexString(modeFlags), new Throwable()); &#125;&#125; 关于 UriPermission 我们这里只涉及这么多！ 3.3.5 启动 persistent 进程 - startPersistentApps12345678910111213141516171819private void startPersistentApps(int matchFlags) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) return; synchronized (this) &#123; try &#123; //【1】获得 persistent 类型的 app 的信息！ final List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager() .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList(); for (ApplicationInfo app : apps) &#123; if (!\"android\".equals(app.packageName)) &#123; //【2】启动对应进程！ addAppLocked(app, false, null /* ABI override */); &#125; &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; 启动进程调用了 addAppLocked，我们继续看！ 3.3.5.1 ActivityManagerS.addAppLocked1234567891011121314151617181920212223242526272829303132333435363738394041final ProcessRecord addAppLocked(ApplicationInfo info, boolean isolated, String abiOverride) &#123; //【1】创建 persistent 进程对应的 ProcessRecord 对象！ ProcessRecord app; if (!isolated) &#123; app = getProcessRecordLocked(info.processName, info.uid, true); &#125; else &#123; app = null; &#125; if (app == null) &#123; app = newProcessRecordLocked(info, null, isolated, 0); updateLruProcessLocked(app, false, null); updateOomAdjLocked(); &#125; //【2】要被启动的 package 不能处于 true 状态！ try &#123; AppGlobals.getPackageManager().setPackageStoppedState( info.packageName, false, UserHandle.getUserId(app.uid)); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + info.packageName + \": \" + e); &#125; //【3】设置进程的 persistent 和 maxAdj 属性！ if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; &#125; //【4】保存到 mPersistentStartingProcesses 类型的集合中进行管理，并启动进程！ if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); startProcessLocked(app, \"added application\", app.processName, abiOverride, null /* entryPoint */, null /* entryPointArgs */); &#125; return app;&#125; 关于进程的启动，请看我的另一系列的博文，这里就不多说了！ 3.3.6 启动桌面进程接着是启动桌面所在的进程： 3.3.6.1 startHomeActivityLocked12345678910111213141516171819202122232425262728293031boolean startHomeActivityLocked(int userId, String reason) &#123; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) &#123; return false; &#125; //【1】创建启动桌面的 Intent！ Intent intent = getHomeIntent(); //【2】获得桌面应用对应的 ActivityInfo 实例！ ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); //【2.1】获得桌面的进程 ProcessRecord，因为 ams 的初始化在开机，所以 app 一定为 null！ ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //【2.2】启动桌面！ mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); &#125; &#125; else &#123; Slog.wtf(TAG, \"No home screen found for \" + intent, new Throwable()); &#125; return true;&#125; 3.3.6.1.1 ActivityManagerS.getHomeIntent1234567891011Intent getHomeIntent() &#123; //【1】这里的 mTopAction 等于 Intent.ACTION_MAIN; Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; intent.addCategory(Intent.CATEGORY_HOME); &#125; return intent;&#125; startHomeActivityLocked 方法最后会来自桌面 activity 的 onCreate 方法，然后，resumeFocusedStackTopActivityLocked 又会拉起桌面 activity 的 onResume 方法： 1mStackSupervisor.resumeFocusedStackTopActivityLocked(); 对于 activity 的启动，这里我就不多讲了，请看我的其他博文！ 到这里，桌面就完全显示在用户面前的，然而，还没有结束，我们进入到 ActivityThread 中去： 3.3.6.2 ActivityThread.handleResumeActivityhandleResumeActivity 负责拉起桌面 activity 的 onResume 方法，我们过滤掉一些不重要的代码： 12345678910111213141516171819202122232425262728293031323334final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ... ... ... ... // 拉起桌面 activity 的 onResume 方法！ r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; ... ... ... ... if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; // 创建了一个 Idler 对象，加入到了主线程的 Looper 队列中！ Looper.myQueue().addIdleHandler(new Idler()); &#125; r.onlyLocalRequest = false; if (reallyResume) &#123; try &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; else &#123; ... ... ... ... // 异常状态，不处理！ &#125;&#125; 当桌面进程的主线程进入空闲状态时，Idler.queueIdle 方法会被执行： 123456789101112131415161718192021222324252627282930313233343536373839private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) &#123; stopProfiling = true; &#125; if (a != null) &#123; mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do &#123; if (localLOGV) Slog.v( TAG, \"Reporting idle of \" + a + \" finished=\" + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; //【1】调用 ams 的 activityIdle 方法！ am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; if (stopProfiling) &#123; mProfiler.stopProfiling(); &#125; ensureJitEnabled(); return false; &#125;&#125; 下面，进入 ActivityManagerService 中去： 3.3.6.3 ActivityManagerS.activityIdle12345678910111213141516171819202122@Overridepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; //【1】继续调用！ ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) &#123; if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) &#123; try &#123; mProfileFd.close(); &#125; catch (IOException e) &#123; &#125; clearProfilerLocked(); &#125; &#125; &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; 3.3.6.4 ActivityManagerS.activityIdleInternalLocked这里我们只关注和 AMS启动有关的代码！ 1234567891011121314151617181920212223242526272829303132333435363738final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123; if (DEBUG_ALL) Slog.v(TAG, \"Activity idle: \" + token); ArrayList&lt;ActivityRecord&gt; finishes = null; ArrayList&lt;UserState&gt; startingUsers = null; int NS = 0; int NF = 0; boolean booting = false; boolean activityRemoved = false; ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r != null) &#123; if (DEBUG_IDLE) Slog.d(TAG_IDLE, \"activityIdleInternalLocked: Callers=\" + Debug.getCallers(4)); mHandler.removeMessages(IDLE_TIMEOUT_MSG, r); r.finishLaunchTickingLocked(); if (fromTimeout) &#123; reportActivityLaunchedLocked(fromTimeout, r, -1, -1); &#125; if (config != null) &#123; r.configuration = config; &#125; r.idle = true; // 显然，桌面 activity 所在的 stack 就是焦点栈！ if (isFocusedStack(r.task.stack) || fromTimeout) &#123; //【1】继续调用！ booting = checkFinishBootingLocked(); &#125; &#125; ... ... ... ... return r;&#125; 3.3.6.5 ActivityStackS.checkFinishBootingLocked123456789101112131415private boolean checkFinishBootingLocked() &#123; // 此时 mService.mBooting 为 true； final boolean booting = mService.mBooting; boolean enableScreen = false; mService.mBooting = false; if (!mService.mBooted) &#123; mService.mBooted = true; enableScreen = true; &#125; if (booting || enableScreen) &#123; //【1】进入这里！ mService.postFinishBooting(booting, enableScreen); &#125; return booting;&#125; postFinishBooting 会通过 MainHandler 发送 FINISH_BOOTING_MSG 消息给子线程，子线程会调用 AMS.finishBooting 的方法！ 3.3.6.6 ActivityManagerS.finishBooting该方法就是最关键的地方了，我们的开机广播就是在这个地方发送的！！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112final void finishBooting() &#123; synchronized (this) &#123; //【1】如果开机动画没有显示完，则退出，等开机动画显示完后才会调用！ if (!mBootAnimationComplete) &#123; mCallFinishBooting = true; return; &#125; mCallFinishBooting = false; &#125; // 检查系统 ABI，ABI 和系统 cpu 指令集有关！ ArraySet&lt;String&gt; completedIsas = new ArraySet&lt;String&gt;(); for (String abi : Build.SUPPORTED_ABIS) &#123; Process.establishZygoteConnectionForAbi(abi); final String instructionSet = VMRuntime.getInstructionSet(abi); if (!completedIsas.contains(instructionSet)) &#123; try &#123; mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi)); &#125; catch (InstallerException e) &#123; Slog.w(TAG, \"Unable to mark boot complete for abi: \" + abi + \" (\" + e.getMessage() +\")\"); &#125; completedIsas.add(instructionSet); &#125; &#125; // 注册接收者，监听重启 package 的广播，当系统发送了该广播后，该广播会传递所有需要重启的 package // 这里监听到该广播后，会重启所有的 package 的进程！ IntentFilter pkgFilter = new IntentFilter(); pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); pkgFilter.addDataScheme(\"package\"); mContext.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES); if (pkgs != null) &#123; for (String pkg : pkgs) &#123; synchronized (ActivityManagerService.this) &#123; if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, \"query restart\")) &#123; setResultCode(Activity.RESULT_OK); return; &#125; &#125; &#125; &#125; &#125; &#125;, pkgFilter); // 注册接收者，监听 ACTION_DELETE_DUMPHEAP 广播！ IntentFilter dumpheapFilter = new IntentFilter(); dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP); mContext.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) &#123; mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5*60*1000); &#125; else &#123; mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG); &#125; &#125; &#125;, dumpheapFilter); // 通知系统服务已经进入最后阶段：PHASE_BOOT_COMPLETED mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED); synchronized (this) &#123; // 启动那些之前无法启动的进程，比如系统进程未准备好，且不是常驻进程等等！ final int NP = mProcessesOnHold.size(); if (NP &gt; 0) &#123; ArrayList&lt;ProcessRecord&gt; procs = new ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold); for (int ip=0; ip&lt;NP; ip++) &#123; if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, \"Starting process on hold: \" + procs.get(ip)); // 启动之前无法启动而被系统暂时监管的应用进程！ startProcessLocked(procs.get(ip), \"on-hold\", null); &#125; &#125; if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG); mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY); // 设置系统属性！ SystemProperties.set(\"sys.boot_completed\", \"1\"); if (!\"trigger_restart_min_framework\".equals(SystemProperties.get(\"vold.decrypt\")) || \"\".equals(SystemProperties.get(\"vold.encrypt_progress\"))) &#123; SystemProperties.set(\"dev.bootcomplete\", \"1\"); &#125; //【2】解锁设备用户，发送开机相关的广播！ mUserController.sendBootCompletedLocked( new IIntentReceiver.Stub() &#123; @Override public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; synchronized (ActivityManagerService.this) &#123; requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false); &#125; &#125; &#125;); scheduleStartProfilesLocked(); &#125; &#125;&#125; 总体来看，逻辑不复杂，最后的一步很关键：1mUserController.sendBootCompletedLocked(...); 该方法会发送一系列的开机广播，并且会解除所有启动完成的设备用户的锁定状态！ 广播的发送顺序是： 1ACTION_LOCKED_BOOT_COMPLETED -&gt; ACTION_PRE_BOOT_COMPLETED -&gt; ACTION_BOOT_COMPLETED ACTION_LOCKED_BOOT_COMPLETED 因为此时设备用户仍然处于锁定状态，该方法会首先发送 ACTION_LOCKED_BOOT_COMPLETED 广播，这个广播的触发时机是：设备用户已经完成了启动，当时仍然处于锁定状态！ 发生了该广播后，系统进程就会开始接触设备用户的锁定！！ ACTION_PRE_BOOT_COMPLETED 当设备用户解除锁定后，就会发送这个广播，这个广播的发送时机是，系统升级后，设备的 FINGERPRINT 发生了变化！如果没有发生变化的话，会直接发送 ACTION_BOOT_COMPLETED 广播！ 下面是核心代码：123456789101112131415161718192021222324252627282930313233void finishUserUnlocked(final UserState uss) &#123; final int userId = uss.mHandle.getIdentifier(); synchronized (mService) &#123; ... ... ... ... if (uss.setState(STATE_RUNNING_UNLOCKING, STATE_RUNNING_UNLOCKED)) &#123; ... ... ... ... ... final UserInfo info = getUserInfo(userId); if (!Objects.equals(info.lastLoggedInFingerprint, Build.FINGERPRINT)) &#123; final boolean quiet; if (info.isManagedProfile()) &#123; quiet = !uss.tokenProvided || !mLockPatternUtils.isSeparateProfileChallengeEnabled(userId); &#125; else &#123; quiet = false; &#125; // PreBootBroadcaster 的 sendNext 方法中会发送 ACTION_PRE_BOOT_COMPLETED！ new PreBootBroadcaster(mService, userId, null, quiet) &#123; @Override public void onFinished() &#123; // 该方法会发送 ACTION_BOOT_COMPLETED 广播！ finishUserUnlockedCompleted(uss); &#125; &#125;.sendNext(); &#125; else &#123; // 该方法会发送 ACTION_BOOT_COMPLETED 广播！ finishUserUnlockedCompleted(uss); &#125; &#125; &#125;&#125; ACTION_BOOT_COMPLETED ACTION_PRE_BOOT_COMPLETED 广播是最后发送的，也就是我们说的开机广播，发送的代码在 finishUserUnlockedCompleted 方法中！ 4 总结到这里，AMS 的启动过程就分析完了!","categories":[{"name":"AndroidFramework源码分析","slug":"AndroidFramework源码分析","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/"},{"name":"ActivityManager活动管理","slug":"AndroidFramework源码分析/ActivityManager活动管理","permalink":"https://coolqi.top/categories/AndroidFramework源码分析/ActivityManager活动管理/"}],"tags":[{"name":"ActivityManager活动管理","slug":"ActivityManager活动管理","permalink":"https://coolqi.top/tags/ActivityManager活动管理/"}]}]}